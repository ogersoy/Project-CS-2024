# Foreword
This Technical Report has been produced by the 3rd Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
This technical report studies and evaluates architecture enhancements on
potential optimizations to the Release 15 Service-Based Architecture (SBA) in
order to provide higher flexibility and better modularization of the 5G System
for the easier definition of different network slices and to enable better re-
use of the defined services. Moreover, the technical report considers
mechanisms in order to better support automation and high reliability of
network function service(s). The following aspects are covered:
\- Optimizing the modularization of the system to improve its agility.
\- Extending the service concept from 5GC control plane to the user plane
function(s).
\- Further improvements to service framework related aspects.
\- Architectural support for highly reliable deployments, considering.
\- Study backward and forward compatibility implications resulting from the
above bullets.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or nonâ€‘specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 23.501: \"System Architecture for the 5G System; Stage 2\".
[3] 3GPP TS 23.502: \"Procedures for the 5G System; Stage 2\".
[4] 3GPP TS 29.510: \"5G System; Network function repository services; Stage
3\".
[5] 3GPP TS 23.222: \"Functional architecture and information flows to support
Common API Framework for 3GPP Northbound APIs; Stage 2\".
[6] 3GPP TS 29.531: \"5G System; Network Slice Selection Services; Stage 3\".
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
TR 21.905 [1] apply.
## 3.3 Abbreviations
For the purposes of the present document, the abbreviations given in TR 21.905
[1] and the following apply.\ An abbreviation defined in the present document
takes precedence over the definition of the same abbreviation, if any, in TR
21.905 [1].
SFSF Service Framework Support Function
# 4 Architectural Requirements, Principles and Assumptions
## 4.1 Architectural Requirements
Services shall be fully self-contained, reusable, and shall have independent
life-cycle management (e.g. for scaling, healing, etc.).
The services deployed within a Network Slice shall be able to communicate
efficiently with minimal information about the Network Slice configuration.
The service framework functionalities include service registration/discovery,
communication between service instances and security functions.
The service framework:
\- shall provide registration and discovery.
\- shall enable efficient communication between service instances and allow
distributed scaling.
\- shall enable service communication within one slice, between slices, within
one service framework, instance between different service framework instances
and between different PLMNs with minimal impact to service.
\- shall enable handling of failure scenarios with minimal impact to service.
\- should enable protection of the system against signaling storms.
\- should support protect the integrity and confidentiality of the
communication.
\- should provide the authentication and authorization to access the service.
Editor\'s note: Any service framework used for 5GC SBA will need to support
3GPP specific parameters for e.g. NF/Service selection. It\'s FFS how to
capture this aspect in the requirements on the service framework.
## 4.2 Architectural Principles
\- For interaction between UE/RAN and 5GC, the NF services interactions within
5GC have no impact on NG-RAN or UE, and 5GC interacts with UE and RAN via the
specified Reference Point(s).
\- For interaction between EPC and 5GC, the NF services interactions within
5GC have no impact on EPC network entities, and 5GC interacts with EPC network
entities via the specified Reference Point(s).
\- For interactions with the UPF, the NF services interactions within 5GC have
no impact on the UP traffic processing model in UPF, including session level
reporting by UPF. For all the session level reports, UPF shall report to SMF.
## 4.3 Architectural Assumptions
The assumption is that 5GS architecture supports cloud deployments (fully
virtualized) and can make use of cloud operation mechanisms, e.g. auto-
scaling, self-healing in line with e.g. ETSI NFV specifications.
The implementation architecture is outside of 3GPP SA WG2 scope. For example,
how 3GPP NFs/NF Services are grouped into (VNFs) and how the resources for
VNFs are managed is outside of 3GPP SA WG2 scope.
## 4.4 Service Definitions and Principles
The following principles are general principles for design of services. The
Principles are work in progress and will be revisited and evaluated at future
meetings. Compromises on some of the principles may be required when deciding
how the architecture envolve in Rel-16.
\- A service is designed to perform specific tasks, which are different from
other services in the system.
\- A service has a unique identification. Services that perform different
tasks have a different identification.
\- Service operations are the only way to communicate with a service.
\- Within a given communication context, a service may take the role of either
service consumer or service producer. A service consumer is unaware of any
internals of the service producer and vice versa.
\- A service is designed to operate on a specific set of data (data context,
e.g. session data).
\- A service instance is a software executable that implements a service. Each
service instance needs to be uniquely identified.
\- Service instances of the same service may share data via a shared storage
resource.
\- Not all the service instances of the same service need to have access to a
single, shared instantiation of the data context. This may depend on the
implemented data consistency model.
# 5 Key Issues
## 5.1 Key Issue 1: Optimal modularization of the system
### 5.1.1 Description
Optimal modularization of the system shall:
\- enable deployment/configuration of single/separate 5GC services within a
network slice or shared by a set of network slices (e.g. as for the case of
AMF services) which will:
\- improve the system\'s agility in terms of tailoring its functionality and
features, e.g. for network slicing.
\- improve flexibility in terms of dynamic addition and removal of services
and independent lifecycle management of services instances within one network
slice or a set of network slices.
\- enable/enhance re-usability of single services.
\- describe principles to be used for an optimal modularization/granularity of
services that enables different deployment scenarios (e.g. different levels of
service modularization for different NF types)/slice types.
\- achieve appropriate service granularity, i.e. compared to Release 15 NF
service definition for existing features and functionalities:
\- remove dependencies between services in order to enable independent
implementation and deployment of single/separate services.
\- enable services to be deployed by their own without mandatorily relying on
a certain NF, through proper service modelling.
\- clarify how generic the service design should be to enable features to be
used beyond the interactions described in procedure flows.
\- study relation between services and system features (modules), e.g.
identify where services should be merged where necessary.
\- clarify self-contained, reusable, and independent life-cycle management of
services.
## 5.2 Key Issue 2: User Plane Aspects
### 5.2.1 Description
In Rel-15, the Service Concept has been introduced into control plane of 5G
core. This key issue will study **extending the service concept from 5GC
control plane to the user plane function(s), however, this key issue will
focus on how to extend service concept only to the N4 interface, but not to
the N3/N6/N9 interface.**
**This key issue study following aspects:**
\- How to integrate the specific aspects of the UPF (e.g. its resources,
states of PDU Sessions and user plane tunnels, etc.) into the service-based
architecture model and make sure that those aspects of UPF are encompassed by
existing principles of SBA and those going to be newly defined during this
study.
\- What will UPF expose/consume on the service interfaces to/from SMF? e.g.
service related to PDU Sessions and user plane tunnel establishment, etc. This
includes the following aspect:
\- How to enable operator policies on reallocation of sessions handled by UPF
instances within a slice e.g, scenarios where overall traffic load or service
specific traffic load is being re-balanced and all UPF sessions or a subset of
UPF sessions belonging to a UPF instance are reallocated to a new / different
UPF instance. A subset of UPF sessions is selected based on operator policies,
e.g., sessions related to a particular service, sessions of a particular QoS
or protocol, or sessions destined for particular DNN(s). The impact for these
scenarios shall be limited to the SMF, UPF and those involved in managing such
operator policy.
NOTE: Only SA WG2 related aspects of the problem shall be addressed in the
study.
\- Possibility of structuring and separating services into control, reporting
and exposure services.
\- Any impact to the session management procedure defined in TS 23.501 [2] and
TS 23.502 [3] due to UPF having a service based interface?
\- The bootstrap procedures of UPF with service interface, e.g. Whether the
Procedure defined in clause 4.17 of TS 23.502 [3] can be re-used or need to
define new procedures?
\- Within the mix deployment of both the UPF using PtP interface and UPF using
service based interface e.g. within a single PLMN, how to handle session
management procedures e.g. UPF selection, UPF relocation, etc?
NOTE: As stated in the Objectives of the eSBA SID, impacts to User Plane
traffic processing are not expected in the eSBA study. Therefore, solutions
proposed to address this key issue are not expected to impact functionality
handling User plane traffic processing. In addition, solutions addressing this
key issue shall not impactN3/N9 tunnelling protocols defined in Rel-15.
## 5.3 Key Issue 3: Improvements to service framework related aspects
### 5.3.1 Description
Aiming to further optimize 5G service based architecture this key issue will:
\- identify the set of common service framework functionalities, i.e. that are
not part of the service logic.
\- study improvements of service framework related aspects, i.e.:
\- service addressing and communication, e.g., through direct/indirect ways.
\- service discovery, registration & authorisation, in line with the
optimisations in Key Issue 1.
\- selection of a service instance when more than one instance is available to
process a given service operation\".
\- 5GC Overload Handling in coordination with CT4.
\- other communication/interaction related functionalities.
study where to place the common service framework functionalities Any
solutions should aim to ensure that implementations can use current as well as
possible future implementation technologies and design patterns developed by
communities outside 3GPP and should also avoid lock ins to specific
technologies.
## 5.4 Key Issue 4: Architectural support for highly reliable deployments
### 5.4.1 Description
When the 5GC services are deployed in a cloud environment, it is expected that
the overall reliability of the system shall be at least the same as the
reliability of today\'s non-cloud based systems. Therefore, the service-based
architecture should be designed in a way that seamless replacement, addition
or removal of services is possible and does not require specific
(re-)configuration (e.g. point to point interfaces or UE specific binding) of
both the running and the new component(s).
NOTE 1: It is assumed that this functionality introduced for CP NFs/NF
services can be an enabler for ultra-reliable communication (URLLC).
NOTE 2: This key issue focuses on the control plane functions of the 5GC.
This key issue will st**udy architectural aspects supporting highly reliable
deployments in virtualized environments (i.e. built for cloud) including e.g.
(non-exhaustive list):**
\- automation to support independent life cycle management as well as failover
handling of 5GC NFs and/or service instances.
\- impact on service operation to support scenarios with and without long-
living UE-specific bindings between service instances, e.g., by separating
functional processing from state repository or other mechanisms.
\- support traceability and monitoring as needed to support automation.
NOTE 3: Solutions may reuse, where applicable, the enablers for network
automation studied in FS_eNA.
## 5.5 Key Issue 5: SBA backward and forward compatibility
### 5.5.1 Description
This study item analyses potential enhancements of the Rel-15 SBA. It is clear
that operators who deploy the Rel. 15 SBA would need compatibility with and
migration path towards a Rel-16 SBA.
While the actual backward compatibility and forward compatibility of each
solution and the migration path from the Release15 baseline are expected to be
part of the respective solution evaluation this key issue will:
\- provide definitions for backward compatibility and forward compatibility;
\- develop design principles for backward and forward compatibility and how to
apply it to the design of the components of the 5GC.
## 5.6 Key Issue 6: System flexibility and service provisioning
### 5.6.1 Definition
System Feature: _Service (the definition of \"service\" refers to TR 21.905,
clause 3) e.g. SMS, LCS delivered to end user and/or application by 5G system,
which is enabled by a set of Network Functions and/or NF services in 5GC and
NG-RAN in some cases._
### 5.6.2 Description
_System flexibility enables the efficient support of 5G System Features in the
network. The network may support multiple System Features, and these System
Features may be added/updated/removed within a network in operation._
This key issue will study:
\- The principles for identifying System Features.
\- Identifying and listing the set of System Features provided by the 5G
system.
\- How to associate a System Feature with the related NFs, system
procedures/NF services.
\- Potential enhancements to the service framework for better support of
system features e.g. service discovery.
\- How to provision a network based on System Features, including: the
required NFs and/or NF services.
\- The relationship between System Features and Network Slices.
\- Interoperability between different deployments with different system
features and multi-vendor deployment of System Features.
## 5.7 Key Issue 7: Roaming
### 5.7.1 Description
_Aiming to further optimize roaming 5G service-based architecture this key
issue will:_
\- Study roaming related improvements.
NOTE: This key issue is intended to study impacts from service framework
improvements, roaming security requirements and related configurations. It is
not intended to study other functional aspects of the 5GC roaming
architecture.
# 6 Solutions
## 6.1 Solution 1: Simply replace N4 with service operations
### 6.1.1 Introduction
This solution addresses Key Issue 2 on User Plane Aspects.
### 6.1.2 High-level Description
#### 6.1.2.1 General aspects
The basic idea is to replace N4 interface with service based interface.
The N4 point to point interactions between UPF and SMF are defined in clause
4.4 of TS 23.502 [3]. This solution proposes to replace them by introducing
service interface into UPF and SMF, with corresponding services. The service
interface on UPF is named as Nupf, and the service interface on SMF is
existing one, i.e. Nsmf.
#### 6.1.2.2 Bootstrap procedures
The clause 4.17 of TS 23.502 [3] already defined the \"Network Function
Service Framework Procedure\". In the clause 4.17.6 of TS 23.502 [3], SMF
Provisioning of available UPFs using the NRF is defined, and should be used as
base line for UPF with service interface. In other words, locally configure
UPF with service interface in SMF is not recommended.
UPF, with SBI interface or with PtP, shall register with NRF by including an
indication of supporting PtP or SBI. If UPF indicates support of SBI, the UPF
shall also register those services it provides via this SBI.
During the SMF Provisioning of available UPFs using the NRF procedure, the UPF
Provisioning Information sent to SMF shall contain interaction method
supported for each UPF, i.e. using PtP or using SBI. For the SMF Provisioning
of available UPFs using configuration method, e.g. O&M, the configuration
information of each UPF shall contain it\'s interaction method, i.e. using PtP
or using SBI.
#### 6.1.2.3 UPF Service
The following table shows the UPF Services and UPF Service Operations.
NOTE: In the table, the right most column shows the clause of TS 23.502 [3]
which corresponds the point to point procedure.
Table 6.1.2.3-1: NF services provided by the UPF
+-------------+-------------+-------------+-------------+-------------+ | Service | Service | Operation | Example | Mapping | | Name | Operations | | Consumer(s) | from | | | | Semantics | | | | | | | | TS 2 | | | | | | 3.502 [3] | +=============+=============+=============+=============+=============+ | Nu | Es | Reque | SMF | Cla | | pf_Session | tablishment | st/Response | | use 4.4.1.2 | +-------------+-------------+-------------+-------------+-------------+ | | M | Reque | SMF | Cla | | | odification | st/Response | | use 4.4.1.3 | +-------------+-------------+-------------+-------------+-------------+ | | Release | Reque | SMF | Cla | | | | st/Response | | use 4.4.1.4 | +-------------+-------------+-------------+-------------+-------------+ | Nu | Subscribe | Subsc | SMF | See | | pf_Session | | ribe/Notify | | Editor\'s | | _Reporting | | | | note 1. | +-------------+-------------+-------------+-------------+-------------+ | | Unsubscribe | | SMF | | +-------------+-------------+-------------+-------------+-------------+ | | Notify | | SMF | Cla | | | | | | use 4.4.2.2 | +-------------+-------------+-------------+-------------+-------------+ | N | Setup | Reque | SMF | Cla | | upf_Node_ | | st/Response | | use 4.4.3.1 | | Association | | | | | +-------------+-------------+-------------+-------------+-------------+ | | Update | Reque | SMF | Cla | | | | st/Response | | use 4.4.3.2 | +-------------+-------------+-------------+-------------+-------------+ | | Release | Reque | SMF | Cla | | | | st/Response | | use 4.4.3.3 | +-------------+-------------+-------------+-------------+-------------+ | Nupf_Node | Subscribe | Subsc | SMF | See | | _Reporting | | ribe/Notify | | Editor\'s | | | | | | note 2. | +-------------+-------------+-------------+-------------+-------------+ | | Unsubscribe | | SMF | | +-------------+-------------+-------------+-------------+-------------+ | | Notify | | SMF | Cla | | | | | | use 4.4.3.4 | +-------------+-------------+-------------+-------------+-------------+ | Nup | Provision | Reque | SMF | Cla | | f_PFD_Mgt | | st/Response | | use 4.4.3.5 | +-------------+-------------+-------------+-------------+-------------+ | | Remove | Reque | SMF | Cla | | | | st/Response | | use 4.4.3.5 | +-------------+-------------+-------------+-------------+-------------+ | Nupf_Data | Subscribe | Subsc | SMF | See | | _Reporting | | ribe/Notify | | Editor\'s | | | | | | note 3. | +-------------+-------------+-------------+-------------+-------------+ | | Unsubscribe | | SMF | | +-------------+-------------+-------------+-------------+-------------+ | | Notify | | SMF | C | | | | | | lause 4.4.4 | +-------------+-------------+-------------+-------------+-------------+
Editor\'s note: In order to receive/not receive session level reporting, the
SMF needs to subscribe/unsubscribe to UPF. How to do this is FFS.
Editor\'s note: In order to receive/not receive node level reporting, the SMF
needs to subscribe/unsubscribe to UPF. How to do this is FFS.
Editor\'s note: In order to receive/not receive data reporting, the SMF needs
to subscribe/unsubscribe to UPF. How to do this is FFS.
Editor\'s note: To address other key issues, for those service operations
related to same PDU session, how to reach correct UPF for this PDU Session is
FFS.
Editor\'s note: Whether those service and service operations could be combined
or not is FFS.
#### 6.1.2.4 SMF Service
In order to interact with UPF, the following table shows the SMF Services and
SMF Service Operations.
NOTE: In the table, the right most column shows the clause of TS 23.502 [3]
which corresponds the point to point procedure.
Table 6.1.2.4-1: NF services provided by the SMF
+-------------+-------------+-------------+-------------+-------------+ | Service | Service | Operation | Example | Mapping | | Name | Operations | | Consumer(s) | from | | | | Semantics | | | | | | | | TS 2 | | | | | | 3.502 [3] | +=============+=============+=============+=============+=============+ | N | Update | Reque | UPF | Cla | | smf_Node_ | | st/Response | | use 4.4.3.2 | | Association | | | | | +-------------+-------------+-------------+-------------+-------------+ | | Release | Reque | UPF | Cla | | | | st/Response | | use 4.4.3.3 | +-------------+-------------+-------------+-------------+-------------+
#### 6.1.2.5 Co-existing of UPF using PtP interface and UPF using service
based interface
Editor\'s note: It is FFS that within the mix deployment of both the UPF using
PtP interface and UPF using service based interface e.g. within a single PLMN,
how to handle session management procedures e.g. UPF selection, UPF
relocation, etc.?
In order to support mix deployment of both the UPF using PtP interface and UPF
using service based interface e.g. within a single PLMN, the SMF should know
what kind of interface the UPF is using, before actual contact the UPF. For
those UPFs been provisioned into SMF either by O&M or by NRF way, the SMF
should know which interaction method each UPF use, i.e. this UPF using PtP or
that UPF use SBI.
More details can be found in clause 6.1.3.2 (node level procedures) and
6.1.3.3 (session level procedures).
### 6.1.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
#### 6.1.3.1 SMF Pause of Charging procedure
The details of this procedure using N4 interface could be found in clause
4.4.4 of TS 23.502 [3]. Below is the procedure showing with the service
operations.
Figure 6.1.3.1-1: SMF Pause of charging procedure
1\. The UPF receives downlink data packets for a PDU Session that does not
have an N3 tunnel and the UPF sends Nupf_Data_Reporting_Notify to the SMF. The
packets are buffered or discarded in the UPF based on operator policy.
2\. Based on operator policy/configuration the SMF triggers the procedure to
pause PDU Session charging. Triggering criteria are based on SMF operator
policy/configuration.
3\. SMF invoke the Nupf_Session_Modification_Requet service of the UPF where
the Usage Reporting is configured, modifying the Usage Reporting Rules for the
PDU Session so that the usage collection for charging is stopped. In home
routed roaming scenarios, the V-SMF sends a Nsmf_PDUSession_Update request to
the H-SMF with a \"Start Pause of Charging\" Indication. The H-SMF then
requests the H-UPF to stop usage collection as mentioned before.
4\. UPF confirms with a Nupf_Session_Modification_Response.
#### 6.1.3.2 Node Level Procedures between SMF and UPF
In Figure 6.1.3.2-1, which shows the Node association setup procedure for mix
deployment, in this procedure, the SMF first determine the interaction method
that the UPF is using in step 1, i.e. it is SBI or PtP.
Here are two cases, that SMF could determine the interaction method of this
UPF.
In the case 1), the SMF using the NRF method to get UPF provisioning of
available UPFs defined in clause 4.17.6 of TS 23.502 [3]. The UPF indicates
the interaction method it uses, e.g. PtP or SBI during the NF service
registration procedures. Thus during the SMF provisioning of UPF instances
using NRF, the SMF gets the each UPF\'s provisioning information contains the
interaction method.
In the case 2), the SMF may be locally configured with the information about
the available UPFs, e.g. by OA&M system when UPF is instantiated or removed,
the interaction method of each UPF may also be configured.
If the UPF is using SBI, the SMF invoke the node association service by
sending the Nupf_Node_Assocation_Setup_Request message to the UPF in step 2a,
and get response in step 2b. If the UPF is using PtP, the SMF sends the N4
Association Setup Request to the UPF in step 3a, and get response in step 3b.
Once the association is success, in step 4, the SMF may remember the
interaction method used of the UPF, e.g. in the UPF association context.
Figure 6.1.3.2-1: Node association setup procedure for mix-deployment
In Figure 6.1.3.2-2, which shows the Node association update procedure for mix
deployment, in this procedure, the SMF first determine the interaction method
that the UPF is using in step 1. During step 1, the SMF may know the
interaction method from the UPF association context. If there is no such
context, the SMF finds the interaction method as the step 1 of the Node
association setup procedure for mix deployment.
If the UPF is using SBI, the SMF invoke the node association service in step
2a, and get response in step 2b. If the UPF is using PtP, the SMF sends the N4
Association Update Request to the UPF in step 3a, and get response in step 3b.
Figure 6.1.3.2-2: Node association update procedure for mix-deployment
Basically, other Node Level procedures, such as Association release, PFD
management procedures may follow the general logical sequence described in the
Node association update procedure for mix-deployment.
#### 6.1.3.3 Session Level Procedures between SMF and UPF
The session level procedures normally happen after SMF has association with
UPF. Within the PDU session establishment procedures, one or more UPF may be
selected for such PDU session. During mobility procedure, UPF may be
relocated. In such cases, the SMF should use the Node association setup
procedure for mix deployment described in clause 6.1.3.2 to associate with
selected UPFs.
Taking the procedure in clause 4.3.2.2.1 of TS 23.502 [3] as basis, figure
6.1.3.3-1 shows the PDU session establishment procedure for mix deployment. In
this procedure, once the UPF is selected in Step 8, the SMF then knows the
interaction method that the UPF is using, i.e. it is SBI or PtP(as those two
cases described in clause 6.1.3.2.). Then SMF stores the interaction method
that each UPF uses for this PDU session in the SM context of this PDU session.
If the selected UPF is using PtP, the steps in BOX A and BOX C is executed. If
the selected UPF is using SBI, the steps in BOX B and BOX D is executed.
Figure 6.1.3.3-1: UE-requested PDU Session Establishment for non-roaming and
roaming with local breakout for mix-deployment
For the PDU session modification and PDU session release procedure, this SMF
also finds the interaction method before talk to UPFs. That is, the SMF
retrieves the interaction method of UPF from the SM context, and then use
corresponding method i.e. PtP or SBI to interact with the UPF.
### 6.1.4 Impacts on existing NFs, NF services and interfaces
Impacts to the UPF:
\- UPF need indicates interaction method i.e. PtP or SBI to NRF;
\- UPF need provides those services it could provide via this SBI to NRF;
Impacts to the SMF:
\- SMF needs determine UPF\'s interaction method i.e. using PtP or SBI, before
interact with UPF;
\- SMF needs store UPF\'s interaction method;
Impacts to the NRF:
Need to support new parameters when UPF using SBI register with NRF.
### 6.1.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.2 Solution 2: Amendments to NF Service Interaction model
### 6.2.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
The service based architecture of Rel-15 inherits aspects from the reference
point based p2p interaction concepts. In this direct interaction model the NF
services themselves have several responsibilities that are not part of the NF
services\' business logic. NF service instances have, for example, to discover
other NF service instances as their communication peers, to select one of
them, to supervise the message flow, to perform message authorization actions
and to maintain the communication relationship with the selected peer for
subsequent transactions. Service consumers also need to be involved in load
balancing between their potential communication peers before or during a
communication relationship.
This puts some redundant burden on the implementation of the NF services which
can limit the development and deployment agility and interoperability. But
even more critically, the delegation of some of these responsibilities to the
NF services can cause limitations for automation flexibility and for customer
service availability, especially in case of failures of NF service instances,
and therefore have a negative influence on the overall system availability and
reliability.
This solution proposes amendments to the NF service interaction model that
addresses these issues outlined above on architectural level.
### 6.2.2 High-level Description
This solution covers two main aspects which are shortly discussed in the
following clauses:
\- Reduction of the complexity of the NFservices.
\- Improvement to the overall system reliability and availability.
#### 6.2.2.1 Reduction of NFservice complexity
This aspect addresses the reduction of the complexity of NF services by
identification and extraction of functionality that is common to all NF
services and placing it into a component outside of the actual NF service.
These common functionalities include:
\- Discovery of communication peers.
\- Selection of communication peers, including load-balancing between
selectable communication peers.
\- Delivery of messages between communication peers, and matching of responses
where needed.
\- Policy enforcement, authorization of the message delivery.
\- Handling of addition, removal and replacement of NF service instances, i.e.
when new selectable peers become available or existing peers disappear from
the system.
#### 6.2.2.2 Reliability improvements
This aspect addresses the way how NF service instances communicate with each
other. Today the NF services themselves have the responsibility for the
discovery and selection of peers for inter-service communication and for
keeping the state of these communication relationships alive for subsequent
transactions. This behaviour is based on the assumption and pre-condition that
both communication peers are highly available and reliable themselves, which
is not valid anymore in a cloud based deployment environment.
In case of failures in one NF service instance, each corresponding
communication peer must be notified about it and perform failover strategies
to find and connect to a replacement peer NF service instance and to restore
and synchronize the communication and application state.
This solution removes the need for such failover mechanisms to be implemented
as part of every NF service.
#### 6.2.2.3 Solution Preconditions, Assumptions and Requirements
Preconditions:
\- There is no long-living binding between NF service instance(s) and
application context(s).
NOTE: This precondition can be fulfilled e.g. by separation of \"compute\"
resources from \"storage\" resources.
Assumptions:
\- There exists a mechanism (e.g. Service Mesh, messages oriented middleware
...) to decouple communication peers from each other, in order to:
\- Remove the need for implementation of peer-discovery, -selection and
-binding from each service.
\- Remove the need for implementation of dedicated failover strategies from
each service- That mechanism provides functionality that allows NF service
instances to send messages to a type of peer NF service (not a dedicated
service instance).
\- That mechanism provides functionality that allows NF service instances to
receive messages from another service instance.
\- The API(s) provided by such existing mechanisms is/are different from the
3GPP SBIs.
\- That mechanism has internal functionality to perform peer-discovery and
-selection on behalf of the sending NF service instance, i.e. it implements,
or interacts with, a service repository such as the NRF.
\- That mechanism can deliver messages from the sending peer to the selected
receiving peer.
\- That mechanism provides means to support short-lived peer-bindings, if
required for certain communication patterns. Bindings may exist for a single
message exchange or over a sequence of such exchanges as needed.
\- That mechanism is message content agnostic, i.e. it supports any payload.
\- That mechanism supports interaction between different data centers / points
of presence, while hiding the deployment topology of the system from each of
the NF service instances.
\- That mechanism supports authorization and enforcement of policies for the
delivery of messages, including location affinity rules in case of
distribution across multiple PoPs.
Requirements:
\- The NF service logic must be designed to be interoperable with the selected
mechanism.
\- The NF services shall be able to use the APIs, provided by the selected
mechanism, i.e. an adaptation function is needed between the 3GPP SBIs used by
the NF services and the selected mechanism.
#### 6.2.2.4 High-level Solution\'s Architecture
The following figure illustrates a high-level architecture, where the common
functionalities are separate from the business logic of the NF service
implementations and provided by common service framework functionalities.
Figure 6.2.2.4-1: Non-roaming architecture
\- The architecture consists of the following 3 building blocks:
\- 3GPP defined NF services and their SBIs.
\- The common functionalities that are expected from an existing mechanism as
described in clause 6.2.2.3.
\- A Service Access Point (SAPo) function that performs adaptation, as needed,
between the NF services and the common service framework functionalities.
The access to the functionalities of the service framework is offered via
Service Access Point (SAPo) functional elements which provide a northbound
API, the Service Access Point API (SAPA) towards the NF services. Multiple
SAPo instances (as needed by operator deployment) may exist as shown in the
diagram above. Each SAPo instance allows registration and deregistration of NF
service instances as well as sending and receiving messages by the NF service
instances. SAPos may also monitor the presence of registered NF service
instances, e.g. via a keep-alive mechanism. The SAPA is object of
standardisation by 3GPP. It defines the API for the common set of service
framework functionalities.
SAPA is generic in terms of the access to the common set of service framework
functionalities, and agnostic of the content of messages exchanged between NF
services. Therefore, technically speaking, any NF service instance can make
use of any SAPo instance. However, in actual deployments, SAPos might be
pooled for use by certain sets of NF service instances. Such configuration,
and number of deployed SAPos, depends on the SAPo deployment options described
in clause 6.2.2.4.8 and on operator deployment strategy.
The actual implementation of the service framework is implementation specific
and not object of standardization by 3GPP. It is assumed that existing
solutions (e.g. service mesh, enterprise message systems, ...) can be
leveraged to implement the proposed service framework solution. The Service
Access Points (SAPo) are hiding such implementation details of the service
frameworks behind a common API (SAPA). Therefore, NF services are able to run
on any service framework implementation for which a SAPo, compatible with the
3GPP-defined SAPA, exists.
As stated, the SAPA must be standardised on both stage2 and stage3 level so
that multivendor interoperability of the NF services is supported. It is
possible in principle that the \"southbound\" interface of the SAPo also uses
a standard protocol, e.g. AMQP (standardised by OASIS) for enterprise message
systems. In this case, it is not precluded that SAPo is integrated into a
service implementation; however, this combined implementation would then only
operate with AMQP-based frameworks and lose its generic interworking
capability with any SAPA-based (3GPP) framework.
The intention of this architecture is to de-couple communication peers from
each other, to simplify the internal structure of the NF services and to
overcome limitations of the traditional P2P interaction concept, especially
with respect to failover handling.
The functional blocks of the service framework and their role in the
architecture are described in the following clauses.
NOTE: As with the NRF in Release 15 the mentioned Service Framework Functions
can be slice specific or shared across slices.
##### 6.2.2.4.1 SAPo (Service Access Points) and SAPA (Service Access Point
API)
Service Access Point is a functional entity that acts as an adapter between
the implementation specific service framework and the NF services that make
use of the service framework functionalities. The SAPA is the \"contract\"
between services and the SAPo, which is defined, standardised and documented
by 3GPP.
The SAPA provides methods for the registration/de-registration of NF services
instances as well as for the sending and receiving of messages.
Editor\'s note: The details of the message exchange between NF services and
the SAPo, including what needs to be clarified in the study or can be left to
the normative phase, are FFS.
NOTE: Protocol details (e.g. whether the SAPA provides 1:1 replica of R 15 SBI
or uses a simple encapsulation of R 15 SBI), can be left to stage 3 decisions.
The implementation of the SAPo depends on the vendor specific implementation
of the service framework; therefore it can be assumed that each service
framework vendor will provide its own SAPo implementation. clause 6.2.2.4.8
discusses possible ways how SAPos can be implemented and provided.
##### 6.2.2.4.2 Registration- Discovery and Authorization Management
The architecture figure depicts functional blocks for the registration-,
authorization- and discovery- management as part of the service framework.
This functionality correlates with the functionality of the Network Repository
Function (NRF).
The SAPA must contain methods to perform registration, de-registration,
authorization. SAPA does not require methods for discovery, because the
service producer selection by a service consumer is not required in this
solution (it is an implicit functionality provided by the framework).
Editor\'s note: Solution 5 provides a way how discovery can be treated in a
backward compatible manner.
##### 6.2.2.4.3 Communication Mechanism
The Communication Mechanism is the core part of the service framework because
it is in full control of the message exchange. It is responsible for the
routing and forwarding of messages between consumer and producer NF instances/
NF service instances and supports the automatic establishment and destruction
of temporary bindings between NF instances/NF service instances when needed.
Messages are in this model addressed to types of producer NFs/NF services, not
to individual producer NF instances/ NF service instances. The routing
mechanism takes over the responsibility of the discovery and selection of
communication peers, as well as the process of the actual delivery of messages
between the peers. The internal protocols and mechanisms used by the
communication mechanism for the plain message delivery are implementation
specific.
NOTE 1: Management of temporary bindings is described in other solution
proposals.
The SAPA must therefore contain methods allowing service instances to delegate
message delivery and receiving to the service framework. This might also
include mechanism for the notification of message delivery failures.
Editor\'s note: How to support selection of, and communication with, a
specific (set of) peer(s) (e.g. in case of UDM, UPF), whether it is needed
and/or the temporary bindings can be reused, is ffs.
The Communication Mechanism shall also monitor the message delivery process
and might use this information for support of load-balancing as well as for
the detection of failure conditions.
NOTE 2: Cross data center communication follows the same principles as with
release 15 deployments.
##### 6.2.2.4.4 Policy Enforcement
The described Communication Mechanism decouples the communication peers from
each other and applies common procedures to all messages exchanged between
communication peers. Amongst other things this allows for a common enforcement
of communication related policies, if required.
For example, the Communication Mechanism may provide a policy enforcement
mechanism to limit the message rate in receiving and sending directions up to
discarding of messages in case of overload.
Another example is to handle location affinity in deployments where the
service frameworks spans over multiple locations.
In general, it is expected that the specification and management of these
policies is specific to the framework. Any specific policy that affects the
SAPA would be standardised by 3GPP.
NOTE: Some policies applicable to the SAPA, e.g. throttling message rates by
an NF service instance for overload protection / mitigation, should be
discussed at stage3.
##### 6.2.2.4.5 Load Balancing
Due to the proposed monitoring of the message delivery process, the routing
management component shall have a certain degree of awareness of facts like:
\- message retention/delivery times,
\- delivery failures for certain message types or communication peer
instances,
\- overall system load, etc.
Such facts, combined with potential additional implementation specific
algorithms, might be used by the service framework to apply load-balancing to
the message delivery process.
NOTE: Details on the message delivery, i.e. pushed to a producer instance by
the service framework or pulled by a service instance are subject for stage 3
decision. Existing realisations of service frameworks should be taken into
account when defining these details.
##### 6.2.2.4.6 Failover Management
A major point that this solution addresses is a drastically simplified
management of failover situations. In the traditional P2P based interaction
model with long-living bindings between communication peers (as specified in
Rel-15) the responsibility for failover handling is put on the service
implementations.
The solution, described in this document proposes an implicit management of
failover situations in the service framework and removes this burden from the
NF service implementation. This is achieved by the decoupled, unsticky
communication relations between the NF service instances in combination with a
stateless NF service design (request messages are not sent to a specific
instance of a NF service, but to a NF service type instead). This makes NF
service instances in general replaceable without specific recovery procedures
to be specified. If the communication mechanism detects certain NF service
instances being unresponsive, then the corresponding message will be routed to
another NF service instance that can process it without impacting the customer
service. This ensures that only \"healthy\" NF service instances are used.
e.g. a heartbeat mechanism might be introduced that allows an early detection
of failed service instances and supports the health monitoring mechanism.
##### 6.2.2.4.7 Roaming architecture
Following figure illustrates the architecture in the roaming case.
Figure 6.2.2.4.7-1: Roaming architecture
The SEPP (Security Edge Protection Proxy) is connected to the Service
Framework via a R-SAPo (Roaming-SAPo) and registers itself with an indication
of the reachable PLMNs. The roaming procedures are transparent to the NF/NF
services.
The R-SAPo does not expose SBI methods, but instead just forwards messages to
and receives messages from SEPP.
##### 6.2.2.4.8 SAPo Implementation and Deployment options
This clause describes two different options how SAPos can be implemented and
deployed, to indicate consequences for the overall system deployment and
implementation flexibility.
In these two options the SAPo can either be integrated and delivered with the
Service Framework (SFW) or be a part of the NF service implementations
directly.
{width="4.165277777777778in" height="1.6520833333333333in"}
Figure 6.2.2.4.8-1: SAPo integrated in the Service Framework
The sequence above illustrates a NF/NF service registration procedure for the
case that the SAPo is part of the Service Framework. In this case the register
request from the NF service instance [01] and the returned response [03] are
3GPP compliant service invocations. The SAPo translates them to and from a
Service Framework specific format.
With this deployment option, NF services as well as the Service Framework are
in general replaceable by different implementations, since they are de-coupled
by a 3GPP standardized SAPA. A NF service implementation can operate on
different Service Frameworks as well as different NF service implementations
can operate on the same Service Framework.
{width="4.173611111111111in" height="1.8958333333333333in"}
Figure 6.2.2.4.8-2 SAPo integrated in the Service implementation
The second deployment option shows the case when the SAPo is integrated into
the NF service implementation. In this case the register request from the NF
service instance [01] and the returned response [03] are Service Framework
specific service invocations and therefore not 3GPP compliant. The NF service
implementations might in this case share a framework specific library that
encapsulates the interaction with a dedicated implementation of the Service
Framework.
With this deployment option, the NF service implementations are only
replaceable for the same type of Service Framework. An operation on a
different framework would require adaptations in the NF service
implementation. On the other hand, this deployment option might allow for
framework specific optimizations, e.g. to improve performance.
### 6.2.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
The procedures illustrated in the following clauses are based on deployment
option 1, as described in previous chapter.
#### 6.2.3.1 Registration and de-registration of NF instances/NF service
instances
This clause describes the high-level procedures for the registration of NF
instances/NF service instances at the service framework. In general, the
procedures for the registration of NF/NF service (instances) are unchanged
compared to Rel-15.
Registration of NF instances/NF service instances:
{width="3.2694444444444444in" height="1.64375in"}
Figure 6.2.3.1-1: NF/NF service instance registration procedure
01\. The NF instance/NF service instance sends a 3GPP compliant register
message to the Service Framework to register itself. The integrated SAPo
performs all necessary actions to adapt the registration message to a format
compliant with the vendor specific service framework implementation and
forwards it to the framework.
02\. The vendor specific service framework implementation performs any
required steps to handle this registration.
03\. The Service framework returns a 3GPP compliant register response back to
the NF service instance.
De-Registration of NF instances/NF service instances:
{width="3.44375in" height="1.64375in"}
Figure 6.2.3.1-2: NF/NF service instance de-registration procedure
01\. The NF instance/NF service instance sends a 3GPP compliant de-register
message to the Service Framework to de-register itself. The integrated SAPo
performs all necessary actions to adapt the de-registration message to a
format compliant with the vendor specific service framework implementation and
forwards it to the framework.
02\. The vendor specific service framework implementation performs any
required steps to handle this de-registration.
03\. The Service framework returns a 3GPP compliant de-register response back
to the NF service instance.
#### 6.2.3.2 Delivery of messages
As agreed in clause 6.5, a NF/NF Service consumer can request services, i.e.,
NFs/NF Services by name, using the Communication Service. The Communication
Service is referred to in clause 6.5 as \"message passing function\". The
solution assumes that the specific business logic is used to derive the name
the message passing function uses to route the message. This is illustrated in
Figure 6.2.3.2-1 below:
Figure 6.2.3.2-1: Communication Service Enabler
1) Service X Instance-1 determines as part of its business logic that a
service needs to be invoked. Service X Instance-1 derives a Service name based
on its specific business logic. E.g., if a Mobility Management Service
Instance is requesting services leading to the establishment of a PDU Session,
the relevant instance selects e.g,.\"session.smf.3gpp.org and it provides the
associated business logic parameters. It is FFS how specific business logic
derives the address or the name of the service producer.
Note that using similar naming, Network Slicing can be supported either as
part of the business logic or through NF/NF Service naming. e.g., if a
Mobility Management Service Instance is requesting services leading to the
establishment of a PDU Session in a particular Network Slice, e.g., Service X
Instance-1 selects e.g,.\"session.smf.s-nssai_1.3gpp.org\" (e.g., as specified
in TR 21.905 [1]),) and it provides the associated business logic parameters.
Note that in this solution, the Service consumer can use any name to request a
Service from the Service producer. This name can be constructed using any of
the examples provided above, including the UUID as described in IETF RFC 4122.
2) Service X Instance-1 requests communication services from the Service
Framework indicating the Service Name and associated business logic
parameters.
3) The Service Framework selects a Service Instance of the requested Service,
based on the business logic parameters provided by Service X Instance-1 and it
may optionally use network operator polices for such selection.
4) Depending on the internals of the Communication Service, within the Service
Framework, the communication service derives a routing path to the selected
Service Instance.
5a/b) The Communication Service delivers the message from Service X Instance-1
to the selected Service Y Instance(1/2), through the selected path.
##### 6.2.3.2.1 Communication Service Enabler Roaming Case
Figure 6.2.3.2.1-1: Communication Service Enabler - Roaming Case
1) Service X Instance-1 determines as part of its business logic that a
service needs to be invoked and that this service is outside the current PLMN.
Service X Instance-1 derives a Service name for Service Y, based on its
specific business logic. E.g., if a Mobility Management Service Instance is
requesting services leading to the establishment of a home routed PDU Session
for a visiting roaming subscriber, Service X (e.g.,
mm1.amf.3gpp.org/subscriber-data/{supi}/) may select Service Y\'s name, which
is offered in the HPLM, e.g,.\"session.smf.plmn-id.3gpp.org, and it provides
the associated business logic parameters.
2) Service X Instance-1 requests communication services from the V-Service
Framework indicating the Service Name, the HPLMN ID and associated business
logic parameters. Multiple instances of the Communication Service can be
deployed according to the network operator deployment needs.
3) The Communication Service, within the V-Service Framework, routes the
message to a Communication Service in the HPLMN according to the path derived
from the Service Name in the HPLMN.
4) The Communication Service in the VPLMN delivers the message from Service X
to the Communication Service in the HPLMN.
5) The Communication Service in the HPLMN, uses the Service Name, operator
policies and business logic parameters to derive the path toward the selected
Service Y Instance.
6) The Communication Service in the HPLMN delivers the message from Service X
Instance to the selected Service Y Instance, through the selected path.
#### 6.2.3.3 Failover Handling Procedures
Due to the decoupled service communication and the implicit load-balanced
distribution of messages to one of the registered producers of the same type
there are no special procedures for failover foreseen.
One exception is the case when a consumer sends a message to a special service
type and fails/crashes before it is able to receive and handle the
corresponding response.
### 6.2.4 Impacts on existing NFs/NF services and interfaces
The procedures for registration, de-registration and update of NF instances or
NF service instances as well as the SBIs do not change on Stage 2 level.
Service implementations don\'t need to handle the discovery of communication
peers, the maintenance and potential recovery of the communication
relationship as well as the enforcement of communication related policies.
Service implementations must register/de-register, and send and receive
messages via SAPA.
NOTE: Impact on granularity and therefore whether NFs or NF services or both
exist is studied in key issue 1 \"Optimal modularization of the system\".
This solution supports service compatibility through the support of Rel-15
service interfaces in the Rel-16 Service Framework.
Figure 6.2.4-1 illustrates how Discovery and Communication Services can work
without modification to Rel-15 NFs.
Figure 6.2.4-1: Enabling backward compatibility to Rel-15 communication
service
Figure 6.2.4-1 describes a comparable view of how Rel-15 message exchange
across SBA compatible NF Services can work using the proposed Communication
Service.
1) A Rel-15 NF Service selects a target NF service name and NF type, based on
the execution of the business logic.
1a) The proposed Communication Service also enables NF Service to select a
target NF Service name, in accordance to their business logic by using
Discovery Service within the Service Framework. Note that since the proposal
assumes name based routing, a Rel-15 NF can keep using the NF name and type to
request Discovery Service from the Service Framework.
2/3) A Rel. 15 NF Services uses the target NF Service name and type, along
with business logic parameters (e.g., S-NSSAI, DNN, SUPI) to obtain the IP
Address or FQDN of the target NF Service.
2a/3a) The proposed Communication Service uses the target Service name to
derive the path toward the relevant Service Instance. A Rel-15 NF Service
could avail of the Service Framework Discovery Service to obtain the FQDN of a
target Service Framework, that will route the message to the NF Service
producer.
4) A Rel-15 NF Service uses the FQDN or IP Addressed of the target NF Service
to route the control plane message to the target NF Service producer.
4a) In the proposed Communication Service the Rel. 15 NF uses the URI provided
by the Service Framework which along which will be use by the Communication
Service to routes the message to a target Service Instance, according to
network operator polices and business logic parameters. Note that the URI is
not the URI of the service instance but the an identifier that pointing to the
Service Framework that would process the message.
5/6/7) A Rel. 15 system still needs to implement a Communication Service able
to route control plane messages based on the FQDN or IP Address. The proposed
Communication Service routes the message using the FQDN or IP Address provided
by the NF Service as a name to derive path to the NF Service producer along
with the business logic parameters.
Editor\'s note: Further details regarding impacts are FFS
### 6.2.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.3 Solution 3: Distributed Service Framework
### 6.3.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
### 6.3.2 High level description
This clause proposes a framework that is based on Rel-15 and is designed as
distributed manner to achieve high efficiency.
The service logics and the service framework are decoupled. A service consists
of service logic and the \"framework agent\". The framework contains services
defined by 3GPP such as framework agent, service registration, discovery,
authorization, routing control, etc., as well as other supporting services
that are not defined by 3GPP.
Service logics are only responsible for the processing of business logic, and
do not need to care about service discovery. When there is a service invoke
request, the request will be sent to the framework agent. A service, when be
introduced into the system, will register to the framework through the
framework agent. The framework agent will store the service instance ID and
determine whether it is a new service based on the Service profile (e.g.,
service name, version, location of service, DNN, slice information). The
framework agent will register the service to the framework if it is a new
service, with the Service profile, otherwise the agent just store the service
instance ID.
Figure 6.3.2.1: Distributed Service Framework of eSBA
The service framework as shown in Figure 6.3.2.1. The Service 1 and 2 in the
Figure can either be instances of two NF services or one NF service. The
Service framework consists the following aspects:
\- Framework agent: responsible for the communication between services,
through proper message routing and service discovery as needed. Therefore, the
agent contains service discovery logic as well message encapsulation/de-
capsulation logic, when the service producer instance is not in the local
agent that serves the service, the local agent discover the peer agent
instance through the service profile. An agent, in implementation, can be
integrated with service logic as software module or deployed in the same
platform (e.g., data center). The service agent enforces message invoking
monitoring, select the appropriate peer service instance and the appropriate
routing to communicate based on the \"Routing Control\" functionality of the
framework. A Data Center can deploy one or more framework agent instance. An
agent can be invoked by one or multiple service logic instances. An agent can
be invoked by one or multiple service logic instances.
NOTE: the framework provides deployment flexibility and it is per choice by
operator to enable a/a set of framework agent(s) to serve some services, e.g.,
based on Service type, framework agent vendor, or data center.
Editor\'s note: Considering the reliability of the framework agent, the load
balancing and failover mechanism can be used by the Framework agent.
\- Routing Control: a logical centralized service that and provides service
interaction message routing policy for framework agent. The routing control
may consider factors such as versions, capacities of the service instances,
which are unaware by services.
Editor\'s note: Whether the interface between Routing Control and Framework
Agent is FFS.
\- Registration, authorization and discovery. Similar as the NRF role defined
in Rel-15. Provides service registration, authorization and discovery. The
discovery service may be invoked by framework agent. The registration service
will stores the registered service profile and the corresponding end address
(the framework agent address).
The interactions shown in Figure 6.3.2.1 are through API invoking through the
following service-based interfaces:
\- Ns1 is the interface between any service logic and the framework agent. It
is defined by 3GPP as a general interface which does not specific for a
certain service. A service logic will do service registration to the service
framework, through Ns1.
\- Ns2 is the interface between a framework agent and a framework. Ns2 is
defined by 3GPP. The interface is not responsible for sending and receiving
specific service messages but responsible for the control of the agent, as
well as service discovery as needed. Thus, Ns2 is based on the Rel-15 defined
Nnrf interface and needs to be further enhanced to support routing control and
other enhanced function which is FFS.
\- Ns3 is the interface between framework agents. According to the
framework\'s routing policy, the agent select the peer agent instance and
establish a direct connection toward it to send and receive service messages
for service logic, then the peer agent select the specific service instance to
route the message. The interactions between services across service framework
follows Rel-15 defined HTTP/2 based interfaces.
### 6.3.3 Services and illustrated Procedures
#### 6.3.3.1 Registration of service instances
Figure 6.3.3.1-1: Service registration procedure
1\. When a service instance becomes operative for the first time (registration
operation) or upon individual service instance activation/de-activation within
the service instance (update operation) e.g. triggered after a scaling
operation, the service instance register itself to Framework Agent (service
profile, service instance ID).\ Note: The framework agent address to which the
service instance belongs is configured in the service instance in advance. The
agent store the service profile, service instance ID and other parameters of
the service instance.
2\. The agent check whether it is a new service profile or just a new service
instance for an existed service profile, if it is a new service profile, the
agent will register this new service profile to the framework, together with
the framework agent address.
3\. Framework to framework agent: Registration response.
4\. Framework agent to service instanceï¼šRegistration response.
#### 6.3.3.2 Service invoking procedures
A agent provides the \"Message Transfer\" service which is defined with input
parameter as:
\- _User ID, Service profile of service provider, Message container_.
The service is invoked when a service logic needs to communicate with other
services. The agent establishes the connection to the remote agent if
necessary and transfer the message to the peer, as shown in the Figure
6.3.3-1.
Figure 6.3.3.2-1: Service invoke procedure
Taken the AMF interaction with UDM as an example (e.g., AMF register with UDM
using Nudm_UECM_Registration in the registration procedure).
1\. When a UE accesses to 5GC, the service consumer NF service A instance
decides to register the UE and construct Nudm_UECM_Registration service
message, then invoke the corresponding Framework Agent\'s Message Transfer
service with parameter: User ID (SUPI), service profile of the service
provider and the Message container(body of the Nudm_UECM_Registration service
invoke) to transfer the service message to Framework Agent.
2\. The Framework agent will check whether the qualified
Nudm_UECM_Registration service instance is available in local, if yes then the
agent will forward the message to it. Otherwise, the agent will select a peer
framework agent instance through service discovery procedure and establishes a
connection to it.
3\. Local Framework Agent route the message to the peer agent,
4\. The peer agent selects a Nudm_UECM_Registration service (NF Service B)
instance depending on the local policy or the policy from the framework.
5\. The peer agent forwards the service invoking message to the selected
service instance.
6\. The peer agent to the local agent: Response message.
7\. The local agent to the consumer service instance: Response message.
### 6.3.4 Impacts on existing Services and Interfaces
Editor\'s note: Further details regarding impacts are FFS.
This distributed service framework is compatible with Rel-15 and extends the
NRF based service framework.
### 6.3.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.4 Solution 4: Distributed 3GPP Aware Service Framework
Service framework is a set of common services which are not part of any
business logic but can be used by any business logic. It consists of common
services like Discovery, Authorization, Overload Control, Security, etc.
This solution is backward compatible with Rel-15 SBA.
The service framework proposed here will be distributed across multiple data
centers/hosts.
This solution also addresses key issue 5 on backward compatibility.
### 6.4.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
### 6.4.2 High level description
This clause proposes a framework that is based on Rel-15 SBA with some
possible Rel-16 enhancements and is designed as a service framework to enable
inter service communication in a consistent and uniform way.
The business logic and the service framework are decoupled. A service consists
of business logic which can be independently configured, deployed and scaled.
The service framework contains a set of common services such as service
registration, discovery, authorization, routing control, etc. Service
Framework may be realized in an operator network using various mechanisms and
could support various models of distribution and connectivity with the
business logic. However, the functions provided by the framework and
implementation aspects of the framework are not intended to be defined by
3GPP. What may be defined by 3GPP, if required, are certain requirements
around functions provided by the service framework (e.g. an overload control
algorithm).
The Service Framework will have an adaptation layer, which is 3GPP aware, and
which is thus able to select a producer based (among other considerations) on
3GPP info. The Business Logic always communicates with the Service Framework
via the service adaptor using the defined SBI service messages. The service
adaptor may consume or modify the message in the process of delivering it
based on configuration and the Service Framework functionality. The service
adaptor can be configured as an HTTP outbound proxy such that all messages
sent from a consumer or producer goes through the service adaptor. Note that
the service adaptor functionality can be realized by various models of
distribution and connectivity to ensure it is not a bottleneck or single point
of failure.
Examples of capabilities that could be supported by Service Adaptor are:
\- Utilization of 3GPP Information Elements in HTTP headers and JSON content
in performing discovery, selection, load balancing, prioritization, etc.
\- Adaptation to framework implementation.
\- Supports distributed multi-host/multi-datacentre architecture.
The Service Framework should be capable of performing transparent routing or
non-transparent routing. In the transparent routing mode, the service
framework routes messages between consumers and producers without modifying
identities/URIs used to locate corresponding resources. In this case, such
identities/URIs are assumed to be routable between consumers and producers. In
the non-transparent mode, the service framework may modify identities/URIs
used by consumers and producers to locate corresponding resource for the
purpose of hiding such information from recipients (topology hiding) or to
transform non-routable identities/URIs to routable ones.
API revisions that may be performed as part of Rel-16 shall facilitate
presence and functioning of a Service Framework. Considerations such as
placing of information related to routing, discovery, priority etc in headers
vs. content shall take into account presence of Service Framework. Similarly,
authorization and authentication aspects shall take into account the presence
of Service Framework. The service framework introduction shall ensure backward
compatibility with Rel-15 services.
Business logic is only responsible for the processing of business logic, and
does not need to care about service discovery. When there is a service
invocation request, the request will be sent to the service framework (as an
outbound proxy).
The interactions between services across the service framework follow the SBA
defined HTTP/2 based interface. This includes the interactions with the NRF.
The service framework forwards a request from one service to another service.
Figure 6.4.2.1 below illustrates the service framework and its interaction
with the business logic of the 3GPP NF.
Figure 6.4.2.1: Distributed Service Framework of eSBA
To support the backward compatibility with Rel-15 the NRF can be used along
with Service Framework. Rel-15 NFs can continue to interface with Rel-15 NRF
via the Service Framework, including performing the selection of a service
producer instance. However, in order to fully achieve the separation of
business logic from the common service framework, a key part of service
producer selection logic which has been included in the service consumer (in
release 15) should be moved to the Service Framework.
Follows are some of the key functionalities, which the service framework
supports:
Service registration, Service discovery, Service authorization, Load
balancing, Overload control and more.
Editor\'s note: Additional services provided by the service framework such as
failover handling, retries, etc. are FFS.
##### 6.4.2.1 Roaming architecture
The following figure illustrates the architecture in the roaming case:
Figure 6.4.2.1-1: Roaming architecture
The SEPP (Security Edge Protection Proxy) functions as defined in TS 23.501
[2]. It communicates with the Service Framework via the Service Adaptor using
the 3GPP SBIs.
The interactions between NFs/services and the SEPP for roaming procedures are
handled by the service framework: the service framework sends messages to the
SEPP when they are intended for another PLMN and sends messages received by
the SEPP from another PLMN to the appropriate internal NF consumer/producer.
##### 6.4.2.2 Network slicing aspects
The Service Framework based on operator preferences may get deployed at three
possible levels: PLMN level, slice common level, slice level. Figure 6.4.2.2-1
below illustrates a deployment option where each slice has its own Service
Framework. This design adheres to slice isolation principles, simplifies the
service framework logic, and enables the operator to implement different types
of frameworks per slice. The PLMN level NFs such as the AMF, UDM and NSSF are
viewed in this regard as being located in a special type of \"slice\", and
thus use their own Service Framework. In this deployment option, Service
Frameworks will need to communicate with each other to convey messages between
NFs/services served by different Service Frameworks.
NOTE 1: How different Service Framework instances discover each other is
outside of the scope of 3GPP, i.e. this is similar to how different instances
of NRFs in discover each other in Release 15.
Figure 6.4.2.2-1: Service Framework deployed in NS Level
Figure 6.4.2.2-2 below illustrates a deployment option where a Service
Framework is deployed in a slice common level, i.e. it is shared across
multiple slices. This design enables visibility of the Service Framework to
multiple slices, and may be more suitable to deploy than a slice level Service
Framework to minimize the number of service frameworks when multiple slices
have similar characteristics, and thus having a common logical service
framework can simplify the deployment model. In this deployment model, the
PLMN Level NFs such as the AMF, UDM, NSSF, may still use their own Service
Framework.
NOTE 2: How different Service Framework instances discover each other is
outside of the scope of 3GPP, i.e. this is similar to how different instances
of NRFs in discover each other in Release 15.
Figure 6.4.2.2-2: Service Framework deployed in an NS-Common Level
Figure 6.4.2.2-3 below illustrates a deployment option where a Service
Framework is deployed in a PLMN level, i.e. all NFs in the PLMN (including
those inside a slice) communicate via a common logical Service Framework
(which can be deployed as a distributed framework). This design enables
visibility of the Service Framework to the entire core, and may be simpler to
deploy than a slice level Service Framework. In this deployment option, there
is no need for an inter service framework communication.
Figure 6.4.2.2-3: Service Framework deployed in a PLMN Level
### 6.4.3 Services and illustrated Procedures
#### 6.4.3.1 Service Registration/Update/Deregistration
According to TS 23.502 [3] clause 4.17, a Rel-15 NF service producer, e.g. SMF
instance, registers itself by sending an Nnrf_NFManagement_NFRegister Request
message (the NF profile of NF serviceproducer) to the NRF to inform the NRF of
its NF profile when the NF service producer becomes operative for the first
time.
Later on the NF service producer can update the NRF for changes in profile by
sending the NRF an Nnrf_NFManagement_NF Update_Request message.
Finally the NF service producer can let the NRF know about its unavailability
by sending the NRF an Nnrf_NFManagement_NFDeregister_Request message.
According to this solution, a Rel-15 NF service producer can register itself
by simply sending the Nnrf_NFManagement_NFRegister Request message to the
service framework (i.e. to its HTTP outbound proxy).
The service framework can then decide whether to send the message to the NRF
or whether to consume the message internally, and register the service
producer within the service framework itself (e.g. in its own database).
If the service framework forwards the Request message to the NRF, the NRF
processes the Request and returns a corresponding response to the service
framework.
When service framework supports registry functions, it is up to implementation
on how the internal framework service registry and NRF express themselves
together as a logical NRF. The service framework then forwards the response
back to the service producer.
If the service framework consumes the Request message internally, it processes
the Request and returns a corresponding response to the service producer.
According to this solution, for a Rel-16 NF service producer there is an
option that the above-mentioned message exchange between NF and NRF is omitted
and the service framework implicitly addresses registration by its own
mechanism (e.g. combined with creation and maintenance of instances).
Some examples on the combination of NRF and the service framework are listed
below for illustration purposes:
1\. Service registry is not implemented in the framework and NRF acts the sole
service registry.
2\. Service framework itself provides service registry and, when needed,
provides NRF services.
In general, all discovery and registration requests, if any and needed, are
expected to be routed through Service Framework and hence Service Framework
can process such requests based on shared responsibilities between Service
Framework and NRF.
#### 6.4.3.2 Service Discovery
Service Discovery can be performed in either of the following two modes:
Explicit Mode (supports backward compatibility) and Implicit mode.
In the Explicit mode, service discovery is done explicitly in the same way it
is done in Rel 15. This is illustrated in TS 23.502 [3] clauses 4.17.4 and
4.17.5. The only difference in Rel-16 is that the service consumer will send
the Nnrf_NFDiscovery_Request to the service framework (as its HTTP outbound
proxy) instead of sending it directly to the NRF.
In the Implicit mode, service discovery is delegated to the service framework.
This can be achieved by means of configuration, i.e. the service consumer can
be configured to skip service discovery by simply sending the actual service
request to the service framework. For example, AMF can be configured to send
Npcf_AMPolicyControl_Create request to the service framework without going
first through the procedure of service discovery.
The Implicit mode is an optional feature left for operator configuration and
may not be backward compatible with Rel-15.
Upon receiving the actual request from the service consumer, the service
framework, if needed, performs the service discovery request on behalf of the
service consumer. It consumes the service discovery response internally
andperforms service producer selection to decide where to send the service
request received from the service consumer. Some service invocation requests
may require additional parameters added as headers or JSON payload to support
service producer selection as previously defined for some NF. The service
consumer is able to maintain the binding to the service producer by using the
response URI included in the service producer response, so the Service
Framework does not need to cache the producer selection for each request.
#### 6.4.3.3 Service Request/Response
As described in clause 6.4.2, the service framework can be defined as an HTTP
outbound proxy of a service consumer. Based on that, any request of a source
service consumer is simply forwarded to the service framework as is. The
service framework can then apply any special processing (eg Load balancing)
and forward the request to the target service consumer. The service logic will
send all the information elements (e.g S-NSSAI, DNN, SUPI etc) in the service
request.
Based on normal HTTP routing, the response from the target service
consumerwill be returned to the service framework. The service framework will
then match the response with its original request and accordingly will forward
the response back to the sourceservice consumer.
### 6.4.4 Impacts on existing Services and Interfaces
Editor\'s note: Further details regarding impacts are FFS.
This distributed service framework is compatible with Rel-15 and extends the
NRF based service framework.
The Rel-15 consumer is not aware of a Rel-16 service framework existence
configured for explicit mode, other than have it configured as its HTTP
outbound proxy (which can be the case in Rel-15 as well when using an HTTP
equivalent of DRA).
When the service framework is configured for explicit mode, the Rel-16
consumer is not aware of a service framework existence, other than have it
configured as it s HTTP outbound proxy (which can be the case in Rel-15 as
well when using an HTTP equivalent of DRA).
When the service framework is configured for implicit mode, the Rel-16 SBI may
require updates based on the identification of parameters associated with
service producer selection if those parameters are not already present in the
message. The Rel-16 SBI may require updates regardless of the presence of a
service framework as other new functionality is introduced, so the updates to
provide easy access to selection related parameters should not be a
significant impact. Extra parameters (e.g. DNN, SUPI) to enable the service
framework to perform the delegated service discovery are those listed for the
query strings in URI for GET methods of Rel. 15 Nnssf_NSSelection Service (TS
29.531 [6], Table 6.1.3.2.3.1-1) and Nnrf_NFDiscovery Service (TS 29.510 [4],
Table 6.2.3.2.3.1-1).
### 6.4.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.5 Solution 5: Flexible Service Framework Deployment
### 6.5.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\" and key issue 5 \"SBA backward and forward compatibility\".
### 6.5.2 High level description
In Rel-15 the service framework consists of the functional components
illustrated by the figure 6.5.2-1 below.
{width="6.669444444444444in" height="2.765277777777778in"}
Figure 6.5.2-1: Rel 15 service framework
The NRF handles the service registry and the consumer authorization. The NF
may consist of one or several NF Service consumers and NF Service producers.
An NF service consumer consists of the service business logic, service
discovery and service instance selection. An NF producer consists of service
business logic, service registration and optionally load balancing. It is
implementation dependent if there is a load balancer. NF service consumers
communicates directly with NF service producers. The ovals in figure 6.5.2-1
can be seen as components of the service framework.
NOTE 1: An NF service may include both the consumer and producer roles in the
same NF service. They are discussed and shown separately in figures in order
to clarify the functionality needed for the 2 different roles.
In a new service framework, these types of components will still need to exist
in one way or the other. The solution in 6.2 introduces a service framework
where all of these components are moved to a logically centralized service
framework. This does not mean that in deployment time that the service
framework is centralized. For simplicity reasons in this clause 6.5
centralized framework mean that it is logically centralized.
To enable co-existence of existing Re. 15 service and the possibility to
choose at network design which type of service frame work is wanted by an
operator, the following model is proposed as shown in figure 6.5.2-2 below.
Figure 6.5.2-2: Flexible service framework
The NF/NF services in Relâ€‘15 can be kept asis. If a centralized service
framework is selected in the network design (deployment), the service
consumers will either get pseudo addresses of the producer leading to the
centralized service framework (CSF) or it will be configured with a HTTP proxy
address leading to the centralized service framework. By this all the
consumers\' service invocations will go via the CSF. Still, consumers will do
selection ,which may be a Selection of a service set/NF. If a centralized
service framework is not selected in the network design (in deployment), then
rel. 15 procedures will be used.
NOTE 2: Using proxy may inhibit use of TLS. E.g. use of SEPP required change
of FQDN in the HTTP header.
Standardized consumers always do discovery of a service producer. The reason
for this is backward compatibility and the possibility to support both
services frameworks as well as potentially lesser configuration. The discovery
procedure is done seldom, and the basic part can be implemented in a few lines
of code, and depending on implementation architecture used by a vendor, it may
be a common SW entity that is re-used by all the vendor\'s consumer
implementations. However, in Relâ€‘15 there are some special behaviour for
discovery of for example UDM where MNC and MCC are important parameters to
consider, and thus it may not be so that all consumers can have just a generic
discovery procedure.
One should observe here that instance selection is not always generic. For
example, when AMF selects an SMF instance the following should be considered:
\- Selected Data Network Name (DNN).
\- S-NSSAI.
\- Subscription information from UDM, e.g.:
\- per DNN: whether LBO roaming is allowed.
\- per S-NSSAI: the subscribed DNN(s).
\- per (S-NSSAI, subscribed DNN): whether LBO roaming is allowed.
\- Local operator policies.
\- Load conditions of the candidate SMFs.
\- Access technology being used by the UE.
This is different from when AMF selects another AMF then the following shall
be considered:
\- AMF Region ID and AMF Set ID derived from GUAMI.
\- Requested NSSAI.
\- Local operator policies.
\- Availability of candidate AMFs.
\- Load balancing across candidate AMFs (e.g. considering weight factors of
candidate AMFs in the AMF Set).
As can be seen some of the factors to consider for AMF when selecting SMF
could be generalized, but some are unique per selection. Therefore a consumer
will do selection based on 3GPP unique parameters, if a CSF is deployed,,a
consumer may just do selection of NF instance or service instance set. When
the consumer has made the selection, the CSF may select a service instance.
If it is arbitrary which producer instance is selected, i.e. no 3GPP
parameters are to be considered in the selection, the discovery result may be
one SBI address representing all the producers and the CSF will select a
producer instance. The producer may reply with a resource URI identifying the
specific producer URI which shall be used by the consumer for subsequent
requests.
### 6.5.3 Services and illustrated Procedures
#### 6.5.3.1 Registration and de-registration of NF instances/NF service
instances
This clause describes the high-level procedures for the registration of NF
instances/NF service instances at the service framework. In general, the
procedures for the registration of NF/NF service (instances) are unchanged
compared to Rel-15.
Registration of NF instances/NF service instances:
\- the NF instances/NF service instance uses the Rel-15 mechanism to register
it self.
De-Registration of NF instances/NF service instances:
\- the NF instances/NF service instance uses the Rel-15 mechanism to
deregister itself.
#### 6.5.3.2 Discovery and selection of NF services and communication between
consumer and producer without Centralised Service Framework
A legacy consumer uses the Rel-15 mechanism to discover producers. New
standardized consumers services always do service discovery. See clause 6.5.2.
For examples of consumer to producer communication see below figures 6.5.3.2-1
and 6.5.3.2-2 for non-roaming and 6.5.3.2-3 and 6.5.3.2-4 for roaming.
{width="6.695833333333334in" height="4.104166666666667in"}
Figure 6.5.3.2-1: Consumer to producer communication, no centralized service
framework
Figure 6.5.3.2-1 is the Relâ€‘15 behaviour, and will be used if no centralized
service framework is wanted.
#### 6.5.3.3 Discovery and selection of services and communication between
consumer and producer with Centralised Service Framework
##### 6.5.3.3.1 Example when 3GPP specific parameters are needed in the
selection
Figure 6.5.3.3.1-1: Consumer to producer communication, with centralized
service framework, 3GPP specific parameters needed for selection
In figure 6.5.3.3.1-1 represent an example of a consumer x instance #1 that
wants to communicate with the producer y. The consumer is configured with a
proxy address or the NRF has generated pseudo addresses for producer y as
shown in figure, which leads to the CSF. The producer y has 3GPP specific
parameters needed for selection.The consumer does discovery and gets a list of
pseudo network addresses of service instance #1 in this example, and sends the
request to pseudo address for the service set (or NF)which is the an ingress
address of CSF. The CSF will select a producer instance among the selected
service instance set (or NF instance) to be used for this operation, producer
service y set #1 service instance #2 in this example.
##### 6.5.3.3.2 Example when 3GPP specific parameters are not needed in the
selection (and discovery)
Figure 6.5.3.3.2-1 shows an example flow for a request where no 3GPP specific
selection (nor discovery) is needed.
Figure 6.5.3.3.2-1
A consumer x instance #1 wants to communicate with the producer y.. The
consumer does not need to consider 3GPP specific parameters for selection The
consumer does discovery and gets only one address representing all instances
and sets (NFs if rel 15) of producer y this address is either a pseudo
address, or if proxy is used as in this example a real address representing
all producers. The consumer selects this address and sends the request to the
configured proxy address, which is the ingress address of CSF. The CSF will
select a producer instanceof producer y and sends the request to this
instance. The producer responses and includes a URI that shall be used for all
following requests regarding this context. In this case it is a URI that
represent the selected set.
In a subsequent request regarding this context, the consumer x uses the
received URI (uri of set #1) and the CSF uses this to route the message to an
instance within the service set. In this example instance #1 of service set #1
of service y.
If pseudo address is used representing the consumer, then similar procedure is
used.
##### 6.5.3.3.3 Examples of roaming
The following figures shows roaming examples of how a logically centralised
service framework deployed the visited network interacts with a Relâ€‘15 based
Service framework in the home network and vice versa.
Figure 6.5.3.3.3-1: Consumer to producer communication over roaming interface,
centralized service framework in VPLMN
Figure 6.5.3.3.3-2: Consumer to producer communication over roaming interface,
centralized service framework in HPLMN
The SEPP in figures 6.5.3.3.3-1 and 6.5.3.3.3-2 may of course do topology
hiding. These figures illustrated the principles.
#### 6.5.3.3 Non-standardized services
Non-standardized services could be implemented targeting a specific network
design model. These non-standard services may utilize a centralized service
framework by for example to not do service discovery or instance selection.
They may interact with the centralized service framework in a different way
compared to the standardized services.
### 6.5.4 Impacts on existing NF/NF Services and Interfaces
No impact on existing NF/NF services and interfaces.
### 6.5.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.6 Solution 6: Services Framework enhanced with a Service Agent
### 6.6.1 Introduction
This solution addresses key issues #3 \"Improvements to service framework
related aspects\" and #5 \"SBA backward and forward compatibility\".
In Rel-15, 5G System supports services framework as follows:
Following are 5 main steps involved:
\- Advertisement of NF/NF Service to NRF for Registration and Update. NRF
manages the NFs and NF Services.
\- Consumer performs Dynamic Discovery of NF Service Producer with the NRF.
\- Consumer selects NF/NF Service Producer.
\- First level of authorization of NF Service Consumer by the NRF to contact
the NF Service Producer.
\- Distributed Routing of service request from NF Service Consumer towards NF
Service Producer for unlimited scaling.
### 6.6.2 High-level Description
In this solution, we propose to introduce Service Agent for the Service
Producer and Service Consumer. Service Agent may function as follows:- Case 1:
Perform load balancing and serve as Gate Keeper (e.g. signalling storm
protection) for the Service Producer instances.
\- Case 2: Serve as Gate Keeper (e.g. signalling storm protection) for the
Service Producer instances.
Following principles are proposed:
\- Service Producer and Service Consumer may decide whether it exposes Service
Instance URI or registers Service Agent URI only for a given Service with the
NRF.
\- When Service Consumer performs discovery query, it may either receive:
\- URI of Service Agents only (Case 1); (or)
\- URI of Service Instances (Case 2).
Service Consumer can optionally perform discovery via Service Agent and in
this case, Service Agent performs the discovery request with the NRF on behalf
of the Service Consumer.
NOTE 1: Even in Rel-15, it is up to the NF/NF Services to determine whether it
is the URI of the Service Instance or the URI of the NF is registered with the
NRF. Case 1) and Case 2) enables support for backward compatibility with
Rel-15 NF/NF Services.
NOTE 2: For case 1, Service Agent is registered and it is assumed the full URI
is available (i.e. it could be seen as equivalent to the Rel-15 NF FQDN or IP
address) thus backward compatibility is achieved. For case 2, backward
compatibility is enabled by registering the service instances leveraging the
attribute ipEndPoints (reference clause 6.1.6.2.3 in TS 29.510 [4]). This can
use the IP address of the Service Agent to enforce that it is always in the
path and a dedicated port per service instance.
* * *
ipEndPoints array(IpEndPoint) O 0..N IP address(es) and port information of
the Network Function (including IPv4 and/or IPv6 address) where the service is
listening for incoming service requests
* * *
\- Case 1: If Service Consumer/Service Agent of the Service Consumer receive
URI of Service Agents, it performs Selection of the right Service Agent and
uses the URI of the Service Agent for the target service request; Service
Consumer sends the Service Request message to the selected Producer Service
Agent and the Service Agent performs load balancing and forwards the request
towards the selected Producer Service instance.
\- Case 2: If Consumer receive URI of Service Instance, it performs Selection
of the right Service Instance and uses the URI of the service instance for the
target service request.
\- No additional API needed between NRF and Service Agent. From Services and
NRF perspective, it works as though there is direct communication between
services and direct communication with NRF.
\- Service Agent can either be standalone or collocated with the Service. If
there are multiple Service Agents for the same type of Service, multiple
Service Agents could interact with each other (e.g. to address failure, load
re-balancing situations).
The following figure illustrates the two architectural (deployment) options:
Figure 6.6.2-1: Service Framework with a Service Agent
Service 1, Service 2, Service 3 are instances of the same type of Service.
Following figure illustrates that a cardinality mapping between Service and
Service Agent could be m:n:
Figure 6.6.2-2: Service Framework with a Service Agent
In the above figure, Service Agent-P refers to Producer Service Instances and
Service Agent-C refers to Consumer Service Instances.
This architecture implies that trust relationships need to be established:
\- Trust between the Service Instance and the Service Agent (both in the
Producer and Consumer side).
\- Service Agent of the Service Producer does the verification of the access
token (and not the Service Producer anymore as in Rel-15).
\- The NRF needs to authorize the consumer to obtain services from any of the
Service Producer instance served by the Service Agent (i.e. the access token
should not point to a specific Service Producer instance as in Rel-15).
Items #1 and #2 are potential impacts only if the interface between Service
and Service Agent is a multi-vendor interface.
### 6.6.3 Illustrated Procedures
Following call flow illustrates how a Service Consumer discovers a Service
Producer and requests for a service via Service Agent (Case 1):
Figure 6.6.3-1: Call flow for Case 1: Two Step Selection Method
\- The NF Service consumer requests discovery of the NF Service producer by
invoking a Discovery Request API (e.g. providing service specific parameters
such as MCC, MNC, Routing ID, Group ID etc for UDM selection) on its Service
Agent interface with its associated Service Agent (Consumer Service Agent).
\- The Service Agent forwards the request to the NRF over a mutually
authenticated secure connection.
\- The NRF authorizes the NF Service Consumer, determines the appropriate NF
Producer Instance(s) or NF Producer Service Instance(s) and provides
information of their associated Service Agents to the Service Consumer in the
discovery response message.
\- The NF Service Consumer selects an appropriate Producer Service Agent from
the list provided by the NRF considering service specific parameters (e.g.
TAI, S-NSSAI, locality, priority etc). This is the first step in the selection
process.
\- The NF Service Consumer obtains Access token from NRF via its associated
Consumer Service Agent. The Access token will enable the Service Consumer to
obtain service from any of the Service Producers associated with the selected
Producer Service Agent.
\- The NF Service consumer requests service from the NF Service producer by
invoking an API on its Service Agent interface with the selected Producer
Service Agent. The NF Service Consumer includes the access token in this API.
The request is made over a mutually authenticated secure connection.
\- The receiving Service Agent verifies the token in one of the following
ways:
\- Request the NRF to verify the token. The NRF verifies the token and
responds back to the Service Agent.
\- The Service Agent verifies the integrity of the token on its own. If
integrity check is successful, the Service Agent next verifies the claims in
the token.
\- If the authorization check is successful, the Service Agent selects a
target Producer NF Instance or NF Service Instance, and forwards the API
Request to the selected NF Service Producer.
\- The NF Service Producer provides the requested service to the NF Service
Consumer.
From this point onwards, the Service Agent of the NF Service producer is
involved in routing of the messages between the two NFs.
Following call flow illustrates how a Service Consumer discovers a Service
Producer and requests for a service via Service Agent (Case 2):
Figure 6.6.3-2: Call flow for Case 2: One Step Selection Method
The same call flow steps as for figure 6.6.3-1 applies with the following
differences:
\- Step 4 - Service Consumer selects the Service Producer Instance directly.
\- Step 8 - Service Agent of the Service Producer routes the Service Request
message directly to the Service Producer Instance (i.e. no selection needed).
Figure 6.6.3-3: Call flow for Case 1: One Step Selection Method - Roaming
Scenario
The same call flow steps as for figure 6.6.3-1 applies with the following
differences:
\- Requests between Services/Service Agents in the VPLMN and HPLMN are
transmitted via V-SEPP and H-SEPP.
### 6.6.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
### 6.6.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.7 Solution 7: SBA with stateless and unsticky services
### 6.7.1 Introduction
This solution addresses key issues 4 \"Architectural Support for Highly
Reliable Deployments\".
When the 5G system is deployed in the cloud, the overall reliability of the
system shall be at least at the same level as non-cloud implementations /
deployments. In a typical cloud environment, NFs or NF services may fail at
any time and in general more frequently than traditional network nodes. For
this reason, the 5G system shall be able to deal with the unexpected loss of
NF instances / NF services instances in a way that avoids impact on the
customer service or detrimental side effects on the network (e.g. signalling
storms) when such failures occur.
Unexpected loss of NF instances/NF service instances leads to system and / or
customer service impact when the failed instance has active bindings (e.g.
tightly coupled UE-specific information) with other NF instances / NF service
instances. This might require the standardisation of complex recovery
mechanisms to return to normal operation while minimising end user service
impact.
Such complex mechanisms would have to include the transfer of the failed
instance\'s load / service contexts to other existing instances or to newly
instantiated \"replacement\" NF / NF service instances. This may cause
limitations to network automation, e.g. when:
\- Newly instantiated NFs / NF services that replace the failed instance need
to be specifically configured to act as replacement for the failed instance.
\- Existing NFs / NF services need to be specifically configured to integrate
the newly instantiated NFs / NF services as the replacement of the failed
instance.
\- Existing NFs / NF services need to be specifically configured to take over
for the failed instance.
\- Previously existing bindings and / or service contexts have to be restored
and be moved to existing or the new instance(s).
It should be noted that the restoration of pre-existing bindings or service
contexts might not be possible in many cases, i.e. the recovery procedure
implies the loss of the bindings or service contexts.
In the following clauses, a solution is presented that avoids the above issues
and does not require the specification of complex recovery procedures that
would probably have to be specific per NF / NF service type and / or failure
scenario.
### 6.7.2 High level description
#### 6.7.2.1 Solution aspects
The solution proposed here contains two main aspects to address the above
issues:
\- Specifying the NFs / NF services as \"unsticky\" so that long-living
bindings between NF / NF service instances are avoided.
\- Specifying the NFs / NF services as \"stateless\" (separation of compute
and storage resources), i.e. NF / NF service instances store state / service
context information in an external storage layer (e.g. UDSF) when the state /
service context is stable (e.g. at the completion of a transaction).
Thereby, failed instances can effortlessly be replaced by newly instantiated
or already existing ones, which can then promptly recover the stored state /
service context from the storage layer when and as needed.
#### 6.7.2.2 Issues related to long-living bindings between NFs / NF services
Today the UE gets assigned serving NFs (e.g. based on the UE\'s location). The
UE will continue to be served by these NF instances until a trigger to re-
allocate a serving NF occurs (e.g. UE moves out of the service area of its
current serving NF instance(s)). Thereby bindings are created between the UE
and its serving NF instances, and orderly re-bindings (i.e. change of serving
NF instance) can only occur by system procedures (e.g. mobility) specified in
3GPP.
In the Rel-15 5GC, serving instances of AMF, SMF, SMSF and PCF NF/NF services
are selected per UE. This creates UE specific bindings between the selected
AMF, SMF, SMSF and PCF NF/NF services instances.
Furthermore, the identities of the serving NFs/NF services are stored in the
UDM/UDR NF/NF services, which creates another set of bindings in the 5GC.
Loss of any of the UE\'s serving instances destroys the associated bindings
and thereby breaks the UE\'s service context environment in the network,
causing the correlated customer service to fail.
In a cloudified 5G system, a long-living binding to a dedicated NF or NF
service instance always means a long-living binding to a dedicated SW instance
that represents the NF / NF service. Consequently, the above system and
service impact may occur any time a SW instance is lost (e.g. due to HW
failure or SW bug), but it is only the case when there is a one-to-one
assignment of an NF/NF service to an individual HW/SW instance, which could be
avoided by different solutions, e.g. a pool of SW/HW instances are offered by
a single point of access as a single NF/NF service.
In case there is a one-to-one assignment of an NF/NF service to an individual
HW/SW instance, a summary of identified problems and challenges with long-
living bindings in the cloud (non-exhaustive list) can be given as follows:
\- Complex scaling operations across the network:
\- when scaling out:
\- make the new instances known to other services to \'start using them\',
this leads to high configuration effort;
\- need to transfer bindings from already existing instances to new ones, this
leads to the need for complex reallocation procedures.
\- when scaling in:
\- make other instances aware that the to-be-removed instance shall no longer
be used;
\- transfer bindings to other instances or await orderly unbinding (e.g. UE
detaches).
\- Need for load-(re)balancing:
\- with long-living bindings a load distribution for new bindings has to be
done;
\- in case of unequal load of service instances a dedicated re-distribution of
load, implying transfer of the binding(s), has to be done (additional load re-
distribution mechanism needed).
\- in case of failure:
\- customer impact is likely in case of service instance failure;
\- reallocation (transfer of bindings) similar to scale-in but additional
challenges need to be handled due to the \"unexpected scale in\";
\- complex configuration or complex automation procedures.
#### 6.7.2.3 Issues related to stateful NFs
A typical NF / NF service is defined by its service logic (executed by some
compute resources) and some service context data (located in a storage
resource) on which the service logic is applied. The service logic data is
well-defined in 3GPP specifications for the 5G system, while the service
context/session data is defined only when it is required for external
interactions with other NF/NF services via standard interfaces, e.g. it is
defined the UE permanent data that is stored in UDR that is required by
another entity to perform its service logic; while it is not defined the
internal session/context data that is required internally by each NF/NF
service to perform its service logic.
Historically, 3GPP network entities retain service contexts locally even when
they are not used, i.e. not currently being subject to service logic
processing.
If a NF / NF service instance holds unused service context information (e.g. a
UE\'s MM context) internally (i.e. compute and storage resources are not
separated) and the instance becomes unavailable (due to HW or SW failure) the
service context data is lost and the customer\'s service is impacted.
As defined in 3GPP UDC (from Rel-13 on), subscription data is stored
externally, while in Rel-15 Storage architecture solution indicates that not
only subscription data, but as well policy data, application data and
structured data for exposure is stored externally in UDR. Apart from that,
internal session/context data may be stored in external storage resources by
each implementation.
In case service data is stored in the same SW/HW entity as the one used for
processing (logic and data is not separated), then identified problems and
challenges with NF / NF service internal storage of service context
information in the cloud are similar to the issues listed in relation of long-
living bindings, as also the service contexts need to be managed in a similar
way to the bindings and case of scaling, load (re-)balancing or failure
recovery. In addition, local storage of service contexts within NF instances /
NF service instances limits the use of such context data by other entities as
it is necessary to have knowledge about the location of the desired context
data within a specific NF instance / NF service instance.
#### 6.7.2.4 Solution Preconditions, Assumptions and Requirements
Preconditions:
\- the 5G system is made up a suitable set of 3GPP defined \"modules\" (NFs
and/or NF services) that allow fast spin-up and teardown of instances.
Assumptions:
\- There exists a suitable storage layer/resources that can be used by all
relevant NF / NF service instances for storing and retrieving service context
data.
\- The service context data stored in the storage layer corresponds to the
3GPP defined NF / NF service context data that a NF / NF service processes
when applying its service logic. This corresponds to data that is stored
according to Rel-15 storage architecture into UDR, plus session/context data
that may be stored externally (e.g. in UDSF).
\- Adequate reliability and availability of the storage layer can be achieved
and is realised by methods internal to the storage layer.
NOTE 1: the existence of NFs and/or NF services in Rel-16 is determined under
key issue 1.
Requirements:
\- The service context information that is stored in the storage layer and
necessary for multivendor interoperability between services shall be
structured and standardised in 3GPP, similar to e.g. a UE context that is
passed between AMFs during a relocation procedure. This corresponds to the
data defined to be stored in Rel-15 UDR.
\- The service context information that is stored in the storage layer and
necessary for recovery of instances of the same NF/NF service, is required to
be standardized by 3GPP to achieve multi-vendor deployments of instances of
the same NF/NF service. This will correspond to new data to be stored in UDR
(as long as this data is meant to be standardized).
\- Part of the service context information that is stored in the storage layer
may be shared by other types of NF/NF services, if so, it is required to be
standardized by 3GPP. This will correspond to new data to be stored in UDR (as
long as this data is meant to be standardized).
\- Deployment of the storage layer (e.g. UDR, UDSF) ensures that stored
information is available as close to the requesting NF instance/NF service
instance as needed.
NOTE 2: This does not exclude any additional vendor-specific data being stored
in the storage layer.
#### 6.7.2.5 High-level Solution Architecture
It is proposed that:
\- Any available specific instance of a requested NF/NF service type within a
slice or shared among available slices can handle an incoming message
dedicated to that service, that means:
\- NF instance/NF service instances do not store other instance\'s IDs for
sub-sequent requests.
\- Requests by service consumers do not contain NF instance/NF service
instance IDs but only the type of the requested service.
\- How the specific NF instance/NF service instance that shall handle a
particular request is selected or if and by who it needs to be selected, and
what information to use in the selection process, depends on the inter-NF / NF
service communication method (cf. key issue 3) and is out of scope of this
solution.
NOTE 3: NF/NF service type is a unique identification of the service.
\- When the service context information reaches stable state (based on the
needs for recovery of an instance of this service), then it shall be stored in
a storage layer external to the service instance; that means:
\- Any authorized service instance of the same type can access the service
context data.
\- When the service context information reaches stable state (for the data
that may be shared by other types of NF/NF services), then it shall be stored
in a storage layer external to the service instance; that means:
\- Any authorized service instance of a different type can access the service
context data.
Examples of service context information are:
\- Subscription -, policy -and application specific data.
\- Mobility management data.
\- Session/context data (related to user subscription and its UE session-,
registration-and connection state).
\- standardized or exchanged as part of standardized NF service interfaces
with other NFs. Represents a stable state, that can be recovered/re-created by
a NF service in failure scenarios.
Dependencies to other solutions to key issues:
\- Solution 2 in the key issue 3 \"Improvements to Service Framework\" relies
on the unstickiness and the statelessness of service instances (see clause
6.2.2.3 pre-condition).
##### 6.7.2.5.1 NF instance/NF Service instance selection
Selection on NF instance/NF Service instance is subject of solution in 6.2.
##### 6.7.2.5.2 Storage layer aspects
The storage layer is considered to be primary and only storage for stable
context data and offers both to store opaque (vendor specific structured or
unstructured) context data as well as standardized structured context data.
The minimum context data that need to be standardized is determined by what
data are required to support multi-vendor interoperability.
On potential race conditions related to the storage layer:
\- Read operation of any context data in the storage layer is possible at any
point in time and state of the NF service instances.
\- Update operations could e.g. lock the context data for time it is processed
by a service instance. However, locking may slow down every process affecting
the performance of every operation to address conflicts that are rare to
happen, and additionally not potential race conditions can be solved by
locking.
A simple example of a potential race conditions where locking the context data
would not solve entirely the race condition is shown in the figure below
illustrating an example of \"circular deadlock\", in case of concurring paging
and service request for a UE:
Figure 6.7.2.5.2
As illustrated above the locking of the context data in step 2 and 5, has
created a deadlock in step 7 and 9.
Different techniques to solve this kind of deadlocks are available, and may be
different depending on the kind of race conditions. To avoid possible conflict
between different solutions, solutions for most race condition case would need
to be standardized, and mechanisms to remove deadlocks for cases not caught by
standards. If OCC (Optimistic Concurrency Control) is used, this needs
standardized methods to handle consistent rollback for all services and
procedures.
In essence, race conditions may be handled through following methods, both
having some drawbacks to consider:
\- Procedure lock: that requires standardized solution to avoid circular
deadlock, which may impact the overall performance.
\- OCC: that requires standardized methods to handle consistent rollback for
all services & procedures.
\- Whether race conditions during interaction of the storage layer and NF
services instances can occur or not depends on how the services and procedures
are defined and on the amount of shared context. These need to be addressed on
a case by case basis during normative phase.
NOTE: Race conditions can occur only as long as there is transient state
within an NF service instance as described below. Race conditions cause by
conflicting producer NF service instance selection by NF service consumers
cannot occur because as per solution 2 NF service consumers do not select
producer NF service instances (this is done by the service framework).
Regarding local knowledge of data:
Local knowledge of data in the sense of locally at the NF service instance is
only required until a procedure is completed (i.e. while it has some transient
state) and a stable state can be stored to the data layer. Storage layer is
assumed to be a distributed database and it is up to implementation/a
deployment issue how the synchronization between any instances of the storage
layer is achieved.
Relation to network slicing:
In case of network slicing, an instance of the storage layer can either serve
multiple network slices or be slice specific (based on operator deployment).
Editor\'s note: How to handle timers and triggers for context stored in the
storage layer and whether this is an internal storage layer functionality or a
functionality of a separate service to be defined as part of modularization
key issue is FFS.
### 6.7.3 Services and illustrated Procedures
Editor\'s note: This clause describes services and related high-level
procedures for the solution.
### 6.7.4 Impacts on existing Services and Interfaces
Editor\'s note: Further details regarding impacts are FFS.
### 6.7.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.8 Solution 8: Support for highly reliable deployments
### 6.8.1 Introduction
To support highly reliable deployments enabling seamless replacement, addition
or removal of services and new components without the need for reconfiguration
of either running components or new components, separation of functional
processing from state management is essential. Such an approach enables
independent life cycle management as well as failover handling of NFs and
Service Instances.
### 6.8.2 High-level Description
Editor\'s note: This clause outlines solution principles, assumptions and
high-level architectures, etc.
Externalisation of finalised transactions carried out during the execution of
a procedure is essential towards enabling separation of functional processing
from state handling. In addition, the Communication Service within the Service
Framework, through which messages are carried, should support registration of
entities and routing of messages resilient to failover and capable of
operating even when life-cycle management operations are carried out. Such
common service framework functionalities need to be added to the general SBA
capability of 5GS:
\- To enable the use of stateless NF Services, it is proposed that relevant
state information of finalised transactions may be pushed to a Shared Data
Layer Service (e.g. the UDSF) and hence made available to other NF Services
which require the specific data for further processing.
\- The Shared Data Layer Service is a repository where relevant state
information may be stored and fetched as required.
\- The Communication Service within the Service Framework provides routing
management aligned with the availability of new service instances and reactive
to topology/service failures in short term range (i.e. ms range).
### 6.8.3 Services and Illustrated Procedures
#### 6.8.3.1 Registration Services
NF services register to the Service Framework using the Service Framework
Registration capabilities. E.g., using NRF. Registration through the Service
Framework also enables NF Services to use the Service Framework Communication
services.
Editor\'s note: This clause describes services and related high-level
procedures for the solution.
Figure 6.8.3.1-1
1\. NF Service Instance consumer becomes operative for the first time.
2\. The NF Service Registers with the Service Framework and provides the
service profile (e.g. Service Type and Service ID) the be used by the Service
Framework for forwarding determination.
3\. The Service Framework stores the NF service information that enables
routing to instances of a service.
4\. The Service Framework confirms successful registration.
#### 6.8.3.2 Communication Services and Shared Data Layer
The Communication services allow the transport of messages across NF Services.
Share Data Layer Services may be distributed and they may be accessed based on
the Service Type, Network Slice and possible, specific users.
The Communication Services operates may operate on a single Slice or across
multiple Network Slices. E.g., Using the Slice Selection Type.
Figure 6.8.3.2-1
1\. The Service Framework receives a Request from a NF/NF Service requesting a
particular Service (e.g., Session Establishment).
2\. The Service Framework determines the Endpoint of a NF Service instance
capable of servicing the Request. The Service Framework may use the NRF to
resolve the NF Service Instance Endpoint address.
3\. The Service Framework forwards the request the available Service Instance
Endpoint. To achieve this, the Service Framework maintains a list of available
NF Service Instances of a particular type, capable of servicing a request.
4\. a-c. The NF Service Endpoint then retrieves necessary context information
from the Shared Data Layer and it locks the context to enable processing of
data before any other NF Service can access the Context data.
5\. a-c. The Shared Data Layer acknowledges context locking and provides data
information relevant to a specific service.
6, The NF Service process the message for the NF service using the data
information retrieved from the Shared Data Layer Service.
7\. a-c. The NF Service updates relevant data and it unlocks the context for
use by another process.
8\. a-c. The NF Service forwards the result of the execution of a NF service
through the Service Framework along with any relevant information carried in
the message container.
9\. Steps 4-8 are used.
### 6.8.4 Impacts on existing services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
Relevant NF Services may expose and retrieve finalised transactions and its
states for processing requests. These NF Services and its components have to
register and de-register to the Registration and Discovery Service, within the
Service Framework. This may be the same procedure as the NF Service to the NRF
registering.
Services use the Communication Service within the Service Framework to route
messages to the relevant Service Endpoint instance, without having to first
retrieve its address from the NRF. The NRF functionality may be contained
within the Service Framework.
### 6.8.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution
## 6.9 Solution 9: Temporary bindings between the service instances
### 6.9.1 Introduction
**This solution is to address the Key Issue 4 and in particular the** impact
on service operation to support scenarios with and without long-living UE-
specific bindings between service instances.
One requirement for 5GS architecture in Release 16 is to support a design
paradigm of stateless service instances; where any service instance in the
cluster of instances can process the service request, and where the selected
service instance after processing the task stores the session data externally
(e.g. in UDSF). Thus no binding relations should exist between individual
service instances. The service instances should not store the instance ID or
IP address of the other service instance after the service request has been
completed. The aspects of stateless service instances are not part of this
solution, but corresponding solutions are provided e.g. in Solutions 7 and 8.
However, in 5GS some e2e signalling flows consist of a sequence of services
and/or service operations between the same Network Functions. For example, in
Release 15 in UE Requested PDU Session Establishment (clause 4.3.2.2 in TS
23.502 [3]), typically four service operations are performed in sequence
between AMF and SMF: Nsmf_PDUSession_CreateSMContext,
Namf_Communication_N1N2MessageTransfer, Nsmf_PDUSession_UpdateSMContext and
Namf_EventExposure_Subscribe. In stateless design, if the service instances
would need to store and retrieve the session state (UE context) from an
external storage (UDSF) between all of the above transactions, this causes
unnecessary processing delay. Therefore, in scenarios where the next service
operation is expected to come quickly after the previous operation is
completed, it must be possible temporarily to store the session state locally
and force the counterpart service instance to re-use the same service instance
of the provider for the next service operation. The temporary binding between
instances is short-living; the binding is released immediately once the
sequence of service invocations that require stateful operation has been
completed.
This solution provides a mechanism for the service instances to create
temporary bindings between the instances, and a mechanism to release such
bindings. The solution can be seen to complement the Solutions in 7 and 8.
This solution does not define a mechanism to setup bindings with service
instance sets as described e.g. in Solutions 10, 11, 14 and 16. The binding
with service instance set is typically long-living, it exists e.g. for the
whole lifetime of the PDU Session. Temporary, short-living binding with the
instances and long-living binding with the service instance sets are
complementary mechanisms.
### 6.9.2 High-level Description
The solution assumes that the service instances may become stateless in this
case the old service instance and new service instance of the session are able
to share the session data e.g. via UDSF. How do they share the data is not
part of this solution.
The following figures describe the principles in the solution. The first
figure describes how the service provider is able to establish a temporary
binding as part of the service response.
Figure 6.9.2-1: Creating the binding in Service Response
1\. Service consumer initiates a service request for Service1 (S1). As there
is no prior binding between the service instances, the service consumer
discovers the service instance of S1 e.g. using NRF. The service discovery
returns the Instance ID (IID) of service instance 1 (IID1). Service consumer
targets the service request to IID1.
2\. Instance IID1 wants to create a temporary binding with service consumer,
and returns the binding information in the service response. The binding
information includes the Service S1 and the corresponding Instance ID.
3\. For the next service operation with the same service, the service consumer
does not discover the service instance but instead uses the IID1 as a target
for the service requests. Note that service consumer instance in step 1 can be
stateless and therefore a new consumer instance is used in step 3.
4\. The Instance IID1 responds with an indication that the binding with the
Service S1 can be released.
5\. (Optional) As it may be the service consumer did not send the service
request in step 3, the IID1 can also release the binding proactively e.g. due
to timeout without receiving the service request.
6\. Next time the NF consumer needs to send a service operation for the same
service, the service consumer discovers the service instance again for Service
S1 (e.g. using NRF), and uses the discovered service instance as a target for
the service requests (IID2 in this example). It is assumed the IID1 and IID2
can share the session state e.g. via UDSF.
The next figure describes how the service consumer is able to establish a
temporary binding as part of the service request.
Figure 6.9.2-2: Creating the binding in Service Request
1\. Service consumer initiates a service operation for Service 1 (S1). As
there is no prior binding between the service instances, the service consumer
discovers the instance of service provider for S1 e.g. using NRF. The service
discovery returns the Instance ID (IID) of IIDx. Service consumer targets the
service request to IIDx.
As service consumer wants to establish a temporary binding with IID1, it
indicates the list of services and the corresponding Instance ID of the
service instance that provides this service.
2\. The IIDx sends a service response.
3\. Next time the service instance of IIDx needs to send a service operation
with the indicated service in step 1, the service consumer does not discover
the service instance for the S1, but instead uses the indicated service
instance as a target for the service requests (IID1 in this example). Note
that service provider instance in step 1 can be stateless and therefore a new
service consumer instance is used in step 3.
4\. The IID1 responds with an indication that the binding to S1 can be
released.
5\. As it may be the service consumer did not send the service request in step
3, the IID1 can also release the binding proactively e.g. due to timeout
without receiving the service request.
6\. Next time the service consumer needs to send a service operation for the
same service, the service consumer discovers the service instance again for
Service S1 (e.g. using NRF), and uses the discovered service instance as a
target for the service requests (IID2 in this example). It is assumed the IID1
and IID2 can share the session state e.g. via UDSF.
When following procedure describes how the solution can be used together with
the Service Framework that provides the service discovery, as described in
Solution 8. The Communication Service within the Service Framework provides
service instance discovery and routing management between the service
instances. The flow in the clause 6.8.3.2 is used as a baseline.
Figure 6.9.2-3: Using this solution together with the Service Framework of
Solution 8
1\. The Service Framework receives a Request from a service consumer
requesting a particular Service. If there is an existing temporary binding to
a particular service instance of the NF Service X, the request includes the
Instance ID of the service instance of NF Service X as a target of the
request.
If the service provider instance that acts as a service consumer in Step 1
wants to establish a temporary binding as part of the service request, it
indicates the list of services it provides, and the corresponding Instance ID.
2\. The Service Framework selects the instance serving the Request. If the
request in Step 1 includes the target Instance ID, the Service Framework
resolves the endpoint address for the target Instance ID.
3\. The Service Framework forwards the request to the service instance.
4\. a-c. As in Solution 8. This step can be skipped when there is an existing
binding to a particular service instance of the NF Service X.
5\. a-c. As in Solution 8. This step can be skipped when there is an existing
binding to a particular service instance of the NF Service X.
6\. The NF Service processes the message for the NF service.
7-8. If there was an existing temporary binding for the service instance of NF
Service X, the response can indicate that this binding is now released. In
this case, the service instance of NF Service X can update the relevant data
in Shared Data Layer and unlock the context for another service instance. The
context includes the possible temporary bindings established as part of the
service request in Step 1.
If there was no existing temporary binding for the service instance of NF
Service X and the service instance wants to create a temporary binding as part
of the response, the response indicates the list of services and the
corresponding Instance ID of the service instance that provides each service.
In this case, the service instance of NF Service X does not unlock the context
for another service instance in Shared Data Layer.
### 6.9.3 Illustrated Procedures
The figure below shows an example flow how the mechanisms described in this
solution can be applied to the communication between AMF and SMF in UE
Requested PDU Session establishment procedure so that temporary binding can be
created between the service instances of AMF and SMF.
Figure 6.9.3-1: The solution applied to PDU Session Establishment procedure
1\. The AMF instance which was initiated to process the PDU Session
Establishment Request discovers the SMF instance for PDUSession service from
NRF. The NRF provides the Instance ID of the selected service instance. The
AMF targets the Nsmf_PDUSession_CreateSMContext Request to the instance IID2
of the SMF. The AMF includes in the request an Instance ID and an indication
of the service(s) for which this instance ID must be used. In this example the
AMF indicates it wants the AMF Instance IID1 to be used to request
Namf_Communication service. The SMF stores the AMF instance ID and the
service(s) associated to the AMF Instance ID.
2\. The SMF responds with the Nsmf_PDUSession_CreateSMContext Response. SMF
provides the SM Context identifier. The SM context identifier shall not
include the IP address of the SMF service instance. The SMF includes in the
response an indication that the same SMF Instance of IID2 must be used with
the upcoming Nsmf_PDUSession service operations.
3\. The SMF reserves the resources from the UPF. As SMF received the AMF
Instance ID (IID1) in step 1, the SMF uses the Instance ID to resolve the IP
address of the AMF service instance IID1 The SMF sends
Namf_Communication_N1N2MessageTransfer Request to this AMF service instance.
4\. The AMF responds with the Namf_Communication_N1N2MessageTransfer Response.
In this example the AMF does not update the binding information so the binding
with Instance ID provided in step 1 continues, and must be used for possible
upcoming Namf_Communication service operations.
5\. The RAN responds to AMF with the N2 message including the N3 Tunnel
Information. As the AMF received the SMF Instance ID in step 2, the AMF uses
the Instance ID to resolve the IP address of the SMF service instance IID2.
The AMF sends the Nsmf_PDUSession_UpdateSMContext Request to the corresponding
IP address. In typical scenario the AMF includes an indication that the
previous binding of Namf_Communication service with IID1 can now be released,
so the SMF knows to use the NRF to discover the AMF instance for any further
service requests for Namf_Communication service. This ensures that when the
SMF needs to trigger the release of the PDU Session, the SMF targets the
related Namf_Communication_N1N2MessageTransfer service operation to the AMF
instance discovered via NRF, and not to the same Instance of IID1 indicated in
step 1.
6\. The SMF responds with the Nsmf_PDUSession_UpdateSMContext Response. In
this example the SMF indicates that the binding to Instance ID of IID2
provided in step 2 shall be released, so the AMF knows to use the NRF to
discover the SMF for any further service request of Nsmf_PDUSession service.
7\. The SMF subscribes to the UE mobility event notification from the AMF
(e.g. location reporting, UE moving into or out of Area Of Interest), by
invoking Namf_EventExposure_Subscribe service operation. As the AMF has not
provided binding for this service, the SMF targets the request to the AMF
instance discovered via NRF.
8\. A new AMF instance is selected to process the subscription to the UE
mobility event notification. The AMF responds with the Subscription
Correlation ID, and optionally with a binding indication.
### 6.9.4 Impacts on existing NFs, NF services and interfaces
If Service Framework is used together with this solution, the Service
Framework must be able to target the service request to the corresponding
instance based on the binding information in the service request.
The service interfaces must be able to carry the binding information in the
service requests and responses. The service interfaces must be able to
indicate the release of the binding.
### 6.9.5 Evaluation
The solution provides a mechanism to setup short-living temporary bindings
between the instances. It describes a mechanism for the instances to signal
the release of the binding. The solution does not describe how to setup and
release bindings with Service Instance Sets.
## 6.10 Solution 10: NF/NF services Reliability
### 6.10.1 Introduction
In Rel-15, enablers were introduced for AMF reliability allowing also dynamic
runtime load balancing and dynamic runtime load re-balancing. AMF Set was a
key concept enabling scalability up to n AMFs within an AMF Set. We propose to
introduce the Set concept also for other 5GC NFs and standalone 5GC NF
Services that are introduced as part of this TR.
The Concept of NF/NF Services reliability should work irrespective of whether
UDSF is deployed or not. Furthermore, concept of NF/NF Services reliability
should work irrespective of whether UDSF is used as a primary storage or
secondary storage.
### 6.10.2 High-level Description
It is proposed to introduce the concept of NF/NF Services Set for all 5GC
NFs/NF Services. The NF/NF Services instances within a given NF/NF Services
Set are expected to have access to the same storage layer (e.g. UDSF and when
UDSF is deployed) or use backup NF instance by implementation specific means
to share context amongst NF instances within the NF Set. Thus, in principle,
any NF/NF Services instance, or one pair NF/NF Services instance within an
NF/NF Services set should be able to process the UE transaction as it has
access to UE context. The NF/NF Services instances within a given NF/NF
Services Set share the following characteristics:
\- NF/NF Service instances support the same network slice(s). For instance,
{NF/NF Service1, NF/NF Service2, NF/NF Service3} in a given Set supports the
same IoT slice.
\- NF/NF Service instances may access to the same storage layer (e.g. UDSF and
the UDSF is deployed) that is geographically close. For instance, {NF/NF
Service1, NF/NF Service2, NF/NF Service3} in a given Set supporting the same
IoT slice have access to the same UDSF instance. If the NF/NF service
instances do not share the same storage layer, the UE contexts are stored in
each NF/NF service instances, and backup in other NF/NF service instances
within the same NF/NF service set.
\- NF/NF Service instances may also be geographically close to access to the
same storage layer (e.g. UDSF and the UDSF is deployed).
\- Each NF/NF service instances may support one or more NF/NF service
pointers. The NF/NF service instance pointer(s) that a NF/NF service instance
supports are registered in NRF. The NF/NF service instance may add or remove
its supported NF/NF service instance pointers registered in NRF during runtime
load rebalancing.
\- If the NF/NF service instances have been assigned NF/NF service pointers,
the NF/NF service instance allocates a NF/NF service instance pointer to a UE
context during UE context establishment, and sends the NF/NF service instance
pointer to peer NF/service instances.
Editor\'s note: How long to keep the knowledge of NF/NF service instance
pointer at peer NF/NF Service instance is FFS.
\- The peer NF/NF service instances may subscribe for the NF/NF service
instance status change notification, when the status of NF/NF service instance
has changed, e.g. NF/NF service instance pointer has been removed or added, a
notification is sent to the peer NF/NF service instances.
\- If the peer NF/NF service instance has not subscribed to the NF/NF service
instance status change notification, the peer NF/NF service determines that
one NF/NF service pointer is not associated with the old NF/NF service
instance when a rejection has been received from the old NF/NF service
instance, or when the transmission of a transaction to old NF/NF service
instance has been failure.
\- When the UE context is no longer served by the old NF/NF service instance,
the peer NF/NF service selects a NF/NF Service instance from the same NF/NF
Service Set if no backup NF/NF service instance is notified before.
\- If there is no NF/NF Service instance pointer associated with the UE
Context, the peer (NF Service Consumer) NF/NF Service instance should be able
to select any NF/NF service instance from NF/NF Service Set of NF Service
Provider for forwarding a transaction targeted for a given UE, otherwise, the
peer NF/NF Service instance selects a target NF/NF Service instance based on
NF/NF service instance pointer associated with the UE context, which is the
backup NF/NF service instance.
\- The Set of equivalent NF/NF Service Instances may be identified by a common
\"NF/NF Service Set ID\".
Following characteristics apply for specific 5GC NFs that are specified in TS
23.501 [2]:
\- In case of SMF, SMFs within the SMF Set can access the same UPFs. This is
to allow any SMF within the SMF Set to be selected when user plane traffic is
ongoing for a given UE for a certain PDU Session. This is explained with an
example below. In a certain network, not all SMFs are able to connect to all
UPFs e.g. for domain reasons.
\- SMF1, SMF2, SMF3 - can connect only to UPF1, UPF2, UPF3.
\- SMF4, SMF5, SMF6 - can connect only to UPF4, UPF5, UPF6.
UE has PDU sessions with UPF1 as PDU Session Anchor; Now, if the SMFs have to
be stateless and we want the ability to select any SMF for processing a
transaction for a given UE/PDU Session, then it should be able to possible to
select any of the SMFs but at the same time it needs to be ensured that they
are selected from set of {SMF1, SMF2, SMF2}.
Editor\'s note: the solution can be updated to adopt standalone NF/NF Services
depending on the outcome of the architecture decided for FS_eSBA.
### 6.10.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.10.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
The following impacts are expected for the introduction of NF Sets in stage 2:
\- New descriptions of NF set concept.
\- Descriptions should be updated to refer to NF Sets.
\- Update Stickiness solutions and bindings to be based on NF Sets.
\- Updated Service Framework to be based on NF sets.
### 6.10.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.11 Solution 11: 5GC Reliability
### 6.11.1 Introduction
In Rel-15, different concepts have been adopted for reliability in various
NFs. It\'s proposed to provide further possibilities to enhance the
reliability in Rel-16. This solution proposes to define a Services Instance
Set concept that can support high reliability and also has potential to
improve other aspects of the 5GC architecture.
The solutions for reliability should work irrespective of whether UDSF is
deployed or not.
### 6.11.2 High-level Description
It is proposed to introduce the concept of Service instance Set for 5GC. The
Service instances within a given Service instance Set are expected to have
access to the same data sets in a data storage entity e.g. UDSF. Thus, in
principle, any Service Instance within a Service Instance set should be able
to process UE transactions as it has access to UE context.
Following are the key principles for Service Instance Sets:
\- A Set of instances of the same service type.
\- All Service instances in a Set can access the same data storage e.g. UDSF.
Editor\'s note: How this relates to solution for key issue 1 is FFS.
As shown in figure 6.11.2-1 a Service Instance Set has a storage resource
accessible by all service Instances in the Set. A Service Instance Set may
expose individual service instances towards consumers or it can use a load
balancer. If a load balancer is used the Service Instance Set may appear as
one Service Instance towards consumers.
Figure 6.11.2-1: A Service Instance Set with Shared storage resource and
optional load balancer
When a Service Instance Set exposes multiple service instances towards a
consumer, the consumer is allowed to reselect a different Service Instance
(within the same set) between transactions. Race conditions with multiple
requests for the same UE is up to implementation to resolve, potentially using
mechanisms like redirect between Service Instances in the Set.
As shown in figure 6.11.2-2 a Service Instance Set may span multiple data
centres.
Figure 6.11.2-2: A Service Instance Set can span across multiple data centres
As Service Instance Set\'s can span across multiple data centres the profile
in the NRF should include proximity information for each service instance in
order to facilitate proximity-based selection of service instances. This
proximity information provides an indication of physical distance based on
network deployment and topology, e.g. the DC identification could be used for
this purpose.
Proximity complements Service Instance Set information, in a way that same
Proximity value (e.g. same DC, same data repository) may include different
Service Instance Sets . Different Service Instance Sets can be from the same
vendor or different vendors. They may be configured to serve for the same or
different S-NSSAI. They are configured to access different Storage Resources.
Service Instance Set can be used as following:
\- NF/NF Service SET1 of instances optimized for IoT is from vendor 1.
\- NF/NF Service SET2 of instances optimized for IoT is from vendor 2.
\- NF/NF Service SET1 of instances optimized for eMBB is from vendor 1.
\- NF/NF Service SET2 of instances optimized for eMBB is from vendor 2.
Service Instance Set may be considered optional value, since in some cases,
Proximity could be sufficient for a consumer.
### 6.11.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.11.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
The impacts on NF Services, NF profile and selection rules are primarily
driven by allowing reselection of different service instances between
transactions and addition of proximity per service instance.
Impacts on (Service/NF) service profile in NRF:
\- Addition of Service Instance Set ID per service Instance.
\- Addition of proximity information per service instance.
Impacts on Selections and Reselection rules:
\- A consumer first discovers and selects one suitable Service Instance Set,
optionally from a list of service instance sets received from the NRF. Once
the Service Instance Set is selected it selects a suitable Service Instance
for the next transaction.
\- A consumer may reselect any Service Instance, within the same set, between
different transactions
\- A consumer should consider the proximity information when selecting a
Service Instance Set and re-selecting between Service Instances within the
Service Instance Set.
The Service Instance Set concept allows to decrease the dependencies on the NF
concept in the 3GPP functional architecture. This can be achieved by the
additions described above and by replacing the NF bindings established in the
information flows with bindings between the service Instance Sets.
### 6.11.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
\- The meaning of the Service Instance Set IDs shall be configured and
maintained by the operator.
## 6.12 Solution 12: Common Network Data Service
### 6.12.1 Introduction
This solution addresses key issue 4 \"Architectural support for highly
reliable deployments\". Especially on the following aspects:
_\- impact on service operation to support scenarios with and without long-
living UE-specific bindings between service instances, e.g., by separating
functional processing from state repository or other mechanisms._
### 6.12.2 High-level Description
This solution propose to introduce a common network data service that further
extend the NF/service defined in Rel-15 by UDSF. The goal is to: simplify the
service implementation, achieve independent data/logic handling thus decouples
the technology evolution, and improve reliability/resiliency in the cloud
environment.
Data service is generally used in IT infrastructure, e.g., as a common service
provided as a PaaS where the data security, persistence, reliability, etc.,
are considered as the internal platform functionality and out of 3GPP scope.
3GPP shall defines the interface between NF service and the data service,
which can best leverage latest technology of those infrastructure.
NOTE: the solution is not to limit the usage of the data storage technologies
developed outside of 3GPP.
The solution is based on Rel-15 defined UDSF service but has the following
enhancement:
1) The data service can be invoked by any consumer, e.g. any NF service in CN
to achieve stateless capability. The data model of the context data is not
necessarily been specified. 3GPP identifies the key context data that need to
be stored by data service so that some system level reliability and stateless
can be achieved. This does not prevent a service can still store local cached
data for high performance.
2) The data service provides network data service with standardized interface.
The protocols to be used shall be specified (e.g., in stage 3) to achieve high
performance data access service. Whether a single protocol or multiple
protocols are defined is per stage 3 decision.
3) Complete the definition of UDSF service definition. The Rel-15
\"UnstructuredDataManagement\" is defined but only as \"Data Identifier\" as
input which shall be extended in this solution to further cover information
that enables related network data can be stored in a secured, persistent way.
### 6.12.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.12.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
### 6.12.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.13 Solution 13: Utilize System Feature to enable system flexibility and
service provisioning
### 6.13.1 Introduction
This solution addresses Key Issue 6 on system flexibility and service
provisioning.
### 6.13.2 High-level Description
In 5G core network, _a set of Network Functions and NF services are
orchestrated to enable one system feature, and one system feature can be
added/updated/removed in 5GC via deploying/updating/removing the corresponding
NFs and NF services._
One System Feature can be independently deployed from other System Features in
the network. The authorized System Features for a given UE can be explicitly
identified by user subscription data.
_Relationship between System Feature and the set of NFs/NF services enabling
this System Feature is specified in Annex B. The relation between System
Feature and the set of NFs/NF services enabling this system feature shall be
stored in_ network management system.
NOTE: one System Feature may also involve the support of NG-RAN.
When provisioning the network, one or multiple System Feature shall be
deployed. The network management system determines the required NFs and/or NF
services to be deployed according to the relationship of System Features and
corresponding NF/NF services.
The NF/NF service profile may include the information of its supported system
feature(s). The required system feature(s) may be included in service
discovery request sent to the NRF by the NF/NF service consumer, and the NRF
determine the target NF/NF service instance(s) according to the profile of
NF/NF service instances.
Editor\'s note: The NF instances may be updated to add/update/remove the
supported NF services during provisioning, and how to add/update/remove NF
service in NF instance is FFS, e.g. whether it needs to be standardized
depends on vendor implementation.
Editor\'s note: The System Feature mapping to (NF) Services (subject to
specification) is FFS.
One Network Slice may deploy several System Features according to the service
requirement, and multiple Network Slices may also separately deploy the same
System Feature. The configuration information of one Network Slice includes
the supported System Feature(s). When adding/updating/removing one System
Feature in one Network Slice, the management system of network slice
determines which NFs and/or NF services need to be added, updated or removed,
and it also updates configuration information of this Network Slice.
The enhancement to service framework for better support of System Features
include:
\- The network monitoring can be per System Feature to obtain monitoring
information per System Feature, e.g. the statistics information of each System
Feature.
Editor\'s note: other enhancements to service framework are FFS.
### 6.13.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.13.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
### 6.13.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.14 Solution 14: NF/ Service Set based Service Framework
### 6.14.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
The design principle of this solution:
\- One NF/Service Instance is identified by the NF/Service Set ID and Instance
Pointer.
\- Decouple the Producer Discovery and Instance selection procedure which is
separately determined at the Consumer and Framework function. The Producer
Discovery is to find the suitable NF/Service Set which provide the required
NF/NF service requested by the consumer. The Instance selection is to find one
provider instance within the indicated NF/Service Set.
\- When a NF/Service Instance is register to NRF via the Framework function,
thecorresponding Service Set ID and Instance pointer is provided to the
Framework Function. When the Consumer communicate with the Producer Instance,
it discover the Framework Function based on the Producer Service Set and the
Framework Function determines the Producer Instance to be contacted. The
change of Producer Instance within the Producer Set does not need be aware by
the Consumer.
### 6.14.2 High level description
The high-level architecture of this solution is illustrated in the following
figure:
Figure 6.3.14.2-1: NF/ Service Set based Service Framework Architecture
NF/Services are grouped into NF/Service Sets. Within one NF/Service Set, the
capability of each NF/service Instance are same. From NRF view the Service Set
defined in Rel-16 is similar as the NF Set defined in Rel-15, e.g. AMF set.
One NF/Service Set can be deployed across DCs. Each NF/service set has one
globally unique identity.
The NF/Service instances are deployed in Units. Each Unit shares the same
platform function and includes one or multiple NF/Service sets, which can be
same or different NF/Service types, and a Service Framework. A unit is located
within one DC(Data Center). The NF/Service instances within a Unit may not
expose to services outside of the Unit. The Framework Function provide
functions like registration/discovery of internal service instances for
internal service management, registration/discovery with NRF for outside
communication, communication between internal NF/Service instances and outside
the Unit, load balance among service instances connected to it, etc. It is
built on top of the existing service Frameworks Function, e.g. Linkerd (refer
to https://linkerd.io/1/features/), Istio. It is also possible that the
NF/Service instances within the Unit communicate with outside directly without
going through the Framework Function.
Figure 6.4.14.2-2: NF/Service Set across Units
One NF/Service set is composed by the NF/Service instances located at the same
or different Units. NF/Service instances within a NF/Service set share the
same set of data.
If the NF/Service instance does not expose to service outside of the unit, it
only register to the Framework Function. If the NF/Service instance wants to
expose service outside, besides the registration to the Framework Function,
the NF/Service Instance is also registered to the NRF via the standardized
interface.When the NF/service instance is registered to NRF, depend on whether
or not it wants to be accessed directly, the information registered in NRF is
different. If the NF/service instance is hidden toward outside, the set ID of
the service instance and the Unit address pointing to the Framework Function
are registered to NRF. On the contrary, if the service instance is directly
registered to the NRF, i.e. no service instance hiding, the service instance
and the Unit address pointing to the service instance itself are registered to
NRF. For each registered address at NRF it is associated with one weight
factor, which reflect the capacity of the NF/service instance associated with
the registered address.
When one NF/Service Set is deployed across several DCs, the Unit Addresses
associated with each DC are registered in NRF.
When a consumer initiates communication, it first invokes service discovery.
\- In case the Framework Function is used, the producer set ID together with
Unit address pointing to Framework Function are provided to the consumer in
the service discovery response. The consumer can initiate communication with
producer by including the producer set ID in the message, and send the message
to the indicated Unit address which points to the Framework Function. The
Framework Function selects producer instances based on the producer set ID and
the previously registered NF/Service instance. Thus the Load balancing is
achieved by the Framework Function.
NOTE: the producer set ID can be part of the Unit address to be communicated,
e.g. information in the FQDN.
\- In case the Framework Function is not used, the NF/Service Set ID and
Instance Pointer, together with Unit address pointing to Instance address, are
provided to the consumer in the service discovery response. It is same as the
Rel-15 NF/Service discovery procedure.
\- If the NF/Service Set is spread across DCs, the weight factor of each Unit
address is also returned to the consumer, and the consumer selects a Unit
address based on the weight factor associated with it and other parameters,
e.g. proximity.
The Producer discovery messages may be between the consumer and the NRF
directly, or the message may be relayed by an entity within the Unit, e.g. the
Framework Function. If it is relayed, the framework function may respond the
consumer directly without invoking discovery service toward the NRF, if the
producer service can be found locally.
### 6.14.3 Illustrated procedures
The following figure depicts message exchange between a Consumer Instance and
a Producer Instance. In the below figure, the Consumer Instance/Producer
Instance is assumed to be a Service.
Figure 6.3.14.3-1: Procedure of across Unit service communication
1\. The Service Consumer Instance initiates Service Discovery. The message is
sent toNRF. The request includes the parameters to find the Service Producer
Instance, e.g. service set type, location info, and depending on service set
type, some service specific info like DNN may also be included.
If the Discovery message is relayed via the framework function and the
producer service can be found locally, the framework function respond the
consumer directly without invoking discovery service toward the NRF.
2\. In the service discovery response, the service producer service set ID and
the Unit address are returned to the consumer instance.
3\. The Consumer constructs a request message which includes the Service
Producer set ID information received in step 2, and sends the message to the
Unit address received in step 2. Depending on the type of the Unit address,
i.e. pointing to the registered instance or framework function, the message
may be sent directly to a producer instance or to an entity within the Unit,
e.g. Framework Function, which chooses producer instance and forwards the
message to the producer instance.
4\. The producer handles the request message, and sends response message to
consumer instance.
### 6.14.4 Impacts on existing NFs, NF Services and Interfaces
The impacts on existing services and interfaces are:
NRF:
The NF/Service Set ID is registered to the NRF. However, the NF/Service Set
can be regarded as Rel-15 NF Instance. NRF does not need differentiate on
whether it is NF/Service Set or a NF Instance, no impact on the NRF.
Each NF/NF Service Set may be associated with one, or multiple Unit addresses
together with an associated weight factor. When the NRF selects Unit address,
the weight factor need be taken into account.
### 6.14.5 Evaluation of the Solution
In this solution the NF/Service are group into NF/Services Sets and managed by
the Framework Function. This solution have the following characteristics:
\- NF/Service Registration management, for each NF/Service instance, it
register to the Framework Function and optionally register to NRF. The
Framework Function is aware of the addition, removal or failover of NF/Service
instances within the Unit.
\- Authorization control: Based on the registered NF/Service profile the
Framework Function or NRF can authorize the access to the service of Producer.
\- Discovery: By separating the whole discovery procedure into two steps, i.e.
NF/Service Set Discovery and Instance selection, the Service Framework
Function does not need to understand the business service logic related
discovery strategies, which involves parameters used for services discovery,
and the related discovery failure handling. Also the consumer are not need be
aware the status of the provider Instance, e.g. scaling in/out.
\- Communication: when the message is routed via the Framework Function, the
Framework Function always routes message based on the NF/Service Set ID and
Unit address. One simple and unified routing mechanism can be used.
\- Load Balancing/Failover management/Routing Control: The Framework Function
manages the NF/Service Instance. The NF/Service context is shared among the
NF/Service Instance within the same the NF/Service Set. The Instance within
the same set is replaceable with each other, Thus the change of the NF/Service
Instance need not be notified to the peer NF/Service instances.
\- Backward compatibility: The interface between the Framework function and
NRF is compliant with the Relâ€‘15 defined Service Based interface. No need to
enhance Relâ€‘15 Service Based Interface to carry complicated routing
information from NF/Service instance to Service Framework Function, and no
need to change existing NF/Service instance implementation.
From above it can be seen that any change of the Provider Service Instance,
e.g. scaling in/out, it does not impact the Consumer Service Instance. The
Framework Function is responsible for NF/Service instance selection for the
communication between NF/Service instances. Hence, the NF/Service instance can
focus on business logic. Also the Framework function route the message using
the same mechanism. It avoid the Framework function need be involved the
business logic.
## 6.15 Solution 15: High reliable deployment via the binding information
stored at Framework Function
### 6.15.1 Introduction
This solution is to address the Key Issue 4 and in particular how to maintain
the bindings between service consumer and respective service producer to
support high reliable deployment.
It is based on architecture defined in 6.14 NF/ Service Set based Service
Framework. When one Service Instance communicates with another Service
Instance, it includes the binding ID information, which is generated by the
service producer. The Service Consumer instance stores the received binding ID
until the UE context is released. The binding information, i.e. the binding
between the binding ID and service instance, is stored in a new functional
module within the Service Framework where the service producer is deployed.
When the binding is changed, e.g., the service instance is scaling in/out or
failure, the communication peer does not need to be aware. Thus the high
reliability can be reached if the service instance to be communicated is
replaced, e.g. due to failure.
### 6.15.2 High level description
Similar as the definition of the AMF Instance at Rel-15, it is assumed that
the service instance is identified by a Service Set ID and Instance Pointer.
When the Service Producer Instance is communicated per the Service Consumer
request, the Service Producer Instance provides a binding identifier (i.e.
binding ID) and returned it to the Service Consumer. The Service Consumer use
the binding ID to identify the Producer Instance to be contacted. Two types of
bindings ID are defined:
\- Service Set ID based, bind to a service set and is not limited to a
dedicated Instance.
\- Service Set ID and Instance Pointer based. Depending on the meaning of
binding ID, it can be bound to a specific service instance but the service
instance can be replaced, or only to one dedicated Instance.
The Service Consumer instance stores the received binding ID until the UE
context is released, and includes it in the following request targeted to the
same Producer Service. When the message reaches the Unit where the service
producer instance is located, it is routed to a service producer instance
based on the binding ID included in the message. The binding between the
binding ID and a service producer instance is stored within the Unit, e.g.
framework function. The service producer instance may change, while the
binding ID exposed to the Service Consumer remains the same. In that case
different transactions may reach to different Service Instance even using the
same binding ID.
The UE context are shared among the NF/Service Instance within the same
NF/Service set. If one NF/Service Instance fails, the message targeting to the
failed NF/Service Instance is routed to another NF/Service Instance within the
same NF/Service set. The replacing NF/Service Instance retrieve the UE
contexts to handle the incoming message. Thus the high reliability can be
achieved. How to select the replacing NF/Service Instance is implemented as
below:
\- If not all the NF/Service Set instance within the same Units are failure,
based on the binding ID type the Framework Function avoid select the failed
NF/Service instance or reselect another NF Service Instance based on the
preconfigured rule via OAM, e.g. when the NF/Service Instance-1 is failure it
is replaced by NF/Service Instance -5.
\- If a NF/Service Set is spread across multiple Units in different DCs, and
all the NF/Service Set instance within the same Units are failure (which does
not happen often) and if there are binding IDs bound to NF/Service instances
in the failed Unit, the NRF notifies the communication peers of the NF/Service
Set of the Unit failure event. Upon receiving the Unit failover notification,
the communication peer re-selects a target Unit Address based on the
NF/Service Set ID, and send messages to the target Unit using the same binding
ID. The Service Framework Function in the target Unit selects a target
NF/Service instance based on the binding ID and preconfigured rule.
\- The replacing NF/Service Instance updates the Service Consumer instance
with a new binding ID.
### 6.15.3 Illustrated procedures
**The below procedure illustrate how to exchange the binding ID between the
consumer and producer. And how the message is routed based on binding ID.**
Figure 6.15.3-1 Binding information stored at the Framework Function and its
usage
The binding between the service instance and the binding ID is maintained
within the Unit, e.g. by the Framework Function. As an example, the binding
can be established when the service instance is started, e.g. as part of the
service instance registration procedure. The Service Framework includes a
function module which stores the following information: the Service Set ID,
Instance Pointer, IP address. Thus no matter which type binding ID is used by
the service instance later, the Function in the Unit, e.g. Framework Function,
can always route the message to the service instance. The service instance
indicates the assigned binding ID to the Service Framework at the registration
procedure, and Service Framework stores the assigned binding ID.
Binding ID exchange between the consumer and producer:
1\. The consumer allocates a binding ID, which is related to the service
consumer and used for following transaction request from the peer service
instance, and include this information in the message sent to producer. The
type of binding ID consumer allocated is per how the consumer prefer following
transaction request from peer side communicate with it.
If the following transaction request from peer side is preferred to be handled
by any instance within the same service consumer set, the binding ID is
Service Set ID based. If the following transaction request from peer side is
preferred to be handled by this instance, the binding ID is Service Set ID and
Instance Pointer based.
NOTE: The consumer\'s binding ID is included only if the consumer can behave
as service producer.
2\. The Function in the Unit, e.g. the framework function, selects the
producer instance based on the previously stored association of binding ID and
instance ID.
3\. The Message 1 is forwarded to the selected producer instance.
4\. The producer instance provides a producer\'s binding ID to the consumer
instance in response message. The type of binding ID allocated is similar as
the step 1.
5\. The response message is forwarded to the Consumer. The Consumer stores the
received Producer\'s binding ID as part of the UE context.
Binding ID usage for the following transaction:
6\. Consumer sends message 2, including producer\'s binding ID received at
step 5.
7\. If the producer\'s binding ID allocated at step 4 is the Service Set ID
and Instance pointer based, Producer 1 is selected based on producer\'s
binding ID.
If the producer\'s binding ID allocated at step 4 is the Service Set ID based,
the Function in the Unit, e.g. the framework function, re-selects the producer
instance. The re-selected producer instance may be different comparing to the
Producer 1. In that case if the transaction need be routed to the same
Producer Instance for following transaction, another information need be
provided, e.g. a different binding information which is called as temporary
binding ID defined in clause 6.9 is used.
8\. Message 2 is forwarded to Producer 1.
Binding information update:
9\. The binding between the binding ID and Producer 1 is released, e.g. due to
producer instance is deregistered scale in/out.
Message handling after the binding information is released:
10\. The consumer sends Message 3 which include the producer\'s binding ID
provided by Producer 1.
11\. Since there is no producer instance associated with the binding ID, but
the binding ID includes the Service Set ID information, a new producer
instance is selected based on Producer service set ID and optional
preconfigured rule.
12\. Message 3 is forwarded to Producer 2.
Editor\'s note: Producer 2 receives the request with the Pointer of Producer
1. It is FFS how the producer handles this mismatch.
13\. The Producer 2 retrieve the UE context and provides a new producer\'s
binding ID which is associated with producer 2 or this Set.
14\. The response message is forwarded to the Consumer.
Editor\'s note: Consumer receives the response with the Pointer of Producer 2.
It is FFS how the consumer handles this mismatch.
### 6.15.4 Impacts on existing NFs, NF Services and Interfaces
The impact of this solution includes:
\- The Framework function manage the mapping between the producer NF/Service
instance and binding ID. The Service Framework update the association when the
producer instances are changed.
\- The Producer NF/Service instance generate and send the binding ID to
consumer NF/Service instance. The Consumer NF/Service instance store the
received binding for the following transaction with producer NF/Service
Instance. The Producer NF/Service instance may update the binding ID and send
to the consumer NF/Service Instance anytime.
\- The consumer NF/Service instance includes the binding ID when it
communicate with the producer NF/Service instance. The Service Framework must
be able to target the service request to the corresponding instance based on
the binding ID in the service request.
\- The Service Framework Function route messages based on binding ID to
corresponding NF/Service instance.
### 6.15.5 Evaluation of the Solution
This solution focus on how to maintain the communication between the consumer
and producer, i.e. via the binding ID. How to share the data among the
NF/Service Instance within the same NF/Service Set is independent on how long
the binding is maintained.
This solution have following characteristics:
\- It provides a method to setup a long-living binding between the service
consumer and producer. The binding can be set either with the service Set ID
or Service Set ID and Instance Pointer. The binding is released when the UE
context is released, e.g. then the PDU Session is released.
\- The producer instances can decide how to bind a consumer instance with a
producer instance, for example, a consumer instance can be bound to a producer
instance only for a transaction, or for a period of time (e.g. it is
maintained until the producer set is rescaled).
\- The Service Framework Function maintains the binding between the binding ID
and the producer NF/Service instance. The Service Framework can update the
binding to a new producer instance in middle of the PDU Session e.g. when the
producer instances are deregistered. The consumer NF/Service instance does not
need to be aware which producer NF/Service instance is bound to the binding
ID.
Support partial or all the NF/Service Instance within one Unit are failure.
By using the binding ID it avoid the unnecessity to change the NF Service
Instance for each transaction but also keep the flexibility if the NF/Service
Instance change per transaction is required.
## 6.16 Solution 16: the optimization for profile of NF/NF service instance
### 6.16.1 Introduction
This solution is related to Key Issue 4 on NF/NF service reliability.
### 6.16.2 High-level Description
This solution applies to the NF/NF service instances which require the
provisioning of network service area. NF Service Region is introduced to
simplify network service area management of NF/NF service instance in NRF.
NF/NF Service Set is utilized to support NF/NF service reliability. The NF/NF
service instances in one NF/NF Service Set have the same network service area,
and multiple NF/NF Service Sets also may support the same network service
area. In this case, these NF/NF service instances can belong to the same NF
Service Region.
NRF maintains the association between one NF Service Region and the
corresponding network service area i.e. TAI list. This association information
is provided by network management system e.g. OAM, and network management
system also updates this association information when the network service area
of the NF Service Region changes.
The identity of NF instance includes NF Service Region Identity and NF/NF
Service Set Identity, and the profile of the NF/NF service instance maintained
by NRF does not need to include their network service area in order to avoid
repeatedly maintaining network service area per NF/NF service instance.
When NRF handles NF/NF service discovery request including target network
service area, NRF is able to determine the target NF/NF service instance
according to the target network service area, the maintained information of NF
Service Region and the profile of NF/NF service instances. To support NF/NF
service reliability, NRF is also able to determine the alternative NF/NF
service instance according to NF Service Region Identity and NF/NF Service Set
Identity indicated in discover request.
The relationship among NF Service Region, NF/NF Service Set and NF/NF service
instance is depicted in the figure below:
Figure 6.16.2-1: NF/NF Service Region, Set, Instance
Depending on the configuration of network, NF/NF service sets with different
NF/NF service type may belong to the same NF Service Region, it is also
allowed that one NF Service Region only includes NF/NF service Set with the
same NF/NF service type.
### 6.16.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.16.4 Impacts on existing NFs, NF services and interfaces
The solution impact the following NFs, NF services and interfaces:
\- NRF receives the provisioning information of NF Service Region from network
management system.
\- The profile of NF/NF service instance includes NF Service Region ID and NF
Set ID, and the network service area is not required in the profile of NF/NF
service instance.
### 6.16.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.17 Solution 17: Modularization based on NF Services only
### 6.17.1 Introduction
As laid out in the corresponding Key Issue 1, optimal modularization of the 5G
System shall enable deployment of 5GC services by their own without
mandatorily relying on a certain NF. Optimal modularization of the 5GC is
essential for network slicing and to enable better re-usability of the defined
services according to slicing and/or e2e customer service requirements.
Therefore, a higher granularity of the 5GC services than Rel-15 NFs / NF
Services is necessary.
\"Modules\" of Rel-15 architecture are NFs and NF Services. While the former
is clearly defined for multivendor interoperability the multivendor
interoperability for NF Services is not specified.
The proposal of this solution is that release 16 defines NF Services only
where the NF Services represent the desired 5GC \"modules\". These NF Services
shall be deployable independent of NFs and shall support multivendor
operability.
The drivers for modularization are the flexibility to exchange Network
Function Services, to re-use Network Function Services, and/or to break
Network Function Services down on a level where they can be easily
implemented, tested, and debugged. The optimal modularization of the system
shall improve the system\'s agility in terms of enhancing its functionality
and features. With future NF Services becoming the representation of the
modules, a corresponding modeling of the 3GPP defined NF services is
necessary.
For this reason, the design of release 15 NF Services should be revisited in
order to achieve these goals.
The future 5GC has to fulfil different, sometimes orthogonal, requirements
from the different use-cases e.g. from verticals. Therefore, it is necessary
to have a flexible design, which contains easy-to-use and re-useable NF
Services, and the possibility to combine them in a flexible way (plug and
play). Flexible systems provide the possibility to install NF Services
according to the requirements of a certain network slice. These NF Services
are the smallest deployable units for an operator, regardless of how they are
implemented internally.
NF Services can be grouped in bigger packages to allow different deployment
scenarios. Ultimately, the goal is to model the NF Services as fully self-
contained units that operate on a dedicated context. However, this may lead to
a model where most of the NF services as defined per NF type in Rel-15 would
need to be put into one big group. More optimal modularization from
independent scaling point of view would require the NF services should be kept
separate, even though they need to be able to share the same context. A
solution could be to group multiple NF services of the same NF Service type
into a group of NF services. The service instances from this group are
expected to have an access to the same, consistent data, e.g. UE context.
Optimal modularization shall enable to deploy use-case specific network
slices, i.e. is driven by network slice blueprints and specific additional
requirements as currently being defined in GSMA:
\- https://www.gsma.com/futurenetworks/5g/network-slicing-use-case-
requirements-whitepaper/
\- https://www.gsma.com/futurenetworks/digest/new-5g-network-slicing-report/
The actual modularized 3GPP system architecture is proposed in clause 6.17.3.
In accordance with the key issue description, solutions shall also describe
the principles to be used for an optimal modularization/granularity of the NF
services; this is provided in clause 6.17.2.1.
### 6.17.2 High level description
#### 6.17.2.1 Principles to be used for optimal modularization
Principles for modularising the 5GC architecture:
\- Achieve multivendor interoperability between NF Services.
\- Have NF Services as independently deployable units.
\- Specify loosely coupled NF services that are:
\- instantiable without impact on other NF services;
\- replaceable:
\- in case of failure;
\- by another (better performant) implementation.
\- Each NF Service implements one specific functionality (i.e. has one
specific and well-defined purpose) - separation of concern
\- Each NF Service shall provide a unique SBI.
\- NF Services to be modelled as fully self-contained units that operate on a
dedicated context.
\- NF Services shall have independent life-cycle management (e.g. for scaling,
healing, etc.). NF Services can be deployed, updated, and removed during
runtime without dependencies to other NF Services.
\- Re-usability: Any NF Service can be used by any other NF Services with
appropriate authorization.
\- NF Services shall be agnostic to which consumer is making use of their
functionality/API.
\- A NF Service provides always the same functionality, regardless of the
origin of the invocation.
\- A NF Service provides expected outputs based on specific inputs.
\- Regarding Service Producers, Service Consumers can assume that all options
defined for a NF Service (if any) are supported by all instances of that NF
Service.
#### 6.17.2.2 Solution Preconditions and Requirements
Preconditions:
\- The Rel-16 Service framework as well as the Management and Orchestration
framework support deployment of NF Services instead of NFs.
Requirements:
\- See the modularization principles of this solution as described in clause
6.17.2.1
#### 6.17.2.3 High-level Solution Architecture
Release 16 architecture consists of NF Services only. System procedures are
based on a chain of these NF Services.
Figure 6.17.2.3-1 Modularization principles
Per the principles for optimal modularization described above, NF Service
A/B/C/..... can be different from Rel-15 NF Services. Still, a Rel-15 NF can
be constructed by implementing a NF Service A and NF Service B that behave
like NF Service 1 and NF Service 2, respectively, and packaging them together
as described in clause 6.x.1 above.
The following diagram puts this solution into context with solution 2 and
solution 7:
The NF services communicate through the Service Framework via the Service
Access Point API (SAPA). Since the NF Service does not have any dependencies
to other NF Services and does not store states and data, there will be a
request, receive, and a write of the states and data from/to the (shared)
storage layer.
Figure 6.17.2.3-2: High level view on a NF Service
The Service Collection is a group of instances of NF services that can access
to the same, consistent data, e.g. UE context in UDSF.\ Storage Resource ID is
a location reference to the consistent data stored for the Service Collection.
Storage Resource ID can be signalled in the service operations over the SBI to
ensure that the NF service instances are discovered from a particular Service
Collection, so that they can share the same consistent data. If Service
Framework is used for discovery and message routing, it is the task of Service
Framework to ensure the service request is routed to proper NF service
instance by taking the Storage Resource ID into account.
The next figure illustrates an example how the Storage Resource ID can be used
during the PDU Session establishment.
{width="6.426388888888889in" height="1.8173611111111112in"}
Figure 6.17.2.3-3: Example of the use of Storage resource ID
When the Service Consumer of Nsmf_PDUSession service sends the
Nsmf_PDUSession_CreateSMContext service operation, it includes its Storage
Resource ID to the request. When the Service Consumer of Namf_Communication
and Namf_EventExposure services invokes these services, it includes the
received Storage Resource ID to the request. The Service Framework discovers
the suitable service instances and ensures both the instance of
Namf_Communication and Namf_EventExposure are selected from the same Service
Collection, therefore able to access the same data. Internal communication
between Namf_Communication and Namf_EventExposure is not subject to
standardization.
The Service Collection is similar concept to Rel-15 Network Function; the
difference is that the Service Collection allows more flexible grouping of NF
services, e.g. NF services that do not need to share the data can be
configured to different Service Collections.
In addition, the Service Collection can be used to achieve the same outcome as
the concept of Service Instance Set. The instances of a single NF service
within the Service Collection can be considered as \"Service Instance Set\".
This set of instances can be referred with the particular Storage Resource ID
and the corresponding NF Service type. Thus a separate concept of Service
Instance Set is not required.
### 6.17.3 Modularized 3GPP System Architecture
Editor\'s Note: Modularized architecture is FFS
### 6.17.4 Impacts on existing NF/NF Services and Interfaces
NF profile is not needed anymore. NF Service profile needs to be updated to
include the Storage Resource ID.
The impact on stage 2 is:
\- Definitions and architecture adapted with NF services and NF service types
(where applicable).
\- Descriptions adapted with NF Service Description.
\- Adapt all flow descriptions towards NF Services.
\- Update Stickiness solutions and bindings to be based on NF Services.
\- Updated Service Framework to be based on NF services.
Editor\'s note: Further details regarding impacts are FFS.
### 6.17.5 Evaluation of the Solution
With the Service Framework and the modularization, the full freedom is ensured
to react on the requirements of the different use-cases to implement the use
case specific network slices.
Analysis of this solution shows that a group the multiple NF services of
different NF service type may need to share data, e.g. NF services as defined
per NF type in Rel-15. The Storage Resource ID is introduced to be able to
discover and refer to a set of service instances that can access the same,
consistent data.
## 6.18 Solution 18: Further AMF modularization
### 6.18.1 Introduction
This solution addresses the key issue 1 Optimal modularization of the system.
In Rel-15, one AMF instance is modularized as four services:
Namf_Communication, Namf_EventExposure , Namf_Location, and Namf_MT.
This solution is proposed to introduce an independent service to manage the N2
connection for the UE.
Editor\'s note: Relationship between the NAS and N2 procedures for this
proposal will be further clarified in the next version.
Editor\'s note: It is FFS how N1 transactions and retransmissions are handled
with N2 Service.
Editor\'s note: It is also FFS how MO and MT transactions are handled if they
happen concurrently, especially considering N2 Service is not aware of UE
specific handling.
### 6.18.2 High-level Description
A further service named N2 service is split from the AMF. The N2 service
terminates the TNLA protocol. The Non UE-associated NGAP services is provided
between the N2 service instance and NG-RAN. The Release 16 AMF terminates the
N1 interface and keeps all functionalities of Release 15 AMF except the Non
UE- associated NGAP services and TNLA handling. The UE-associated NGAP
services are still provided between the NG-RAN and AMF. The following figure
shows the proposed concept.
Figure 6.18.2-1: Further AMF modularization
The interface between the AMF and N2 service is service based interface. The
AMF and N2 service register its service profiles/configurations together with
the service area into the NRF. The AMF obtains the service profiles of N2
service in the same service area. Similar, the N2 service obtains the service
profile of AMF in the same service area.
The N2 service aggregates configuration information from all NG-RANs
connecting to it and registers the N2 service configuration information into
the NRF. The NRF then notifies the AMF with N2 service configuration. The N2
service stores the NG-RAN configuration. The AMF stores N2 configuration.
When the UE is in IDLE state, the N2 service removes the UE contexts while the
AMF keeps the UE context. When the UE is in CONNECTED mode, the N2 service
keeps the mapping information between the NG-RAN and the AMF serving the UE.
The N2 service converts the transportation protocol between SBI and TNLA, but
does not change the UE- associated NGAP signalling exchanged between the NG-
RAN and AMF.
When the UE is registered via multiple accesses within the same PLMN, the N2
service is selected per access, while only single AMF is used to serve the UE.
Service Set concept can be used for the N2 service. The relationship between
N2 service Set and AMF service Set is 1:1. One N2 service setis mapped to a
one AMF service Set.
The NG-RAN and peer NFs don\'t need to know if the N2 service instance has
been split from AMF instance or not, therefore no impact on NG-RAN and peer
NFs.
The N2 service instance transparently transfer the UE- associated NGAP
signalling between the AMF and NG-RAN. Any race conditions with multiple
requests for the same UE are handled in NG-RAN and AMF instance as Rel 15.
### 6.18.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
#### 6.18.3.1 AMF or N2 Service Registration/Update/Deregistration
Figure 6.18.3.1-1
1a\~3a, 1b\~3b. After AMF instance or N2 service is instantiated/removed in
the network, or the configuration information of AMF or N2 service has been
updated, it registers/deregisters is latest service profiles in the NRF. The
service profile includes the service area of the AMF or N2 service.
4\. If the NRF already has the N2 services registered before, the NRF checks
whether the N2 Service area is the same as the AMF service area. If yes, the
NRF notifies the AMF with the latest service profile of N2 eservice via
Nnrf_NFManagement_NFStatusNotify message.
5\. If the N2 service has registered in NRF before and subscribed AMF service
status notification, the NRF checks whether the N2 service area is the same as
the AMF service area. If yes the NRF notifies the N2 service with the latest
service profiles of AMF via Nnrf_NFManagement_NFStatusNotify message.
6\~7. If the N2 service receives the Nnrf_NFManagement_NFStatusnotification
from the NRF, the N2 service sends AMF configuration update message to the NG-
RAN to update the AMF information stored in the NG-RAN.
#### 6.18.3.2 NG-RAN setup or configuration update
Figure 6.18.3.2-1
1\~3. In case of adding a new NG-RAN, the NG-RAN sends a NR Setup request to
N2 service. In case of configuration update of the NG-RAN, the NG-RAN sends NR
Configuration update request to the N2 service. If case of restoration, the
NG-RAN send a NR reset message to the N2 service.
The NG-RAN performs step1\~3 to all the N2 services it has been configured to
connect.
4\~5. N2 service collects configuration information from all NG-RANs it has
TNLA connections with. The N2 service updates the N2 service configuration
information in the NRF. The NRF responses to the N2 service.
6\. If the AMF service has registered in NRF before and subscribed N2 service
status notification, the NRF checks whether the N2 service area is the same as
the AMF service area. If yes, the NRF notifies the AMF with the latest N2
service configuration information via Nnrf_NFManagement_NFStatusNotify
message.
#### 6.18.3.3 Mobile Origination procedure
Figure 6.18.3.3-1
1\. The UE initiates a NAS procedure, e.g. registration procedure, or service
request procedure. NAS message is included in the RRC message.
2\. Same as Release 15. The NG-RAN now selects the N2 service instance,
instead of AMF service instance.
3\. If the GUAMI or 5G S-TMSI of the UE is included in step2, the N2 service
selects AMF using the GUAMI or 5G S-TMSI. Otherwise the N2 service randomly
selects an AMF service instance in the corresponding AMF Set. N2 service sends
Nn2_N1N2Message_Notification(NAS message, N2 UE ID) message to AMF. N2 UE ID
is allocated by N2 service to uniquely identify the UE context in the N2
service Set.
4\. AMF handles the NAS message.
5\. If AMF service needs to send message back to NG-RAN, it sends the
Nn2_N1N2Message Transfer message to N2 service. AMF allocates N1 UE ID to
uniquely identify the UE context in the AMF Set and includes it in the message
to N2 service. This message also include the N2 UE ID received in step 3.
6\~9. The N2 service identifies the UE context via N2 UE ID and stores the N1
UE ID. The N2 service transfers the DL NAS message to the UE via NG-RAN. The
UE may send UL NAS message to the AMF via the NG-RAN and N2 service. The NG-
RAN and N2 service exchange N2 messages by using the RAN UE NGAP ID and AMF UE
NGAP ID to uniquely identify the UE context. The N2 service and AMF exchanges
the messages by using the N2 UE ID and N1 UE ID to identify the UE context.
#### 6.18.3.4 Mobile termination procedure
Figure 6.18.3.4-1
1\. when the UE is in idle mode and AMF receives a downlink transmission
message, e.g. Namf_Communication_N1N2MessageTransfer message, the AMF decides
to page the UE.
2\. the AMF selects one or multiple N2 service instances based on UE
registration area.
3\~5.The AMF sends Nn2_Paging Request message to the selected N2 service
instance(s). This message includes the UE registration area and the S-TMSI of
the UE. The N2 service decides all the NG-RANs under the UE registration area
and sends the N2 paging message to the selected NG-RANs. The NG-RAN pages the
UE when it receives the paging request message from N2 services.
6\. The UE initiates Service Request procedure when it receives the paging
message.
### 6.18.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
The AMF is further split the N2 service outside of the AMF services.
NRF is enhanced to support AMF and N2 service management and status
notification.
No impacts on NG-RAN, UE, other peer NFs.
### 6.18.5 Evaluation
The solution further decouple a new service N2 service outside of AMF. The N2
service terminates the TNLA protocols. The Non UE-associated NGAP services is
provided between the N2 service instance and the NG-RAN. The UE-associated
NGAP service is provided between the AMF service instance and the NG-RAN. The
N2 service exposes a service based interface that can be used by other
services (e.g. AMF). The N2 service instance The AMF does need to handle the
TNLA protocol so this can simplify the AMF logic. This solution has no impact
on the NG-RAN and other peer NFs and is therefore backwards compatible.
## 6.19 Solution 19: UPF Services introduced in 5G eSBA
### 6.19.1 Introduction
This solution addresses key issue 2 \"Extend Service Concept into User
Plane\".\ In Release 15 SBA design, the SBA applies to 5GC control plane only
due to time constraints. This leads to both SBI and PtP interfaces exists in
the core network, causing the protocol complexity. The user plane function
(UPF) is the NF that possesses many functionalities. Therefore, extends the
service concept into User Plane helps to modularize the functionalities so
that the UPF can be flexible defined/deployed, e.g., per network slicing/edge
computing requirement.
There are 13 main functionalities of UPF illustrated in TS 23.501 [2], clause
6.2.3.
1\. Anchor point for Intra-/Inter-RAT mobility (when applicable).
2\. External PDU Session point of interconnect to Data Network.
3\. Packet routing & forwarding (e.g. support of Uplink classifier to route
traffic flows to an instance of a data network, support of Branching point to
support multi-homed PDU Session).
4\. Packet inspection (e.g. Application detection based on service data flow
template and the optional PFDs received from the SMF in addition).
5\. User Plane part of policy rule enforcement, e.g. Gating, Redirection,
Traffic steering).
6\. Lawful intercept (UP collection).
7\. Traffic usage reporting.
8\. QoS handling for user plane, e.g. UL/DL rate enforcement, Reflective QoS
marking in DL.
9\. Uplink Traffic verification (SDF to QoS Flow mapping).
10\. Transport level packet marking in the uplink and downlink.
11\. Downlink packet buffering and downlink data notification triggering.
12\. Sending and forwarding of one or more \"end marker\" to the source NG-RAN
node.
13\. ARP proxying as specified in IETF RFC 1027] and / or IPv6 Neighbour
Solicitation Proxying as specified in IETF RFC 4861 functionality for the
Ethernet PDUs. The UPF responds to the ARP and / or the IPv6 Neighbour
Solicitation Request by providing the MAC address corresponding to the IP
address sent in the request.
Some considerations to defines UPF services:
1\. UPF\'s functionality characteristics. There are 13 main functionalities of
UPF illustrated in TS 23.501 [2]. Considering the N3 and N9 is not in the
scope of eSBA, there are eleven functionalities of UPF can be categorized into
three services, i.e. the Traffic Path Control Service (fulfilling UPF
functionality 1,2,3), Policy Control Service(fulfilling UPF functionality
4,5,6,8,9,10) and Event Exposure Service(fulfilling UPF functionality 7,11).
In addition, the UPF functionalities may be either session-level or UPF node-
level i.e., N4 association.
2\. Context/data independencies.
Editor\'s Note: It is need to investigate the independency of the NF services
defined.
### 6.19.2 High-level Description
Based on the functionalities as well as the data/context managed, the 5G user
plane NF services are defined as the following:
**\- Traffic Path Control** is the service to establish the traffic routing
path for uplink/downlink data. It can be used to update the tunnel info when
the UPF implements the mobility anchor, or a UPF is inserted into/removed from
the existing data path.
**\- N4 Association:** the association of N4, between SMF and UPF. This is a
UPF level (as compared with session level) handling service.
**\- Policy Control** is the service to configure corresponding PCF policy
and/or policy trigger information on UPF for proper data traffic handling, and
to achieve PFD management. SMF can invoke the policy control service to
transfer the QoS, Lawful Interception, Charging or other policies to UPFs, and
after this configuration, the policy can be enforced when the corresponding
uplink/downlink data starts to transfer.
**\- Event Exposure** is the service which can report the UPF information to
the consumers subscribed this event. For example, N4 node level reporting, the
downlink data notification, etc.
### 6.19.3 Services and illustrated Procedures
Table 6.19.3-1: List of UPF Services
+-------------+-------------+-------------+-------------+-------------+ | Service | Service | Operation | Known | Example | | Name | Operations | | Consumer(s) | Reference | | | | Semantic | | | +=============+=============+=============+=============+=============+ | Nu | Create | Request/ | SMF | Step 10a | | pf_Traffic | | Response | | and 10b of | | PathControl | | | | clause | | service | | | | 4.3.2.2.1. | | | | | | | | | | | | Step 4a, 4b | | | | | | of | | | | | | cla | | | | | | use 4.3.5.3 | +-------------+-------------+-------------+-------------+-------------+ | | Update | Request/ | SMF | Step 16a | | | | Response | | and 16b of | | | | | | claus | | | | | | e 4.3.2.2.1 | | | | | | | | | | | | Step 5a ,5b | | | | | | and 6a,6b | | | | | | of | | | | | | cla | | | | | | use 4.3.5.3 | +-------------+-------------+-------------+-------------+-------------+ | | Release | Request/ | SMF | Step 2a and | | | | Response | | 2b of | | | | | | cla | | | | | | use 4.3.4.2 | +-------------+-------------+-------------+-------------+-------------+ | Nupf_N4 | Setup | Request/ | SMF | Steps of | | Association | | Response | | cla | | | | | | use 4.4.3.1 | +-------------+-------------+-------------+-------------+-------------+ | | Update | Request/ | SMF | Steps of | | | | Response | | cla | | | | | | use 4.4.3.2 | | | | | | SMF | | | | | | initiated | | | | | | N4 | | | | | | association | | | | | | update | | | | | | procedure | +-------------+-------------+-------------+-------------+-------------+ | | Release | Request/ | SMF | Steps of | | | | Response | | cla | | | | | | use 4.4.3.3 | | | | | | SMF | | | | | | initiated | | | | | | N4 | | | | | | association | | | | | | release | | | | | | procedure | +-------------+-------------+-------------+-------------+-------------+ | Nupf_Po | Create | Request/ | SMF, | Step 10a | | licyControl | | Response | | and 10b of | | service | | | | claus | | | | | | e 4.3.2.2.1 | +-------------+-------------+-------------+-------------+-------------+ | | Update | Request/ | SMF | Step 12a, | | | | Response | | 12b of | | | | | | cla | | | | | | use 4.3.3.2 | | | | | | | | | | | | Step 3 and | | | | | | 4 of | | | | | | c | | | | | | lause 4.4.4 | +-------------+-------------+-------------+-------------+-------------+ | | Release | Request/ | SMF | Steps of | | | | Response | | cla | | | | | | use 4.4.1.4 | +-------------+-------------+-------------+-------------+-------------+ | Nupf_Ev | Notify | Subsc | SMF, | Step 1 of | | entExposure | | ribe/Notify | | c | | service | | | | lause 4.4.4 | | | | | | | | | | | | Step 2a of | | | | | | cla | | | | | | use 4.2.3.3 | +-------------+-------------+-------------+-------------+-------------+
### 6.19.4 Co-existing of N4 PtP and N4 SBI
In order to support co-exist deployment of UPFs using PtP or using service
based interface, some assumptions should be considered:
1\. One SMF can support one protocol interface between UPF and 5GC, i.e. PtP
or SBI.
2\. One UPF can support one protocol interface between UPF and 5GC, i.e. PtP
or SBI.
Based on the above assumptions, and the discovery mechanism that SMF get the
available UPFs using the NRF, the following solution is proposed.
When the UPF registers itself in the NRF, the indication of what protocols can
be supported should be included. The SMF may provide the required UPF type
during UPF discovery through NRF. NRF returns UPF according to the request.
The SMF shall decide the protocol used for this N4 interface, or the SMF
rejects to use the UPF in case the SMF only support one protocol and the
returned UPF only support the other protocol.
### 6.19.5 Impacts on existing Services and Interfaces
The SMF needs to be updated to be able to invoke the corresponding UPF
services.
The N4 PtP interface should be updated to support service based interface.
Editor\'s Note: The protocol design of N4 SBI is per stage 3 and considering
the performance.
Editor\'s Note: Whether the procedure like Step 10a and 10b of clause
4.3.2.2.1 can be divided into two services invocation
e.g.Nupf_PathControl_Create and Nupf_PolicyControl_Create is FFS.
### 6.19.6 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.20 Solution 20: Service Framework based on CAPIF
### 6.20.1 Introduction
This solution addresses Key Issues 3 \"Improvements to service framework
related aspects\".
### 6.20.2 High level description
This clause proposes a framework that is based on Rel-15 CAPIF functionality
as defined in TS 23.222 [5].
The CAPIF Core Function (CCF) provides following functionality:
\- On-boarding/off-boarding API invoker.
\- Register/de-register APIs, Update APIs.
\- APIs Discovery.
\- Entity Authentication/Authorization.
\- Enables secure communication.
\- Logging, Monitoring and Auditing the service API invocations.
\- Controlling the service API access based on configured policies.
Figure 6.20.2-1: High level architecture view
Network Function Service Producer implements the following functionality:
\- The API Exposing Function (AEF) can in principle be any entity exposing a
Service API defined by 3GPP.
\- The API publishing function (APF) enables the API provider to publish the
service APIs information in order to enable the discovery of service APIs by
the API invoker.
\- The API management function (APIMF) enables the API provider to perform
administration of the service APIs.
The API Invoker (AI) entities are any entities that invoke the APIs exposed by
the CCF and AEF. The AI\'s can be located inside or outside the trust domain
of the PLMN. They are considered in the TS 23.222 [5] to be external 3rd party
applications. However, although CAPIF is designed for consumption of
northbound APIs by 3rd party applications, the design principles and solutions
can be applied to southbound APIs.
Put in terms of the terminology used when discussing SBA, AEFs are Producers
and AIs are Consumers.
The service framework requirements, as set out in clause 4.1 of the present
document are listed in the first column of Table 6.20.2-1.
Table 6.20.2-1: Service requirements and CAPIF functionality
Service framework requirements Supported by CAPIF? Comments
* * *
Shall provide registration and discovery. Yes  
Shall enable efficient communication between service instances and allow
distributed scaling No There are implementation-specific means for enabling
communication between service instances, and to support distributed scaling.
Shall enable service communication within one slice, between slices, within
one service framework, instance between different service framework instances
and between different PLMNs with minimal impact to service No There are
implementation-specific means for enabling these communication requirements.
Shall enable handling of failure scenarios with minimal impact to service. Yes  
Should enable protection of the system against signalling storms No This can
be achieved by appropriate implementation and deployment choices. Should
support protect the integrity and confidentiality of the communication Yes  
Should provide the authentication and authorization to access the service Yes
In addition the following functionality is supported by CAPIF, but at this
point in time not required by the eSBA Framework. Re-use of CAPIF would allow
these features to be available to the eSBA Framework if needed in the future.
Table 6.20.2-2: Additional CAPIF functionality
Additional CAPIF functionality Comments
* * *
Logging service invocations  
Charging the service invocations Potential for use in multi-admin domain
deployments Monitoring events reported due to service invocations  
Managing service consumers Onboarding, offboarding Mutual authentication
between Potential for use in multi-admin domain deployments
The following provides more detail on the CAPIF reference points.
CAPIF-3, CAPIF-4 and CAPIF-5 are used to perform the following actions:
\- CAPIF-3
\- Authenticating the Service consumer based on its identity and credentials;
\- Providing authorization for the Service consumer prior to accessing the
Service producer;
\- Authorization verification for the Service consumer upon accessing the
Service producer;
\- Controlling the service access based on PLMN operator configured policies;
\- Logging the service invocations; and
\- Charging the service invocations.
\- CAPIF-4
\- Publishing the service information by the publishing function.
\- CAPIF-5
\- Accessing the service invocation logs by the management function;
\- Enabling the management function to monitor the events reported due to the
service invocations;
\- Onboarding new Service consumers by provisioning the Service consumer
information at the CAPIF core function, requesting explicit grant of new
Service consumers onboarding and confirming onboarding success;
\- Offboarding Service consumers;
\- Enabling the API management function to configure policies at the CAPIF
core function e.g. service invocation throttling, blocking invocation for
certain duration; and
\- Enabling the API provider to monitor the status of services (e.g. pilot or
live status, start or stop status of service API).
CAPIF-1 is used to perform the following actions:
\- Authenticating the Service consumer based on its identity and credentials;
\- Mutual authentication between the Service consumer and the CAPIF core
function;
\- Providing authorization for the Service consumer prior to accessing the
Service producer; and
\- Discovering the Service producer information.
To support the backward compatibility with Rel-15 the NRF can be used along
with the CCF. Rel-15 NFs can continue to interface with the NRF and the NRF
can proxy the message to the CCF.
### 6.20.3 Backwards compatibility with Rel-15
For deployments where Release 15 network functions and Release 15 NRFs are
already deployed it is necessary to consider how a service framework based on
the CAPIF APIs can be supported.
At a high level two options are identified for how Rel-15 and Rel-16 network
functions, a Rel-15 NRF and a service framework based on CAPIF could co-exist:
Figure 6.20.3-1: Option 1 for backwards compatibility
A Rel-16 Framework based on the CAPIF Core Function (CCF) is deployed that
also implements the Rel-15 NRF interfaces. Rel-15 NFs can continue to use the
Rel-15 NRF interfaces to register themselves. An adaptation layer in the
Rel-16 Framework translates the registrations such that a Rel-16 NF can
discover the Rel-15 NFs. The Rel-16 NF can also publish itself and the
adaptation layer allows Rel-15 NFs to discover it.
Figure 6.20.3-2: Option 2 for backwards compatibility
Alternatively, as shown in Figure 6.20.3-2 an existing Rel-15 NRF could be
updated to support the adaptation functionality mentioned above. When a Rel-15
NF registers with the Rel-15 NRF it invokes the publish operation on the
Rel-16 Framework. If the preference is to leave the Rel-15 NRF unchanged then
Option 3, as shown in Figure 6.20.3-3 could be used.
Figure 6.20.3-3: Option 3 for backwards compatibility
Looking in more detail at the services and operations supported by the NRF,
and how they map to the CAPIF services shows that the mapping is quite
straightforward.
As specified in TS 23.502 [3] a Rel-15 NRF supports the Nnrf_NFManagement,
Nnrf_NFDiscovery and Nnrf_AccessToken services and associated service
operations. These can be mapped to analogous CAPIF services and service
operations as defined in TS 23.222 [5].
Table 6.20.3-1: Mapping of NRF to CAPIF services and operations
**Rel-15 NRF** **Rel-15 CAPIF**
* * *
**Service Name** **Service Operations** **Service Name** **Service Operation**
Nnrf_NFManagement NFRegister CAPIF_Publish_Service_API Publish_Service_API
NFUpdate CAPIF_Publish_Service_API Update_Service_API NFDeregister
CAPIF_Publish_Service_API Unpublish_Service_API NFStatusSubscribe
CAPIF_Discover_Service_API Subscribe_Event NFStatusNotify
CAPIF_Discover_Service_API Notify_Event NFStatusUnSubscribe
CAPIF_Discover_Service_API Unsubscribe_Event Nnrf_NFDiscovery Request
CAPIF_Discover_Service_API Discover_Service_API Nnrf_AccessToken Get
CAPIF_Security API Obtain_Authorization
Looking in more detail at the NFRegister operation of the Nnrf_NFManagement
service and comparing it with the CAPIF Publish_Service API:
Table 6.20.3-2: Comparison of NFRegister and Publish_Service_API parameters
+----------------------+----------------------+----------------------+ | | Nnrf_NFMa | P | | | nagement_NFRegister | ublish_Service_API | +======================+======================+======================+ | Mandatory input | NF profile of the NF | API publisher | | parameters | consumer (NF type, | information (may | | | NF instance ID, | include identity, | | | Names of supported | authentication and | | | NF services) | authorization | | | | information). | | | | | | | | Service API | | | | information | | | | (includes service | | | | API name, service | | | | API type, | | | | communication type, | | | | description, | | | | interface details | | | | (e.g. IP address, | | | | port number, URI), | | | | protocols, version | | | | numbers, and data | | | | format) | +----------------------+----------------------+----------------------+ | Optional input | Data Set(s), UDM | None | | parameters | Group ID, UDR Group | | | | ID, AUSF Group ID, | | | | Routing ID, | | | | GUAMI(s), UPF | | | | Provisioning | | | | Information, | | | | S-NSSAIs and | | | | associated NSI IDs, | | | | location of NF | | | | consumer, TAIs | | +----------------------+----------------------+----------------------+
Although some mapping of NRF input and output parameters are straightforward
(such as mapping NF type to service API type) there are other NRF parameters
that will require enhancement to Rel-15 CAPIF to support (such as NF instance
ID).
Below is a call flow showing a Rel-15 NF invoking Nnrf_NFManagement_NFRegister
towards an NRF and the NRF invoking the CAPIF_Publish_Service_API
Publish_Service_API operation on the CAPIF Core Function. Subsequently a
Rel-16 NF discovers the Rel-15 NF, and a different Rel-15 NF discovers the
Rel-15 NF. The NRF and CCF could be separate (Option 2 above), or their
functions can be co-located (Option 1 above).
Figure 6.20.3-4: Rel-15 NF and Rel-16 NF co-existence
### 6.20.4 Support for roaming
There are two options for support of roaming when using CAPIF, as shown below.
Either an NF in the serving network can interact with a CAPIF CCF in the
serving network which in turn could interact with a CAPIF CCF in the home
network (Option 1 below) or an NF in the serving network can interact directly
with a CAPIF CCF in the home network (Option 2 below). Option 2 is supported
in Rel-15 in TS 23.222 [5], as an API can reside outside a PLMN domain and use
CAPIF-1e and CAPIF-2e. Option 1 is not currently specified in TS 23.222 [5]
and would need to be introduced in Rel-16.
Figure 6.20.4-1: Options for roaming support
### 6.20.5 Services and illustrated procedures
The following procedures are taken from TS 23.222 [5], clause 8. In the
figures the API publishing function can be interpreted as a service producer.
#### 6.20.5.1 Registration
In CAPIF terminology the registration of a service producer is registration of
a Service API.
Figure 6.20.5.1-1: Publish service
1\. The API publishing function sends a service API publish request to the
CAPIF core function, with the details of the service API.
2\. Upon receiving the service API publish request, the CAPIF core function
checks whether the API publishing function is authorized to publish service
APIs. If the check is successful, the service API information provided by the
API publishing function is stored at the CAPIF core function (API registry).
3\. The CAPIF core function provides a service API publish response to the API
publishing function indicating success or failure result and triggers
notifications to subscribed API invokers as described in clause 8.8.4.
#### 6.20.5.2 Discovery
In CAPIF terminology the discovery of a service producer is discovery of a
Service API.
Figure 6.20.5.2-1: Discover service
1\. The API invoker sends a service API discover request to the CAPIF core
function. It includes the API invoker identity, and may include query
information.
2\. Upon receiving the service API discover request, the CAPIF core function
verifies the identity of the API invoker (via authentication). The CAPIF core
function retrieves the stored service API(s) information from the CAPIF core
function (API registry) as per the query information in the service API
discover request. Further, the CAPIF core function applies the discovery
policy and performs filtering of service APIs information retrieved from the
CAPIF core function.
3\. The CAPIF core function sends a service API discover response to the API
invoker with the list of service API information for which the API invoker has
the required authorization.
### 6.20.6 Impacts on existing Services and Interfaces
There are some NRF parameters that will require enhancement to Rel-15 CAPIF in
order to provide the same NF service registration and discovery capabilities.
It may be necessary to evolve Rel-15 CAPIF to support the interaction of a
CAPIF CCF in a serving PLMN with a CAPIF CCF in the home PLMN to support
roaming cases.
### 6.20.7 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.21 Solution 21: Hierarchical service framework
### 6.21.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
### 6.21.2 High level description
New technologies are coming for inter container communication, such as message
bus communication solutions and service mesh solutions. This solution allows
for integrating these solutions into the existing Rel-15 based service
framework. See figure 6.21.2-1. As described in solution 5 \"Flexible Service
Framework\" it is possible to deploy the Rel-15 service framework with both
indirect and direct communication between services. Similarly, when applied in
the hierarchical service framework model, both direct and indirect
communication can be used and it\'s up to the operator to select the option to
use in a deployment. If supported by the cluster specific service frameworks,
services in different clusters may use direct communication.
Figure 6.21.2-1: hierarchical service framework
In this architecture the new innovations can be introduced within each service
cluster. A service cluster may span just a POD, a data centre, or a network
slice, it is really up to how an operator wants to deploy this architecture.
The service cluster hides the specifics of the cluster specific service
framework. All services that shall be reachable from the outside world are
registered in the NRF. The different clusters can use rel 15 based mechanisms
to register these services. Exactly how that is done within the service
cluster is service cluster specific, it could be from the service itself or
from some entity within the cluster specific service framework.
A cluster may contain NF/Services from different vendors supporting the
cluster specific service framework. Examples of service frameworks that can be
use in a service cluster are, Linkerd, Istio, a service framework solution as
proposed in clause 6.2, 6.3, 6.4, 6.5, 6.6 or something specific to an
operator or vendor.
Editor\'s note: If a cluster should be part of the NF profile and be part of a
discovery is FFS
If a service consumer within the service cluster need to connect to a service
producer outside the service cluster, some entity in the service cluster (the
service itself or the cluster specific service framework) will discover and
select the service producer according to rel 15 principles. Inter cluster
addressing of services are done according to rel. 15. The external entry and
exit points of the service cluster for a service producer and service consumer
may be the service itself, the NF, or some entity within the service cluster
specific framework. The same principle will apply to roaming: from a service
consumer perspective when the service producer in a different PLMN is outside
the service cluster. Here all communication between a service consumer and a
service producer must be via SEPPs, according to rel 15 principles,
The figure 6.21.2-1 shows an example of 3 different service clusters. The
NF/NF services that are addressable outside the clusters have non-dotted
lines. For example, NF A and its services are present in service cluster #1
and service cluster #2, service cluster #3 does not provide NF A and its
services (at least not outside the cluster). The figure also shows some
internal cluster services by dotted lines, for example services x1 and x2.
These services are not reachable from outside the service cluster #1, only
consumers within service cluster #1 may consume these services, and thus they
are not registered within the NRF. It is even so that the services that are
reachable from the outside world, may be built up of several services within
the service cluster, however this would be completely hidden from outside of
the service cluster. This is illustrated in service cluster #3, where NF B and
service b1 and b2 are build-up of services z1 through z6. The addressable
resources from the outside world in service cluster #3 are services b1 and b2,
but internally, service z1 through z6 execute them (c1 and c2). Service z1
through z6 are hidden and not addressable from outside.
This architecture will allow for adopting new technologies, but at the same
time keep existing Rel 15 NFs and NF services if needed.
The inter cluster service framework may be a distributed or centralized
service framework according to 6.5 \"Flexible service framework\"
The figure 6.21.2-2 shows an example on how roaming can be addressed. The SEPP
is shown as part of the Inter cluster service framework, and the SEPP is
offering roaming services enabling inter-PLMN signalling between vNRFs and
hNRF and between service consumers in service clusters in VPLMN and service
producers in service clusters in HPLMN.
Figure 6.21.2-2 hierarchical service framework and roaming
### 6.21.4 Impacts on existing NF/NF Services and Interfaces
No impact on existing NF/NF services and interfaces.
Each service cluster need to integrate with the overall Rel-15 based inter
cluster service framework.
### 6.21.5 Evaluation of the Solution
Editor\'s note: This clause provides an evaluation of the solution.
## 6.22 Solution 22: Services Framework enhancement
### 6.22.1 Introduction
This solution addresses key issue #3 \"Improvements to service framework
related aspects\" and key issue #7 \"Roaming\".
This solution is backward compatible with Rel-15 SBA.
The service framework proposed in this solution can be distributed across
multiple data centers/hosts.
The solution reduces the complexity of the NF services by extraction of some
common functionalities, includes:
\- Discovery of communication peers.
\- Policy enforcement, authorization of the message delivery.
### 6.22.2 High-level Description
This clause proposes a service framework architecture that is based on Rel-15
service based architecture with some improvements. The design aims to enable
inter service communication in an efficient way.
In this solution, the service framework architecture includes the Service,
Service Agent and the Service Framework.
The following figure illustrates the architecture:
Figure 6.22.2-1: Service Framework architecture
NOTE 1: In figure 6.22.2-1, each service can communicate with each other
through SBI directly.
The service framework architecture includes the following aspects:
\- Service Framework: responsible for service registration, customer
authorization, service discovery, service monitoring, service configuration
profile management, traffic management, etc. Service registration is invoked
by the service when the service is introduced into the system. Service
configuration profile management is responsible for the addition, removal,
version control of service configuration profile. Service discovery can be
invoked by each service. Service Monitoring monitors the status of each
service, e.g. the invoking time of the service, the abnormal behaviour of the
service. Customer authorization is performed during the service discovery to
authorize the customer service to access the producer service. Traffic
management is responsible for controlling the percentage of signaling traffic
each service instance handles. The Service Framework is not responsible for
the message delivery between services.
\- Service Agent: responsible for the management of the service instances
within the same host. It monitors whether the service instance is alive, and
handles the addition/removal/update of the service instances. It needs to
feedback the service instance information to the Service Framework. The
Service Agent is not responsible for the message delivery between services.
The Service Agent is not specific for the same type of services.
\- Service: each service contains mainly business logic. After service
discovery, the customer service instance communicates with the producer
service instance directly through SBI.
The interfaces shown in Figure 6.22.2-1 follows the aspects below:
\- The communication between two services is through the SBI between services
directly. The communication between the services and the Service Framework is
through the SBI directly.
\- The details of the SBI is the responsibility of stage 3.
\- The Services, the Service Framework, and the SBIs are needed to be defined
by 3GPP.
\- The Nsa interface is the interface between the Service and the Service
Agent. It is responsible for the lifecycle management and the statistic
information collection of each service instances.
\- The Nsb interface is the interface between the Service Agent and the
Service Framework. It is responsible for reporting the statistic information
of each service instances to the Service Framework.
NOTE 2: Whether Nsa and Nsb interfaces need to be standardized is decided in
3GPP SA5.
Relationship with the Rel-15 SBA architecture:
\- There is no impact on the Rel-15 NF / NF services.
\- The functionalities of NRF in Rel-15 can be supported in the Service
Framework.
Reliability consideration:
\- The reliability of the solution could be realized by making the services
stateless. The service instance contains mainly the business logic which is
considered as stateless. The stateful data can be stored in the middleware,
e.g. data center.
\- The heartbeat mechanism could be used by the service instance to detect the
availability of the peer service instance. If the service instance detects
that the peer service instance is unavailable, it will select another service
instance from the set of service instances obtained during the service
discovery.
NOTE 3: The reliability issue will not be further described in this solution.
NOTE 4: The heartbeat is not sent within the SBI message.
\- This newly selected service instance shall be able to access the data
stored by the previously service instance in the middleware. Based on the
above analysis, the service framework architecture is compatible with the
Rel-15 service based architecture.
Roaming support:
\- The figure 6.22.2-2 shows an example on how roaming can be addressed.
\- The SEPP (Security Edge Protection Proxy) functions as defined in TS 23.501
[2]. It communicates with the Service Framework via the 3GPP SBIs.
\- The SEPP is offering roaming services enabling inter-PLMN signalling
between Service Frameworks and between service consumers in VPLMN and service
producers in HPLMN.
Figure 6.22.2-2: Service Framework and roaming
### 6.22.3 Illustrated Procedures
#### 6.22.3.1 Registration and de-registration of service instances
In general, the procedures for the registration of service instance at the
service framework are similar with the registration of NF service compared to
Rel-15.
The procedures for the de-registration of service instance at the service
framework are similar with the de-registration of NF service compared to
Rel-15.
#### 6.22.3.2 Discovery of service instances and communication between
consumer and producer service instances
The consumer service instance needs to discover the producer service instances
through Service Framework. After the service discovery, the consumer service
instance selects the producer service instance and communicates with it
through SBI. The detailed procedure is in Figure 6.22.3.2-1.
Figure 6.22.3.2-1: Consumer to producer service instance communication
Figure 6.22.3.2-1 represents an example of a consumer service instance #1 that
wants to communicate with the producer service instance.
1\. The consumer service instance #1 does service discovery towards the
Service Framework.
2\. The Service Framework authorizes the consumer service instance #1 to
access the producer service instances.
3\. The Service Framework returns the addresses of a set of the producer
service instances, e.g. producer service instance#1 and producer service
instance #2, to the consumer service instance #1. The address of the producer
service instances could be IP address or FQDN.
4\. After the service discovery, the consumer service instance #1 selects the
producer service instance #1 from the set of producer service instances.
5 and 6. The consumer service instance #1 communicates with the producer
service instance #1 through SBI.
The detailed procedure for roaming is shown in Figure 6.22.3.2-2. The figure
shows an example of a consumer x instance #1 in the VPLMN that wants to
communicate with the producer y in the HPLMN.
Figure 6.22.3.2-2: Consumer to producer service instance communication-
Roaming
For the roaming cases, the same call flow steps as for figure 6.22.3.2-1
applies with the following differences:
\- Service discovery between Service Frameworks in the VPLMN and HPLMN are
transmitted via vSEPP and hSEPP.
\- Interactions between Services in the VPLMN and HPLMN are transmitted via
vSEPP and hSEPP.
### 6.22.4 Impacts on existing NFs, NF services and interfaces
No impact on existing NF/NF services in Rel-15.
This service framework is compatible with Rel-15.
This solution can support the existing SBI interfaces between NFs in Rel-15.
However, if the services are designed as self-contained, independent and
stateless in eSBA, there may be more inactions between services compared with
that in Rel-15 procedures, so whether high performance SBI protocols are
needed to be defined is per stage 3 decision. This also depends on the
solutions for key issue#1, e.g. solution 17.
### 6.22.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
This solution can be used to solve key issue#3 in the following aspects:
\- Identify the set of common Service Framework functionalities, i.e. that are
not part of the service logic. The detailed functionalities of the Service
Framework are described in clause 6.22.2.
\- Improvements of service framework related aspects, i.e.:
\- Service communication through direct ways.
\- The interaction between service and Service Framework for service
discovery, registration/de-registration is through direct ways.
\- Service Agent can be used for the management of the service instances
within the same host. The detailed functionalities are described in clause
6.22.2.
\- Selection of a service instance when more than one instance is available to
process a given service operation is realized in the customer service
instance.
\- this solution is backward compatible with Rel-15. NRF function can be
realized in Service Framework.
This solution can be used to solve key issue#7 in the following aspects:
\- Service Framework for supporting roaming. SEPP defined in Rel-15 can be
reused to enable inter-PLMN signalling between Service Frameworks and between
service consumers in VPLMN and service producers in HPLMN.
\- Service communication call flows for roaming scenario.
## 6.23 Solution 23: Single UPF service
### 6.23.1 Introduction
This solution addresses Key Issue 2: User Plane Aspects.
### 6.23.2 High-level description
#### 6.23.2.1 General aspects
This solution maps N4 procedures, as defined in TS 23.502 [3] clause 4.4, to
UPF services.
#### 6.23.2.2 Co-existence between PtP and SBI N4
In Rel-15, only one UPF service was defined, namely UPF_Management service.
The introduction of \"SBI N4\" would require a new UPF service definition.
In Rel-16, when SMFs provisioning of UPFs is done via NRF, UPFs supporting PtP
N4 are registered as supporting UPF_Management service, and UPFs supporting
SBI N4 would be registered in NRF as supporting a new service in NRF. SMFs can
discover whether UPFs support PtP N4 or SBI N4 via the services registered in
NRF.
### 6.23.3 Service and illustrated Procedures
#### 6.23.3.1 UPF service description
Table 6.23.3.1-1 lists the UPF service and UPF service operations which can be
mapped from N4 association procedures.
Table 6.23.3.1-1: UPF service and UPF service operations for N4 association
procedures
+-------------+-------------+-------------+-------------+-------------+ | Service | Service | Operation | Example | Mapping | | Name | Operations | | Consumer(s) | with N4 | | | | Semantics | | procedures | +=============+=============+=============+=============+=============+ | Nupf | Associ | Reque | SMF | N4 | | _UPService | ationCreate | st/Response | | association | | | | | | setup | | | | | | | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.3.1) | +-------------+-------------+-------------+-------------+-------------+ | | Associ | Reque | SMF | N4 | | | ationUpdate | st/Response | | association | | | | | | update | | | | | | initiated | | | | | | by SMF | | | | | | | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.3.2) | | | | | | and N4 PFD | | | | | | management | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.3.5) | +-------------+-------------+-------------+-------------+-------------+ | | Associ | Reque | SMF | N4 | | | ationDelete | st/Response | | association | | | | | | release | | | | | | initiated | | | | | | by SMF | | | | | | | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.3.3) | +-------------+-------------+-------------+-------------+-------------+ | | Associ | Subsc | SMF | N4 report, | | | ationReport | ribe/notify | | e.g. for | | | | | | user plane | | | | | | failure | | | | | | report | | | | | | | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.3.4) | +-------------+-------------+-------------+-------------+-------------+ | | Se | Reque | SMF | N4 session | | | ssionCreate | st/Response | | es | | | | | | tablishment | | | | | | Inputs: | | | | | | Session ID, | | | | | | PDRs, URRs, | | | | | | FARs, BARs, | | | | | | QERs, | | | | | | reporting | | | | | | triggers | +-------------+-------------+-------------+-------------+-------------+ | | Se | Reque | SMF | N4 session | | | ssionUpdate | st/Response | | m | | | | | | odification | | | | | | | | | | | | Inputs: | | | | | | Session ID, | | | | | | PDRs, URRs, | | | | | | FARs, BARs, | | | | | | QERs, | | | | | | reporting | | | | | | triggers | +-------------+-------------+-------------+-------------+-------------+ | | Se | Reque | SMF | N4 session | | | ssionDelete | st/Response | | release | | | | | | | | | | | | Inputs: | | | | | | Session ID | +-------------+-------------+-------------+-------------+-------------+ | | Se | Subsc | SMF | N4 session | | | ssionReport | ribe/notify | | report | | | | | | (TS 2 | | | | | | 3.502 [3] | | | | | | clau | | | | | | se 4.4.2.2) | +-------------+-------------+-------------+-------------+-------------+
Editor\'s note: How to model N4 association update and deletion initiated by
the UPF is FFS.
Editor\'s note: Service operations definition, e.g. listing inputs and
outputs, is FFS.
Editor\'s note: Whether UPF capabilities can be part of UPF profile registered
at NRF is FFS.
#### 6.23.3.2 Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.23.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
### 6.23.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.24 Solution 24: 5GC Reliability -- Resolution for Race condition
### 6.24.1 Introduction
This solution describes a potential race conditions that can occur due to
solutions 7-12, 17, 18 described in this TR along with potential resolution
for such race conditions.
### 6.24.2 High-level Description
When the NF stores context externally in a storage layer (e.g. UDSF), multiple
other NFs may try to send a UE specific message. This implies multiple other
peer NFs can select a NF instance for processing UE transaction (which has
access to the same UE context via common storage layer e.g. UDSF). If such
transactions and NF instance selection occur in parallel for processing a
given UE transaction, then this results in a race condition. This is
illustrated in the following call flow:
Figure 6.24.2-1: Concurrent message resulting in a race condition
Here is one possible step towards the resolution for the race condition
detected above. It should be noted that additional race conditions can occur
even as part of resolution which is not shown here.
Figure 6.24.2-2: Possible step towards resolution of the race condition
### 6.24.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.24.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
### 6.24.5 Evaluation
Editor\'s note: This clause provides an evaluation of the solution.
## 6.25 Solution 25: Service Group for reliability and flexible deploymemt
### 6.25.1 Introduction
This solution addresses key issues 3 \"Improvements to service framework
related aspects\" and Key Issue 6 \"System flexibility and service
provisioning\".
In Rel-15, AMF set was introduced for reliability. It\'s proposed to provide
further possibilities to enhance the reliability in Rel-16 eSBA. Several
solutions propose to define a Services Instance Set concept to support high
reliability. The service instance set has the following principles as stated
in clause 6.11.2:
\- A Set of instances of the same service type.
\- All Service instances in a Set can access the same data storage e.g. UDSF.
In this solution, we introduce the concept of Service Group to support high
reliability and resource isolation. Service Group in this solution is
different from the service set concept. The details of the solution are
described in clause 6.25.2. This solution also simplifies the service
monitoring and fault management.
### 6.25.2 High-level Description
#### 6.25.2.1 Concept of Service Group
In this solution, we propose to introduce the concept of Service Group to
support high reliability and resource isolation. The concept of Service Group
is defined as follows:
\- One Service Group could include different service instance sets.
\- Each service instance set include service instances of the same service
type.
\- All Service instances within the same service instance set can access the
same data storage e.g. UDSF.
\- The customer service instance could invoke the services instances within
the same Service Group.
The concept of Service Group should work irrespective of whether UDSF is
deployed or not. Furthermore, concept of Service Group should work
irrespective of whether UDSF is used as a primary storage or secondary
storage.
There is no vendor restriction for the services within one Service Group.
The concept of Service Group is shown in Figures 6.25.2-1 and 6.25.2-2.
Figure 6.25.2-1: A Service Group
Figure 6.25.2-2: Multiple Service Groups
The Service Group is identified by the following two parts:
\- Service Group name:
Service Group name can be identified by the operators according to the
function of the Service Group or the operator\'s deployment.
\- Service Group ID:
Service Group ID can be used to differentiate the Service Groups under the
same Service Group name.
The number of Service Group IDs can be decided by the Service Framework
according to the traffic supported by the Service Groups.
The customer service instance could invoke the service instances which belong
to the same Service Group, i.e. same Service Group name and Service Group ID.
The customer service instance can\'t invoke the service instances of different
Service Group ID under the same Service Group name.
The customer service instance could invoke the service instances under
different Service Group name.
As shown in Figure 6.25.2-2, service instance a within Service Group name: xxx
and Service Group ID: id-1 could invoke service instance b within the same
Service Group, i.e. Service Group name: xxx and Service Group ID: id-1, but
can\'t invoke service instance b in the service Group with Service Group name:
xxx and Service Group ID: id-2.
Service instance a with Service Group name: xxx and Service Group ID: id-1
could invoke service instance **f** with Service Group name: yyy and Service
Group ID: id-1.
The Service Group identities are allocated by the Service Framework to the
service instances at the registration response message. The Service Framework
also maintains the Service Group identities of the service instances. Some
service instances may not belong to any Service Group.
The service group identities need to be considered during the service
discovery procedure.
The benefit of the Service Group is as follows:
\- The resource of service instances of different Service Groups can be
isolated.
The service instance can\'t invoke the service instances with the same Service
Group name but different Service Group ID.
\- If there is any abnormal condition, e.g. high load in any service instance,
malfunction of any service instance, happening in one Service Group, the
feature supported in this Service Group ID will be impacted, but other Service
Groups will not suffer. In this case, the abnormal condition will only impact
the UEs accessing this service group, without impacting the UEs routed to
other service groups with different Service Group IDs. So it\'s easy for the
network to realize the monitoring and fault management.
\- The Service Group is also beneficial to the traffic management and
scalability.
The network could deploy several Service Groups for the same network feature,
e.g., network slice, system feature. So the traffic from different UEs can be
routed to different Groups supporting the same network feature. It\'s easy for
the network to calculate the traffic supported in each Service Group according
to its capacity.
The network could realize scalability by deploying or removing the Service
Groups.
#### 6.25.2.2 Flexible deployment support
The Service Group could be deployed flexibly in the network. The deployment
options may be as follows:
\- One Service Group may correspond to one network slice instance.
\- One Service Group may correspond to one system feature instance.
\- One network slice instance may include several service groups.
\- etc.
The following two examples show how the Service Group can be applied to the
service framework:
\- Example 1: Network slice:
Service Group could be used in the network slice level as the following
example:
Service Group name: S-NSSAI-A.
Service Group ID: NSI-ID- 1: {Service a instance set 1, Service b instance set
1, Service c instance set 1}
Service Group ID: NSI-ID-2: {Service a instance set 2, Service b instance set
2, Service c instance set 2}
In this example, the service a instance of Service a instance set 1 could
invoke the service b instance in Service Group ID NSI-ID-1, but can\'t invoke
service b instance of Service Group ID NSI-ID-2. _This example is shown in
Figure 6.25.2-3._
_The relationship between Network slice and_ Service Group identification
_shall be stored in_ Service Framework.
Figure 6.25.2-3: Service Group supporting network slice
\- Example 2: System feature:
If system feature is going to be supported in Rel-16 eSBA, the Service Group
could also correspond to system feature.
Service Group name: system feature-1.
Service Group ID:id-1: {service a instances set 3, service c instances set 3,
service d instances set 1}
Service Group ID: id-2: {service a instances set 4, service c instances set 4,
service d instances set 2}
In this example, _a set of services are orchestrated to form the_ Service
Group _to enable one system feature, and one system feature can be
added/updated/removed in 5GC via deploying/updating/removing the
corresponding_ Service Group _. This example is shown in Figure 6.25.2-4._
_The relationship between System Feature and_ Service Group identification
_shall be stored in_ Service Framework.
Figure 6.25.2-4: Service Group supporting system feature
The following figure 6.25.2-5 shows how the Service Group works in the whole
architecture, if the Service Group is deployed as a system feature.
As shown in figure 6.25.2-5, UE 1 and UE 2 are accessing system feature 1 and
system feature 2. The traffic of UE 1 is routed to Service Group {Service
Group name=system feature-1, Service Group ID 1} and Service Group {Service
Group name=system feature-2, Service Group ID 2}. The traffic of UE 2 is
routed to Service Group {Service Group name=system feature-1, Service Group ID
1} and Service Group {Service Group name=system feature-3, Service Group ID
1}.
Figure 6.25.2-5: Service Group supporting system feature-multiple system
features
### 6.25.3 Illustrated Procedures
Editor\'s note: This clause describes related high-level procedures for the
solution.
### 6.25.4 Impacts on existing NFs, NF services and interfaces
Editor\'s note: This clause describes impacts to existing services and
interfaces.
There is no impact on SBI interface (except NRF interface) defined in Rel-15.
The service framework needs to allocate Service Group identities to the
service instances during service registration procedure.
The service group identities need to be considered during the service
discovery procedure.
### 6.25.5 Evaluation
This solution addresses key issues 3 \"Improvements to service framework
related aspects\".
The Service Group aims to provide a tool for operators to enable better system
flexibility. It does not cover high-availability, which is covered by instance
sets.
It is beneficial to the traffic load balancing, scalability, resource
balancing and isolation, flexible grouping of services.
The service group could be applied flexibly in the network based on the
operator policy.
One Service Group could include service instances of different service type.
Service Group identifier, i.e. Service Group name and Service Group ID, are
introduced to identify the service group.
Based on the operator policy, the Service Group could be created and applied
in the network.
The Service Group identifier shall be considered during service discovery and
selection procedure when the Service Group is applied.
# 7 Evaluation
## 7.1 Design Principles and Criteria for Backward Compatibility
For an eSBA solution to be backward compatible mixed 5G Core deployments
across the two releases (Release 15 and Release 16) should be possible.
Exceptions and constraints where they exist for such deployments should be
identified. More specifically;
1\. When Release 16 service framework is deployed, it should work or can co-
exist with Release 15 NFs also present in that deployment; Release 15 NFs that
cannot work or co-exist with Release 16 service framework should be
identified.
2\. If there are differences between Release 15 NF/NF services and Release 16
NF/NF services, Release 15 NFs and Release 16 NF/NF service instances(s)
should work with each other; If the solutions assume, Release 15 NF/NF
services and Release 16 NF/NF services cannot work or co-exist with each other
in such a mixed deployed system, this should be identified and mitigation
should be identified.
3\. It should be possible to aggregate Release 16 NF/NF services to create
functionally equivalent Release 15 NF/NF services; solutions with NF/NF
services that cannot be aggregated in this manner should be identified.
4\. Mixed deployments where certain instances of a NF are Release 15 and
functionally comparable / equivalent Release 16 aggregate service instances
also exist should be possible; Release 15 NFs and equivalent Release 16
aggregate services where it is not possible should be identified.
5\. Roaming should be supported when Serving Network is Release 15 SBA and
Home Network is Release 16 eSBA. Roaming should be supported when Serving
Network is Release 16 eSBA and Home Network is Release 15 SBA. Roaming should
also be supported when either of the two Serving or Home) has a mixed Release
15/Release 16 (e)SBA deployment.
6 How to avoid Release incompatibility scenarios and improve coexistence in a
mixed deployment should be considered e.g. by identifying at service instance
registry its backward compatibility to work with a Release 15 NF, etc.
## 7.2 Evaluation of the solutions for Key Issue 4
In this study, the Solution 9/ Solution 15 all address how to establish the
binding between the NF/NF service consumer and NF/NF service producer in case
resource URI need be created at the producer side.
\- Solution 9 establish a temporarily binding between the consumer and
producer. The binding have an explicit procedure on establishment and release
procedure. To assure the different transaction can be handled in the same
target, after the establishment of binding, the communication can only address
the determined producer instance, i.e. it can not be transferred to other
producer instance.
\- Solution 15 establish a long-living binding between the consumer and
producer. The binding is established after the first time communication
between the consumer and producer. It is released when the UE context is
released. However even the binding information is long living, it does not
means that the only one particular NF/NF service producer instance can be
contacted. It allows that target NF producer instance can be changed without
the NF/NF service consumer awareness.
# 8 Conclusions
## 8.1 Conclusions for KI #1 Optimal Modularization of Services
It is proposed to retain NF -> NF Services mapping as in Rel-15. Modularity of
the NF Service is defined on a case by case basis.
## 8.2 Void
## 8.3 Conclusions for KI #3 Improvements to service framework related aspects
### 8.3.1 Principles related to registration and discovery of services
A.1) Rel-16 will support implicit discovery, i.e. that NF Services are
discovered and selected by the Service Framework Support Function (SFSF)
without an explicit discovery request from the consumer.
a) Discovery and selection of a suitable NF Service instance is based on a
combination of 3GPP specified attributes as metadata, for example:
\- Service Type of the provider.
\- Service Type of the consumer.
\- S-NSSAI.
\- Service Instance Set ID.
\- Service Zone ID.
\- Service Area.
\- DNN.
NOTE 1: The list of 3GPP specified attributes which may be used as metadata
for discovery will be finalized during the normative process.
NOTE 2: The SFSF is not assumed to have specific 3GPP application knowledge in
order to perform discovery and selection. The SFSF matches the attributes that
are requested by the service consumer in the service request to the attributes
that are provided by the service producer at the NF Service instance
registration, and identifies a set of suitable candidate NF Service instances
based on the match and select an instance.
NOTE 3: The SFSF may support different load balancing policies when selecting
the NF Service instance.
A.2) For model D1 (as shown in Annex C) the SFSF may not perform a full
service discovery for each request received . For example, a request from a
service consumer targeting a previously created resource in a service producer
use the resource URI for selection of a member in a specific set of service
producer instances without having to discover the set.
A.3) The SFSF shall support the discovery of NF Service based on the
combination of SET ID and Service Zone ID can be used to indicate that the
target NF Service instance should be selected from the SET in particular
Service Zone.
A.4) Rel-16 will include the support for NF service registration and discovery
based on Rel-15 SBIs, i.e. Rel-16 shall include support for NF/NF services
discovery.
A.5) Rel-16 shall allow the deployments of multiple Service Frameworks and
support the communication between service consumers and service producers
registered in different service frameworks. The NF Service(s) shall be made
discoverable to the NF Service in other SFSF(s) by registering of the NF
Service(s).
### 8.3.2 Principles related to routing of service requests
B.1) In case of indirect communication, the Service Framework Support Function
shall provide routing for NF service requests and responses.
B.2) Whether a NF or NF service use direct communication or indirect
communication via the SFSF is based on configuration of that NF or NF service.
B.3) Direct and indirect communication may be supported in the same network.
B.4) It is expected that the introduction of indirect communication will not
require changes to system procedures in clause 4 of TS 23.502 [3].
### 8.3.3 Principles related to Service Framework functionality and
communication between services
C.1) Service Framework functionalities include service registration/de-
registration, consumer authorization, service discovery, and inter service
communication, which include selection and message passing, according to TS
23.501 [2] clauses 7.1 and 6.3.1. The service framework includes functions
like the NRF and SFSF. The Service framework functions may be deployed in a
distributed manner.
C.2) In Rel-15, the functionality of a service framework is provided in the NF
service consumers and NF service producers and NRF.
C.5) In both direct and indirect communication, functions related to service
registration and discovery shall be supported by the NRF. See clause 8.3.1 for
principles related to service registration and discovery.
### 8.3.4 Principles related to service producers
D.1) It is a deployment option if a producer registers itself.
D.3) Service producer shall provide the service operations through SBI. Thus,
to access service producers the HTTP based API shall be used.
### 8.3.5 Principles related to service consumers
> E.1) Service consumer shall access the services provided by the producer
> through SBI, i.e. service consumers use resource URIs to access producer
> APIs
>
> E.2) A service consumer creating a resource in a service producer, shall use
> the received URI for further communications regarding concerned resource
>
> E.3) It is a deployment option if a consumer does discovery, as in Rel-15
### 8.3.6 Conclusions for the inter service communication in the service
framework
All communication options listed in Annex C shall be supported in Rel-16
specification. The specifications shall specify enablers to allow for these
communication options to co-exist in a deployment.
In order for the communication options to co-exist and be backward compatible
to Release 15 NFs, following are the principles to be followed:
a. If the NF/NF Service set does internal load balancing amongst its NF
Service instances within the Set, then the NF/NF Service set exhibits itself
as an instance towards the Consumer.
b. If the NF/NF service instance indicates a specific target instance (e.g.
URI points to the target instance) for a service request, then the SFSF shall
route the service request to the specific target instance only (unless the
target instance has failed and reselection is necessary).
c. If NF/NF service instance indicates a specific target set (e.g. URI points
to a set of instances) for a service request, SFSF shall select an NF/NF
service instance from the set and route the service request to the selected
target instance but within the consumer selected set only.
d. If NF/NF service instance indicates a specific target NF type (i.e. some
means to indicate that the SFSF shall perform discovery) for a service
request, SFSF shall discover and select a specific NF/NF service instance of
given NF type.
## 8.4 Conclusions for KI #4 Architectural support for highly reliable
deployments
### 8.4.1 Principles for Service Context Transfer
For Key issue#4 solution(s) shall be developed and evaluated based on to the
following principles:
1\. Specify service based procedures for service context transfer from one
NF/NF service instance to another NF/NF service instance from a different
vendor. This is for services in all major NFs (such as SMF, PCF, etc.).
a. As part of the procedure the context information to be transferred between
instances shall be standardized. E.g. such standard context is already
available on Namf and Nsmf.
2\. This procedures shall allow some service procedures to be handled by one
service instance and the following procedures of the same service to be
handled by the service instance from a different vendor.
Editor\'s note: Whether all service procedures can be seamlessly continued
after it is transferred is FFS.
3\. It shall be possible to transfer service context between different
vendor\'s instances without contacting the UE.
NOTE 1: After resumption of a new service transaction, it may be necessary to
contact the UE using existing procedures.
NOTE 2: Some features of an NF service instance may not continue after the
inter-vendor transfer to a new service instance.
4\. A list of triggers for context transfer shall be defined. This includes
triggers from operator\'s OA&M system (e.g. load level).
### 8.4.2 Principles for NF/NF Service/Service instance Sets
Following are the principles:
NOTE 1: Bullet 7 and 8 below reflect the current status of discussion on
relationship between NF Service instance set to NF Set. This should be further
clarified and documented in the normative phase prior to updating related
aspects in the TSs.
1) Introduce the concept of NF/NF Service/Service instance Set for 5GC. The
Set is identified by SET ID.
2) The NF/NF Service instances within a given NF/NF Service/Service instance
Set are expected to have access to the same data sets in a data storage entity
e.g. UDSF. Thus, in principle, any NF/NF Service/Service Instance within a
Service Instance set should be able to process UE transactions as it has
access to UE context. Following are the key principles for NF/NF
Service/Service Instance Sets:
\- A Set of instances of the same service type.
\- All NF/NF Service/Service instances in a Set can access the same data
storage e.g. UDSF.
3) Here is an example of how SET concept can be leveraged:
\- NF/NF Service SET1 of instances optimized for IoT is from vendor 1.
\- NF/NF Service SET2 of instances optimized for IoT is from vendor 2.
\- NF/NF Service SET1 of instances optimized for eMBB is from vendor 1.
\- NF/NF Service SET2 of instances optimized for eMBB is from vendor 2.
4) When a NF/NF Service/Service Instance Set exposes multiple NF/NF
Service/service instances towards a consumer, the consumer is allowed to
reselect a different NF/NF Service/Service Instance (within the same set)
between transactions. Race conditions with multiple requests for the same UE
is up to implementation to resolve, potentially using mechanisms like redirect
between NF/NF Service/Service Instances in the Set.
5) There may be additional restrictions for creation of assigning NFs/NF
Services/Services to a set:
\- Sets of NFs/NF services/Services (i.e. SMF) managing UPFs need to be
connected to the same UPF.
NOTE 2: The UPFs are not grouped as SETs.
\- The enhancements related to NF/NF Service/Service Set shall also be
supported for the protocol(s) supported over N4.
NOTE 3: The Set within an operator network can be identified using SET ID and
the actual mapping of instances to a given SET is up to deployment.
NOTE 4: When a single Set expands across multiple locations within an operator
network, the Service Zone ID can be used to refer to NF/NF Service/service
instances within a Set in particular location. Service Zone ID corresponds to
the \"locality\" information (currently defined in Rel-15).
6) The combination of SET ID and Service Zone ID can be used to indicate that
the target NF/NF Service/service instance should be selected from the SET in
particular Service Zone.
7) Introduce the concept of NF Set for 5GC (Solution #10). This can apply for
existing NFs and newly introduced NFs. The NF Set is identified by NF SET ID.
8) If NF Service instances within the NF are made discoverable in the NRF (as
specified in Release 15 already), then it should be an option to exhibit and
register NF Service instances of the NF Service instance Set in the NRF along
with NF Service Instance Set ID (i.e. allowing load balancing of NF Service
instance by the consumer or SFSF). Alternatively, the NF Service Instance Set
can be made discoverable as a single NF service instance while registering in
the NRF (i.e. in this case, load balancing of NF Service Instances of the NF
Service Instance Set is internal to the NF).
NF Service Instance Set is the group of NF Service Instances in the same NF
instance that are of the same service type and are interchangeable. The NF
Service Instance Set is identified by NF Service Instance SET ID.
### 8.4.3 Conclusions on binding between consumer and producer
If bindings between instances is needed, the following principles applies:
\- When the service consumer instance communicates with the service producer
instance, the service producer instance may return a binding information to
the service consumer. The service consumer store the received binding
information. Based on the received binding information the binding is
established with the service producer set, or producer set and service zone,
or the service producer instance. - If the service consumer instance can also
be as a service producer for later communication from the contacted service
producer, it may include the binding information in the service request sent
to the service producer.
\- When the service consumer send the service request including the binding
information, the SFSF selects the producer instance as following:
\- In case of the binding is established with the producer instance, the
indicated producer instance is used. If the indicated producer instance become
unavailable, a different producer instance within the same Set is selected.
\- In case of the binding is established with the producer set, one of the
producer instance from the indicated producer set is selected.
\- In case of the binding is established with the producer set for a given
service zone, one of the producer instance from the indicated producer set
corresponding to the service zone is selected.
\- The producer instance may update the binding information to change the
binding to a producer set or different producer instance within the same set
or different producer instance within the same set and service zone in any
responses sent to consumer.
NOTE: whether the update of binding information from the producer instance to
producer set need explicit signalling is left to normative work.
How bindings are managed across service sets or instances not belonging to
service sets not addressed by this principles.
## 8.5 Conclusions for KI #5 SBA Backward and Forward Compatibility
Support for backward and forward compatibility (especially backward
compatibility) is considered to be inherent design principle for 5G System
evolution. No additional normative requirement expected to be specified
specifically for this key issue but the principles concluded for every key
issue is required to support backward and forward compatibility.
## 8.6 Conclusions for KI #6 System flexibility and service provisioning
Following are the conclusions for Key issue 6:
\- NF/NF Service instance registers the supported features as part of the
NF/NF service profile into the NRF once it is instantiated.
\- During the NF/NF services discovery, the consumer NF/NF services may
provide the intended feature(s) supported by the producer NF/NF services, to
the NRF.
\- One NF/NF service can support multiple features.
\- No specific normative work has been identified in stage 2.
## 8.7 Conclusions for KI #7 Roaming
No additional normative requirement expected to be specified specifically for
this key issue.
###### ### Annex A: 3GPP SBA and ETSI NFV concepts
# A.1 Introduction
In this annex we aim to align the understanding and terminology around
architecture concepts in 3GPP and other fora\'s relevant for the eSBA study.
It is important to understand and separate the different perspectives of the
architectural concepts. This annex clarifies the differences and relationships
between the following perspectives:
\- _Logical functional architecture perspective_ \- defined in 3GPP.
\- _Managed Element perspective_ \- defined by ETSI, Vendor, etc.
\- _Implementation architecture_ \- defined by Vendor (considering
requirements from Network Operators).
NOTE: SA WG5 is responsible for the management of 3GPP functions including NF
LCM and the interactions with ETSI NFV MANO. This is, however, not further
described in this annex.
# A.2 Architecture perspectives
## A.2.1 3GPP Rel-15 architecture
3GPP defines a logical functional architecture and, as a part of 3GPP Rel-15,
has defined a logical functional Service Based Architecture i.e. 3GPP SBA.
The 3GPP Rel-15 SBA architecture defines a set of Logical Network Functions
(NFs). Each 3GPP NF may produce and/or consume one or more service
capabilities (3GPP NF Services) through a 3GPP defined Service Based Interface
(SBI).
Figure A.2.1-1: Simplified 3GPP Service based architecture according to 3GPP
Rel-15
## A.2.2 ETSI NFV including MANO
The ETSI NFV architecture specifies the management view of the resources
required by the applications. This means that ETSI specifies how resources
required by any software are managed and orchestrated via a generic management
and orchestration (MANO) architecture framework. ETSI NFV specifies how the
resources for a VNF instance can be life cycle managed, upgraded and inter-
connected.
**The VNF (Virtualised Network Function).**
The term VNF is defined by ETSI NFV. **A VNF is a managed element**. i.e. it
offers an aligned point of integration towards an Element management function
and OSS/BSS, see Figure A.2.2-1. A VNF also need have clearly defined
interfaces, whether standardized or proprietary, allowing it to communicate
with other VNFs.
Figure A.2.2-1: ETSI NFV architecture (ETSI GS NFV 002 v1.2.1)
**The VNFC (Virtual Network Function Component).**
The VNFC is defined in the ETSI GS NFV- 003 specification and some
characteristics of a VNFC are:
\- A VNF may be composed of one or multiple components, called VNFC.
\- A VNFC is a VNF Providers specific component of a VNF, and VNFC Instances
(VNFCIs) are the executing constituents which make up a VNF Instance.
\- A VNF realized by a set of one or more VNFCs appear to the outside as a
single, integrated system.
\- Some VNF LCM aspects can be solved with VNFC level operations (e.g.
horizontal scalability, upgrade, self-healing).
So, VNFC instance runs in a VM or a container and implements either the full
scope of the VNF or a subset of a VNF. A VNFC instance is considered one Unit
of Deployment.
Figure A.2.2-2: VNFC relation to VNF
# A.3 The relationships
## A.3.1 3GPP Network Function vs ETSI VNF
The ETSI NFV constructs of VNF and VNFC provide the flexibility of various
implementation and deployment options for a 3GPP NF and its 3GPP NF Services.
A VNF can, but **does not** have to map 1:1 to a 3GPP NF and ETSI NFV allows
also for other options, such as one VNF may be used to deploy and manage
resources for multiple 3GPP NFs. In 3GPP Rel-15 5GCN the 3GPP NF is the
smallest logical entity exposing multivendor interfaces.
How 3GPP NFs are grouped into managed elements (VNFs) **is a task for the
vendor** (based on requirements to be fulfilled e.g. from operators) **and it
is outside of 3GPP SA WG2 sc** ope. The grouping in Figures A.3.1-1, A.3.1-2,
and A.3.1-3 are examples, not proposals, for how NFs could be grouped.
NOTE: Depending on the eSBA work for 5GCN in Rel-16 there may be additional
possibilities to group one or more services in a VNF.
Figure A.3.1-1: 3GPP Rel 15 NF granularity of managed element deployed as a
VNF
Figure A.3.1-2: Grouping of 3GPP NFs into managed elements (VNFs)
Figure A.3.1-3: Single managed element for entire 5GCN
## A.3.2 Microservice implementations and 3GPP Rel-15 SBA and ETSI NFV
The implementation architecture is orthogonal to 3GPP SBA and is vendor
specific.
The functionality and service capabilities of a 3GPP NF/NF Service will
typically be realized by using several microservices.
As per ETSI NFV Release 3, a microservice can map 1:1 to VNFC but the
granularity of the microservice is determined only by the implementations and
deployment scenario. For example, while in some cases a full 3GPP NF Service
can be implemented as a single monolithic component, in other cases
implementations may use several microservices as part of the realization of
the 3GPP NF Service.
Since it is application-agnostic, ETSI NFV does not have the awareness of what
the 3GPP NF or the 3GPP NF Service is, nor which grouping of VNFCs or VNFs
realize one 3GPP NF, or one 3GPP NF Service (this is within 3GPP SA WG5
scope).
# A.4 Lifecycle management
The VNF resource LCM (Lifecycle Management) is defined by ETSI NFV, is outside
3GPP SA WG2 scope:
\- VNFs are always separately lifecycle managed i.e. they can be scaled and
upgraded independently.
\- VNFCs can be upgraded independently and scaled independently.
NOTE: This assumes ETSI NFV release 3, including ongoing/planned work. In
addition, some implementations may require multiple co-located containers that
are tightly coupled and share resources. Such implementations need to scale
the containers and resources together as a single entity.
In ETSI NFV there are additional mechanisms available that allows the VNF
provider to place constraints at the VNF to couple the LCM of several VNFs or
VNFCs.
###### ### Annex B: Example of System Features
Table B-1: Example of System Features
+---------------------------+---------------------+---------------------+ | Release 15 system feature | Required NF | NF Services* | +===========================+=====================+=====================+ | SMS over NAS | AMF, SMSF, UDM | Nsmsf_SMService | | | | | | | | Nudm_UECM | | | | | | | | Namf_Communication | +---------------------------+---------------------+---------------------+ | LCS | LMF, AMF, GMLC, UDM | Nlmf_Location | | | | | | | | Namf_Location | | | | | | | | Nudm_UECM | +---------------------------+---------------------+---------------------+
NOTE 1: The NF Services listed in this table are not yet complete nor
exhaustive.
###### ### Annex C: Communication options for consumer-producer communication
in Rel-16
## C.1 General
This annex lists the SBA consumer to producer communication options for
Rel-16. The different communication options are described on high level.
Details on how they work can be found in solution clauses regarding Key Issue
3, and in TS 23.501 [2] and TS 23.502 [3].
The Annex uses SFSF (Service Framework Support Function) to denote the entity
that can perform service discovery and selection on behalf of the consumer
depending on communication option. The may as well do overload control,
message routing, etc.
## C.2 Communication to resources created via SBI
There are 4 communication cases identified in TS 23.501 [2] and TS 23.502 [3]
and the present document, for when consumers request resources to be created
in a producer and when the consumer after resources are created have
subsequent signalling towards the created resource, see figure C.2-1 below.
NOTE: Protocol details in the following Figures and text are included for
illustrative purposes only.
**Figure C.2-1:** Communication options when resources are created
The SFSF in option C1 and D1 can consume NRF SBI\'s. No specific changes or
additions are expected for to support SFSF i.e. any additional information
required by the SFSF (e.g. routing policies) would be provided via
implementation specific means.
**Option A1:** This case is when no NRF or SFSF is used. Consumers are
configured with producers\' \"NF profiles\".
**Option B1:** This is how inter-service communication works in Rel-15.
Consumer does discovery by querying NRF. Based on query result consumer does
selection. Consumer sends request to selected producer. Producer responds with
a resource URI identifying created resource. Consumer uses received URI for
subsequent requests regarding concerned resource.
Consumers may cache the query result from NRF, thus consumer does not have to
contact NRF for every new request creating a resource.
**Option C1:** Consumer does discovery by querying NRF. Based on query result
consumer does selection. Consumer send the request to the SFSF (how consumer
routes messages to the SFSF can be found in some of the solutions in this TR)
containing a URI representing the resource that the consumer selected (e.g. an
NF instance or set of service instances). The SFSF will use the received URI
to select a producer instance that may serve the request and routes the
message to the selected producer instance. The produce instance responds with
a URI representing the created resource. Consumer uses received URI for
subsequent requests regarding concerned resource.
Consumers may cache the query result from NRF, thus consumer does not have to
contact NRF for every new request creating a resource.
**Option D1:** Consumer does not do any discovery or selection. It may be able
to use the URI of concerned resource, but it may also need to add information
in the request HTTP message header by some means if the resource URI does not
contain enough information for discovery and selection. The SFSF uses URI and
if present, the received discovery and selection parameters received in the
HTTP header to route the request to a selected producer instance. Producer
responds with a resource URI identifying created resource. Consumer uses
received URI for subsequent requests regarding concerned resource. The
addressing part (FQDN) of the received URI should ideally lead to the SFSF.
## C.3 Communication to resource not created via SBI
There are 4 communication options identified in TS 23.501 [2] and the present
document when resources are not created due to SBA signalling.
**Figure C.3-1:** Communication options when resources are not created
The SFSF in option C2 and D2 can consume NRF SBI\'s. No specific changes or
additions are expected for to support SFSF i.e. any additional information
required by the SFSF (e.g. routing policies) would be provided via
implementation specific means.
**Option A2:** This case is when no NRF or SFSF is used. Consumers are
configured with producer\'s \"NF profiles\".
**Option B2:** This is how inter-service communication works in Rel-15.
Consumer does discovery by querying NRF. Based on query result consumer does
selection. Consumer sends request to selected producer.
Consumers may cache the query result from NRF, thus consumer does not have to
contact NRF for every new request.
**Option C2:** Consumer does discovery by querying NRF. Based on query result
consumer does selection. Consumer send the request to the SFSF (this can be
done via a proxy configuration in the consumer or that pseudo addresses was
sent from the NRF, for more info see the different solutions in the present
document) containing a URI representing the resource that the consumer
selected (e.g. an NF instance or set of service instances). The SFSF will use
the received URI to select a producer instance that may serve the request and
routes the message to the selected producer instance.\ Consumers may cache the
query result from NRF, thus consumer does not have to contact NRF for every
new request creating a resource.
**Option D2:** Consumer does not do any discovery or selection. It may be able
to use the URI of concerned resource, but it may also need to add information
in the request HTTP message header by some means if the resource URI does not
contain enough information for discovery and selection. The SFSF uses URI
and/or the HTTP header information to do discovery and selection. SFSF routes
the request to a selected producer instance.
## C.4 Security considerations
SA WG3 has solved the security for direct communication. For indirect
communication with SFSF the security aspects need to be worked out by SA WG3.
## C.5 Roaming considerations
The D options requires the SFSF to construct a discovery message in case of
roaming, so a discovery request can be sent to the home NRF.
#
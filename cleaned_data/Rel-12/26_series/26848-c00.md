# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
The present document covers the MBMS enhancement aspects, including MBMS Over
The Air (OTA) efficiency, MBMS for datacasting and real-time content, and
generic signalling of DASH transport over broadcast, multicast and unicast.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or nonâ€‘specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 26.346: \"Multimedia Broadcast/Multicast Service (MBMS); Protocols
and codecs\".
[3] 3GPP TS 26.247: \"Transparent end-to-end Packet-switched Streaming Service
(PSS); Progressive Download and Dynamic Adaptive Streaming over HTTP (3GP-
DASH)\".
[4] IETF RFC 3450 (December 2002): \"Asynchronous Layered Coding (ALC)
Protocol Instantiation\", M. Luby.et al.
[5] IETF RFC 5775 (April 2010):\"Asynchronous Layered Coding (ALC) Protocol
Instantiation\", M Luby, M.Watson, L.Vicisano.
[6] 3GPP TS 26.233: \"Transparent end-to-end Packet-switched Streaming Service
(PSS); General description\".
[7] 3GPP TS 23.003: \"Numbering, addressing and identification\".
[8] 3GPP TS 36.443: \" Evolved Universal Terrestrial Radio Access Network
(E-UTRAN); M2 Application Protocol (M2AP)\".
[9] ISO/IEC 23009-1: \"Information technology -- Dynamic adaptive streaming
over HTTP (DASH) -- Part 1: Media presentation description and segment
formats\".
[10] IETF RFC 3926: \"FLUTE - File Delivery over Unidirectional Transport\".
[11] IETF RFC 6726: \"FLUTE - File Delivery over Unidirectional Transport\".
[12] IETF RFC 5052: \"Forward Error Correction (FEC) Building Block\".
[13] IETF RFC 5651: \"Layered Coding Transport (LCT) Building Block\".
[14] IETF RFC 3451: \"Layered Coding Transport (LCT) Building Block\".
[15] IETF RFC 2068: \"Hypertext Transfer Protocol -- HTTP/1.1\".
[16] IETF RFC 2616: \" Hypertext Transfer Protocol -- HTTP/1.1\".
# 3 Abbreviations
For the purposes of the present document, the abbreviations given in TR 21.905
[1] and the following apply. An abbreviation defined in the present document
takes precedence over the definition of the same abbreviation, if any, in TR
21.905 [1].
BM-SC Broadcast-Multicast - Service Centre
DASH Dynamic Adaptive Streaming over HTTP
eMBMS Evolved MBMS
FDT File Description Table
FLUTE File deLivery over Unidirectional Transport
MPD Media Presentation Description
# 4 Enhanced MBMS Operation
## 4.1 Introduction
## 4.2 Enhancement, Recommended Requirements and Working assumptions
### 4.2.1 Switch from HTTP-based unicast delivery method to MBMS download
delivery method
#### 4.2.1.1 Description
An MBMS client acquires a USD including a mediaPresentationDescription element
which references a Media Presentation Description containing descriptive
information on a DASH Media Presentation.
The DASH-based user service is available over both HTTP-based unicast delivery
method and MBMS download delivery method.
Due to the fact that the UE is initially located outside of MBMS broadcast
coverage, it starts to consume the DASH service delivered through HTTP-based
unicast delivery method.
Later on, as the UE enters MBMS broadcast coverage, it switches to MBMS
download delivery method for receiving the DASH service, for example, due to
better quality of content delivered over MBMS download delivery method.
Subsequently, the UE moves away from MBMS broadcast coverage, and switches
back to HTTP-based unicast delivery method of the DASH service.
The service switch in each of the above cases is performed transparently to
the user and does not adversely impact the user experience.
#### 4.2.1.2 Recommended Requirements & Evaluation Criteria
The following recommended requirements are collected:
\- The MPD and other DASH formats delivered in the MBMS User Service conform
to TS 26.247 [3].
\- The fallback to unicast can be done without bitrate guarantees matching
those on the unicast distribution, i.e. the content delivered over unicast may
provide alternative Representations of the same content that is delivered over
broadcast.
\- The information on what DASH resources (MPD, Segments, xlink resources,
etc.) are available in broadcast and what are available in unicast is included
in the User Service Description.
\- Seamless switch of MBMS User Service when switching between unicast and
broadcast is enabled.
\- The signalling is generic enough to at least support the two example DASH
over MBMS architectures in clause 4.2.1.5.1.
\- Takes into account the recommendation from MPEG: \"... we concluded that
for delivery protocols interfacing with HTTP such as FLUTE, no change or
extension of DASH format is needed and the system adopting the DASH standard
can support such deployments using the existing standard.\"
#### 4.2.1.3 Gap Analysis & Evaluation
#### 4.2.1.4 Assumptions
A UE receives enough information which allows it to perform a switch from
HTTP-based unicast delivery method to MBMS download deliver method of the DASH
service, and vice versa.
A UE is able to identify the delivery method Segments and other MPD resources
are provided.
A UE is able to ensure continuous playout when the switch from HTTP-based
delivery method to MBMS download delivery method is performed and vice versa.
An MBMS client is able to forward a DASH Media Presentation that conforms to
TS 26.247 [3] without parsing the MPD.
#### 4.2.1.5 Solution
##### 4.2.1.5.1 Example DASH over MBMS Architectures
As an illustrative example, figure 4.2.1-1 depicts a potential end-to-end
network architecture for DASH content delivery over MBMS bearer with unicast
fallback. FLUTE-based download delivery represents the TS 26.346 [2] -defined
interface between the BM-SC and MBMS client. The assumed interface between the
DASH client and the MBMS client (here assumed to be a composite entity
including MBMS receiver, device-based HTTP server, policy, redirection and
proxy functions) is HTTP/1.1.
Figure 4.2.1-1: Potential DASH over MBMS Architecture #1
Figure 4.2.1-2 depicts another potential DASH over MBMS architecture,
indicating the use of a local application web cache by the DASH client to
serve its requests. The application web cache is shared with the MBMS client
that implements a FLUTE receiver. Upon reception and reconstruction of DASH
media segments over FLUTE, the segments are inserted into the application web
cache. An interface between the DASH client and the FLUTE receiver/MBMS client
is shown in this diagram to exchange information on the available and possibly
recommended Representation(s) based on various conditions (e.g. location
inside or outside MBMS coverage, policy) along with other metadata (e.g.
available bandwidth, reason code).
{width="4.020138888888889in" height="2.4618055555555554in"}
Fig. 4.2.1-2: Potential DASH over MBMS Architecture #2
##### 4.2.1.5.2 Solution of DASH over MBMS
A basic concept of the proposed solution is that the MBMS client does not have
to process the MPD in order to determine the delivery method of DASH
resources. It merely has to perform data matching of newly-added metadata in
the USD with the URL of Segment requests generated by the DASH client to
determine whether the requested Segment is available over broadcast, unicast,
or both transport modes. This is possible because a fixed portion of the
request URL that uniquely identifies the Representation to which the requested
Segment pertains, referred to in our solution as the _basePattern_ , will also
be conveyed in the USD. In conjunction with any other relevant rules and
conditions, such as coverage condition (whether the UE is located within
broadcast coverage), network operator and/or service provider policy, etc.,
the MBMS client can employ various implementation mechanisms to mediate
Segment requests to resources -- i.e. via access to locally stored content in
the UE, or at an external HTTP server. The XML content model of the proposed
solution for extending the USD is shown in figure 4.2.1-3. These pertain to
modifications to the _userServiceDescription_ and _deliveryMethod_ elements,
for the purposes of defining switchability of contents of the DASH-over-MBMS
service, and transport/access specific information, respectively.
{width="3.7194444444444446in" height="8.822916666666666in"}
Figure 4.2.1-3: USD Extension for DASH-over-MBMS User Service
###### 4.2.1.5.2.1 Extension of deliveryMethod element
The _deliveryMethod_ element may include one or more instances of the
_r12:broadcastAppService_. Each entry of _r12:broadcastAppService_ denotes a
single broadcast Representation, in either multiplexed or non-multiplexed form
for media content components, of the DASH-over-MBMS user service, across all
Periods of the affiliated Media Presentation. Each entry of _basePattern_
under the _r12:broadcastAppService_ element is for use by the MBMS client to
match against a portion of the Segment URL used by the DASH client to request
Segments of a parent Representation under its containing Period. The
_basePattern_ may comprise the concatenation of the URI scheme, the
\"authority\" part of the URL, and the portion of the \"path\" part of the URL
that extends to and is inclusive of the Representation-ID (value of
**Representation** \@id in the MPD). URI scheme, \"authority\" and \"path\"
are in accordance to the terminology of RFC 3986 [2]. A match implies that the
corresponding requested Segment is carried over an MBMS bearer. For example,
should the URL associated with a Segment request contain the BaseURL
\"http://example.com/per-3/rep-512\", and the same BaseURL value appears in an
instance of _r12:broadcastAppService.basePattern_ , it means that the
Representation with **Representation** \@id = \'512\' is available over
broadcast. The _basePattern_ value may be, but is not required to be,
identical to that of the **Representation**.BaseURL if present in the MPD.
Each _r12:broadcastAppService_ element may contain one or more _serviceArea_
child elements which specify the service area(s) in which that broadcast
Representation is delivered/accessible. The semantics of _serviceArea_ ,
corresponds to the _MBMS Service Area Identity_ as defined in TS 23.003 [7],
TS 36.443 [8]. A given broadcast Representation may be available in a set of
service area(s) in common with, or different from, the service area(s) of any
other broadcast Representation. Absence of the _serviceArea_ element implies
that the availability of the broadcast Representation is not restricted by
service area.
The _deliveryMethod_ element may also include one or more instances of the
_r12:unicastAppService_. Each entry of _r12:unicastAppService_ denotes a
single unicast Representation, in either multiplexed or non-multiplexed form
for media content components, of the DASH-over-MBMS user service, across all
Periods of the affiliated Media Presentation. Similar to
_r12:broadcastAppService_ , each entry of _basePattern_ under the
_r12:unicastAppService_ element is for use by the MBMS client to match against
a portion of the Segment URL used by the DASH client to request Segments of a
parent Representation under its containing Period. A match implies that the
associated Representation is available over unicast delivery. For example,
should the URL associated with a Segment request contain the BaseURL
\"http://example.com/per-3/rep-256\", and the same BaseURL value appears in an
instance of _r12: unicastAppService.basePattern_ , it means that the
Representation with **Representation** \@id = \'256\' is available over
unicast. The _basePattern_ value may be, but is not required to be, identical
to that of the **Representation**.BaseURL if present in the MPD.
A given Representation may be available over one or both transport modes. The
broadcast version might be deemed as preferable or even required for reception
from the service provider policy perspective, for example when the UE is
located within MBMS coverage.
The presence of the _r12:broadcastAppService_ and/or _r12:unicastAppService_
element under _deliveryMethod_ signifies that the parent MBMS User Service is
an application service which contains content components delivered via
broadcast and/or unicast modes. One or both of these child elements of
_deliveryMethod_ has to be present when its parent _userServiceDescription_
element contains the _r12:appService_ (see clause 4.2.1.5.2.2).
###### 4.2.1.5.2.2 Extension of userServiceDescription element
Presence of the _r12:appService_ child element of _userServiceDescription_
indicates that the associated MBMS User Service is an application service
explicitly linked to the _r12:broadcastAppService_ and _r12:unicastAppService_
elements under _deliveryMethod_. Furthermore, the _r12:appService_ element may
contain either or both the child elements _identicalContent_ and
_alternativeContent_.
Each _identicalContent_ element contains two or more interchangeable URLs for
an identical Representation, as indicated by the _basePattern_ values. The
implication is that that Representation is available over both broadcast and
unicast transport and could be interchanged in accordance to coverage
condition, policy requirements, etc.
Each _alternativeContent_ element contains two or more interchangeable URLs,
as indicated by the _basePattern_ values, corresponding to different
Representations available over broadcast and unicast transport but which could
be substituted for one another in accordance to coverage condition, policy
requirements, etc. In practical deployment of a DASH-over-MBMS service, such
switching may require the following conditions to be met:
a) the employed media codecs and configuration information must be identical
between the requested and substituted Representations,
b) the request does not contain a byte range, and
c) segments of the alternative Representations must be time-aligned.
_identicalContent_ and/or _alternativeContent_ may be present under the
_r12:appService_ element because Representations listed in the MPD may be
encoded differently, or associated with different configurations for a given
encoding scheme, as defined by their Initialization Segments (represented by
Initialization Segment Description fragments). Therefore, the mere presence of
_basePattern_ entries under _r12:broadcastAppService_ and
_r12:unicastAppService_ does not imply that the associated Representations are
automatically eligible for interchange between broadcast and unicast
reception.
The attribute _appServiceDescriptionURI_ of _r12:appService_ references an
application service description document, which in the present document is a
Media Presentation Description fragment containing the MPD. The attribute
_mimeType_ of _r12:appService_ specifies the MIME type of the MPD, which may
include the optional \'profiles\' parameter. The latter parameter declares the
interoperability and signals the use of features associated with the DASH
Media Presentation described by this MPD. An example value of _mimeType_ is
\"application/dash+xml;profiles=\"urn:3GPP:PSS:profile:DASH10\", which denotes
an MPD conforming with the 3GP-DASH Release-10 profile.
### 4.2.2 Potential FLUTE Enhancements
#### 4.2.2.1 Deployment Architecture considerations
##### 4.2.2.1.1 Introduction
This clause presents and discusses different deployment architectures for Live
Video, which is supported by the 3GPP architecture. 3GPP typically collapses
the infrastructure and UE internal functions into one box, each. The
specifications focus on the interactions between UE and infrastructure.
However, for the MBMS performance improvement discussions, a more detailed
understanding of certain implementation is beneficial.
The figure below depicts the 3GPP architecture for PSS (incl. DASH) and MBMS
as presented in TS 26.233 [6] and TS 26.346 [2]. Note that the PSS Server
according to TS 26.233 [6] includes the HTTP Server functions for DASH. The
general description of PSS (incl. DASH) in TS 26.233 [6] does not impose
requirements or assumptions on the separation of content preparation functions
between Content Source and 3GPP System (PSS Server, incl. the Content
Preparation for DASH). That way of specifying allows for multiple
infrastructure realizations, depending on the separation and distribution of
functions between 3GPP system and content provider. Also in MBMS TS 26.346 [2]
there are no requirements or assumptions on the separation of content
preparation functions between Content Provider and BM-SC.
{width="6.498611111111111in" height="1.582638888888889in"}
Figure 4.2.2-1: 3GPP Architecture for PSS (incl. DASH) and MBMS
##### 4.2.2.1.2 Scenario 1: Managed Live DASH
The figure below depicts a conceptual deployment architecture for managed Live
DASH over eMBMS (Media Path only). The term \"managed\" refers here to the
fact, that the operator has a relation with the content provider, so that the
DASH Segmenter can be logically in the same network to or even collocated with
the BM-SC. The encoder and Segmenter settings can be tuned for the eMBMS
transmission, e.g. short segments are selected when low e2e delay is required
or longer segments to increase efficiency. In case of OTT content it is
expected that the BM-SC pulls the content from CDN, which is certainly
increasing the e2e delay, see Scenario 2 for details.
{width="6.493055555555555in" height="1.9756944444444444in"}
Figure 4.2.2-2: Scenario 1: Example deployment architecture for managed Live
DASH\ (Media Path only)
A number of functions are collapsed into the **PSS Server** , namely CDN
components like Edge and Origin servers, as well as the head-end equipment
like DASH Segmenter and Encoders. The DASH Segmenter may be operated by the
different content provider.
A number of functions are collapsed into the **BM-SC** , namely the BM-SC
Media Distribution Function (MDF), the DASH Segmenter and the Live Encoder.
From performance perspective, an implementation, which integrates the BM-SC,
the PSS server and the Segmenter on the same node could be beneficial.
The Live Segmenter and Live Encoder functions are very generic functions and
can run in different (Non-MBMS) deployment scenarios. The separation of the
Segmenter from the BM-SC follows the same argumentation as the separation of
the generic DASH client from the MBMS Receiver on the UE side. It is of course
one implementation option to collocate the Segmenter with the BM-SC and the
MBMS client with the DASH client in order to provide a very good and short e2e
delay. However, these are implementation considerations and the new FLUTE
enhancement should bring benefits for all four implementation options.
{width="4.338888888888889in" height="1.1958333333333333in"}
Figure 4.2.2-3: Handling Segments and MPD / IS
The DASH Segmenter publishes at least three types of different files for the
DASH ISO-BMFF Live Profile, namely the Media Presentation Description (MPD),
one or more Initialization Segments (IS) and the media segments. The media
segments are handled by the MBMS Delivery Function (MDF), while MPD and IS are
handled by the User Service Discovery / Announcement Function (USD/A), shown
as SA in figure 4.2.2-3. The USD/A function announces MBMS services via
unicast (HTTP), SMS or MBMS together with all other fragments for the service.
The MBMS TS 26.346 [2] and the DASH TS 26.247 [3] specifications only define
the protocol and procedures between the UE and the System (either as a DASH
Server, PSS Server or BM-SC, depending on the specification). Conceptually,
there is no difference between the DASH Player interacting via HTTP with the
DASH Server or the UE internal Web Server.
##### 4.2.2.1.3 Scenario 2: Unmanaged Live DASH
The figure 4.2.2-4 depicts a conceptual deployment architecture for unmanaged
Live DASH over eMBMS (Media Path only). The term \"unmanaged\" refers here to
the fact, that the operator has no strong relation with the content provider.
The BM-SC pulls here segments from CDN like any other DASH client.
Some relations with the content provider are certainly needed. For instance,
the link between BM-SC and the Edge Server may be QoS provisioned so that the
required media bitrate for the Live Service can be ensured. Otherwise, the
system risks buffer underruns by the UE. The BM-SC cannot simply forward a
different representation (bitrate) in case of link bitrate variations. Pre-
Release 12 clients only expect a single video representation available in the
MPD. Changing a representation may require the change of the initialization
segment, e.g. because the representations use different video resolutions. The
new representation may have a different presentation timeline. The Service
Announcement for the Live DASH service needs to be updated (in-band and out-
of-band).
Of course, the operator may impose requirements on the content authoring,
which is actually the same as Scenario 1 \"Managed Live DASH\".
{width="6.49375in" height="1.9097222222222223in"}
Figure 4.2.2-4: Scenario 2: Example deployment architecture for Unmanaged Live
DASH
The DASH over unicast functions are typically collapsed into the PSS Server.
The entire transmission chain northbound of the BM-SC, including the Edge and
Origin Servers are collapsed into the BM-SC when sending DASH segments over
broadcast. From UE and transmission format perspective, the back-end
architecture is not visible.
However, certain FLUTE enhancement improvement proposals impose requirements
on this architecture, which are not clearly described and highlighted yet. It
needs to be discussed, whether the realization of these requirements are
feasible for the above presented deployment scenarios or not.
#### 4.2.2.2 High-Level Design Principles
##### 4.2.2.2.1 Error Resilience
HTTP is typically delivered over TCP and objects are expected to be delivered
error-free. FLUTE+ should include methods for error resilience, in particular
FEC. Also HTTP-based repair of objects as defined in TS26.346[2] should be
naturally supported. However, in contrast to FLUTE the error resilience is
preferably not integral to the base protocol, but an add-on.
FLUTE provides error resilience tools for file protection that are FEC and
file repair. The FEC performance improves with larger source block sizes. File
repair procedures are triggered after exhausting other recovery options and
takes place over unicast. The advanced FLUTE protocol should enable low delay
error resilience tools.
##### 4.2.2.2.2 Self-containment
The client should be able to locate and reconstruct the transmitted resource
without having to fetch another object. In FLUTE, the receiver needs to first
fetch an FDT instance, which is carried with a TOI 0, and then parse the XML
file and locate the TOI for the object of interest. The TOI assignment to a
specific is arbitrary because the number of files delivered over the FLUTE
session and their order may not be known a-priori. In the Advanced FLUTE, the
file should be self-contained, i.e. it should contain its own metadata to
enable the client to identify it. Out-of-band signaling is also possible.
The minimization of objects/information that is needed to be received in real-
time is required to be available without delay. For example, in a dynamic
object generation environment such as live DASH, the avoidance of delivering
FDTs along with each object avoids dependency problems.
##### 4.2.2.2.3 Optimization for Real-time Services
Real-time services consisting of a timed sequence of multiple objects (despite
delivered over HTTP) generate a significant portion of Internet traffic.
Examples are DASH Media Presentations or other HTTP streaming technologies.
Optimization for such flow-based services is essential for FLUTE+. It is
relevant that for real-time services objects need to be recovered and be
available by a certain time. This aspects needs to be taken into account.
FLUTE comes with a FEC building block that divides the file into several
source blocks of (almost) equal size and each source block is then divided
into equal size packets, so called source symbols. When DASH media segments
are being delivered, the source blocks and packets will have arbitrary
boundaries inside the segment. The advanced FLUTE protocol should allow
arbitrary fragmentation, for example to enable for packetization that takes
into account structures of the delivered data.
As discussed in the previous recommended requirement, a whole file is
partitioned by the sender and recovered at the receiver. Without having the
full file at the sender, transmission cannot be started. Also the whole file
needs to be recovered before it can be forwarded to the application layer. The
advanced FLUTE protocol should enable progressive delivery without having the
full resource available at the sender. This may also allow a client to start
consuming the file before it is fully available
##### 4.2.2.2.4 Static and Dynamic Information
Real-time services consisting of a timed sequence of multiple objects (despite
delivered over HTTP) generate a significant portion of Internet traffic.
Examples are DASH Media Presentations or other HTTP streaming technologies.
Optimization for such flow-based services is essential for an advanced FLUTE+.
An important aspect in such flows is that certain information is static
(assigned to all objects to the flow, e.g. the type, encoding, etc.) whereas
other information is dynamic and assigned to each object (object size, URL,
etc.). It should be possible to deliver static information out-of-band in a
way similar to the SDP.
##### 4.2.2.2.5 Modular, Generic, Extensible and Efficient Design
Despite priority for some use cases such as DASH over MBMS may be given, it is
relevant to define FLUTE+ in a modular and generic manner such that any type
of content that can be delivered over HTTP can also be delivered over FLUTE+.
In addition, efficiency and extensibility are relevant. However, efficiency
should always be traded off with complexity, modularity, and extensibility.
#### 4.2.2.3 Recommended Requirements & Evaluation Criteria
The following list provides potential enhancements of FLUTE based on
deployment experience:
\- Enhance FLUTE delivery of a sequence of related objects: Generally, if a
sequence of objects are delivered, e.g. as a DASH Representation then this
object flow contains static and dynamic information. The static information
may be delivered ahead of time and the dynamic information may be delivered
along with the object directly.
\- Minimize number of objects needed to receive to recover each portion of
content: In particular for receiving an object, not only the object but also
the FDT needs to be received. In a dynamic object generation environment such
as live DASH, the avoidance of delivering FDTs along with each object avoids
dependency problems.
\- Provide advance information to FLUTE receivers before objects
sent/received: In certain cases some properties of the objects are known prior
to the generation of the object. Providing this information to the receivers
ahead of time allows more intelligent FLUTE receiver decisions and planning is
possible. Specifically sending of known and static metadata of file objects
once instead of repeatedly with each file increases the efficiency of file
delivery by reducing the amount of overhead transmitted. Furthermore,
predictability of time-varying metadata associated with file objects by the
download delivery receiver, by using properties of those objects received in
advance, enhances file delivery efficiency by not having to transmit that
overhead continuously during the download delivery session.
\- An object or an object flow may be directly linked to an application, for
example to a DASH Representation.
\- Enable chunk delivery/reception of objects. In case of live service where
multimedia data is generated, this enables reduction of sender latency
independent of usage of FEC. In addition, receiver latency reduction may be
achieved if FEC is not used at all of if later stall when FEC used is
acceptable. Chunked delivery combines the advantages of packet-based streaming
with object delivery with or without FEC.
\- Enable variable size source packets: Source packet boundaries can be
aligned with underlying media structure boundaries if desired. This may
improve chunked delivery and may also provide additional error resilience as
error concealment may be simplified if only single access units are lost.
\- Enable delivery of source content with no FEC semantics: In this case
receivers that don\'t implement/need/understand FEC can still receive the
source stream. In addition, the same source stream can be easily mapped to
multiple FEC configurations, e.g. different FEC schemes, different source
block sizes, etc. This is in particular possible with systematic FEC codes
such as the Raptor code defined TS26.346[2].
\- Enable FEC object bundling: Provide FEC protection over multiple objects,
which can increase the efficiency of FEC protection.
\- Enable that delivered object contains all information of a complete HTTP
GET response, i.e. the HTTP header and the HTTP GET response: In many cases
the objects delivered through FLUTE are objects that are made available as
resources on an http server/proxy/cache. FLUTE can very well be used to feed
such HTTP caches, but it is preferable to have all information of a regular
HTTP response included in the delivery of the object. Also objects may have
certain live/availability times on caches. Signaling for this purpose may be
necessary .
\- Add timing information to FLUTE delivery: FLUTE packets are time agnostic.
By adding timing to FLUTE packets, this enables temporal measurements, e.g.
for jitter or delay measurements.
\- Reuse current standards, especially FLUTE, as much as possible: For
example, it should allow delivery of standard FLUTE objects in same session
with FDTs if backward compatibility is necessary.
\- A solution including the enhancements corresponding to the recommended
requirements of this clause is expected to be applicable to both, segment
streaming, such as 3GP-DASH delivery, as well as file delivery.
\- Multiplexed segments, in particular for environments with higher packet
error rates (i.e. when the usage of larger source blocks becomes more
efficient) may be recommended when used together with FEC and for simple
service offerings.
\- Using short media segments in order to reduce the e2e delay for Live. There
should be an additional note highlighting the tradeoff between e2e delay /
short segments and the FEC efficiency. The FEC efficiency is significantly
reduced when operating with small source blocks.
\- Add informational clause to the MBMS specification, clarifying the benefit
of sending the DASH segment in a different order, if the segmenter is co-
located with the BM-SC.
Note 1: All the above recommended requirements for MBMS broadcast are expected
to be done in a backward compatible manner; otherwise the specific enhancement
related to that recommended requirement is not considered any longer.
Note 2: The gains and/or benefits for FLUTE enhancements is needed for
justification.
A protocol that enhances FLUTE is expected to fulfil the following features:
\- Delivery of data objects over unidirectional transport to enable HTTP/1.1
similar functionalities:
\- Delivery of objects that are uniquely named by HTTP-URLs
\- Provision of object properties along with the delivery of the object
including Content-Type, Content-Encoding, size of extension headers, etc.
without dependency on any other objects.
\- Delivery and signalling of byte-ranges of a content object
\- Chunked transfer of objects
\- Enabling caching of objects
\- Reliable delivery of objects using existing error recovery methods:
\- By the support of application layer FEC
\- By combining FEC protection for multiple objects
\- Without including/tying the source packets to a specific error recovery
scheme
\- Efficient and reliable support of object flows with timing real-time
properties, in particular segmented DASH Representations within a Media
Presentation of type dynamic, which includes:
\- Delivery of static information a priori in a reliable information
\- Bundling of dynamic information with the media object
\- Enable the support of timing information to the delivery
\- Provide generality without tying the base protocol to a specific
application or media format
\- Provide extensibility and modularity
\- Enable optimizations for specific applications as well as objects and
object flows, including:
\- Application-driven packet sizes and packet fragmentation including
signalling of functional properties in packet headers, e.g. random access
points in a sense that any packet prior to a random access point is of no
value for the application.
\- DASH content, for example using predictive information in the MPD also in
the signalling of the FLUTE+ protocol.
In addition, a protocol that enhances FLUTE preferably provides the following
features:
\- Efficiency in terms of packet overhead
\- Reasonable complexity
\- Compatibility to some FLUTE building blocks
If considered beneficial in terms of enhancements of FLUTE, \"RFC 3451:
Layered Coding Transport (LCT) Building Block\" may be replaced with RFC 5651
in TS 26.346[2] Rel-12, without breaking backward-compatibility according to
Type 1, Type 2 and Type 3 as defined in clause 4.2.2.4 of the present
document.
#### 4.2.2.4 Gap Analysis & Evaluation
Changing FLUTE may be a major step forward and the pros and cons of doing
should be considered. However, in order to obtain a better support for the
delivery of objects flows as available in DASH and to deliver timed media
data, the definition of a new object delivery protocol may be justifiable as
long as it is kept as close as possible to what FLUTE provides and possible
use a new version of FLUTE to extend as proposed in the present document.
In order to progress the work in SA4, a list of potential functional
enhancements should be collected and agreed. Based on the list of functional
improvements, the decision should be made if and how FLUTE is enhanced and to
what extent backward-compatibility is maintained.
##### 4.2.2.4.1 Type 1: Backward compatible towards Rel-11 and earlier UEs
\- A Rel-11 and earlier MBMS UE would be able to receive and consume the
content from enhanced FLUTE from Rel-12 network. The Rel-11 and earlier MBMS
UE ignores Rel-12 specific signaling of FLUTE enhancements (e.g. reserved bits
in Rel-11 may be used for enhancements in Rel-12, but just ignored by Rel-11
and earlier MBMS UEs), but is able to receive the content carried over
enhanced FLUTE (e.g. could be 3GP-DASH content or file delivery); and
\- A Rel-11 and earlier MBMS UE is able to operate normally on reception of
Rel-12 FLUTE enhancements; and
\- Rel-12 MBMS UEs are able to take advantage of FLUTE enhancements defined in
Rel-12.
Note: A Rel-11 and earlier MBMS UE cannot take advantage of any Rel-12 FLUTE
enhancements.
##### 4.2.2.4.2 Type 2: Backward compatible towards Rel-11 and earlier
Networks
\- A Rel-12 MBMS UE is able to receive and consume the content from Rel-11 and
earlier network.
##### 4.2.2.4.3 Type 3: Backward compatible towards Rel-11 and earlier
Networks and UEs
\- The criteria of clauses 4.2.2.4.1 and 4.2.2.4.2 apply simultaneously.
If FLUTE+ enhancements refer to backward compatibility without indicating the
type of backward compatibility, than the definition in clause 4.2.2.4.3
applies.
##### 4.2.2.4.4 Type 4: UEs of Rel-11 and earlier releases ignore content
delivered over Rel-12 FLUTE+
\- A Rel-11 and earlier UE attempts to receive content carried with Rel-12
enhanced FLUTE. The Rel-11 and earlier MBMS UE detects an unknown FLUTE
version (e.g. if a new LCT version number is defined for FLUTE+), and thus
ignore the remaining content of this FLUTE packet/object.
##### 4.2.2.4.5 Considered Strictly backward-compatible extensions
###### 4.2.2.4.5.1 General
This clause is a collection of potential enhancements that may be performed in
a backwards-compatible way.
The following general tools are considered:
\- Ability to delivery FDT Instance in USD as a static information
\- Extensions to the FDT Instance to signal Object Flows and CodePoints
\- Sending existing or newly defined LCT extension headers
\- Use of the code point signalling
\- Recommendation on the use of certain tools
###### 4.2.2.4.5.2 LCT based on RFC 5651
###### # 4.2.2.4.5.2.1 Description
As stated in clause 4.2.2.3, \"RFC 3451: Layered Coding Transport (LCT)
Building Block\" may be replaced with RFC 5651 in TS 26.346[2] Rel-12, without
breaking backward-compatibility according to Type 1, Type 2 and Type 3 as
defined in clause 4.2.2.4 of the present document.
The use of RFC 5651 is beneficial as 3GPP can:
\- Use existing extension headers to LCT as defined in RFC 5651.
\- Define and register new extension headers with IETF based on the procedures
defined in RFC 5651.
\- Refer to an RFC that is in standards-track of the IETF.
Therefore, it is proposed to replace RFC 3451 with RFC 5651. In addition, the
following restrictions need to be added:
\- Use the FDT Instance with version 1 according to RFC 3926.
\- Set reserved bits in the LCT header to zero.
###### # 4.2.2.4.5.2.2 Justification
Using RFC 5651 enables to use extension headers defined in RFC 5651 and to
register new extension headers. It also enables to move from an experimental
RFC to a standard track RFC.
###### # 4.2.2.4.5.2.3 Open Issues
The following issues still need clarification:
\- Is ALC also upgraded to RFC 5775 [5]?
###### 4.2.2.4.5.3 File Delivery Table Instance Descriptor
###### # 4.2.2.4.5.3.1 Description
In order to enable providing an FDT Instance out-of-band in the USD a File
Delivery Table Instance Descriptor (FID) may be added to the USD as a USD
fragment.
The FID fragments may be associated to one download delivery session. Each of
the FID expresses sufficient information such that all functionalities of a
sequence of FDT Instances can be generated by the receiver based on the FID
and information in LCT packet headers, specifically the TOI.
In case of sending DASH over Flute, the BM-SC may generate a new FDT Instance
for each new DASH segment.
The FID may be delivered out-of-band or in-band and the attributes of the
metadata envelope provide the context for the FID, i.e. its validity period as
well as the URL as referred to by the USD.
###### # 4.2.2.4.5.3.2 Justification
This extension enables to deliver all static and known information ahead of
time and out-of band. By this, dependency on the reception of inband FDT
Instanceis reduced and clients understanding this fragment can parse this w/o
relying on the reception of the inband FDT instance as all information is
provided in the combination of the FID and the LCT headers.
###### # 4.2.2.4.5.3.3 Open Issues
Is this FDT Instance Descriptor (FID) only to be sent as USD fragment or is it
also to be sent inband.
###### 4.2.2.4.5.4 Extensions to FDT Instance
###### # 4.2.2.4.5.4.1 General
The following extensions only apply if the FDT Instance is delivered as a FID
as a metadata fragment. Whether any of these extensions are useful for a
regular inband FDT Instance is for further study.
###### # 4.2.2.4.5.4.2 Object Flows
###### # 4.2.2.4.5.4.2.1 Description
An FDT Instance may contain one or more object flow descriptors that are
described in the following. This extension element may be added to the FDT
Instance to generate equivalent data as provided by one or more File elements
in the FDT Instance. Each object flow is identified by an \@id.
In order to address DASH based delivery, or general delivery of objects,
object flows are defined. Objects are associated to a specific object flow by
having a specific pattern of the TOI. A flow is defined by the **ObjectFlow**
\@id that if applied to the TOI field results in a match. The object flow
identifier may be applied to the TOI or to the (TSI,TOI) fields
If the ObjectFlow element is present, then no File element should be present
that overlaps with the TOI space generated by the Object Flow.
+-------------+-------------+-------------+-------------+-------------+ | Element or | Use | Description | | | | Attribute | | | | | | Name | | | | | +-------------+-------------+-------------+-------------+-------------+ | | **O | | specifies | | | | bjectFlow** | | the static | | | | | | File | | | | | | Delivery | | | | | | Descriptor | | +-------------+-------------+-------------+-------------+-------------+ | | | \@id | M | specifies | | | | | | the object | | | | | | flow | | | | | | identifier. | +-------------+-------------+-------------+-------------+-------------+ | | | \@ | O | identical | | | | contentType | | to | | | | | | Conte | | | | | | nt-Location | | | | | | attribute | | | | | | in FLUTE | +-------------+-------------+-------------+-------------+-------------+ | | | \@cont | O | identical | | | | entEncoding | | to | | | | | | Conte | | | | | | nt-Encoding | | | | | | attribute | | | | | | in FLUTE | +-------------+-------------+-------------+-------------+-------------+ | | | **Fil | 0...1 | specifies a | | | | eTemplate** | | file | | | | | | template in | | | | | | the body. | | | | | | For details | | | | | | refer to | | | | | | section. | +-------------+-------------+-------------+-------------+-------------+ | | Legend: | | | | | | | | | | | | > For | | | | | | > | | | | | | attributes: | | | | | | > M | | | | | | =Mandatory, | | | | | | > | | | | | | O=Optional, | | | | | | > | | | | | | OD=Optional | | | | | | > with | | | | | | > Default | | | | | | > Value, | | | | | | > CM=Co | | | | | | nditionally | | | | | | > | | | | | | Mandatory. | | | | | | > | | | | | | > For | | | | | | > elements: | | | | | | > \...\ | | | | | | > (N | | | | | | =unbounded) | | | | | | > | | | | | | > Note that | | | | | | > the | | | | | | > | | | | | | conditions | | | | | | > only | | | | | | > holds | | | | | | > without | | | | | | > using | | | | | | > | | | | | | xlink:href. | | | | | | > If | | | | | | > linking | | | | | | > is used, | | | | | | > then all | | | | | | > | | | | | | attributes | | | | | | > are | | | | | | > \ | | | | | | "optional\" | | | | | | > and | | | | | | > \ | | | | | | | | | | | | Elements | | | | | | are bold; | | | | | | attributes | | | | | | are | | | | | | non-bold | | | | | | and | | | | | | preceded | | | | | | with an @. | | | | +-------------+-------------+-------------+-------------+-------------+
###### # 4.2.2.4.5.4.2.2 Justification
Using object flows enables to group objects with identical properties and
enables to provide this information in a static manner. This reduces the
dependency on receiving the FDT Instance as static information that applies to
all objects in the flow are summarized in the object flow. This specifically
includes the \@contentType. Typically this maps to a Representation.
###### # 4.2.2.4.5.4.2.3 Open Issues
\- What other parameters may be added to the Object Flow, e.g. FEC Parameters?
\- Do we want to have the ability to enable describing a range of TOIs using
start and end TOI attributes for the file template?
\- The relationship to multiple FLUTE sessions needs to be clarified.
\- The usage of TOI only, TOI+TSI, or TSI only for object flow id needs to be
clarified.
\- Handling of the Flute FDT instance expire.
###### # 4.2.2.4.5.4.3 File Template
###### # 4.2.2.4.5.4.3.1 Description
The static File Delivery Description may include a **FileTemplate** element.
The value of FileTemplate element attribute may contain one or more of the
identifiers as listed in Table 4.2.2-1.
The element enables to generate a one to one mapping between a OFI and TOI and
URL.
In each URI, the identifiers from Table 4.2.2-1 should be replaced by the
substitution parameter defined in Table 4.2.2-1. Identifier matching is case-
sensitive. If the URI contains unescaped \$ symbols which do not enclose a
valid identifier then the result of URI formation is undefined. The format of
the identifier is also specified in Table 16.
Each identifier may be suffixed, within the enclosing \'\$\' characters
following this prototype:
> %0[width]d
The width parameter is an unsigned integer that provides the minimum number of
characters to be printed. If the value to be printed is shorter than this
number, the result should be padded with zeros. The value is not truncated
even if the result is larger.
The **FileTemplate** should be authored such that the application of the
substitution process results in valid URIs.
Strings outside identifiers should only contain characters that are permitted
within URIs according to RFC 3986.
Table 4.2.2-1: Identifiers for File templates
+--------------------+-----------------------+-----------------------+ | \$\\$ | Substitution | Format | | | parameter | | +--------------------+-----------------------+-----------------------+ | _\$\$_ | Is an escape | not applicable | | | sequence, i.e. | | | | \"\$\$\" is | | | | non-recursively | | | | replaced with a | | | | single \"\$\" | | +--------------------+-----------------------+-----------------------+ | _\$OFI\$_ | This identifier is | The format tag may be | | | substituted with the | present. | | | object flow | | | | identifier | If no format tag is | | | **ObjectFlow** \@id | present, a default | | | the corresponding LCT | format tag with | | | packet. | width=1 should be | | | | used. | +--------------------+-----------------------+-----------------------+ | _\$ON\$_ | This identifier is | The format tag may be | | | substituted with the | present. | | | object number which | | | | is represented by the | If no format tag is | | | remaining non flow if | present, a default | | | bits of the | format tag with | | | corresponding LCT | width=1 should be | | | packet | used. | +--------------------+-----------------------+-----------------------+
###### # 4.2.2.4.5.4.3.2 Justification
Using a template enables to create the information \@TOI and \@contentLocation
information contained in the File element in the FDT Instance by using this
static information and the TOI.
###### 4.2.2.4.5.5 Extension Headers
###### # 4.2.2.4.5.5.1 Deriving Object size
###### # 4.2.2.4.5.5.1.1 Description
The information about the object size and the other OTI needs to be delivered
with each object to enable FDT-free object recovery.
If the File Template is used, then an extension header permits to send the
object size of the object with a specific TOI (combination of object flow id
and object number).
One option is to use the general EXT_FTI as defined in RFC 3926, section
5.1.1. This may be used to deliver the Transfer Length of the carried object.
Alternatively a new extension header solely carrying the object size may be
defined.
This extension header should be sent with every repair packet.
###### # 4.2.2.4.5.5.1.2 Justification
In order to enable to rely on static information and information included in
the LCT packets only, the transport object size needs to be added to LCT
packets.
###### # 4.2.2.4.5.5.1.3 Open Issue
The EXT_FTI is initially designed for this purpose. Whether to use the EXT_FTI
or define a new headers is unclear.
The issue is that TS 26.346[2] is currently states:
FLUTE extension header fields EXT_FDT, EXT_FTI, EXT_CENC [9] should be used as
follows:
\- EXT_FTI should be included in every FLUTE packet carrying symbols belonging
to any FDT Instance.
\- FLUTE packets carrying symbols of files (not FDT Instances) should not
include an EXT_FTI.
\- FDT Instances should not be content encoded and therefore EXT_CENC should
not be used.
In FLUTE the following applies:
\- EXT_FDT is in every FLUTE packet carrying symbols belonging to any FDT
Instance.
\- FLUTE packets carrying symbols of files (not FDT instances) do not include
the EXT_FDT.
###### # 4.2.2.4.5.5.2 Timing Extension Header
###### # 4.2.2.4.5.5.2.1 Description
The LCT Header EXT_TIME extension as defined in RFC 5651 may be used by sender
in the following manner:
\- The Sender Current Time may be used to occasionally or frequently signal
the sender current time depending on the application. This may be used in
order to synchronize the clock of the sender and the receiver.
\- The Expected Residual Time (ERT) may be used to indicate the expected
remaining time for the current object.
\- The SLC flag is typically of no use, but may be used to indicate
addition/removal of segments.
###### # 4.2.2.4.5.5.2.2 Justification
This allows sending timing in band in order to provide synchronization,
dejittering and so on.
###### # 4.2.2.4.5.5.2.3 Open Issues
The exact interpretation of these timing signals needs to be defined.
For DASH, the usage of this timing may be more explicit.
###### # 4.2.2.4.5.5.3 Object Expires
###### # 4.2.2.4.5.5.3.1 Description
The object expiry information as currently present in the FDT Instance may
have to be sent for certain applications.
###### # 4.2.2.4.5.5.3.2 Justification
In order to enable to rely on static information and information included in
the FID and LCT packets only..
###### # 4.2.2.4.5.5.3.3 Open Issues
\- Can this be solved with the FID only
\- Or do we need an extension header and if so:
\- Can an existing extension header be used, like an EXT_TIME header?
\- Do we need to define a new extension header?
###### 4.2.2.4.5.6 Code Points
###### # 4.2.2.4.5.6.1 Description
The FDT Instance may be extended by a code point element. Code points may be
used to signal specific information of the packet carrying the data with
respect to the object.
###### # 4.2.2.4.5.6.2 Justification
This permits to signal application specific aspects associated to individual
LCT packets.
###### # 4.2.2.4.5.6.3 Open Issues
\- Details of the signalling in the FID.
\- Examples for application specific signals.
\- Usage of code points in the existing specification.
###### 4.2.2.4.5.7 Object expiration mechanism for FLUTE enhancements
FLUTE, as defined by RFC 3926 and updated into RFC 6726, defines file delivery
over UDP using LCT and ALC building blocks from IETF. ALC and LCT define the
transmission of \"objects\", without any additional metadata characterizing
the objects, using UDP. FLUTE adds the needed mechanism of associating HTTP
like metadata such as a Content-Location and Content-Type to an LCT
Transmission Object.
FLUTE defines the so-called File Delivery Table (FDT), which is basically a
list containing the association of file metadata to the transport object
identifier (TOI). The client maintains the FDT. The sender can add entries by
using FDT Instances. Each FDT Instance can provide one or more file
association entries. Each FDT Instance is sent as a Transmission Object. Each
FDT instance is identified by the same TOI of value zero. Each FDT Instance is
marked with a unique FDT Instance Id. The client can use the FDT Instance Id
to identify repetitions of already received FDT Instance objects (which are
all use the same TOI value of zero).
The mechanisms to add new file associations into the client FDT are clearly
defined. The clean-up mechanism to remove file associations (when not needed
anymore) is only vaguely defined through the FDT Instance expiry.
FLUTE RFC (RFC 3926 and RFC 6726) contains a mandatory expire mechanism, which
allows the sender to define a lifetime for an FDT Instance.
An example transmission is depicted below: The BM-SC partitions a file into a
sequence of IP/UDP packets. The BM-SC also adds Repair packets, containing the
FEC redundancy.
{width="6.49375in" height="2.3097222222222222in"}
Figure 4.2.2-5: Example transmission of FLUTE object
The FLUTE FDT Instances, which provides the file metadata for the TOI, are
interleaved with the rest of the transmission. The BM-SC starts at some time
(marked as \"Start of Object Transmission\"). The \"End of Object
Transmission\" is the time at which the BM-SC has sent all source and repair
packets.
The reception of a new object starts when the client receives a first IP
packet of the new transport object. The client can make the object available
as file to the higher layers, when sufficient number of packets for object
recovery is received. In the figure above, the reception of Client A is
finished before all packets have been transmitted. So, the client is actively
ignoring / discarding all subsequently received packets of that TOI.
Further, the client should have received the associated file metadata. The
client may ignore all subsequent packets of that transmission object (as
identified by the TOI), since it has already received the object.
In the example above, the packet losses of Client B are too high for the
provided FEC redundancy. So, at some point in time, the client needs to
discard all data of that TOI or start file repair (if provisioned) or make a
partial file available (UE implementation option).
In order to simplify the network procedure for calculating the expiration time
and determining a sufficiently precise transmission delay, a relative
timestamp for object expiry is agreed. The solution may re-use the expected
residual time (ERT) mechanism to convey the information for object expiry or
may define a new extension header, depending on the selected LCT RFC.
Figure 4.2.2-6 depicts the construction as example: The BM-SC has done the
file partitioning for the file in the first step and has determined the number
of packet needed to carry the file. In the figure, the file plus the FEC
overhead is partitioned into 400 IP packets. Due to the target bitrate, one
packet needs to be sent every 40 ms.
{width="6.488194444444445in" height="4.261111111111111in"}
Figure 4.2.2-6: Example for ERT usage
Constant inter-transmit intervals considered here for sake of simplicity. The
inter-transmit interval may depend on the segment size, if a transmission
duration should be the same for segment at variable segment sizes. For
instance segments containing 1sec of media data may vary in size. So, some
segments may be partitioned into 380 IP packets, while other segments require
420 IP Packets to be transmitted.
In the example above, the BM-SC needs 16sec to transmit the 400 packets with
the 40 ms interval (transmission duration excluded).The BM-SC determines the
expiry of the segment as 16 sec plus a margin of X sec. The BM-SC uses a
safety margin of X= 1sec so, the expiry should be 17 sec after the reception
of the first packet. However, since the first packet might get lost, also
subsequent packets should carry timeout information.
The value of the Expected Residual Time header (EXT_TIME with ERT option) is
depicted for each packet. Note, the ERT as defined in RFC 5651 has a second
precision, not a millisecond precision. The client uses the ERT to calculate
the FDT Instance expiration time. The ERT is decrementing with each packet.
To reduce transmission overhead, the EXT_TIME header may be included with a
fixed period larger 1. For instance, the EXT_TIME header may be added every
10th Packet.
Note, in case FLUTE FDT instances are interleaved within the FLUTE session
e.g. for backward compatible, the object expiry time provided with the FLUTE
packets needs to be consistent with the expiry in the FDT instances.
###### 4.2.2.4.5.8 FLUTE packets of DASH Segments in different order
In deployments in which the DASH segments are produced in the same location as
the BM-SC, media samples of a segment may be delivered prior to the
availability of all samples in order to reduce end-to-end latency. This
enables that FLUTE packets are delivered prior to the availability of the full
segment, i.e. the delivery object. However, as segments include information
about the contained samples in the beginning of the object, the delivery of
the initial symbols of an object needs to be delayed as they can only be
generated after the full segment is created. In the following a possible way
how achieve this is explained.
The delivery of the FLUTE packets composing a DASH segment become technically
possible while being compliant to the DASH specification. This may allow to
reduce the overall delay for delivering DASH over MBMS. However, creation of
DASH segments within the BM-SC is one very specific deployment option, and it
is expected that most deployments would have DASH segmentation function not
co-located with the BM-SC.
When a DASH media segment is in the 3GPP file format, it can be constructed
out of order in the following way. As media samples (video and audio frames
etc.) are available, they are appended at an estimated offset at the end of
the segment, in what will become the body of the media-data (\'mdat\') box.
The estimate needs to be as large as the maximum size of the data that will
later be inserted to complete the segment. The size of the movie fragment box
may depend on the number of samples provided in the DASH Segment.
In addition, the offset needs to exactly be mapped to an integer symbol
boundary of the FLUTE delivery.
When the segment is to be completed, the earlier parts are then constructed
and sent; those earlier parts include the segment-type (\'styp\') box, movie
fragment (\'moof\') box, and the header of the media-data box. Padding may be
needed to fill in to the estimated offset used.
In order to do this, the sender needs to:
\- Ensure that the DASH segment is sent as a single source block.
\- Estimate the size of the earlier parts of the segment, to determine the
offset to the first media samples.
\- Select a suitable encoding symbol size considering boundary alignment with
the start of the media data container.
\- Send the FDT Instance including FEC Object Transmission Information file
partitioning information at the end, as the actual file size of the DASH
segment is only known at DASH segment creation. Note that by doing this, this
provides a justifiable exception to RFC 3926, section 3.2, to not send the FDT
instance prior to sending of the described file within a file delivery
session. Receivers should be aware that the FDT instance is received at the
end or later and should collect packets associated to a TOI for which no FDT
instance is received.
##### 4.2.2.4.6 ALC RFC differences and analysis
##### 4.2.2.4.6.1 Differences {#differences .H6}
The latest ALC RFC 5775 [5] indicates in section 8 the changes from RFC 3450
[4]:
1) Updated all references to the obsoleted RFC 2068 to RFC 2616.
2) Removed the \'Statement of Intent\' from the introduction. (The Statement
of Intent was meant to clarify the \"Experimental\" status of RFC 3450 [4].)
3) Removed the \'Intellectual Property Issues\' Section and replaced with a
standard IPR Statement.
4) Removed material duplicated in LCT.
5) Updated references in the present document to new versions of the LCT
Building Block and the FEC Building Block, and aligned the present document
with changes in the new version of the FEC Building Block.
6) Split normative and informative references.
7) Material applicable in a general LCT context, not just for ALC has been
moved to LCT.
8) The first bit of the \"Protocol-Specific Indication\" in the LCT Header is
defined as a \"Source Packet Indication\". This is used in the case that an
FEC Scheme defines two FEC Payload ID formats, one of which is for packets
containing only source symbols that can be processed by receivers that do not
support FEC Decoding.
9) Definition and IANA registration of the EXT_FTI LCT Header Extension.
##### 4.2.2.4.6.2 Analysis {#analysis .H6}
Out of the differences listed in clause 4.2.2.4.6.1, items 2, 3, 6 are
editorial in nature, so they are not analyzed here. Other items are analyzed
one by one.
##### 4.2.2.4.6.2.1 Item 1 -- reference to RFC 2616 {#item-1-reference-to-
rfc-2616 .H6}
The old ALC RFC was referring to RFC 2068 HTTP 1.1 for one possible definition
of the SDP HTTP/Mime Headers. RFC 2616 does obsolete RFC 2068.
This has no foreseen technical impacts in the context of MBMS.
##### 4.2.2.4.6.2.2 Item 4 -- Removed material duplicated in LCT
{#item-4-removed-material-duplicated-in-lct .H6}
This item states that there were duplication of text in ALC protocol, compared
to LCT, and the duplicated text in ALC was removed. This is a good approach to
avoid duplication, and improve readability of the LCT and ALC RFCs. Looking at
the new RFC, it is noted that LCT specific protocol operation text (e.g.
section 4.2 in old ALC RFC 3450 [4]) was indeed moved out of ALC.
This has no foreseen technical impacts in the context of MBMS.
##### 4.2.2.4.6.2.3 Item 5 -- Updated references to new building blocks
{#item-5-updated-references-to-new-building-blocks .H6}
The new ALC RFC is referencing the new LCT Building Block RFC 5651, as well as
the new FEC Building Block RFC 5052.
For LCT, we have agreed that we should refer to the most recent LCT RFC 5651.
For the FEC Building Block RFC, the current TS 26.346 Release 9 onwards refers
to that latest FEC Building Block RFC 5052.
The most recent ALC RFC 5775 [5] is consistent with existing TS 26.346 [2],
with respect to referring to the same FEC Building Block RFC 5052.
This has no foreseen technical impacts in the context of MBMS.
##### 4.2.2.4.6.2.4 Item 7 -- LCT material moved from ALC RFC to new LCT RFC
{#item-7-lct-material-moved-from-alc-rfc-to-new-lct-rfc .H6}
Though it is not exactly known which part of the ALC RFC was moved to the LCT
RCF, this item suggests that since we have agreed to the new LCT RFC, we
should go with the new ALC RFC, to avoid duplication if we were to use the new
LCT RFC with the old ALC.
This has no foreseen technical impacts in the context of MBMS.
##### 4.2.2.4.6.2.5 Item 8 - The first bit of the \"Protocol-Specific
Indication\" in the LCT Header is defined as a \"Source Packet Indication\"
{#item-8---the-first-bit-of-the-protocol-specific-indication-in-the-lct-
header-is-defined-as-a-source-packet-indication .H6}
With the new LCT RFC, there are 2 reserved bits in the header that have been
converted to a 2-bit indicator called PSI. The usage of the PSI is left to the
protocol instantiation, such as ALC in our case. The new RFC ALC specifies
that one of the PSI bit is still set to 0 and ignored by the receiver, and is
specifying the usage of the other bit as follows:
> PSI bit X - Source Packet Indicator (SPI)
>
> The Source Packet Indicator is used with systematic FEC Schemes which define
> a different FEC Payload ID format for packets containing only source data
> compared to the FEC Payload ID format for packets containing repair data.
> For such FEC Schemes, the SPI is set to 1 when the FEC Payload ID format for
> packets containing only source data is used, and the SPI is set to zero when
> the FEC Payload ID for packets containing repair data is used. In the case
> of FEC Schemes that define only a single FEC Payload ID format, the SPI is
> set to zero by the sender and has to be ignored by the receiver.
Setting of this bit makes it easier for the receiver to process the receive
packets, knowing from the indicator whether the packet contains source data,
or repair data.
In terms of backward compatibility, 2 scenarios are of interest:
1) Pre Rel-12 UE operating in a Rel-12 Network with new ALC RFC
2) Rel-12 UE with the new ALC RFC implemented, and operating in a pre-Rel12
network
For scenario 1), a UE not implementing the new ALC RFC, would ignore the 2-bit
PSI all together. So settings of the SPI would be ignored by that UE, and thus
the UE operates and receives ALC packet without this new improvements, but is
still capable of decoding its content.
For scenario 2), a Rel-12 UE implementing the new ALC RFC expects and reads
the SPI. However, since the network has not yet being upgraded, the network is
considering that bit as reserved. According to the old LCT RFC 3451, it is
specified that:
Reserved (r): 2 bits
> Reserved for future use. A sender sets these bits to zero and a receiver has
> to ignore these bits.
Thus a Rel-12 UE implementing the new ALC RFC would always see a SPI indicated
as 0, indicating FEC Payload ID for packets containing repair data, and that
even if it contains source data.
##### 4.2.2.4.6.2.6 EXT_FTI LCT Header Extension registration in IANA
{#ext_fti-lct-header-extension-registration-in-iana .H6}
Both the old and new ALC RFC had defined EXT_FTI LCT Header, as an ALC
specific extension, coded as 64. The only difference between the old and new
RFC is that the EXT_FTI Header Extension is now registered in IANA, thus
preventing collision with other future header extension that may be defined.
This has no foreseen technical impacts in the context of MBMS.
Moreover, it is foreseen as an advantage to have this extension registered in
IANA to prevent future collision of extension headers, which would come
automatically if the new ALC is agreed for usage in MBMS.
#### 4.2.2.5 Assumptions
##### 4.2.2.5.1 Source Data Properties
\- A single data file without any specific properties. This data file creates
a unit and is only accessible as a whole. Examples are gzipped files, etc. The
file may be of different size between several kBytes up to GBytes.
\- A collection of data files that are individually accessible, but are only
useful together, e.g. objects of a web page, etc.
\- A large multimedia file that is available on the BMSC as whole and is
distributed without any real-time constraints. However, the consumption at the
receiver may only be partial, i.e. access to only a subset done.
\- In the latter four cases, in addition to each timely connected segments or
subsegments/fragments, there may also be multiple media components that are
distributed jointly and played out jointly.
\- Mixes of the above, for example non-realtime and real-time data.
##### 4.2.2.5.2 Upgrade to RFC5651
If the upgrade to RFC5651 is deemed impossible for non-understandable reasons,
then as an alternative the following is proposed:
\- Maintain RFC 3451 in TS26.346 [2].
\- Define extension headers in 3GPP or IETF based on RFC 5651.
\- Use any extension headers available for RFC5651 in context of RFC 3451 in
3GPP.
#### 4.2.2.6 Solution
The following technologies were agreed taking into account benefits, backward-
compatibility and complexity:
  * Addition of the EXT_TIME header from RFC 5651
### 4.2.3 Datacasting Services
#### 4.2.3.1 Description
##### 4.2.3.1.1 Use Case #1 -- Sports Scores and Statistics
A mobile network operator offers NBA basketball scores and statistics
information as an MBMS download delivery service. During the NBA season
between October and April, and across evening hours and weekend afternoons,
files containing live scores and statistical information on players and teams
are broadcast on this service. The size of a given file ranges from 10 kB to
25 kB, with average size of 20 kB. Based on the contractual agreement between
the MBMS service provider and the NBA (the content owner) to support fast
service acquisition, regardless of when the subscriber chooses to monitor the
service, the latest version of service files is transmitted repeatedly, back-
to-back, on the allocated MBMS bearer. Files are nominally updated every 120
seconds, although dynamic changes may occur at any time, for example to
provide real-time announcement of final scores of games as these occur.
Different recommendations on the periodicity for service monitoring, or
_monitoring period_ , depending on the user type, are indicated to subscriber
devices, towards achieving a balance between anticipated user interest in
just-in-time information and efficient battery consumption. For a typical
user, the recommended monitoring period might be set to 5 minutes, placing
greater emphasis on battery efficiency. For basketball fans who wish to find
out final scores or other highlight information as these occur, the
recommended monitoring period might be set to 30 seconds, to better enable
close-to-live reception of information.
A UE which joins the service less frequently than once every nominal update
interval (120 seconds) will miss any real-time updates that may occur within
such intervals, as well as changes at those nominal update times when it\'s
not monitoring the service. However, whenever it joins the service, it will
always obtain the latest service snapshot upon reception, such as current
scores of ongoing games, updated player and team statistics provided at
periodic intervals, previous day final scores, and league standings
information. A UE which monitors the service more frequently than the nominal
update period can detect final scores closer to real time, as well as more
timely reception of asynchronous compilation of statistical information on
players and teams.
##### 4.2.3.1.2 Use Case #2 --USD Delivery
MBMS User Service Announcement, a.k.a. USD, is delivered as a download
delivery service on a dedicated FLUTE session. While the contents of the USD
do not pertain to a MBMS User Service, USD delivery over an MBMS bearer is a
form of Datacasting service, for use by the USD client application. Assume
that one or more USD fragments are expected to be updated several times a day,
for example, every 6 hours which corresponds to the difference between the
_validFrom_ and _validUntil_ attributes of the associated MBMS metadata
envelope(s). More frequent changes may be necessary to accommodate events for
which the actual end time cannot be known in advance. For example, should a
live football game go into overtime, the nominal Schedule Description fragment
might need to be dynamically updated one or more times to convey temporal
extension of the game. As another example, assume that several minutes after
the nominal update of existing USD fragments, a new, long-running User Service
is added, which requires the addition of the corresponding new USD fragments.
As in the previous use case, different monitoring period recommendations are
provided to UEs. A mobile phone-based UE (UE1) is recommended to monitor the
service announcement session every 15 minutes, whereas for an MBMS-equipped
utility meter (UE2), the recommended monitoring period is every 6 hours. In
the event that signaling of the newly-added User Service occurs a few minutes
after the nominal update time, a UE which abides by the recommended monitoring
period for UE1 (i.e. 15 minutes) would miss those newly added USD fragments.
However, at the next expected update of the USD fragments, the service
announcement information will include that previous update. In other words,
USD files contain cumulative service information, thereby ensuring that each
new version reflects up-to-date status of the carried MBMS User Services.
#### 4.2.3.2 Recommended Requirements & Evaluation Criteria
Derived recommended requirements from the above use cases are listed below:
\- The service provider can inform UEs of different recommended durations of
monitoring period.
\- The current version of the Datacasting service content file can be
transmitted repeatedly on the FLUTE session allocated for the service, in
back-to-back or in scheduled and periodic form of delivery, during the entire
update interval.
\- If the network performs scheduled and periodic Datacasting transmission,
the network will inform the UE of the individual session activity times and
the nominal periodicity of session recurrences.
\- For scheduled and periodic Datacasting, a UE that tunes in to the service
right after the end of a session among a recurring series of sessions will be
able to acquire contents on the service sooner than having to wait until the
next scheduled session occurrence.
\- Impact on network-side administrative overhead, USD size, and UE processing
complexity as a result of Datacasting service ought to be minimized.
#### 4.2.3.3 Gap Analysis & Evaluation
#### 4.2.3.4 Assumptions
The following working assumption pertaining to Datacasting Services:
\- It is important for UEs to be able to immediately acquire the current
version of the Datacasting service file whenever it joins the service. Unicast
may be optionally used to acquire the very first data set.
\- Radio resources are scarce resources. Minimal acquisition time needs to be
traded with the needed capacity and the cost of the capacity.
\- There is a certain predictable periodicity at which files are updated, with
the corresponding time interval referred to as the (nominal) _update
interval_. This is depicted as in Figures 4.2.3-1 and 4.2.3-2:
{width="4.822916666666667in" height="1.3534722222222222in"}
Figure 4.2.3-1: Update Interval
Figure 4.2.3-2: Scheduled Datacasting
\- Although file updates usually occur at the start of update intervals,
dynamic file changes are permitted at any time.
\- Any additional file update which occur within an update interval may be
included or obsoleted by the next update which may be another intervening file
update, or one that occur at the start of the next update interval, depending
on the application requirements and operator deployment requirements:
\- It may be important for certain applications that each received update
represents the cumulative changes over a certain time period. For example,
considering figure 4.2.3-1, each of the file updates.
\- That occur at the start of update intervals N and N+1 (i.e. at the times
t~(N)~ and t~(N+1)~), and which may occur within update interval N will convey
the cumulative changes between the time interval t~(N)~ and t~(N+1)~. Example
application: USD reception.
\- If it\'s not important for the application to obtain file updates in a
cumulative manner, then any file update, occurring either at the start of an
update interval, or within an update interval, will obsolete its previous
update. Example application: Live sports score and statistics updates.
\- Operators / Content providers may optimize the needed resources for the
service (cost optimization). Therefore the solution should allow for resource
efficient carousel deployment, e.g. by synchronizing UEs to the actual
transmission.
#### 4.2.3.5 Solution
The proposed solution involves a modification to the Schedule fragment. Under
the _sessionSchedule_ , we propose to add an _r12:recurrence_ element, which
will signal the nominal update interval and delivery mode selection between
back-to-back and scheduled-and-periodic Datacasting delivery modes. Figures
4.2.3-3 and 4.2.3-4 provide a design view of the modifications proposed to the
Schedule Description fragment schema.
Figure 4.2.3-3: Design view of the _serviceScheduleType_ in the Schedule
Description schema
Figure 4.2.3-4: New Release 12 extension of the Schedule Description schema in
support Datacasting
Back-to-back Datacasting mode is indicated through the _mode_ attribute set to
true.
Scheduled and periodic delivery of Datacasting is indicated through the mode
attribute set to false.
The _updateInterval_ element indicates the nominal time interval offile
updates for the associated Datacasting service. In the case of scheduled-and-
periodic datacasting, the start time in UTC of each session occurrence may be
determined relative to the sessionSchedule.start element.
For the case of scheduled and periodic Datacasting, a UE that has tuned in to
a Datacasting service after the end of a given session among a recurring
series of sessions may encounter a significant delay before it can initially
acquire file contents on that service, by having to wait for the next session
occurrence. A solution for this might be to allow the UE to perform a unicast
request of the most recently transmitted Datacasting content, by using file
repair request based solely on Schedule Description fragment information,
according to the MI-EMO enhancement called \"File Repair without FDT\", see
clause 4.2.4 of the present document.
### 4.2.4 File Repair without FDT
#### 4.2.4.1 Description
##### 4.2.4.1.1 Use Case #1 -- Device is tuned to another frequency
Sam is subscribed to a real-time \"BBA Live\" basketball MBMS video service
which allows her to watch live basketball games on her device. The real-time
service is broadcast over MBMS using frequency band 1. Sam\'s mobile device is
also configured to receive software updates via an MBMS Firmware OTA service
that is broadcast over frequency band 2. Sam has been watching a live BBA game
on her device during the time that a firmware download for her device has been
scheduled for delivery over the MBMS FOTA service. Having missed the broadcast
delivery window for the file while Sam was watching the game, the device
retrieves the software update from a file repair server.
##### 4.2.4.1.2 Use Case #2 --Device is powered-off
Tom is a news junkie who is subscribed to the \"CMN\" news service which
periodically broadcasts news articles throughout the day. Tom regularly
commutes between Boston and San Diego for work every week and is diligent
about placing his phone in \"airplane mode\" when he flies. During his flights
Tom\'s phone is unable to download the news articles that are broadcast while
he is in the air. When Tom lands he disables \"airplane mode\" and his device
downloads the missing news articles from the file repair server so that Tom
can start catching up on his news feed.
##### 4.2.4.1.3 Use Case #3 --Device is out of MBMS coverage but in good
unicast coverage
Beth is a postwoman who delivers mail in some areas without eMBMS coverage
(MBMS signal is weak). Her GPS relies on broadcast traffic updates for route
selection. While in the areas with low coverage, the device downloads missing
traffic updates from the file repair server. Beth\'s GPS always selects the
best travel routes.
#### 4.2.4.2 Recommended Requirements & Evaluation Criteria
Derived recommended requirements from the above use cases are listed below.
\- A UE that is unable to receive a file and its FDT during the scheduled
broadcast window is able to fully recover the file from the repair server.
\- The UE is able to make the request for the file from symbol-based repair
servers and conventional HTTP servers.
\- It is desirable for the UE to be able to determine the MD5 of the latest
version of the file of interest.
\- The UE is able to determine the list of files in a session that do not have
a file schedule.
#### 4.2.4.3 Gap Analysis & Evaluation
##### 4.2.4.3.1 Existing Technologies
Clause 7.4 of 3GPP TS 26.346[2] defines OMA Push procedures that a terminal
can use to download files of interest from an MBMS Download service when the
terminal is not in broadcast coverage. The procedures for using the specified
OMA Push mechanism are as follows:
\- When the terminal detects that it is outside of broadcast coverage it
registers with the BM-SC for an OMA Push of the FDTs for files belonging to
the user service. If the terminal is subscribed to multiple user services then
it registers for an OMA Push of FDTs for all these services.
\- If a file for any of the registered services is sent over the MBMS bearer
the BM-SC sends the corresponding FDT to the terminal via an OMA Push.
\- Upon receipt of the FDT, the terminal uses a unicast bearer to download the
corresponding file from the repair server.
\- When the terminal detects that it has entered broadcast coverage it should
then de-register from receiving FDTs via OMA Push. This is needed to avoid
wasting unicast bearer capacity with the unnecessary Push of FDTs to the
terminal.
##### 4.2.4.3.2 Consequences of Existing Technologies
The following clauses analyze the applicability of the OMA Push procedures to
the above agreed use cases.
##### OMA PUSH for Use Case #1 -- Device is tuned to another frequency {#oma-
push-for-use-case-1-device-is-tuned-to-another-frequency .H6}
Using the above described OMA Push procedures for this use case would cause
the terminal to register and de-register each time the user tuned in and out
of a higher priority program on another frequency band. This process can
become frequent when the user is channel surfing between frequency bands.
Hysteresis can be applied to reduce the number registrations and de-
registrations but the amount of hysteresis has to be tempered against the
probability that the terminal will miss a Push or receive an unnecessary Push
of the FDTs. Furthermore, if the terminal is subscribed to multiple services
being sent on the frequency it is tuning away from, the terminal has to
register and de-register for all these services.
Result: Using the OMA Push procedures for this use case can cause frequent
and/or multiple registrations and de-registrations by the terminal.
##### OMA PUSH for Use Case #2 -- Device is powered-off or in airplane mode
{#oma-push-for-use-case-2-device-is-powered-off-or-in-airplane-mode .H6}
When a device is powered off or is set to airplane mode it does not have the
opportunity to register for an OMA Push of the FDTs. If the file(s) of
interest is/are broadcast while the device\'s radio is off the device will not
be pushed the FDT(s) of the file(s) when the device returns to coverage. The
result is that the device will not be able to retrieve the file(s) of
interest.
Result: If the terminal relies on the OMA Push procedures for this use case
then the device does not receive the FDTs and is unable to retrieve the
missing files of interest.
##### OMA PUSH for Use Case #3 -- Device is out of MBMS coverage but in good
unicast coverage {#oma-push-for-use-case-3-device-is-out-of-mbms-coverage-but-
in-good-unicast-coverage .H6}
To avoid unnecessary push of the FDT the terminal de-registers when it can
access the MBMS broadcast bearer. As the terminal travels through areas where
broadcast coverage is spotty, the terminal registers and de-registers for the
OMA Push. Hysteresis can be applied to reduce the number registrations and de-
registrations but again, the amount of hysteresis has to be tempered against
the probability that the terminal will miss a Push or receive an unnecessary
Push of the FDT. If the user is subscribed to multiple services then the
terminal has to register and de-register for all of these services.
Result: Using the OMA Push procedures for this use case can cause frequent
and/or multiple registrations and de-registrations by the terminal.
##### 4.2.4.3.3 Summary of Gap Analysis
The key limitation of the OMA Push procedure is that to enable efficient
delivery of files or FDTs, the terminal has to notify the network when the
terminal can and cannot receive broadcasts. This procedure does not
sufficiently address all of the above use cases as it cannot deliver the FDTs
or files in cases where the terminal is unable to register for the OMA Push.
Furthermore, the procedure introduces additional signalling overhead in other
use cases.
One other consideration is that the OMA Push mechanism is an optional
procedure that may not be deployed in some networks. Providing a simpler
alternative for delivering the FDT info could be useful in these scenarios.
It is recommended that other mechanisms be considered to address the above use
cases that can reliably deliver the FDT or file of interest to the terminal
and do not introduce any additional signalling overhead.
#### 4.2.4.4 Assumptions
The following working assumptions are made for this use case:
\- The UE is able to obtain the Associated Procedure Description and the
Schedule Description Fragment for the file that the UE is interested in
downloading.
\- The Schedule Description Fragment has a File Schedule for the file of
interest and/or a Session Schedule for the session in which the file of
interest is broadcast.
\- If the File Schedule for the file of interest is present it may or may not
have the MD5 of the file.
#### 4.2.4.5 Solution
The Schedule Description specified in 3GPP TS 26.346 [2] enables the UE to
determine the following information from the Session Schedule and File
Schedule:
\- The stop/end time after which a file of interest is no longer going to be
broadcast
\- The fileURI and fileMD5 of the file of interest
With the above information and the Associated Procedure Description, the UE
can determine when and where to retrieve a file which it was unable to receive
over the broadcast bearer. By making use of information already available to
the UE, this mechanism does not require use of OMA Push procedures nor any
additional signalling. This also supports reliable delivery of the relevant
FDT information in all of the use cases identified in clause 2.
_Minimum Required Changes_
Even though the relevant information is made available to the UE in the
Schedule Description, the current procedures in 3GPP TS 26.346 [2] do not
specify that the UE can be triggered to initiate a file repair/download when
reaching the stop time of the session schedule or the end time of the file
schedule. These additional triggering conditions would need to be clarified in
the specification.
_Further Enhancements_
In the following cases the UE does not already have the information needed to
download the missing file from the file repair server:
\- When the File Schedule is not provided in the Schedule Description fragment
\- The file of interest is to be retrieved from a conventional HTTP-based
repair server
The above cases can be addressed by adding a URL in the Session Schedule that
points to an FDT for the file(s) belonging to the session. This is illustrated
in figure 4.2.4-1 below. Once the UE determines that it has missed the
broadcast of the file(s) of interest the UE can retrieve the FDT from the URL
and then download the file(s) from the repair server.
Figure 4.2.4-1: Adding URI of FDT to sessionSchedule
The solution described above can also be used by a terminal to make a fast
acquisition of datacasting information when the terminal tunes-in to a
scheduled datacasting session. If the terminal tunes-in some time before the
next scheduled broadcast it can use the FDT referenced in the sessionSchedule
to quickly download the initial datacasting information.
### 4.2.5 Zapping Portal Services
#### 4.2.5.1 Description
##### 4.2.5.1.1 Use Case #1 --Fast Zap Video
A mobile network operator provides an MBMS streaming service whereby fast
zapping between the offered channels is enabled. The user is able to browse
the available channels while receiving the live video and audio content of the
currently selected channel, without any perceivable delays when switching
between each channel.
##### 4.2.5.1.2 Use Case #2 --Mosaic Service
A mobile network operator offers a \"Mosaic channel service\", as an MBMS
streaming service, as well as linear services like broadcast TV. A \"mosaic
channel\" provides a mosaic of small video images that offers convenient
access to each of the streaming services.
When a user taps a point on the mosaic screen, the pointed (small) video is
highlighted and the associated audio is presented.
Alternatively, when the mosaic channel application starts, the top-left mosaic
element is highlighted by default and its associated audio is presented. When
the user navigates among the mosaic elements, the respective video element is
highlighted and its associated audio is presented instead.
One further use case variant is when the mosaic elements are different views
of the same live event. In this case the audio stream could be the same for
all of the mosaic video elements.
When the user flicks the screen, another mosaic channel appears. Mosaic
channels can be provided as groups of thematically categorized channels, for
example one mosaic containing only sports channels, the next containing only
news channels, etc. In this way the user\'s search and selection of a channel
to view can be aided.
When the user double-taps a point on the mosaic screen, the pointed service is
selected and the user exits the mosaic service. Then the video is presented on
the full screen together with the associated audio.
#### 4.2.5.2 Recommended Requirements & Evaluation Criteria
The following general recommended requirements are considered:
\- The service is supported through MBMS broadcast.
\- The service may also be supported through unicast or enhanced/extended by
unicast.
\- It should be possible to enable a solution based on DASH.
\- The solution enables lip-synced presentation of thumbnail video and audio.
\- The solution enables the continued presentation of audio while
switching/transitioning video from thumbnail to main.
Detailed presentation layout is out-of-scope of the EMO work item, but
presentation layer aspects may be considered in 3GPP.
The following recommended requirements pertain to the server-generated mosaic
approach:
\- The solution might rely on a presentation layer that enables the service
provider to realize the navigation of the component video streams embedded
within a single video stream that is provided to the UE.
The following recommended requirements pertain to the UE-generated mosaic
approach:
\- All components of the mosaic service are carried in the same broadcast
bearer.
\- The delivery of the different service components is done such that is power
and network-efficient.
\- The UE implementation supports decoding of multiple thumbnail video
streams. It might make sense to determine what is the reasonable assumption of
how many streams can be decoded and presented concurrently, also to allow UE
implementations to work around the limitation in concurrent stream decoding
and presentation by way of concessions, e.g. displaying a less frequently
updated, or static still picture for some component streams.
##### 4.2.5.2.1 Fast Zap Video
One possible approach to enabling zapping-optimized video streams is to
constrain the \"fast zap video\" stream as follows:
\- Short RAP time period, and RAPs should be able to be signalled to the UE.
\- Small DASH segment size, to be switchable frequently.
With this approach it may be appropriate for the UE to be able to:
\- Find \"fast zap video\" streams and to consume those streams through the
MBMS broadcast/multicast bearer.
\- Switch to the original channel stream with which the fast zap video stream
is associated, when the end user selects the channel to watch.
##### 4.2.5.2.2 Mosaic Service
In principle there are two distinct approaches to facilitate the mosaic
service: server-generated mosaic, and UE-generated mosaic.
In both approaches,the UE is able to;
\- Find mosaic channel stream and to consume that stream through MBMS bearer.
\- Switch between component audio streams as the active/highlighted thumbnail
video stream is changed.
\- Resolve the source of original channel stream to consume when the user
selects one of the video thumbnails.
\- Consume preferred mosaic channel over MBMS bearer.
The two approaches are described in the following sub-clauses.
###### 4.2.5.2.2.1 Server-generated Mosaic
In this approach the server (BM-SC or external entity) provides the mosaic
video stream by encoding a single video stream that contains miniature
versions of each service\'s video that is to appear in the mosaic, e.g. a 2x2
mosaic as depicted in figure 4.2.5-1. This video stream is embedded in an
application whereby the navigable elements of the user interface include four
virtual screen selections around each of the mosaic video components. The
application logic translates between the highlighted or selected user
interface element and the underlying video component, so that the appropriate
component of the mosaic is presented, along with its associated audio, when
selected by the user.
{width="5.298611111111111in" height="2.609722222222222in"}
Figure 4.2.5-1: Example 2x2 mosaic application screen
The server-generated mosaic relieves the UE of the burden of decoding multiple
video components simultaneously, since this capability might not be common
among UE implementations so far.
###### 4.2.5.2.2.2 UE-generated Mosaic
In this approach the server (BM-SC or external entity) provides reduced
spatial resolution versions of each available service\'s video. The UE offers
a set of these on the screen by decoding the miniature versions, e.g. four of
them in a 2x2 mosaic, and presenting them on the screen within an application
that enables the user to select any one of them for presentation. Only the
audio from the highlighted service is presented.
This approach enables more customization of the mosaic at the UE but it
requires that the UE is capable of decoding and presenting multiple component
video streams simultaneously.
An alternative variant for UEs that are not capable of decoding and presenting
multiple video streams concurrently is where the UE decodes and presents only
the highlighted mosaic video component and the other mosaic elements contain
either an icon and/or a decoded still picture from the respective service. As
the user navigates among the mosaic elements, decoding and presentation only
of the highlighted element resumes.
#### 4.2.5.3 Gap Analysis & Evaluation
##### 4.2.5.3.1 Fast Zap Video
\- Signalling may need to be defined to signal that the service streams are
optimized for the fast zapping use case.
##### 4.2.5.3.2 Mosaic Service
\- Signalling may need to be defined to signal that the service stream is for
mosaic channel.
\- No means in MPD [which should reference _MPEG-DASH or 3GPP-DASH_] is
defined:
\- Signal that the component audio streams are associated with the main video
stream in the mosaic service, and that those audio streams are switchable.
\- Signal the case when a single audio stream is associated with all component
video streams (multi-view event use case).
\- Indicate navigation anchors to resolve associated original streaming
services being converted to configure main mosaic video stream.
As one possible solution for a single USD, the mosaic channel service can be
supported by the following means with existing TS 26.247 [3] and TS 26.346 [2]
specifications:
\- Associate 1 MPD with each \"channel\". The MPD contains at least the
following:
\- One Adaptation Set for the Thumbnail video
\- One Adaptation Set for the Main Video
\- One Adaptation Set for the Audio
\- Note that the Adaptation Set may contain multiple Representations and some
of them may be available through unicast.
\- Provide a DASH over MBMS in the USD that includes a reference to the \"TV
channel\" MPD.
\- Deliver all thumbnails videos in one FLUTE session that is mapped to a
TMGI.
\- Enable the delivery of the each of the main video/audio in a different
FLUTE session/TMGI than the FLUTE session carrying the thumbnails.
\- Enable the delivery of certain components of unicast.
Based on the above solution outline, following are additional procedures may
be considered to support the mosaic channel service:
\- Specify procedures for the distribution of a TV channel over multiple FLUTE
sessions/TMGIs.
\- Specify details if, and how, MPD updates are delivered.
The above considerations for mosaic service are relevant for MBMS.
Different recommended requirements, not directly applicable to MBMS, arise for
each of the possible mosaic service variants:
\- For the server-generated mosaic service, presentation layer functionality
needs to be considered in order to be able to present and navigate the mosaic
components on the UE.
\- For the UE-generated mosaic:
\- The service provider should provide the thumbnail version of the video
component of each service, as well as the full-resolution version.
\- The UE capability as regards the concurrent decoding and presentation of
multiple video components needs to be considered.
#### 4.2.5.4 Assumptions
#### 4.2.5.5 Solution
### 4.2.6 Joint object protection
#### 4.2.6.1 Description
##### 4.2.6.1.1 Use Case
A live event is expected to generate a lot of interest among mobile users, so
the mobile operator decides to offer it via MBMS. To reduce content
preparation overhead, the service is offered as is over MBMS, i.e. using DASH.
The content was prepared with separate Adaptation Sets and Representations for
each media component (Audio, Video, Text, ...). The transmission power is
required to be used efficiently in the SFN area, which results in fair to poor
reception quality at some spots of the SFN area.
The media data is protected against channel errors and packet losses using
FEC. The user is able to consume the service at acceptable quality for all
media components and with reasonable start up delay.
#### 4.2.6.2 Recommended Requirements & Evaluation Criteria
The following recommended requirements apply:
\- The solution should minimize the delay to recover and acquire the media
content that is protected by FEC from the time the loss is detected until the
time the recovered data is made available to the application.
\- The solution should provide improved error resilience that results in equal
protection for all media components of the content.
#### 4.2.6.3 Gap Analysis & Evaluation
#### 4.2.6.4 Assumptions
The following working assumptions are extracted:
\- The solution should be based on FEC.
\- The importance of all components of the media presentation should be the
same.
\- The FEC protection period should be aligned among the different components
of the media presentation so not to jeopardize media synchronization.
#### 4.2.6.5 Solution
### 4.2.7 Multiple FLUTE Sessions for an MBMS User Service
#### 4.2.7.1 Use Case Descriptions
##### 4.2.7.1.1 Multiple Media Streams of a DASH-over-MBMS service
A mobile network operator offers a DASH-over-MBMS service comprising multiple
media streams. One such service is a live sports event for which multiple
camera angle views are provided from which the user may choose to watch as an
inset window along with the main display of the game. Alternatively, the user
may select a specific camera angle view as the primary display. Another DASH-
over-MBMS service delivers popular TV episodes, for which different audio
languages are offered. The user is able to choose the preferred audio language
track for play-out along with the video stream. In a third service offering,
two different resolution quality versions of the same program are offered, to
cater to different user devices -- for example a smartphone with a smaller
display vs. a tablet or PC with larger screen size.
##### 4.2.7.1.2 Hybrid Service Comprising Streaming and Auxiliary File
Contents
A mobile network operator offers hybrid MBMS services which contain a real-
time audio/video stream along with one or more auxiliary file delivery
components. The first service offering is a live car race which is associated
with two auxiliary file delivery components. The first file delivery component
is synchronized race statistics providing information on the leader including
his/her instantaneous and average speed, and current race standings. The
second file component is the delivery of targeted advertisements associated
with location filtering criteria. The second service offering is that of a
live music concert associated with information on the performers and upcoming
tour calendar and related information.
#### 4.2.7.2 Recommended Requirements & Evaluation Criteria
The following are recommended requirements in support of the agreed use cases
and assumptions on multiple FLUTE sessions per service:
\- The service provider is able to provision and operate MBMS user services in
which the multiple media and/or content components of a given service are
delivered on different FLUTE sessions as defined by separate Session
Description instances which are in turn referenced by _deliveryMethod_
instances.
\- The MBMS receiver is able to unambiguously determine the type of media
component or content item (streaming audio, streaming video, timed text,
advertisements, Datacasting files, etc.) carried in each of the FLUTE sessions
employed in the delivery of the overall MBMS user service.
\- The delivery schedule of a particular media component or content item, in
association with the FLUTE session over which it is carried, can be
provisioned independently of the delivery schedule of any other media
component/content item.
\- The delivery schedule of any given media component or content item, in
association with the FLUTE session over which it is carried, can be
unambiguously determined by the MBMS receiver.
\- It is possible for the service operator to unambiguously assign, and the
MBMS receiver to unambiguously identify, one or more FLUTE sessions for
carryinginband USD metadata fragment updates.
\- The service provider is able to specify service area dependent availability
of one or more individual media components of the MBMS service.
\- It is possible for each Reception Report message from the UE to explicitly
identify the FLUTE session delivering the content to which the report
pertains.
#### 4.2.7.3 Gap Analysis & Evaluation
The description below cites some deficiencies in the existing TS 26.346 [2]
for supporting the recommended requirements listed in clause 4.2.7.2.
##### 4.2.7.3.1 Application Identification
It is not possible using the existing USD schema, for example the SDP, to
unambiguously announce/identify the specific content type carried on a given
transport session. For example, different file contents might include targeted
ads and game statistics (the latter representing Datacasting file contents
delivered in conjunction with a live streaming sports event). While these
might be generically identified as application-specific content by assigning
the media line (\"m=\") in the SDP with the value \'application\', that is
insufficient, and a more fine-grain means for identifying different file
contents is desirable.
##### 4.2.7.3.2 Schedule to Session Mapping
The current Schedule fragment does not provide sufficient capability to ensure
that unambiguous binding, between the indicated session schedules and the
multiple FLUTE sessions over which the contents affiliated to those schedules
are transmitted, can always be attained. For example, in download delivery
services whereby only the session schedule for each FLUTE session is present
in the Schedule Description fragment, (i.e. _fileSchedule_ is not
instantiated), the Schedule Description schema does not identify the Session
Description associated with each instance of _sessionSchedule_. This is
illustrated by the content model of the Schedule Description fragment in
Figure 4.2.7-1 below.
Figure 4.2.7-1: Schedule Description schema
##### 4.2.7.3.3 Service Area Specific Availability of Media Components
In the current USD, the _availabilityInfo_ element enables the designation of
RF frequency/frequencies and associated service area(s) for which a given MBMS
User Service is available for reception. The _serviceArea_ element under
_infoBinding_ , if present, indicates the one or more service areas in which
the entire MBMS User Service (i.e. all of its content components) is available
for reception. In contrast, it is desired for the Rel-12 service area
dependence feature to apply to individual content components of the MBMS User
Service, not the entirety of contents belonging to that service. The service
area specific components are assumed to be available in the same frequency. A
means already exists via the USD to signal the available service area(s) of
individual streaming media components of a DASH-over-MBMS service carried over
separate FLUTE sessions. However, it is not possible to define the available
service area(s) availability of individual non-real-time (NRT) file content
items of an MBMS user service, each carried on a separate FLUTE session.
##### 4.2.7.3.4 Inband USD Metadata Fragment Delivery
Currently, inband delivery of certain USD metadata fragments (Session
Description, Associated Delivery Procedure Description, Schedule Description
and Filter Description) is specified in TS 26.346 [2]. However, it is not
possible to designate a specific transport session (one or more such FLUTE
sessions) to carry either all or a portion of the inband metadata fragment
updates. A downside consequence of the current specification is that inband
metadata fragment updates is carried in all of the FLUTE sessions. Doing so is
undesirable in the consumed bandwidth for inband delivery of metadata fragment
updates, or may impose practical limitation on the frequency of metadata
updating on each session.
##### 4.2.7.3.5 Unambiguous Identification of FLUTE Session Associated with
Reception Report
The XML syntax of a Reception Report message, also referred to as a reception
report request, as currently defined in TS 26.346 [2] is shown in figure
4.2.7-2 below.
Figure 4.2.7-2: Reception Report message XML syntax as currently defined in TS
26.346
For an MBMS User Service whose content components are delivered on separate
FLUTE sessions, reception reporting may be required for a multiplicity of
those sessions, in accordance to an Associated Delivery Procedure Description.
As seen in Figure4.2.7-2, when the receptionAcknowledgement child element of
receptionReport is present, the Reception Report message is the \"RAck\" type,
conveying successful file reception information. When the statisticalReport
child element of receptionReport is present, the Reception Report message is
the \"StaR\" type, providing statistical reception information. The RAck
report type does not contain explicit identification of the FLUTE session
delivering the content to which the report pertains. Although the structure of
a statistical report includes an optional sessionId attribute (under
medialevel_qoeMetrics), the use of media-level QoE metrics is only applicable
to statistical reporting of RTP streaming, not for a DASH-over-MBMS service.
In order to use medialevel_qoeMetrics\@sessionId as identifier of the FLUTE
session, it would be necessary to change the implied semantics in TS 26.346
[2] for the usage of media-level QoE metrics in a StaR type of reception
report.
##### 4.2.7.3.6 Multiple MBMS Bearers Consideration
Assume that the following conditions are applicable:
\- The network distributes the content components of a MBMS User Service using
multiple FLUTE sessions over multiple MBMS bearers, and
\- Those content components required for the consumption of a given MBMS
application service are delivered on separate MBMS bearers.
In that situation, users of MBMS UEs which only support a single MBMS bearer
at a time and therefore could only acquire a subset of the contents of that
MBMS application service would be subject to a degraded user experience. The
advantage of the multiple FLUTE sessions over multiple MBMS bearers feature
cannot be fully utilized by such UEs.
The potential for user service degradation, due to multiple FLUTE sessions
carried over multiple MBMS bearers, should be taken into consideration.
#### 4.2.7.4 Assumptions
The following list of working assumptions is associated with the use cases
described in clause 4.2.7.1.
\- The network operator may wish to optimize or increase the flexibility of
the delivery of an MBMS service containing multiple streaming media or
discrete file data component. Reasons may include, but are not limited to: a)
allowing different data rates, and FEC parameters to be specified for the
delivery of each content component, b) configuration of file repair or
reception reporting parameters, or carousel repetition rate to be provisioned
per delivery session and not simply per MBMS User Service, and c) simplified
scheduling -- any content component belonging to the MBMS User Service can be
sent at a unique transmission window independent of the transmission times of
the other content components.
\- An MBMS user service that comprises multiple media components/content items
may be delivered or over multiple FLUTE sessions, each of which corresponds to
a specific FLUTE Session Description referenced by one or more instances of
_deliveryMethod._
\- The MBMS service provider may wish to define unique service areas in which
particular media component(s) of an MBMS User Service containing multiple
media streams are delivered or available for reception. For example, for a
sports event comprising an overall stadium-level camera view, and additional
field-level camera views, the service provider may wish for the field camera
views along with the stadium camera view to be made available only to viewers
situated at the stadium or its immediate vicinity. On the other hand, the
service provider wishes to impose the restriction that only the stadium camera
view is accessible to the national or regional audience which subscribes to
the same MBMS User Service.
\- An MBMS capable UE is only required to support reception of a single MBMS
bearer service at a time i.e. reception of more than one MBMS bearer service
is up to UE implementation.
#### 4.2.7.5 Solution
The solution components pertaining to multiple FLUTE sessions for an MBMS
sevrice, in support of the recommended requirements and gap analysis indicated
in clauses 4.2.7.2 and 4.2.7.3 are described in this clause.
##### 4.2.7.5.1 Schedule to Session Mapping
A central recommended requirement inthe present document is the ability of the
service provider to provision and operate MBMS user services in which the
multiple content components of a given service are delivered on different
FLUTE sessions. This means the individual content components of an MBMS
service, be that a continuous media stream (e.g. audio or video), or discrete
media (e.g. a text or image file), can be carried/received on separate FLUTE
sessions, each of which is described by an SDP file referenced by an
individual _deliveryMethod_ child element of the element
_userServiceDescription_. In addition, there is recommended requirement that
the delivery schedule of a particular media component or content item (in
association with the FLUTE session over which it is carried) can be
provisioned independently of the delivery schedule of any other media
component/content item.
As described in the gap analysis in clause 4.2.7.3.2 of the present document,
it is desirable but currently not possible to use the _sessionSchedule_
element of the Schedule Description to indicate the transmission schedule of
the contents carried in any given FLUTE session. This is due to the absence in
the _sessionSchedule_ of an identifier for the associated FLUTE session. A
simple fix is to add an optional _sessionDescriptionURI_ attribute to
_sessionSchedule_ , identifying the FLUTE session to which this session
schedule applies. This is shown in figure 4.2.7-1 below:
Figure 4.2.7-1: Addition of Session Description reference to _sessionSchedule_
##### 4.2.7.5.2 Inband USD Metadata Fragment Delivery
One of the identified gaps in multiple FLUTE sessions per MBMS service
pertains to inband delivery of USD metadata fragments (one or more types among
Session Description, Associated Delivery Procedure Description, Media
Presentation Description, Schedule Description and Filter Description) as
specified in TS 26.346 [2]. As described inthe present document, clause
4.2.7.3.4, currently it is not possible to designate one of those FLUTE
session to carry all of the metadata fragment eligible to be delivered in-band
with an MBMS download session (\"in-band delivery\" for short). The downside
consequence being that in-band metadata fragment updates is carried in all of
the FLUTE sessions, which is undesirable in wasting bandwidth resources for
in-band delivery of metadata fragment updates, or may impose practical
limitation on the frequency of metadata updating on each session.
The proposed solution is to add an optional attribute _r12:inbandMetadata_
under the _deliveryMethod_ element in the USD. This attribute, when set to
\"true\" or \"1\" indicates that all metadata fragments eligible for in-band
delivery are carried along with the media/content on the FLUTE session
associated with that _deliveryMethod_ instance. From the UE behavior
perspective, it should listen to the FLUTE session designated for carrying all
in-band delivery of fragment updates, even if the UE elects not to consume
content delivered on that FLUTE session.
The XML schema of the _deliveryMetho_ d element with addition of the
_r12:inbandMetadata_ child element is shown below in figure 4.2.7-2.
{width="2.622916666666667in" height="5.438194444444444in"}
Figure 4.2.7-2: Addition of r12:_inbandMetadata_ attribute under
deliveryMethod
##### 4.2.7.5.3 Application Identification
It should be possible to unambiguously announce/identify the specific content
type carried on a given transport session. One of the use cases inthe present
document is a hybrid MBMS service containing a real-time audio/video stream
along with one or more auxiliary file delivery components, with these content
components carried on separate FLUTE sessions. As described in clause
4.2.7.3.1, the use of the \ parameter in the \"m=\" line of the SDP
(RFC 4566, [2]) is inadequate for identifying different auxiliary file
components, for example, game statistics, targeted advertisements, and
upcoming events information, that are associated with a live football game.
The proposed solution framework is to add a parameter to the User Service
Bundle Description fragment to identify the content component(s) carried by
each FLUTE session of the associated MBMS User Service. Specifically, it is
proposed that a new (optional) child element _r12:appComponent_ be added to
the _deliveryMethod_ element, since each FLUTE session of the MBMS service is
described by an SDP file (or Session Description fragment) referenced by a
separate instance of _deliveryMethod_. One or more instances of
_r12:appComponent_ may be present under a given _deliveryMethod_ instance, to
indicate the same number and types of content component(s) carried on the
associated FLUTE session. The collection of _r12:appComponent_ names across
all _deliveryMethod_ instances of an MBMS User Service represents the entire
set of content components types comprising that service.
The values of _r12:appComponent_ are defined and controlled by MBMS
applications, and similar to the _serviceClass_ element in the USD, are
outside the scope of 3GPP standardization,. _r12:appComponent_ values are
passed from the MBMS client to the UE application associated with that MBMS
User Service, thus enabling the application to determine the content component
offerings for that MBMS User Service. Subsequently, the application can inform
the MBMS client of which components to be acquired (received) over MBMS
delivery and forwarded to the application.
It is assumed here that one FLUTE channel is allowed per FLUTE session.
The XML schema of the _deliveryMetho_ d element with addition of the
_r12:appComponent_ child element is shown below in figure 4.2.7-3:
Figure 4.2.7-3: Addition of _r12:appComponent_ element under _deliveryMethod_
##### 4.2.7.5.4 FLUTE Session Association with Reception Report
As described in clause 4.2.7.3.5, an additional recommended requirement for
multiple FLUTE sessions per MBMS service is that it should be possible for
each Reception Report message sent from the UE, regardless of the report type,
to explicitly identify the FLUTE session delivering the content to which the
report pertains. The proposed solution is as follows. First, it is proposed to
add to the Reception Report message, whose XML syntax is defined in TS 26.346
[2], clause 9.5.3, the optional attribute _sessionId_ under the
_receptionAcknowledgement_ element, as shown below in figure 4.2.7-4.
Figure 4.2.7-4: Addition of _sessionId_ attribute under
_receptionAcknowledgement_ element of\ Reception Report message
In addition, the use of the sessionId attribute under the StaR type of
reception reports (i.e. StaR, StaR-all and StaR-only), specifically,
_[receptionReport.statisticalReport.qoeMetrics.medialevel_qoeMetrics\@sessionId]{.underline}_
, will serve to identity the FLUTE session for a given StaR type reception
report. Note also since the _medialevel_qoeMetrics_ element is nominally used
to declare QoE metrics associated with RTP streaming content, only the
_sessionId_ attribute (i.e., none of the other attributes of this element)
should be present under _medialevel_qoeMetrics_ in a StaR type reception
report pertaining to media components of a DASH-over-MBMS service.
##### 4.2.7.5.5 Service Area Specific Availability of NRT Content Components
of a Service
As described in clause 4.2.7.3.3, it is not possible to define service area
dependent availability of non-real-time (NRT) file contents of an MBMS user
service carried over multiple FLUTE sessions. The proposed solution, as shown
below in figure 4.2.7-5, is to add to the _deliveryMethod_ element a child
element _r12:serviceArea_. One or more instances of _r12:serviceArea_ may be
present, each of which specifies the service area in which the NRT contents
delivered on the FLUTE session associated with that instance of
_deliveryMethod_. The semantics of _r12:serviceArea_ complies to the _MBMS
Service Area Identity_ as defined in TS 23.003 [7] and TS 36.443 [8].
It is assumed here that one FLUTE channel is allowed per FLUTE session.
Figure 4.2.7-5:Addition of _r12:serviceArea_ element under _deliveryMethod_
### 4.2.8 Targeted Ad Insertion
#### 4.2.8.1 Description
The growth of video distribution services (e.g. streaming, download,
broadcast, TV, etc.) has driven advertisers to better target users by
personalized advertisements and increase the likelihood of viewing for their
ads by the users and their relevance to the users\' needs/interests. In the
meantime, in broadcast networks such as those based on e-MBMS, from the point
of view of ad insertion, a typical approach today is to insert the ads before
broadcast and distribute ads via broadcast just like the main video content.
This gives little opportunity to target ads to obtain a better return on
investment, since all the users would be receiving the same advertisements.
**Use Case:**
Two major soccer teams of a populated city are to play a derby match against
each other over the weekend. Since the game is expected to generate a lot of
interest among the fans, the operator plans to offer the service over MBMS to
its subscribers. The operator plans on delivering separate sets of targeted
ads to the club fans, i.e., to be played back during the game breaks, etc.,
toward promoting the products from the fan stores of each soccer club, sharing
club related news, etc.
#### 4.2.8.2 Recommended Requirements & Evaluation Criteria
\- It is possible to support targeted ad insertion in MBMS.
\- It is possible to broadcast main content and ads, and enable insertion of
targeted ads with the support of the client.
\- For live events, it is possible to schedule delivery of targeted such that
they can be inserted into the main content in real-time.
\- It is possible for the MBMS clients to selectively receive ads delivered
through MBMS according to user traits.
#### 4.2.8.3 Gap Analysis & Evaluation
The following gaps are identified:
\- Targeted ad content delivery over MBMS is only possible by sending all ad
related resources over the same FLUTE session on the same TMGI. Then reception
is typically done with the promiscuous approach as defined in clause 7.2 of TS
26.346 [2] due to the inability to associate ad content with a specific group
identified by specific user traits.
\- It is not possible to allow MBMS clients to selectively receive ad content
delivered through MBMS according to user traits, in order to enable the one-
copy operation to instruct FLUTE to receive a copy of one or more specific
files (identified by the fileURI or potentially other patterns).
#### 4.2.8.4 Assumptions
The following is a set of proposed assumptions associated with the use case,
recommended requirements and gap analysis defined for targeted Ad insertion.
It is assumed that targeted Ad insertion operates in the context of a
streaming service delivered as DASH formatted contents over MBMS.
\- The occurrence time(s) of the Ad break(s) may or may not be known at the
time of MPD generation.
\- If the Ad break occurrence (i.e., its start time) is known at the MPD
generation time, a corresponding XLink reference to a remote Period element
will be contained in that MPD
\- If the Ad break occurrence is unknown at the MPD generation time, either
synchronous or asynchronous MPD update mechanism may be used to provide an
XLink reference to a remote Period, or Ad-related event information may be
carried inband in Media Segments.
\- If Ad provider provides classification information associated with Ads to
the BM-SC, the BM-SC may broadcast the classification information as filter
data via the USD or through FDT.
\- Classification information on the user is known or derived by the
application, which provides that information to the MBMS client via the DASH
client.
\- The mechanism used by the application to acquire or derive the user
classification information for the purposes of targeted/personalized Ad
insertion is outside the scope of 3GPP.
\- The MBMS client uses the classification information in conjunction with the
filter data to perform selective download and caching of Ad(s)
personalized/targeted for the local user.
\- The DASH client is agnostic of the transport mode of Ads and will fetch Ad
Segments using the Segment URLs indicated by/derived from the inserted Period
element.
#### 4.2.8.5 Solution
##### 4.2.8.5.1 Proposed Architecture
**A reference system architecture comprising functional entities involved in
the delivery of metadata, MPD updates, DASH-formatted media content and
targeted Ads from the content provider and ad source to the UE is shown below
in figure 4.2.8-1.**
Figure 4.2.8-1: Example System Architecture for Targeted Ad Delivery in DASH-
over-MBMS
###### 4.2.8.5.1.1 User Classification
**It is assumed that the MBMS service application (e.g. the \'XYZ Football
App\') is aware of the user classification for Ad personalization purposes.
How this is done (e.g. the App may have access to user profile/preference
information, subscription data, content consumption history, or a content
recommendation engine) is outside the scope of TS 26.346 [2]. For simplicity,
assume that user classification information can be summarized by a group
identifier or _groupID_ value which is passed from the App to the DASH client.
In turn, the DASH client will forward this value to the MBMS client.**
###### 4.2.8.5.1.2 Ad Break and MPD Updating
**Remote Period elements in the MPD inform the DASH client of the description
and access information for Ad contents. There are two scenarios and associated
means for informing the DASH client, via the remote Periods, about impending
Ad breaks:**
1) If the occurrence time(s) of Ad break(s) is known at the time of MPD
generation, an MPD which contains one or more remote Period elements could be
sent to the DASH client well in advance of the Ad break occurrence. Updates of
the MPD, if any, will be provided via existing procedures, i.e. the use of
**MPD** \@minimumUpdatePeriod.
2) If the occurrence time(s) of Ad break(s) is unknown at the time of MPD
generation, MPD update functionality, for example based on synchronous MPD
updates with periodicity defined by **MPD** \@minimumUpdatePeriod, is used to
signal an impending targeted Ad insertion event.
Scenario 2, involving unpredictable occurrence of Ad breaks which trigger
dynamic MPD updates will be assumed in the remaining discussion. The nominal
interaction between the DASH client and the MPD server (latter assumed to
reside in the UE, and part of the MBMS client which may include a local HTTP
proxy and cache) for acquisition of the latest MPD is periodic. However, the
occurrence of Ad breaks can be strictly unpredictable in time, for example as
result of an injury time-out during a football game. Depending on the expected
set-up time of the Ad break -- starting from the triggering event (e.g. the
time-out) to the actual splice time of the Ad insertion, the
MPD\@minimumUpdatePeriod value can be adjusted accordingly so that such
dynamic event will not be missed by the DASH client. When updated, the MPD
will carry a pointer to a remote Period element via Period\@xlink:href.
###### 4.2.8.5.1.3 XLink Resolution and Customized Periods
To signal an impending Ad break, a notification or \"cue\" message indicating
the upcoming splice point is received by the MPD generator, which then creates
a new/updated MPD for the same program, by adding reference to a remote Period
in the updated MPD. Personalization/targeting parameters derived from the cue
message are inserted into the Period\@xlink:href attribute of the inserted
Period. For example, the xlink:href for the remote Period is represented as
\"[http://adservice.com/?group=\"value]{.underline}.
###### 4.2.8.5.1.4 Selective Ad Reception
It is not necessary for the MBMS receiver to download and cache all broadcast
Ads (targeted to different user classifications/_groupID_ \'s), since it will
have access to filter data associated to the scheduled delivery of each Ad
content. For each Ad, its filter data will be identical to the XLink URL sent
by the DASH client for XLink resolution and Period acquisition, i.e. a
customized remote Period URL, for example \"http://adservice.com/?group=X\",
\"http://adservice.com/?group=Y\" or \"http://adservice.com/?group=Z\". The
MBMS client can subsequently match its remote Period URL with the filter data
to perform selective downloading and caching of Ads broadcast according to
their delivery schedules. Different ways are possible to convey the URL-based
filter data for the associated Ads to support selective ad reception by the
MBMS client. For example, the existing Filter Description fragment could be
extended by adding a new child element _groupFilter_ under the _filterData_
element, as identifier for the corresponding ad file whose delivery schedule
is announced by an instance of file schedule. It may also be possible for a
FLUTE FDT extension attribute _groupID_ to be specified for the Ad file
identified by the TOI and Content-Location. We favor the use of the former
mechanism for two reasons:
1) The Filter Description fragment is designed for extensibility in carrying
general-purpose filtering information for targeted/personalized reception of
different contents by the MBMS receiver, with location-based filtering
initially defined in Rel-11 TS 26.346 [2].
2) Content filtering at the FDT level means that the MBMS receiver has to be
powered on at the start of each broadcast ad, and can only be powered off
after having determined the absence of a match between the remote Period URL
and the filter data. It is more battery power efficient for the MBMS receiver
to have a-priori knowledge of whether a particular Ad delivery session is of
interest, which is enabled by use of the Filter Description fragment,
available to the MBMS receiver prior to the broadcast delivery of contents.
**It should be possible for broadcast transmission of Ads to occur well in
advance of the ad break (e.g. overnight before the football game the next
day), or closer in time preceding the actual Ad break. Selective download and
caching of Ads by the MBMS client is achievable by assuming that it performs
the XLink resolution (and therefore can perform URL matching against the
filter data) prior to the scheduled broadcast of the corresponding Ad.**
**Note that the filter criterion is not restricted to a remote Period in DASH.
The filter is general with the following semantics:**
\- If the filter contains a single URL, then the download delivery session
should deliver all objects referenced directly or indirectly by the URL during
the announced schedule.
\- If the filter contains a regular expression (\"regex\") pattern, i.e. a
sequence of characters that forms a search pattern, then the download delivery
session should deliver all objects for which the pattern matches the FDT\'s
\"Content-Location\" attribute of that object during the announced schedule.
##### 4.2.8.5.2 Example Call Flow
An example call flow illustrating targeted ad insertion for a DASH-over-MBMS
service based on the architecture and procedures described in clause 4.2.8.5.1
is shown below in figure 4.2.8-2. Note that in step 14 of the call flow,
broadcast Ad files are likely to be delivered on a separate FLUTE session from
that/those carrying DASH media streams. This is due to the possibly large
bandwidth requirement to send a sizeable number of multimedia Ad files (for
selective reception by UEs using the filte data in the USD).
Figure 4.2.8-2: Example Call of Targeted Ad Insertion for DASH-over-MBMS\
based on architecture in Figure 4.2.8-1
### 4.2.9 Generic Application Service Delivery over MBMS
#### 4.2.9.1 Description
##### 4.2.9.1.1 Example 1: Broadcast of MPEG-DASH
In this case an MPEG-DASH service is mapped to the Application Service concept
introduced in clause 4.2.1.5.2.
Assume a basic DASH service with the following MPD:
* * *
\\ \\ \
\http://example.com/\\ \example.mpd\\
\ \\ \\ \\ \\ \\ \\
\\ \\ \\ \\
\\ \\ \\ \\ \\ \\
\\ \\ \\ \
* * *
Assume the following scenario:
1) The audio and the V2 video of the above Media Presentation is distributed
over MBMS.
2) They are all included in one FLUTE session.
3) The MPD and the Initialization segment are delivered as part of the USD
fragment.
##### 4.2.9.1.2 Example 2: Combined Unicast/Broadcast DASH
In this case the same service as in 1 is available, but in addition different
Representations are available on unicast, but the DASH client is not made
aware of the different delivery methods. In addition, the DASH formats are
conforming to a specific profile and the service provider wants to signal this
in order for clients to be able to accept/reject the service based on this
signalling.
Assume the following scenario:
1) The audio and the V2 video of the above Media Presentation is distributed
over MBMS.
2) They are all included in one FLUTE session.
3) The MPD and the Initialization Segment are delivered as part of the USD
fragment.
4) All data is also available on unicast.
##### 4.2.9.1.3 Example 3: Combined Unicast/Broadcast DASH with Transport
Awareness in DASH client
In this case the same service as in 2 is available, but the DASH client is
made aware of the different delivery methods.
Assume the following scenario:
1) The audio and the V2 video of the above Media Presentation is distributed
over MBMS
2) They are all included in one FLUTE session
3) The MPD and the Initialization segment are delivered as part of the USD
fragment
4) All data is also available on unicast.
5) The DASH client is made aware of different delivery methods.
##### 4.2.9.1.4 Example 4: Apple HLS
In this case parts of an HLS service are provided through MBMS, namely the
playlist and one Representation. Assume the following basic setup:
\- A master index file may reference alternate streams of content. HLS offers
alternate streams with different bitrates so that the client automatically
switches to the optimal bitrate based on the network conditions for a smooth
quality playback experience.
\- Both the master index file and the alternate index files are in .m3u8
playlist format. The master index file is downloaded only once, but for live
broadcasts the alternate index files are reloaded periodically.
\- The first alternate listed in the master index file is the first stream
used and after that the client chooses among the other alternatives by
available bandwidth.
\- The master m3u8 looks like this:
#EXTM3U
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2300000
http://example.com/high.m3u8
#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=500000
http://example.com /low.m3u8
The different high and low m3u8 are updated periodically with new segment
URLs.
The service provider wants to distribute such a service in a smart manner
using the capabilities of MBMS to deliver static data, data through unicast,
data through broadcast and also reuse exiting HLS clients. Figure 4.2.9-1
shows an example for this case.
{width="5.268055555555556in" height="3.4381944444444446in"}
Figure 4.2.9-1: HLS delivery through MBMS
##### 4.2.9.1.5 Example 5: Web Page
#### 4.2.9.2 Recommended Requirements & Evaluation Criteria
#### 4.2.9.3 Gap Analysis & Evaluation
#### 4.2.9.4 Assumptions
#### 4.2.9.5 Solution
### 4.2.10 Improve MBMS OTA efficiency
#### 4.2.10.1 Description
##### 4.2.10.1.1 Use Case #1 --Keep Updated Data Service
The user is interested in software updates for his smartphone or some of the
applications in his smartphone. Because those applications are very popular,
the operator wants to avoid that a significant amount of downloads of the same
resource occur at the same time over the unicast channel. Instead, the updated
resources are delivered over MBMS for more economical resource usage. The UEs
are informed about file updates of interest to them. The UEs then join the
dedicated MBMS service to receive these updates.
#### 4.2.10.2 Recommended Requirements & Evaluation Criteria
The following recommended requirements are derived from the keep updated use
case:
\- The BM-SC can inform the clients about the availability of a keep updated
service and how the UE can use it.
\- The keep updated service is flexible enough to carry a changing set of
different types of content.
\- The BM-SC is able to select or elect what file it wants to offer via the
keep updated service based on the number of interested receivers for that
file.
\- The solution would reuse existing signalling and metadata formats as much
as possible.
\- The solution would be scalable.
#### 4.2.10.3 Gap Analysis & Evaluation
A keep updated service based on the MBMS delivery method is already defined in
TS 26.346 [2]. However, this service assumes that all UEs will remain tuned to
the MBMS service even if there are currently no updates available. It also
does not have any tools to enable the BM-SC to deliver file updates that are
of interest to the UE, so that the UE has no control about what files are
delivered.
The USD defines several metadata fragments that are used to describe the
content of the service. In particular the schedule description metadata
fragment is relevant for this use case, as it enables the BM-SC to inform UEs
about the scheduled files for delivery.
There is also need to ensure that MBMS user services may have silence gaps,
where there is no need to establish MBMS bearers and no data broadcast is
taking place. Alternatively, each time a new update set is made available, a
new USD service is established and the client is informed. Depending on that,
the configuration of the keep updated service may differ.
The following working assumptions pertain to the keep update service:
\- The UEs is able to acquire the file either via broadcast or as a fallback
via unicast.
\- Depending on popularity, efficient use of network resources would be
targeted by offering the content over eMBMS whenever possible.
#### 4.2.10.4 Assumption
#### 4.2.10.5 Solution
As described in the use case, a UE has an app management application, which
keeps track of installed applications and provides access to the application
store (i.e. it acts as a front end to the app store). In order to assist the
app management application and optimize the resource usage, an operator may
decide to make use of the MBMS delivery channel to deliver the app and
firmware updates. The operator offers a keep updated service for this purpose.
The app management application and the MBMS middleware are configured to
recognize and use the keep updated. The app management application is made
aware of the service and it provides its install base to the MBMS middleware.
The MBMS middleware registers the apps with the BM-SC based on the description
provided in the USD of the keep updated service. The MBMS middleware registers
with the OMA PUSH client to receive updates of the USD and USD fragments.
Whenever a set of updates becomes available, the BM-SC sends over OMA PUSH a
schedule description fragment that contains a description of the files that
are contained in that update set. The MBMS middleware tunes in to the keep
updated MBMS service and receives the file of interest for the receiver and
makes it available to the app management application directly or via a cache.
If the file is only available over unicast, the MBMS middleware will inform
the app management application about that, so that it will be downloaded over
the unicast channel.
The procedure is described in figure 4.2.10-1.
Figure 4.2.10-1: Keep-Updated Service
### 4.2.11 Multi-Program Support:
#### 4.2.11.1 Description
##### 4.2.11.1.1 Use Case #1 --Portal and Association
A service provider attempts to offer multiple programs/channels using DASH
over MBMS user services. In order to do so, the service provider wants to
optimize the bundling of the different multiple programs in order to optimize
the delivery and presentation of the user service, for example to create a
portal. For this purpose the service provider wants to provide metadata to
signal that several user services form one multiprogramming offering and may
provide data that is relevant for a portal service or for all services within
the bundle. The service provider also want to associate the TV programs on the
delivery level.
##### 4.2.11.1.2 Use Case #2 --Fast Start-up and Rapid Channel Change
When offering multiple TV programs in a portal using DASH over MBMS user
services, the service provider uses application layer FEC for each for each of
the services in order to provide good and consistent user experience. In
addition, the service provider wants to provide excellent user experience when
accessing the service and especially when changing channels within the
service. Fast start-up and fast channel change should be enabled. The MBMS
client may be connected to unicast or may be in broadcast only mode. The
service provider wants to provide good user experience in both cases. Note
that the service provider may have deployment cases where it is interested in
both low end-to-end latency and low channel change and access time, and other
cases where it is only interested in low channel change and access time, but
not necessarily in low latency.
#### 4.2.11.2 Recommended Requirements & Evaluation Criteria
#### 4.2.11.3 Gap Analysis & Evaluation
#### 4.2.11.4 Assumptions
#### 4.2.11.5 Solution
### 4.2.12 Robust DASH operation in live services
#### 4.2.12.1 Description
When operating DASH-based live services, errors and failures are typically
unavoidable. In order to still provide continuous services, DASH-based service
offerings should be offered in a robust manner and DASH client should
implement measures to compensate any operational issues. In case of DASH-over-
MBMS distribution, additional problems may occur due to segment losses or
other problems.
Typical Problems are:
\- Client Server Synchronization Issues
\- Synchronization Loss of Segmenter
\- Encoder Clock Drift
\- Segment Unavailability
\- Swapping across Redundant Tools
#### 4.2.12.2 Recommended Requirements & Evaluation Criteria
The solutions are expected to fulfil the issues of robustness in order to
provide service continuity and smooth play-out.
#### 4.2.12.3 Gap Analysis & Evaluation
TS26.247 lacks tools for signalling segment gaps, for wall-clock time
synchronization and for robust multi-period offerings.
#### 4.2.12.4 Assumptions
Tools that are defined in MPEG-DASH ISO/IEC 23009-1 are preferable.
#### 4.2.12.5 Solution
The tools are proposed to be added to TS 26.247:
\- Early Terminated Periods as defined in ISO/IEC 23009-1:2014 Cor.1
\- UTC Time Synchronization as defined in ISO/IEC 23009-1:2014 Amd.1
\- Guidelines on robust multi-period offerings
The following solutions are proposed to be added to TS 26.346:
\- DASH Robustness Guidelines including solutions for:
\- Client Server Synchronization Issues referring to tools in TS 26.247
\- Synchronization Loss of Segmenter referring to tools in TS 26.247
\- Encoder Clock Drift referring to tools in TS 26.247
\- Segment Unavailability referring to tools in TS 26.247
\- Swapping across Redundant Tools referring to tools in TS 26.247
## 4.3 Related Change Requests
The changes required have been included is TS 26.346 [2].
# 5 Conclusion
The present document provides the following results of the MI-EMO work item:
\- Descriptions of the use cases and enhancements.
\- Documentation of any associated recommended requirements, evaluation
criteria, assumptions, and gap analysis for each of the use cases and
enhancements.
\- Solutions that enable the uses cases and enhancements are listed below.
\- Switch from HTTP-based unicast delivery method to MBMS download delivery
method
\- Datacasting Services
\- FLUTE enhancements
\- File Repair without FDT
\- Multiple FLUTE Sessions for an MBMS User Service
\- Targeted Ad Insertion
\- Improve MBMS OTA efficiency
\- Robust DASH operation in live services
#
# Foreword
The present document describes the detailed mapping of the general audio
service employing the aacPlus general audio codec within the 3GPP system.
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of this TS, it will be re-released by the TSG with an identifying
change of release date and an increase in version number as follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 Indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the specification;
# 1 Scope
This Telecommunication Standard (TS) describes the SBR encoder part of the
Enhanced aacPlus general audio codec [3].
# 2 Normative references
This TS incorporates by dated and undated reference, provisions from other
publications. These normative references are cited in the appropriate places
in the text and the publications are listed hereafter. For dated references,
subsequent amendments to or revisions of any of these publications apply to
this TS only when incorporated in it by amendment or revision. For undated
references, the latest edition of the publication referred to applies.
[1] ISO/IEC 14496-3:2001/Amd.1:2003, Bandwidth Extension.
[2] ISO/IEC 14496-3:2001/Amd.1:2003/DCOR1.
[3] 3GPP TS 26.401 : Enhanced aacPlus general audio codec; General Description
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of this TS, the following definitions apply:
**band:** (as in limiter band, noise floor band, etc.) a group of consecutive
QMF subbands
**chirp factor:** the bandwidth expansion factor of the formants described by
a LPC polynomial
**Down Sampled SBR:** the SBR Tool with a modified synthesis filterbank
resulting in a down sampled output signal with the same sample rate as the
input signal to the SBR Tool. May be used whenever a lower sample rate output
is desired.
**envelope scalefactor:** an element representing the averaged energy of a
signal over a region described by a frequency band and a time segment
**frequency band:** interval in frequency, group of consecutive QMF subbands
**frequency border:** frequency band delimiter, expressed as a specific QMF
subband
**noise floor:** a vector of noise floor scalefactors
**noise floor scalefactor:** an element associated with a region described by
a frequency band and a time segment, representing the ratio between the energy
of the noise to be added to the envelope adjusted HF generated signal and the
energy of the same
**patch:** a number of adjoining QMF subbands moved to a different frequency
location
**SBR envelope:** a vector of envelope scalefactors
**SBR frame:** time segment associated with one SBR extension data element
**SBR range:** the frequency range of the signal generated by the SBR
algorithm
**subband:** a frequency range represented by one row in a QMF matrix,
carrying a subsampled signal
**time border:** time segment delimiter, expressed as a specific time slot
**time segment:** interval in time, group of consecutive time slots
**time / frequency grid:** a description of SBR envelope time segments and
associated frequency resolution tables as well as description of noise floor
time segments
**time slot:** finest resolution in time for SBR envelopes and noise floors.
One time slot equals two subsamples in the QMF domain
## 3.2 Symbols
For the purposes of this TS, the following symbols apply:
Description of variables defined in one sub clause and used in other
subclasses.
_ch_ is the current channel, and when used as index in vectors left channel is
represented by _ch_ = 0 and right channel is represented _ch_ = 1.
**E** _~Orig~_ has _L~E~_ columns where each column is of length _N~Low~_ or
_N~High~_ depending on the frequency resolution for each SBR envelope. The
elements in **E** _~Orig~_ contains the envelope scalefactors of the original
signal.
{width="1.3465277777777778in" height="0.2916666666666667in"} has two column
vectors containing the frequency border tables for low and high frequency
resolution.
{width="0.375in" height="0.2222222222222222in"} internal sampling frequency of
the SBR Tool, twice the sampling frequency of the core coder (after sampling
frequency mapping, Table 4.55). The sampling frequency of the SBR enhanced
output signal is equal to the internal sampling frequency of the SBR Tool,
unless the SBR Tool is operated in downsampled mode. If the SBR Tool is
operated in downsampled mode, the output sampling frequency is equal to the
sampling frequency of the core coder.
**f** _~Master~_ is of length _N~Master~_ +1 and contains QMF master frequency
grouping information.
**f** _~TableHigh~_ is of length _N~High~_ +1 and contains frequency borders
for high frequency resolution SBR envelopes.
**f** _~TableLow~_ is of length _N~Low~_ +1 and contains frequency borders for
low frequency resolution SBR envelopes.
**f** _~TableNoise~_ is of length _N~Q~_ +1 and contains frequency borders
used by noise floors.
_k~x~_ the first QMF subband in the SBR range.
_k~0~_ the first QMF subband in the **f** _~Master~_ table.
_L~E~_ number of SBR envelopes.
_L~Q~_ number of noise floors.
_M_ number of QMF subbands in the SBR range.
_middleBorder_ points to a specific time border.
_N~L~_ number of limiter bands.
_N~Master~_ number of frequency bands in the master frequency resolution
table.
_N~Q~_ number of noise floor bands.
{width="1.0277777777777777in" height="0.25in"} number of frequency bands for
low and high frequency resolution.
_numPatches_ a variable indicating the number of patches in the SBR range.
_numTimeSlots_ number of SBR envelope time slots that exist within an AAC
frame, 16 for a 1024 AAC frame .
{width="1.2916666666666667in" height="0.25in"} offset-values for the SBR
envelope and noise floor data, when using coupled channels.
**patchBorders** a vector containing the frequency borders of the patches.
**patchNumSubbands** a vector holding the number of subbands in every patch.
**Q** _~Orig~_ has _L~Q~_ columns where each column is of length _N~Q~_ and
contains the noise floor scalefactors.
{width="0.8888888888888888in" height="0.2222222222222222in"} frequency
resolution for all SBR envelopes in the current SBR frame, zero for low
resolution, one for high resolution.
_reset_ a variable in the encoder and the decoder set to one if certain
bitstream elements have changed from the previous SBR frame, otherwise set to
zero.
**t** _~E~_ is of length _L~E~_ +1 and contains start and stop time borders
for all SBR envelopes in the current SBR frame.
_t~HFAdj~_ offset for the envelope adjuster module.
_t~HFGen~_ offset for the HF-generation module.
**t** _~Q~_ is of length _L~Q~_ +1 and contains start and stop time borders
for all noise floors in the current SBR frame.
## 3.3 Abbreviations
For the purposes of this TS, the following abbreviations apply.
> NA Not Applicable
>
> aacPlus Combination of MPEG-4 AAC and MPEG-4 Bandwidth extension (SBR)
>
> Enhanced aacPlus Combination of MPEG-4 AAC, MPEG-4 Bandwidth extension (SBR)
> and MPEG-4 Parametric Stereo
>
> QMF Quadrature Mirror Filter
>
> SBR Spectral Band Replication
# 4 Outline description
This TS is structured as follows:
Section 5.1 gives an encoder overview description. Section 5.2 gives a
detailed description of the filterbanks used in the encoder. Section 5.3 gives
a specification of the used frequency band tables. Section 5.4 gives a
detailed description of the time grid calculation and the transient detection.
Section 5.5 gives a detailed description of the envelope estimation. Section
5.6 gives a detailed description of the estimation of the additional control
parameters. Section 5.7 gives detailed description of the data quantisation.
Section 5.8 gives a detailed description of the envelope coding.
# 5 SBR encoder description
## 5.1 SBR tools overview
The encoder part of the SBR tool estimates several parameters used by the high
frequency reconstruction method on the decoder side. In order to synchronise
the SBR bitstream data with the AAC codec, the two different modes of
operation have to be considered; normal aacPlus operation and aacPlus
parametric stereo operation. In the normal case, the AAC encoder is
responsible for downsampling of the input PCM signal, while the SBR encoder
works in parallel on twice the sampling frequency compared to the downsampled
signal. When using parametric stereo aacPlus, the SBR tool is also responsible
for downsampling of the AAC coder signal. The two modes are outlined in the
following sections and illustrated in Figure 1 and Figure 2.
{width="6.0375in" height="1.8097222222222222in"}
Figure 1 aacPlus block diagram
{width="5.149305555555555in" height="1.895138888888889in"}
Figure 2 Parametric stereo aacPlus block diagram
### 5.1.1 Enhanced aacPlus sdynchronization without parametric stereo
The time domain input PCM signal is assumed to be stored in a buffer **x** ,
where 2048 new samples are added to the end of the buffer every frame. Before
adding new samples, all samples in the buffer must be left-shifted 2048
samples. The buffersize amounts to 576 + 2048 + _t_ ~inputDelay~ samples,
where _t_ ~inputDelay~ equals the total AAC delay, i.e. the delay for the
entire encoder -- decoder chain, plus the SBR decoder buffer delay minus the
SBR encoder buffer delay. All delays are expressed in the SBR input sampling
rate:
{width="3.44375in" height="0.25in"}
The PCM buffer **x** is fed to the analysis QMF bank, where subband filtering
is performed. The window stride of the QMF bank is illustrated in Figure 3a,
which shows that the first window is applied from sample 0 to sample 639 on
the PCM buffer. The output from the analysis QMF bank: 32 subbands having 64
frequency channels each, is stored in the matrix **X** (Figure 3b) as
{width="4.25in" height="0.20833333333333334in"}
A delay of qmfWriteOffset subband samples is hence introduced, making
{width="1.8333333333333333in" height="0.20833333333333334in"}
The algorithmic buffer delay in the decoder is 6 subband samples, giving
{width="1.75in" height="0.20833333333333334in"}
The total AAC delay is the delay introduced by the 1024 point MDCT transform,
the window switching look-ahead and the delay introduced by the downsampling
filter. If other delays are introduced these of course have to be accounted
for.
{width="6.690277777777778in" height="3.9159722222222224in"}
Figure 3 aacPlus encoder buffers and synchronisation
### 5.1.2 Enhanced aacPlus synchronisation with parametric stereo
The time domain input PCM signal is assumed to be stored in a buffer **x** ,
where 2048 new samples are added to the end of the buffer every frame. Before
adding new samples, all samples in the buffer must be left-shifted 2048
samples. The buffersize amounts to 576 + 2048. Note that two buffers are
needed for stereo signals.
The PCM buffer is fed to the analysis QMF bank, where subband filtering is
performed. The window stride of the QMF bank is illustrated in Figure 4a,
which shows that the first window is applied from sample 0 to sample 639 on
the PCM buffer. The output from the analysis QMF bank: 32 subbands having 64
frequency channels each, is stored in the matrix **H** (Figure 4b) as
{width="3.486111111111111in" height="0.25in"}
Two buffers are needed for stereo operation. The subband samples in the matrix
**H** are fed to the hybrid filter bank (See [5]) which introduces a delay of
6 subband samples. Parametric stereo parameters are extracted from the output
of the hybrid filterbank and downmixing of the stereo signal is performed.
Subsequently, hybrid synthesis filtering is applied to the modified hybrid
subband samples.
The downmixed subband samples are fed to the subband matrix **X** (Figure 4c)
as
{width="4.333333333333333in" height="0.25in"}
whereafter \"normal\" SBR operation is undertaken. The subband samples are in
parallell fed to the 32 channel synthesis filter bank. The stride for the
synthesis windowing is illustrated in Figure 4d. The output from the
filterbank, having a sampling frequency half of the SBR sampling frequency is
forwarded to the AAC encoder.
After SBR processing of the current frame, an additional delay of one frame
has to be introduced by delaying the SBR frame data (Figure 4e).
To achieve synchronisation, the total AAC codec delay is bound to be 3200
samples, expressed in the SBR input sampling frequency.
{width="6.690277777777778in" height="8.343055555555555in"}
Figure 4 Enhanced aacPlus stereo synchronisation
### 5.1.3 SBR encoder modules overview
The modules of the encoder part of the SBR tool are illustrated in the block
diagram of Figure 5. The SBR tool operates on discrete mono signals in
general, but some of the modules in Figure 5 need simultaneous access to both
the left and right signal in case of stereo signals.
\- As outlined in 5.1.1 and 5.1.2, the time domain signal is first filtered by
the 64 channel complex QMF bank (section 5.2). The output from the analysis
QMF bank: 32 subbands having 64 frequency channels each, is stored in the
matrix **X** as\ \ {width="4.291666666666667in" height="0.25in"}\ \ Several
modules use the output from the QMF bank;
\- The transient detector operates on the matrix **X** starting at subband
sample 0.
\- The frame splitter operates on the matrix **X** starting at subband sample
0.
\- The output from the transient detector and frame splitter is fed to the
frame generator, where the time and frequency resolutions for the current
frame are determined.
\- The Tonality detector operates on the matrix **X** starting at subband
sample qmfWriteOffset.
\- The control data from the Tonality detector and also the current time and
frequency grid is forwarded to the unit for Additional control parameters. In
this module, the levels of the adaptive noise, inverse filtering and
additional sines are determined.
\- The Envelope energy formatter operates on the matrix **X** starting from
subband sample 0. The unit needs the time frequency grid and the additional
control data as inputs.
\- The formatted envelope data is subsequently quantised and Huffman coded,
before being fed to the Bitstream multiplexer, where all SBR data is formatted
and packed into a SBR frame. The SBR frame is transmitted as a fill-element in
the bitstream multiplex together with the AAC channel element for the current
frame. In case of a Parametric stereo SBR element, the current SBR frame is
delayed one frame before entering the bitstream multiplexer (Section 5.1.2 ).
{width="7.027777777777778in" height="4.936111111111111in"}
Figure 5 Sbr Encoder overview
## 5.2 Analysis filterbank
Subband filtering of the input signal is done by a 64-subband QMF bank. The
output from the filterbank, i.e. the subband samples, are complex-valued and
thus oversampled by a factor two compared to a regular QMF bank. The flowchart
of this operation is given in Figure 6. The filtering comprises the following
steps, where an array **x** consisting of 640 time domain input samples are
assumed. Higher indices into the array corresponds to older samples:
\- Shift the samples in the array **x** by 64 positions. The oldest 64 samples
are discarded and 64 new samples are stored in positions 0 to 63.
\- Multiply the samples of array **x** by window **c**. The window
coefficients are found in Figure 6.
\- Sum the samples according to the formula in the flowchart to create the
128-element array **u**.
\- Build two arrays, **r** and **i** , from **u** by the operations
{width="2.3465277777777778in" height="0.4722222222222222in"}
\- Calculate 64 new complex-valued subband samples, **X** = **R** \+ i **I** ,
where i is the imaginary unit, by DCT and DST type III transforming **r** and
**i** according to
{width="2.9166666666666665in" height="0.94375in"}
Every loop in the flowchart produces 64 complex-valued subband samples, each
representing the output from one filterbank subband. For every SBR frame the
filterbank will produce {width="1.3888888888888888in"
height="0.18055555555555555in"} subband samples from every filterbank subband,
corresponding to a time domain signal of length {width="1.6111111111111112in"
height="0.18055555555555555in"} samples. In the flowchart **X**[k][l]
corresponds to subband sample l in QMF subband k.
{width="4.604166666666667in" height="9.136111111111111in"}
Figure 6: Flowchart of encoder analysis QMF bank
## 5.3 Frequency band tables
The SBR encoder use these different frequency band
tables:{width="0.3611111111111111in" height="0.2222222222222222in"},
{width="0.4861111111111111in" height="0.25in"}, {width="0.4583333333333333in"
height="0.2222222222222222in"} and {width="0.5in"
height="0.2222222222222222in"}, which are defined according to subclause
4.6.18.3.2 in [1]. The parameters needed to define all frequency band tables
are transmitted in the SBR bitstream header. For SBR header bitstream elements
enabled with either **bs_header_extra_1** or **bs_header_extra_1** there are
default values and hence a transmission of these elements are only needed if
they differ from the default value. Default values are defined in subclause
4.5.2.8.1 in [1]. The SBR header parameters are regarded as tuning parameters
since they are strongly bitrate and sampling frequency dependant Throughout
the tuning work for 3GPP submission several bitrate and sampling frequency
dependant tunings have been created and in the reference c-code there are
tunings available from 8kbit/s mono to 48 kbit/s stereo.
## 5.4 Time / frequency grid generation
An introduction to the time / frequency grid generation, including a brief
discussion of the frame classes, is given in the informal encoder description
in [1], subclause 4.B.18.3. The present encoder implementation employs three
tools for the grid generation:
\- The Transient Detector (TD)
\- The Frame Splitter (FS)
\- The Frame Generator (FG)
Those tools are described in the subsequent sections. Figure 7 shows the
ranges of the frame classes and the transient detector offset versus the
indices used by the frame generator.
\|\\|
\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|
0 1 2 3 4 5 6 7 8 9 A B C D E F TD index (hexadecimal)
\|\\|
\|\:\:
:\:\\|
:\:\:\: Ybuffer
................................................................ QMF slots
I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|o\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots
0 4 8 16 19 32 FG index
I: nominal frame boundaries
o: frame overlap region slots
Figure 7: The four frame classes and the transient detector range
### 5.4.1 Transient detector
The transient detection is performed according to the pseudo-code below. It
operates on subband samples of one frame length starting from sample 8\. The
output from the transient detector are the variables tranFlag and tranPos. The
first is a boolean indicating whether there is a transient in the processed
frame, and the second specifies the position (in time slots) for the on-set of
the transient. The time / frequency grid generation module uses the output
from the transient detector and the stored transient detection output from the
previous frame to perform its operations.
{width="1.5965277777777778in" height="1.0138888888888888in"}
{width="5.19375in" height="3.875in"}
{width="3.4583333333333335in" height="2.2916666666666665in"}
**t** and **a** are static channel-dependent arrays of length 64 that needs to
be stored in between calls to the transient detector. On start-up, all
elements in both arrays must be set to zero.
### 5.4.2 Frame splitter
The frame splitting is accomplished according to the following algorithm. It
is only active when the transient detector has detected the absence of a
transient in the current frame of interest, i.e. when tranFlag = 0). It
operates on subband samples of one and a half frame length starting from
subband sample 0. The output from the frame splitter is the variable
splitFlag, which indicates whether the current frame (free from transients)
should be divided into two envelopes of equal size.
{width="4.736111111111111in" height="4.638888888888889in"}
The variable {width="0.4305555555555556in" height="0.25in"} is a static
channel-dependent variable that must be stored in between calls to the frame
splitting module. This variable should be set to zero on start-up.
### 5.4.3 Frame generator
The frame generator creates the time/frequency grid for one SBR frame. Input
signals are provided by the transient detector and the frame splitter. The
frame generator produces two outputs: The sbr_grid() portion of the bitstream,
and an internal representation of the time/frequency grid to be used by the
envelope and noise floor estimators, see Figure 5.
When no transients are present (i.e. tranFlag = 0), FIXFIX class frames are
used. The frame splitter decides whether to use one or two envelopes in the
FIXFIX frames (splitFlag = 0 or splitFlag = 1 respectively). \"Sparse\"
transients (separated by one or more frames with tranFlag = 0) are coded by
means of FIXVAR-VARFIX sequences. \"Tight\" transients ( tranFlag = 1 for two
or more consecutive frames) are handeled by inserting VARVAR class frames.
As most transients are \"sparse\", the frame generator prepares a grid for a
FIXVAR-VARFIX pair upon detection of a transient after a sequence of FIXFIX
frames. The present frame is encoded using the FIXVAR portion, and the VARFIX
grid is stored. At the next call of the generator it is known whether the
transient actually is \"sparse\" or not. If \'yes\', the already calculated
and stored VARFIX grid is used. If \'no\', a new grid, meeting the
requirements of the new transient, as well as those of the previous one, is
calculated, whereby a VARVAR class frame is used.
The operation of the frame generator is further described below by means of
pseudo-code, where the syntax
[_out_ ~0~, _out_ ~1~, ..., _out_ ~m-1~] = _function_(_in_ ~0~, _in_ ~1~, ...,
_in_ ~n-1~) is used.
FrameGenerator(tranFlag, tranPos, splitFlag)
{
static frameClassOld; // frameClass used for previous frame
static G1; // grid designed during previous call
[frameClass, frameClassOld] = calcFrameClass(frameClassOld, tranFlag);
if (tranFlag)
GP = fillFrameTran(tranPos); // load transient borders into GP
switch (frameClass) {
case FIXFIX:
BS = calcSbrGrid(FIXFIX, dc, splitFlag);
break;
case FIXVAR:
if (tranPos > 8)
GP = fillFramePre(GP); // append borders before transient borders
if (tranPos \
\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|
0 1 2 3 4 5 6 7 8 9 A B C D E F TD index
*
\|\\|
N \| N
\|\\|\\|
................................................................ QMF slots
I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|o\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots
0 7 13 15 19 25 32 FG index
I: nominal frame boundaries
o: frame overlap region slots
*: border pointed to by bs_pointer
N: noise floor middle border
Figure 8: Example of isolated transient
In Figure 8. the borders at index 7, 13, 15 and 19 are used for the present
FIXVAR class frame. Conversion into sbr_grid() bitstream elements is performed
in calcSbrGrid(). The methods of the four classes for conversion of borders
and frequency resolutions are implicitely defined by the bitstream and
decoding equations in [1], subclause 4.4.2.8 (Table 4.61A) and 4.6.18.3, and
are hence not described here. In the example bs_var_bord_1 = 3, bs_num_rel_1 =
3, the relative borders have the lengths 4, 2 and 6 (\"right to left\"), and
the frequency resolutions are 0, 0, 1, 1 (\"right to left\"). The bs_pointer
is set to point to the transient leading border, i.e. the value is 3 since
FIXVAR borders are also indexed \"right to left\", starting from 1 (0 signals
that no transient leading border is present within the frame). The border at
index 19 must be followed up in the next frame by a leading border at index 3.
The border at 25, however, may or may not yield a border at 9, since a
transient is possible in frame n + 1. If the transient actually is \"sparse\",
the VARFIX bitstream comprises of bs_var_bord_0 = 3, bs_num_rel_0 = 1, one
relative border of length 6, bs_pointer = 0 and frequency resolutions 1, 1.
Figure 9. gives an example of \"tight\" transients, and also serves to outline
the functionality of fillFrameInter(). Here G1 contains borders at index 1 and
7, but a transient is located already at index 6. In fillFrameInter() the
preliminary border at 7 is simply removed, and the rest of the borders for the
present frame are taken from GP. (If on the other hand the distance between
the last border in G1 and the first border in GP exceeds 12, the segment
inbetween said borders is subdivided analogously to the procedures in
fillFramePre().) Hereafter GP is finalized and split in the same manner as
described above, whereafter G0 is converted into a bitstream using the VARVAR
method of calcSbrGrid(). Hereby the leading border yields bs_var_bord_0 = 1
and the trailing border bs_var_bord_1 = 2. Clearly bs_num_rel_0 = 0 and
bs_num_rel_1 = 3. Figure 9. also shows that fillFramePost() has inserted a
border at 18, thereby meeting the requirement that one border is present
within the interval [16, 19]. This concludes the description of how to
generate BS.
tranFlag = 1
tranPos = 2
\
I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
0 1 2 3 4 5 6 7 8 9 A B C D E F TD index
*
\|\\|
:1\| \| \|
:1\|\\|\\|
................................................................ QMF slots
I-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-Io\|o\|oI-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-\|-I
SBR slots
0 1 6 7 8 12 18 24 32 FG index
Figure 9: Example of tight transients
The second output of the frame generator, FI, comprises of **t** _~E~_ , **r**
, **t** _~Q~_ and _l_ ~A~. Since those signals are equivalent to their
counterparts at the decoder side, the relation between FI and BS is fully
defined by the decoding equations in MPEG-4. Thus, as the last step in the
frame generator, the decodeSbrGrid() function parses and decodes the now
available sbr_grid() portion of the bitstream in accordance with the
description in the MPEG-4 standard, which shall not be repeated here.
## 5.5 Envelope estimation
By using the time/frequency grid created by the framing generator and the
transient information from the transient detector, the QMF bank subband matrix
is grouped in time and frequency into envelope scalefactorbands. For each
scalefactorband the squared average energy is calculated and stored in the
energy matrix according to the recursion below.
{width="3.8465277777777778in" height="3.0965277777777778in"}
If a missing harmonic has been detected in a certain scalefactorband the
squared energy for that scalefatorband is calculated as the maximum energy
instead of average energy. Since the missing harmonics detection and
signalling always operate using the recursion shown below.
{width="4.527777777777778in" height="4.138888888888889in"}
For stereo with no channel coupling, the energy for every channel is
calculated as in the mono case shown above. In the case of stereo and coupling
the energy is calculated according to:
{width="4.333333333333333in" height="0.4305555555555556in"}
{width="3.861111111111111in" height="0.4861111111111111in"}
## 5.6 Additional control parameters
### 5.6.1 Introduction
In order to achieve optimal results, given the HF generator used in the
decoder, several additional parameters apart from the spectral envelope are
assessed. The noise floor is estimated for the current SBR frame. It is
defined as the ratio between the energy of the noise that should be added to a
particular frequency band, in order to obtain a similar tonal to noise ratio
to that of the original signal, and the energy of the HF generated signal for
that frequency band.
The noise floor is estimated once or twice per SBR frame dependent on the
number of spectral envelopes estimated for the SBR frame (indicated by
{width="0.18055555555555555in" height="0.25in"}). The frequency resolution for
the noise floor scalefactor is calculated according to the same algorithm
subsequently used in the decoder and described in [1] subclause 4.6.18.3. The
start and stop time borders of the different noise floors are given from the
time grid.
The level of the inverse filtering applied in the decoder is estimated for
different frequency ranges with the same frequency resolution as used for the
noise floor scalefactor estimation. The estimation algorithm compares the
tonality of the original and the tonality that will be attained after the HF
generator in the decoder. The ratio between the two is mapped to four
different inverse filtering levels, off, low, mid and high. These levels
corresponds to different chirp factors in the HF generator as outlined in [1]
subclause 4.6.18.5. Moreover, the encoder assesses where a strong tonal
component will be missing after the HF generation in the decoder. This
detection is done on the highest frequency resolution given by the high
frequency resolution table, **f** _~TableHigh~_. The level of the tonal
component is implicitly coded by the SBR envelope and the noise floor
scalefactors, and thus only the frequency needs to be coded.
## 5.6.2 Tonality estimation
The following detection modules base their output on a tonality estimate
calculated in the tonality estimation module:
\- Noise-floor estimation
\- Inverse filtering estimation
\- Additional sines estimation
The tonality is derived from the prediction gain of a second order linear
prediction performed in every QMF subband. The LPC is calculated using the
covariance method, and for every frame two tonality estimates are calculated
for every subband.
In the following, **X** is the matrix holding the most recently available
complex QMF subband samples. The tonality values are calculated and stored in
the **T** and **Tsbr** matrices. These also contain buffered values from
previous frames. The **Tsbr** values are obtained from the **T** values by
patching the tonality values similarly to the patching of the subband channels
in the high frequency reconstruction modules in the decoder.
Since the subband signals are complex valued, this results in complex filter
coefficients for the linear prediction. The prediction filter coefficients are
obtained from the covariance method. The covariance matrix elements for every
tonality estimate calculated are:
{width="4.541666666666667in" height="0.4722222222222222in"}
where _k_ is the subband index, and _l_ is the tonality estimate.
Based on the covariance elements the coefficients
{width="0.4166666666666667in" height="0.25in"}and
{width="0.4166666666666667in" height="0.25in"}used to calculate the tonality
estimates for the subbands are calculated as:
{width="2.8194444444444446in" height="0.44375in"},
{width="3.7777777777777777in" height="0.75in"},
{width="3.2777777777777777in" height="0.7638888888888888in"}.
where _~Inv~_ is the relaxation parameter ( _~Inv~_ = 1E-6 ).
The tonality values are calculated based on the above coefficients according
to:
{width="4.125in" height="0.5555555555555556in"}
{width="1.8611111111111112in" height="0.6111111111111112in"}
The tonality values are patched similarly to the patching of the QMF subbands
in the decoder during high frequency reconstruction. Hence, it is possible to
compare tonality of a \"simulated\" SBR signal and the original signal on the
encoder side. The patch used is built in accordance to the flowchart in Figure
4.46, subclause 4.6.18.6.3 in [1], where the output variable _numPatches_ is
an integer value specifying the number of patches. **patchStartSubband** and
**patchNumSubbands** are vectors holding the data output from the patch
decision algorithm.
Hence, the tonality values for the SBR part is obtained according to:
{width="1.7777777777777777in" height="0.25in"}
{width="2.5965277777777778in" height="0.7222222222222222in"}
for {width="4.055555555555555in" height="0.25in"}.
### 5.6.3 Noise-floor estimation
The noise floor estimation module estimates the amount of noise relative to
the energy of the patched SBR signal that should be added on the decoder side
in order to obtain a tonal to noise ratio similar to that of the original. The
estimation is based on the tonality values in the **T** and **Tsbr** matrices,
and the estimation is done for the number of frequency bands indicated by
_N~Q~_ , and the frequency ranges defined in **f** _~TableNoise~_ for the time
segments defined by {width="0.18055555555555555in" height="0.25in"}. The
algorithm below is outlined for noise floor band _nfBand_ for noise floor
_nfEnv_ and should be applied for all noise-floor bands, and noise floors in
the present frame. If the number of spectral envelopes for the present frame
is larger than one, two noise floors will be estimated, otherwise one. For the
case of two noise floors _startIndex_ will be zero for the first noise-floor
and one for the second noise-floor, while _stopIndex_ will be one for the
first noise-floor, and two for the second noise-floor. In case of only one
noise-floor, the _startIndex_ will be zero and the _stopIndex_ will be one.
The noise floor is calculated by averaging of the tonality values for the
given time/frequency range, or by choosing the maximum tonality value. The
latter is used if the additional sine detection algorithm detects that a sine
should be added on the decoder side for frequency band that is included in the
present noise floor frequency band.
Hence, for every noise floor band the tonality values are calculated according
to:
{width="4.819444444444445in" height="0.7638888888888888in"}
{width="5.027777777777778in" height="0.7638888888888888in"}
or, if a sine will be added at the decoder side as indicated by
\"missingHarmonicsFlag\", according to:
> {width="6.596527777777778in"
> height="0.3055555555555556in"}{width="7.027777777777778in"
> height="0.3055555555555556in"}
The tonality values _Tavg_ and _TavgSbr_ are subsequently used to calculate
the actual noise-floor value, according to:
{width="3.4583333333333335in" height="0.4722222222222222in"},
if the additional sine detection has indicated that there is a sinusoidal
missing in the present noise-floor band, or the inverse filtering level for
the present noise-floor band is equal or below INVF_LEVEL_MID. If neither of
these cases are true, the noise-floor value is calculated according to:
{width="4.569444444444445in" height="0.94375in"}
The noise-floor values are smoothed by applying a LP filter over time using
previous noise floor values. Hence for every _nfBand_ , the smoothing is done
according to:
{width="4.513888888888889in" height="0.4305555555555556in"}
where **nf** _~Prev~_ are the **nf** values from the previous estimates (where
the most recent estimates is placed at the end of the vector, i.e. position
2), and **h** is defined as:
{width="3.4166666666666665in" height="0.25in"}
### 5.6.4 Inverse filtering estimation
The inverse filtering detection is done on the frequency bands indicated by
**f** _~TableNoise~_ . For every band a tonality value is calculated from the
original input signal and the \"patched\" SBR signal. The values are mapped to
a specific regions given the \"Region borders\" in the detectorParamsAAC
struct, and the appropriate inverse filtering value is given from the \"Region
space\" also in detectorParamsAAC.
typedef enum
{
INVF_OFF = 0,
INVF_LOW_LEVEL,
INVF_MID_LEVEL,
INVF_HIGH_LEVEL
}
INVF_MODE;
static const DETECTOR_PARAMETERS detectorParamsAAC = {
{ 1.0f, 10.0f, 14.0f, 19.0f}, /* Region borders SBR. */
{ 0.0f, 3.0f, 7.0f, 10.0f}, /* Region borders Orig. */
{25.0f, 30.0f, 35.0f, 40.0f}, /* Region borders Nrg. */
4, /* Number of borders SBR. */
4, /* Number of borders orig. */
4, /* Number of borders Nrg. */
1.0f, /* Delta value for hysteresis. */
{ /* Region space. */
{INVF_MID_LEVEL, INVF_LOW_LEVEL, INVF_OFF, INVF_OFF, INVF_OFF}, /* \| */
{INVF_MID_LEVEL, INVF_LOW_LEVEL, INVF_OFF, INVF_OFF, INVF_OFF}, /* \| */
{INVF_HIGH_LEVEL, INVF_MID_LEVEL, INVF_LOW_LEVEL, INVF_OFF, INVF_OFF},
/*regionSbr*/
{INVF_HIGH_LEVEL, INVF_HIGH_LEVEL,INVF_MID_LEVEL, INVF_OFF, INVF_OFF}, /* \|
*/
{INVF_HIGH_LEVEL, INVF_HIGH_LEVEL,INVF_MID_LEVEL, INVF_OFF, INVF_OFF}, /* \|
*/
},/*------------------------ regionOrig \---------------------------------*/
{ /* Region space transient. */
{INVF_LOW_LEVEL, INVF_LOW_LEVEL, INVF_LOW_LEVEL, INVF_OFF, INVF_OFF}, /* \| */
{INVF_LOW_LEVEL, INVF_LOW_LEVEL, INVF_LOW_LEVEL, INVF_OFF, INVF_OFF}, /* \| */
{INVF_HIGH_LEVEL,INVF_MID_LEVEL, INVF_MID_LEVEL, INVF_OFF, INVF_OFF},
/*regionSbr*/
{INVF_HIGH_LEVEL,INVF_HIGH_LEVEL, INVF_MID_LEVEL, INVF_OFF, INVF_OFF}, /* \|
*/
{INVF_HIGH_LEVEL,INVF_HIGH_LEVEL, INVF_MID_LEVEL, INVF_OFF, INVF_OFF}, /* \|
*/
},/*------------------------ regionOrig \---------------------------------*/
{-4, -3, -2, -1, 0} /*Reduction factor of the inverse filtering for low
energies.*/
};
static const float hysteresis = 1.0f; /* Delta value for hysteresis. */
The parameters _Tavg_ and _TavgSbr_ are calculated for every inverse filtering
band by averaging the tonality values in the **T** and **Tsbr** matrices over
the frequency regions indicated by **f** _~TableNoise~_ according to (outlined
for band _invBand_):
{width="3.3465277777777778in" height="0.7361111111111112in"}
{width="3.5555555555555554in" height="0.7361111111111112in"}
The values are subsequently filtered by a two tap FIR filter according to:
{width="3.013888888888889in" height="0.2222222222222222in"}
{width="3.611111111111111in" height="0.2222222222222222in"}
where the {width="0.5277777777777778in" height="0.2222222222222222in"} and
{width="0.7222222222222222in" height="0.2222222222222222in"}are the _Tavg_ and
_TavgSbr_ from the previous frame.
The _avgNrg_ parameter is similarly calculated:
{width="1.75in" height="0.4305555555555556in"}
The region borders for the SBR tonality and the original tonality is modified
given previous values. The modification is done by adding the \"hysteresis\"
value to the upper border of the previous region, and subtracting the
hysteresis value from the lower border of the previous region. This gives the
region-borders used for the detection of the present band in the present
frame. The following pseudo-code outlines how the hysteresis is applied, where
the quantSteps are the region border given in detectorParamsAAC.
if(prevRegion \ 0)
quantStepsTmp[prevRegion - 1] = quantSteps[prevRegion - 1] - hysteresis;
The region corresponding to the filtered tonality values for the original and
the SBR signal is obtained by finding the region that has an upper border
higher than the present value, and a lower border lower or equal to the
present value. This means that if the present value is smaller than the first
value in the border vector, the region returned will be zero, and so on.
The regions for the original and the SBR signal are used to index the region
space as indicated by the detectorParamsAAC, and the inverse filtering level
value corresponding to the element pointed out by the region indexes is
returned. Different region spaces are used for frames where a transient is
detected.
Subsequently an energy compensation is applied. The energy-value calculated
from the auto correlation is mapped to a region defined in detectorParamsAAC.
The index value is subtracted from the inverse filtering level obtained from
the region space, and this gives the final inverse filtering level stored in
the _bs_inv_filt_ vector.
### 5.6.5 Additional sines estimation
The additional sines estimation module, estimates for which frequency bands a
strong sinusoidal component will be missing after high frequency
reconstruction in the decoder. The result of the detection may not include a
detection of a new siusoidal component unless the frame contains a transient,
as defined by the transient detector, or unless the previous frame contained a
transient positioned less than nine QMF slots from the trailing border of the
previous frame. Such a detection will be removed.
The detection algorithm firstly calculates the input data upon which detection
is done, based on the **T** and **Tsbr** values.
{width="5.513888888888889in" height="0.5416666666666666in"}
{width="5.708333333333333in" height="1.0965277777777778in"}
{width="6.180555555555555in" height="1.0965277777777778in"}
The detection system is based on using guide-vectors holding information on
previous detections. There are two different guide-vectors:
**\- guidevectorDiff** (has the frequency resolution of the scalefactorbands)
**\- guidevectorOrig** (has the frequency resolution of the QMF)
For every frame two tonality estimates in time are available, and hence two
estimates in time for the **diff** , **sfm** , **sfmsbr** parameters are
available as well. For every estimate a detection is done using the guide-
vectors from the previous detection. The results from the separate detections
are finally merged into one decision reflecting the current frame
The detection algorithm is applied for every estimate, using guide-vectors
from the previous detection and producing a detection vector and new guide-
vectors. The algorithm is outlined below for tonality estimate _l~0~_.
Firstly, for every scalefactor band the difference signal is compared to a
threshold _thresTemp._ The threshold is calculated based on the guide-vectors
and a decay-factor according to:
thresTemp = guideVectorDiff[i][l0] ?
max(decayGuideDiff*guideVectorDiff[i][l0],thresHoldDiffGuide):\ thresHoldDiff;
thresTemp = min(thresTemp, thresHoldDiff);
If the difference **diff** for a scalefactor band is higher than the
threshold, the detection vector is set to one for this scalefactor band, and
the new guide vector is given the current difference value for the present
scalefactor band. If the difference in tonality is lower than the threshold,
but the guide vector indicated that present scale factor band had a detected
missing sine in for the previous tonality estimate, the guide vector
\"guideVectorOrig\", is assigned the thresHoldToneGuide value, in order to
track the decay of the original tone instead of the difference signal. This is
outlined for scalefactor band i, in the following pseudo-code:
if(diff[i][l0] > thresTemp){
detVec[i][l0] = 1;
guideVectorDiff[i][l0+1] = diff[i][l0];
}
else{
if(guideVectorDiff[i]){
guideVectorOrig[i][l0] = thresHoldToneGuide;
}
}
A second detection is done for all scalefactor bands where guideVectorOrig is
not zero. The threshold used is calculated according to:
thresOrig = max(guideVectorOrig[i][l0]*decayGuideOrig,thresHoldToneGuide);
thresOrig = min(thresOrig,thresHoldTone);
If the tonality value in **T** for any QMF subband within the a scalefactor
band is above the threshold the detection vector element for this subband is
set to one, as well as the new guide vector. The following pseudo-code
outlines the second round of detection, for scalefactor band _i_ , where _ll_
and _lu_ are the lower and upper QMF subband borders for the present
scalefactor band:
if(guideVectorOrig[i][l0]){
for(j= ll;j\ thresOrig){
detVec[i][l0] = 1;
guideVectorOrig[i][l0+1] = T[j][l0];
}
}
}
Finally, for every scalefactor band, a detection is done in order to make sure
that one single strong sinusoidal in the original signal is not replaced (by
patching) by several strong sinusoids in the SBR signal. For all scalefactor
bands larger than one QMF subband, the values of **sfm** and **sfmSbr** is
compared. This is done according to:
for(j= ll;j\ thresOrig &&
(sfmSbr[i][l0] > sfmThresSbr && sfm[i][l0]\ thresHoldTone &&
(diff[+1][l0] \ 0)
bs_add_harmonic[i] = 0;
}
}
Apart from detection in which scalefactor band a sinusoidal should be added
the module also calculates an energy compensation vector. This is used in the
envelope estimation module.
For every scalefactor band where a missing sine has been detected the maximum
tonality value in the T matrix is found, indicated by _maxPosF_ (indicating
the subband) and _maxPosT_ (indicating the QMF slot). If _maxPosF_ coincides
with a scalefactor band border and a detection was not done for the adjacent
scalefactor band, a compensation value is calculated according to (here
outlined for the case where the _maxPosF_ value coincides for the lower
scalefactorband border):
compValue = (int) (fabs(ILOG2*log(diff[i - 1][maxPosT] +EPS)) + 0.5f);
if (compValue > maxComp)
compValue = maxComp;
if(!pAddHarmonicsScaleFactorBands[i-1]) {
if(tonality[maxPosF -1][maxPosT] > tonalityQuota*tonality[maxPosF][maxPosT]){
compVec[i-1] = -1*compValue;
}
}
Finally the detection algorithm compensates for the case where a strong
sinusoidal is present in the patched SBR signal where there were no strong
sinusoidal in the original, and at the same time there is a sinusoidal missing
in the adjacent scalefactor band. This is done for all scalefactor bands where
a sine is missing (except for the first and the last scalefactor band),
according to the following:
compValue = (int) (fabs(ILOG2*log(diff[i - 1][maxPosT]+EPS)) + 0.5f);
if (compValue > maxComp)
compValue = maxComp;
if(1/diff[i-1][maxPosT] > diffQuota*diff[i][maxPosT]){
compVec[i-1] = -1*compValue;
}
compValue = (int) (fabs(ILOG2*log(diff[i + 1][maxPosT]+EPS)) + 0.5f);
if (compValue > maxComp)
compValue = maxComp;
if(1/diff[i+1][maxPosT] > diffQuota*diff[i][maxPosT]){
compVec[i+1] = compValue;
}
The bitstream element _bs_add_harmonic_flag_ is set to one if any element of
the _bs_add_harmonic_ is not zero, otherwise it is set to zero.
## 5.7 Data quantization
The spectral envelope scalefactors are quantized in 3dB steps or in 1.5dB
steps, dependent on the time frequency resolution of the current SBR frame,
and _bs_amp_res_. For the case where there is only one SBR envelope per SBR
frame and of SBR frame class FIXFIX, 1.5 dB steps are always used, disregarded
the value of _bs_amp_res_.
For mono and stereo without channel coupling the quantization is done
according to:
{width="5.791666666666667in" height="0.5416666666666666in"}
where {width="1.5965277777777778in" height="0.4722222222222222in"} and
{width="3.5277777777777777in" height="0.5in"}
For the coupled channel mode, the left channel is quantized according to the
above, while the right channel should be quantized according to:
{width="4.236111111111111in" height="0.3055555555555556in"}
The noise floor scalefactors data is always quantized in 3dB steps. For stereo
without channel coupling and for mono the channels are quantized according to:
{width="4.138888888888889in" height="0.3055555555555556in"},
where {width="0.5694444444444444in" height="0.2638888888888889in"} shall be
limited to the interval {width="0.4305555555555556in" height="0.25in"}.
For coupling however, the right and left channels are quantized according to:
{width="3.75in" height="0.5555555555555556in"},
{width="5.361111111111111in" height="0.5277777777777778in"}
where
{width="0.7638888888888888in" height="0.2638888888888889in"} shall be limited
to the interval {width="1.3055555555555556in" height="0.2777777777777778in"}
and {width="0.7083333333333334in" height="0.2638888888888889in"} is limited to
the interval {width="0.4305555555555556in" height="0.25in"}.
In the case of coupling, the {width="0.7638888888888888in"
height="0.2638888888888889in"}and{width="0.75in"
height="0.2638888888888889in"} values shall be quantized to multiples of two,
e.g. {width="0.8333333333333334in" height="0.25in"}.
## 5.8 Envelope and noise floor coding
The spectral envelope scalefactors and noise floor scalefactors are delta
coded in either the time direction or the frequency direction, according to
the preferred choice indicated in **bs_df_env**(_l_) and **bs_df_noise**(_l_).
The **bs_df_env** and **bs_df_noise** elements are chosen so that the total
number of bits required for coding the scalefactor data of the present frame
is minimised, with the reservation for the case when _reset_ = 1. In this case
delta coding in the time direction is not allowed for the first SBR envelope
or noise floor of that SBR frame.
The above minimization of envelope bits are for stereo done in both coupling
and left/right stereo mode and based on this the stereo mode is chosen so that
the total number of bits required is minimized.
Below the delta coding of envelope scalefactors and noise floor scalefactors
are defined.
{width="5.569444444444445in" height="6.388888888888889in"}
where {width="2.5833333333333335in" height="0.4722222222222222in"} and,
where {width="0.5416666666666666in" height="0.25in"} and
{width="0.3333333333333333in" height="0.25in"} is defined below. As
{width="0.2222222222222222in" height="0.25in"} represents the envelope
scalefactors for the current SBR frame, the envelope scalefactors from the
previous SBR frame is denoted {width="0.2222222222222222in" height="0.25in"}.
Envelope scalefactors from the previous SBR frame,
{width="0.2222222222222222in" height="0.25in"} is needed when delta coding in
time direction over SBR frame boundaries. The number of SBR envelopes of the
previous SBR frame is denoted {width="0.19375in"
height="0.2222222222222222in"}, and is also needed in that case, as well as
frequency resolution vector of the previous SBR frame, denoted **r\'**.
{width="2.763888888888889in" height="1.0833333333333333in"}and
{width="1.8888888888888888in" height="0.5in"}.
The delta coding of the noise floor scalefactors are defined as:
{width="4.152777777777778in" height="3.25in"}
where
{width="2.5833333333333335in" height="0.4722222222222222in"}
and where {width="0.20833333333333334in" height="0.20833333333333334in"} is
the noise floor scalefactors from the previous SBR frame
and{width="0.20833333333333334in" height="0.25in"}is the number of noise
floors from the previous SBR frame. {width="0.7083333333333334in"
height="0.25in"} and {width="0.69375in" height="0.25in"} are stored as
bitstream element as shown below prior to Huffman coding.
{width="3.2777777777777777in" height="0.5in"}
{width="3.4166666666666665in" height="0.5in"}
For the envelope scalefactors and the noise floor scalefactors different
Huffman tables are used dependent on coding directions, quantization and
stereo mode, according to in [1], sub clause 4.A.6.1 Table 4.A.76
# 6 Bitstream
Figure 10 below gives a brief hierarchical representation of the SBR and
parametric stereo parts of the aacPlus bitstream, with references to the
corresponding decoder specifications. An overview of sbr_extension_data() is
given in [1], Figure 4.19A, and subclause 4.4.2.8 of [1] defines the syntax.
Clearly, the operation of the SBR Bitstream Multiplexer in Figure 5 is defined
by this syntax. The optional CRC calculation is also defined by the decoder
description [1], subclause 4.5.2.8.1. For convenience, pointers to the
relevant sections in the present document are given within paranthesises in
Figure 10.
extension_payload() [1], Amendment Subpart 4, Table 4.51\ sbr_extension_data()
[1], Subclause 4.4.2.8, Table 4.54A\ sbr_header() \", \", Table 4.55A (5.3)\
sbr_data() \", \", Table 4.56A\ sbr_single_channel_element() \", \", Table
4.57A\ sbr_grid() \", \", Table 4.61A (5.4.3)\ sbr_dtdf() \", \", Table 4.62A
(5.8)\ sbr_invf() \", \", Table 4.63A (5.6.4)\ sbr_envelope() \", \", Table
4.64A (5.5, 5.7, 5.8)\ sbr_noise() \", \", Table 4.65A (5.6.3, 5.7, 5.8)\
sbr_sinusoidal_coding() \", \", Table 4.66A (5.6.5)\ sbr_extension() [7],
Subclause 8.A.2, Table 8.A.1\ ps_data() [7], Subclause 8.4.1, Table 8.1
Figure 10: Enhanced aacPlus with parametric stereo bitstream hierarchy
#
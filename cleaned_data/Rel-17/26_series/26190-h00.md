# Foreword
The present document describes the detailed mapping of the wideband telephony
speech service employing the Adaptive Multi-Rate (AMR-WB) speech coder within
the 3GPP system.
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of this TS, it will be re-released by the TSG with an identifying
change of release date and an increase in version number as follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 Indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the specification;
# 1 Scope
This Telecommunication Standard (TS) describes the detailed mapping from input
blocks of 320 speech samples in 16‑bit uniform PCM format to encoded blocks of
132, 177, 253, 285, 317, 365, 397, 461 and 477 bits and from encoded blocks of
132, 177, 253, 285, 317, 365, 397, 461 and 477 bits to output blocks of 320
reconstructed speech samples. The sampling rate is 16 000 samples/s leading to
a bit rate for the encoded bit stream of 6.60, 8.85, 12.65, 14.25, 15.85,
18.25, 19.85, 23.05 or 23.85 kbit/s. The coding scheme for the multi-rate
coding modes is the so‑called Algebraic Code Excited Linear Prediction Coder,
hereafter referred to as ACELP. The multi-rate wideband ACELP coder is
referred to as MRWB-ACELP.
# 2 Normative references
This TS incorporates by dated and undated reference, provisions from other
publications. These normative references are cited in the appropriate places
in the text and the publications are listed hereafter. For dated references,
subsequent amendments to or revisions of any of these publications apply to
this TS only when incorporated in it by amendment or revision. For undated
references, the latest edition of the publication referred to applies.
[1] GSM 03.50: \" Digital cellular telecommunications system (Phase 2);
Transmission planning aspects of the speech service in the GSM Public Land
Mobile Network (PLMN) system\"
[2] 3GPP TS 26.201 : \"AMR wideband speech codec; Frame structure\".
[3] 3GPP TS 26.194: \"AMR wideband speech codec; Voice Activity Detection
(VAD)\".
[4] 3GPP TS 26.173: \"AMR wideband speech codec; ANSI‑C code\".
[5] 3GPP TS 26.174: \"AMR wideband speech codec; Test sequences\".
[6] ITU‑T Recommendation G.711 (1988): \"Coding of analogue signals by pulse
code modulation Pulse code modulation (PCM) of voice frequencies\".
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of this TS, the following definitions apply:
**adaptive codebook:** The adaptive codebook contains excitation vectors that
are adapted for every subframe. The adaptive codebook is derived from the
long-term filter state. The lag value can be viewed as an index into the
adaptive codebook.
**algebraic codebook:** A fixed codebook where algebraic code is used to
populate the excitation vectors (innovation vectors). The excitation contains
a small number of nonzero pulses with predefined interlaced sets of potential
positions. The amplitudes and positions of the pulses of the k^th^ excitation
codevector can be derived from its index k through a rule requiring no or
minimal physical storage, in contrast with stochastic codebooks whereby the
path from the index to the associated codevector involves look-up tables.
**anti-sparseness processing:** An adaptive post-processing procedure applied
to the fixed codebook vector in order to reduce perceptual artifacts from a
sparse fixed codebook vector.
**closed‑loop pitch analysis:** This is the adaptive codebook search, i.e., a
process of estimating the pitch (lag) value from the weighted input speech and
the long term filter state. In the closed‑loop search, the lag is searched
using error minimization loop (analysis‑by‑synthesis). In the adaptive multi-
rate wideband codec, closed‑loop pitch search is performed for every subframe.
**direct form coefficients:** One of the formats for storing the short term
filter parameters. In the adaptive multi-rate wideband codec, all filters
which are used to modify speech samples use direct form coefficients.
**fixed codebook:** The fixed codebook contains excitation vectors for speech
synthesis filters. The contents of the codebook are non‑adaptive (i.e.,
fixed). In the adaptive multi-rate wideband codec, the fixed codebook is
implemented using an algebraic codebook.
**fractional lags:** A set of lag values having sub‑sample resolution. In the
adaptive multi-rate wideband codec a sub‑sample resolution of 1/4th or 1/2nd
of a sample is used.
**frame:** A time interval equal to 20 ms (320 samples at an 16 kHz sampling
rate).
**Immittance Spectral Frequencies:** (see Immittance Spectral Pair)
**Immittance Spectral Pair:** Transformation of LPC parameters. Immittance
Spectral Pairs are obtained by decomposing the inverse filter transfer
function A(z) to a set of two transfer functions, one having even symmetry and
the other having odd symmetry. The Immittance Spectral Pairs (also called as
Immittance Spectral Frequencies) are the roots of these polynomials on the
z-unit circle.
**integer lags:** A set of lag values having whole sample resolution.
**interpolating filter:** An FIR filter used to produce an estimate of sub-
sample resolution samples, given an input sampled with integer sample
resolution. In this implementation, the interpolating filter has low pass
filter characteristics. Thus the adaptive codebook consists of the low-pass
filtered interpolated past excitation.
**inverse filter:** This filter removes the short term correlation from the
speech signal. The filter models an inverse frequency response of the vocal
tract.
**lag:** The long term filter delay. This is typically the true pitch period,
or its multiple or sub‑multiple.
**LP analysis window:** For each frame, the short term filter coefficients are
computed using the high pass filtered speech samples within the analysis
window. In the adaptive multi-rate wideband codec, the length of the analysis
window is always 384 samples. For all the modes, a single asymmetric window is
used to generate a single set of LP coefficients. The 5 ms look-ahead is used
in the analysis.
**LP coefficients:** Linear Prediction (LP) coefficients (also referred as
Linear Predictive Coding (LPC) coefficients) is a generic descriptive term for
the short term filter coefficients.
**mode:** When used alone, refers to the source codec mode, i.e., to one of
the source codecs employed in the AMR-WB codec.
**open‑loop pitch search:** A process of estimating the near optimal lag
directly from the weighted speech input. This is done to simplify the pitch
analysis and confine the closed‑loop pitch search to a small number of lags
around the open‑loop estimated lags. In the adaptive multi-rate wideband
codec, an open‑loop pitch search is performed in every other subframe.
**residual:** The output signal resulting from an inverse filtering operation.
**short term synthesis filter:** This filter introduces, into the excitation
signal, short term correlation which models the impulse response of the vocal
tract.
**perceptual weighting filter:** This filter is employed in the
analysis‑by‑synthesis search of the codebooks. The filter exploits the noise
masking properties of the formants (vocal tract resonances) by weighting the
error less in regions near the formant frequencies and more in regions away
from them.
**subframe:** A time interval equal to 5 ms (80 samples at 16 kHz sampling
rate).
**vector quantization:** A method of grouping several parameters into a vector
and quantizing them simultaneously.
**zero input response:** The output of a filter due to past inputs, i.e. due
to the present state of the filter, given that an input of zeros is applied.
**zero state response:** The output of a filter due to the present input,
given that no past inputs have been applied, i.e., given that the state
information in the filter is all zeroes.
## 3.2 Symbols
For the purposes of this TS, the following symbols apply:
{width="0.3611111111111111in" height="0.25in"} The inverse filter with
unquantized coefficients
{width="0.34652777777777777in" height="0.2777777777777778in"} The inverse
filter with quantized coefficients
{width="0.875in" height="0.4583333333333333in"} The speech synthesis filter
with quantized coefficients
{width="0.18055555555555555in" height="0.2222222222222222in"} The unquantized
linear prediction parameters (direct form coefficients)
{width="0.18055555555555555in" height="0.2222222222222222in"} The quantified
linear prediction parameters
{width="0.18055555555555555in" height="0.1527777777777778in"} The order of the
LP model
{width="0.3611111111111111in" height="0.25in"} The perceptual weighting filter
(unquantized coefficients)
{width="0.16666666666666666in" height="0.20833333333333334in"} The perceptual
weighting factor
{width="0.1527777777777778in" height="0.18055555555555555in"} The integer
pitch lag nearest to the closed‑loop fractional pitch lag of the subframe
{width="0.1388888888888889in" height="0.2222222222222222in"} The adaptive
pre‑filter coefficient (the quantified pitch gain)
{width="0.5in" height="0.2361111111111111in"} Pre‑processing high‑pass filter
{width="0.3611111111111111in" height="0.2222222222222222in"} LP analysis
window
{width="0.18055555555555555in" height="0.2361111111111111in"} Length of the
first part of the LP analysis window {width="0.3611111111111111in"
height="0.2222222222222222in"}
{width="0.19375in" height="0.2361111111111111in"} Length of the second part of
the LP analysis window {width="0.3611111111111111in"
height="0.2222222222222222in"}
{width="0.3333333333333333in" height="0.2222222222222222in"} The
auto‑correlations of the windowed speech {width="0.3611111111111111in"
height="0.20833333333333334in"}
{width="0.5138888888888888in" height="0.2638888888888889in"} Lag window for
the auto‑correlations (60 Hz bandwidth expansion)
{width="0.19375in" height="0.2361111111111111in"} The bandwidth expansion in
Hz
{width="0.19375in" height="0.2222222222222222in"} The sampling frequency in Hz
{width="0.375in" height="0.2222222222222222in"} The modified (bandwidth
expanded) auto‑correlations
{width="0.3194444444444444in" height="0.2361111111111111in"} The prediction
error in the _i_ th iteration of the Levinson algorithm
{width="0.16666666666666666in" height="0.2361111111111111in"} The _i_ th
reflection coefficient
{width="0.2777777777777778in" height="0.3055555555555556in"} The _j_ th direct
form coefficient in the _i_ th iteration of the Levinson algorithm
{width="0.4027777777777778in" height="0.2361111111111111in"} Symmetric ISF
polynomial
{width="0.4166666666666667in" height="0.2361111111111111in"} Antisymmetric ISF
polynomial
{width="0.4027777777777778in" height="0.2361111111111111in"} Polynomial
{width="0.4027777777777778in" height="0.2361111111111111in"}
{width="0.4166666666666667in" height="0.2361111111111111in"} Polynomial
{width="0.4166666666666667in" height="0.2361111111111111in"} with roots
{width="0.3611111111111111in" height="0.16666666666666666in"}and
{width="0.4583333333333333in" height="0.18055555555555555in"} eliminated
{width="0.18055555555555555in" height="0.2361111111111111in"} The immittance
spectral pairs (ISPs) in the cosine domain
{width="0.1388888888888889in" height="0.18055555555555555in"} An ISP vector in
the cosine domain
{width="0.3055555555555556in" height="0.2777777777777778in"} The quantified
ISP vector at the _i_ th subframe of the frame _n_
{width="0.20833333333333334in" height="0.2361111111111111in"} The immittance
spectral frequencies (ISFs)
{width="0.4166666666666667in" height="0.2222222222222222in"} A _m_ th order
Chebyshev polynomial
{width="0.7361111111111112in" height="0.2222222222222222in"} The coefficients
of the polynomials {width="0.3888888888888889in"
height="0.2222222222222222in"}and {width="0.4027777777777778in"
height="0.2222222222222222in"}
{width="0.8055555555555556in" height="0.2638888888888889in"} The coefficients
of the polynomials {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"}
{width="0.3333333333333333in" height="0.2222222222222222in"} The coefficients
of either {width="0.4027777777777778in" height="0.2361111111111111in"} or
{width="0.4166666666666667in" height="0.2361111111111111in"}
{width="0.3611111111111111in" height="0.2222222222222222in"} Sum polynomial of
the Chebyshev polynomials
{width="0.1388888888888889in" height="0.1527777777777778in"} Cosine of angular
frequency {width="0.16666666666666666in" height="0.1527777777777778in"}
{width="0.2222222222222222in" height="0.2361111111111111in"} Recursion
coefficients for the Chebyshev polynomial evaluation
{width="0.2222222222222222in" height="0.2361111111111111in"} The immittance
spectral frequencies (ISFs) in Hz
{width="0.9027777777777778in" height="0.2361111111111111in"} The vector
representation of the ISFs in Hz
{width="0.3194444444444444in" height="0.2361111111111111in"} The mean‑removed
ISF vector at frame _n_
{width="0.3194444444444444in" height="0.2361111111111111in"} The ISF
prediction residual vector at frame _n_
{width="0.3333333333333333in" height="0.20833333333333334in"} The predicted
ISF vector at frame _n_
{width="0.5138888888888888in" height="0.2361111111111111in"} The quantified
residual vector at the past frame
{width="0.18055555555555555in" height="0.2361111111111111in"} The quantified
ISF subvector {width="9.652777777777778e-2in" height="0.16666666666666666in"}
at quantization index _k_
{width="0.2222222222222222in" height="0.2361111111111111in"} The distance
between the immittance spectral frequencies {width="0.3055555555555556in"
height="0.2361111111111111in"} and {width="0.3055555555555556in"
height="0.2361111111111111in"}
{width="0.3333333333333333in" height="0.2222222222222222in"} The impulse
response of the weighted synthesis filter
{width="0.6388888888888888in" height="0.19375in"} The weighted synthesis
filter
{width="0.16666666666666666in" height="0.2222222222222222in"} The integer
nearest to the fractional pitch lag of the previous (1st or 3rd) subframe
{width="0.3611111111111111in" height="0.20833333333333334in"} The windowed
speech signal
{width="0.4166666666666667in" height="0.2361111111111111in"} The weighted
speech signal
{width="0.3194444444444444in" height="0.2222222222222222in"} Reconstructed
speech signal
{width="0.3333333333333333in" height="0.2222222222222222in"} The target signal
for adaptive codebook search
{width="0.4166666666666667in" height="0.2361111111111111in"},
{width="0.20833333333333334in" height="0.2777777777777778in"} The target
signal for algebraic codebook search
{width="0.625in" height="0.2222222222222222in"} The LP residual signal
{width="0.3194444444444444in" height="0.2222222222222222in"} The fixed
codebook vector
{width="0.3194444444444444in" height="0.2222222222222222in"} The adaptive
codebook vector
{width="1.2361111111111112in" height="0.2222222222222222in"} The filtered
adaptive codebook vector
{width="0.4305555555555556in" height="0.2361111111111111in"} The past filtered
excitation
{width="0.3333333333333333in" height="0.2222222222222222in"} The excitation
signal
{width="0.375in" height="0.2222222222222222in"} The gain‑scaled emphasized
excitation signal
{width="0.2638888888888889in" height="0.2638888888888889in"} The best
open‑loop lag
{width="0.3194444444444444in" height="0.2222222222222222in"} Minimum lag
search value
{width="0.34652777777777777in" height="0.2222222222222222in"} Maximum lag
search value
{width="0.3888888888888889in" height="0.25in"} Correlation term to be
maximized in the adaptive codebook search
{width="0.4583333333333333in" height="0.2638888888888889in"} The interpolated
value of {width="0.3888888888888889in" height="0.25in"} for the integer delay
_k_ and fraction _t_
{width="0.2638888888888889in" height="0.2361111111111111in"} Correlation term
to be maximized in the algebraic codebook search at index _k_
{width="0.2222222222222222in" height="0.2361111111111111in"} The correlation
in the numerator of {width="0.2638888888888889in"
height="0.2361111111111111in"} at index _k_
{width="0.3333333333333333in" height="0.25in"} The energy in the denominator
of {width="0.2638888888888889in" height="0.2361111111111111in"} at index _k_
{width="0.6666666666666666in" height="0.2777777777777778in"} The correlation
between the target signal {width="0.34652777777777777in"
height="0.20833333333333334in"} and the impulse response
{width="0.2777777777777778in" height="0.20833333333333334in"}, i.e., backward
filtered target
{width="0.19375in" height="0.18055555555555555in"} The lower triangular
Toepliz convolution matrix with diagonal {width="0.2777777777777778in"
height="0.20833333333333334in"} and lower diagonals
{width="0.7638888888888888in" height="0.20833333333333334in"}
{width="0.5694444444444444in" height="0.25in"} The matrix of correlations of
{width="0.3333333333333333in" height="0.25in"}
{width="0.34652777777777777in" height="0.2222222222222222in"} The elements of
the vector **d**
{width="0.44375in" height="0.2222222222222222in"} The elements of the
symmetric matrix {width="0.18055555555555555in"
height="0.18055555555555555in"}
{width="0.20833333333333334in" height="0.2222222222222222in"} The innovation
vector
{width="0.19375in" height="0.2222222222222222in"} The correlation in the
numerator of {width="0.2638888888888889in" height="0.2361111111111111in"}
{width="0.20833333333333334in" height="0.2361111111111111in"} The position of
the _i_ th pulse
{width="0.20833333333333334in" height="0.2361111111111111in"} The amplitude of
the _i_ th pulse
{width="0.2777777777777778in" height="0.25in"} The number of pulses in the
fixed codebook excitation
{width="0.3055555555555556in" height="0.2222222222222222in"} The energy in the
denominator of {width="0.2638888888888889in" height="0.2361111111111111in"}
{width="0.69375in" height="0.2361111111111111in"} The normalized long‑term
prediction residual
{width="0.3194444444444444in" height="0.2222222222222222in"} The signal used
for presetting the signs in algebraic codebook search
{width="0.4027777777777778in" height="0.2361111111111111in"} The sign signal
for the algebraic codebook search
{width="0.4027777777777778in" height="0.2222222222222222in"} Sign extended
backward filtered target
{width="0.5in" height="0.2638888888888889in"} The modified elements of the
matrix {width="0.18055555555555555in" height="0.18055555555555555in"},
including sign information
{width="0.18055555555555555in" height="0.2222222222222222in"},
{width="0.3611111111111111in" height="0.2361111111111111in"} The fixed
codebook vector convolved with {width="0.3333333333333333in"
height="0.2222222222222222in"}
{width="0.375in" height="0.2222222222222222in"} The mean‑removed innovation
energy (in dB)
{width="0.18055555555555555in" height="0.20833333333333334in"} The mean of the
innovation energy
{width="0.375in" height="0.2361111111111111in"} The predicted energy
{width="0.8611111111111112in" height="0.2638888888888889in"} The MA prediction
coefficients
{width="0.3611111111111111in" height="0.2361111111111111in"} The quantified
prediction error at subframe _k_
{width="0.2638888888888889in" height="0.2222222222222222in"} The mean
innovation energy
{width="0.3888888888888889in" height="0.2222222222222222in"} The prediction
error of the fixed‑codebook gain quantization
{width="0.2916666666666667in" height="0.25in"} The quantization error of the
fixed‑codebook gain quantization
{width="0.3194444444444444in" height="0.2222222222222222in"} The states of the
synthesis filter {width="0.4861111111111111in" height="0.2638888888888889in"}
{width="0.4305555555555556in" height="0.2361111111111111in"} The perceptually
weighted error of the analysis‑by‑synthesis search
{width="0.1527777777777778in" height="0.19375in"} The gain scaling factor for
the emphasized excitation
{width="0.20833333333333334in" height="0.2222222222222222in"} The
fixed‑codebook gain
{width="0.20833333333333334in" height="0.2222222222222222in"} The predicted
fixed‑codebook gain
{width="0.20833333333333334in" height="0.2222222222222222in"} The quantified
fixed codebook gain
{width="0.2361111111111111in" height="0.1951388888888889in"} The adaptive
codebook gain
{width="0.2361111111111111in" height="0.1951388888888889in"} The quantified
adaptive codebook gain
{width="0.9027777777777778in" height="0.25in"} A correction factor between the
gain {width="0.20833333333333334in" height="0.2222222222222222in"} and the
estimated one {width="0.20833333333333334in" height="0.2222222222222222in"}
{width="0.3333333333333333in" height="0.2638888888888889in"} The optimum value
for {width="0.2777777777777778in" height="0.25in"}
{width="0.2638888888888889in" height="0.2361111111111111in"} Gain scaling
factor
## 3.3 Abbreviations
For the purposes of this TS, the following abbreviations apply.
ACELP Algebraic Code Excited Linear Prediction
AGC Adaptive Gain Control
AMR Adaptive Multi-Rate
AMR-WB Adaptive Multi-Rate Wideband
CELP Code Excited Linear Prediction
FIR Finite Impulse Response
ISF Immittance Spectral Frequency
ISP Immittance Spectral Pair
ISPP Interleaved Single‑Pulse Permutation
LP Linear Prediction
LPC Linear Predictive Coding
LTP Long Term Predictor (or Long Term Prediction)
MA Moving Average
MRWB-ACELP Wideband Multi-Rate ACELP
S-MSVQ Split-MultiStage Vector Quantization
WB Wideband
# 4 Outline description
This TS is structured as follows:
Section 4.1 contains a functional description of the audio parts including the
A/D and D/A functions. Section 4.2 describes input format for the AMR-WB
encoder and the output format for the AMR-WB decoder. Sections 4.3 and 4.4
present a simplified description of the principles of the AMR-WB codec
encoding and decoding process respectively. In subclause 4.5, the sequence and
subjective importance of encoded parameters are given.
Section 5 presents the functional description of the AMR-WB codec encoding,
whereas clause 6 describes the decoding procedures. In section 7, the detailed
bit allocation of the AMR-WB codec is tabulated. Section 8 describes the
homing operation.
## 4.1 Functional description of audio parts
The analogue‑to‑digital and digital‑to‑analogue conversion will in principle
comprise the following elements:
1) Analogue to uniform digital PCM
\- microphone;
\- input level adjustment device;
\- input anti‑aliasing filter;
\- sample‑hold device sampling at 16 kHz;
\- analogue‑to‑uniform digital conversion to 14‑bit representation.
The uniform format shall be represented in two\'s complement.
2) Uniform digital PCM to analogue
‑ conversion from 14‑bit/16 kHz uniform PCM to analogue;
‑ a hold device;
‑ reconstruction filter including x/sin( x ) correction;
‑ output level adjustment device;
‑ earphone or loudspeaker.
In the terminal equipment, the A/D function may be achieved
‑ by direct conversion to 14‑bit uniform PCM format;
For the D/A operation, the inverse operations take place.
## 4.2 Preparation of speech samples
The encoder is fed with data comprising of samples with a resolution of 14
bits left justified in a 16‑bit word. The decoder outputs data in the same
format. Outside the speech codec further processing must be applied if the
traffic data occurs in a different representation.
## 4.3 Principles of the adaptive multi-rate wideband speech encoder
The AMR-WB codec consists of nine source codecs with bit-rates of 23.85 23.05,
19.85, 18.25, 15.85, 14.25, 12.65, 8.85 and 6.60 kbit/s.
The codec is based on the code‑excited linear predictive (CELP) coding model.
The input signal is pre-emphasized using the filter _H~pre-emph~_(_z_)=1−μ _z_
^−1^. The CELP model is then applied to the pre-emphasized signal. A 16th
order linear prediction (LP), or short‑term, synthesis filter is used which is
given by:
{width="2.0277777777777777in" height="0.5555555555555556in"}, ( 1 )
where _â~i~,i=1,...,m_ are the (quantized) linear prediction (LP) parameters,
and _m_ = 16 is the predictor order. The long‑term, or pitch, synthesis filter
is usually given by:
{width="1.25in" height="0.5138888888888888in"}, ( 2 )
where _T_ is the pitch delay and _g~p~_ is the pitch gain. The pitch synthesis
filter is implemented using the so-called adaptive codebook approach.
The CELP speech synthesis model is shown in Figure 1. In this model, the
excitation signal at the input of the short‑term LP synthesis filter is
constructed by adding two excitation vectors from adaptive and fixed
(innovative) codebooks. The speech is synthesized by feeding the two properly
chosen vectors from these codebooks through the short‑term synthesis filter.
The optimum excitation sequence in a codebook is chosen using an
analysis‑by‑synthesis search procedure in which the error between the original
and synthesized speech is minimized according to a perceptually weighted
distortion measure.
The perceptual weighting filter used in the analysis‑by‑synthesis search
technique is given by:
{width="1.6111111111111112in" height="0.2222222222222222in"}, ( 3 )
where _A(z)_ is the unquantized LP filter, {width="1.3194444444444444in"
height="0.3888888888888889in"}, and _γ~1~=0.92_ is the perceptual weighting
factor. The weighting filter uses the unquantized LP parameters.
The encoder performs the analysis of the LPC, LTP and fixed codebook
parameters at 12.8 kHz sampling rate. The coder operates on speech frames of
20 ms. At each frame, the speech signal is analysed to extract the parameters
of the CELP model (LP filter coefficients, adaptive and fixed codebooks\'
indices and gains). In addition to these parameters, high-band gain indices
are computed in 23.85 kbit/s mode. These parameters are encoded and
transmitted. At the decoder, these parameters are decoded and speech is
synthesized by filtering the reconstructed excitation signal through the LP
synthesis filter.
The signal flow at the encoder is shown in Figure 2. After decimation, high-
pass and pre-emphasis filtering is performed. LP analysis is performed once
per frame. The set of LP parameters is converted to immittance spectrum pairs
(ISP) and vector quantized using split-multistage vector quantization
(S-MSVQ). The speech frame is divided into 4 subframes of 5 ms each (64
samples at 12.8 kHz sampling rate). The adaptive and fixed codebook parameters
are transmitted every subframe. The quantized and unquantized LP parameters or
their interpolated versions are used depending on the subframe. An open‑loop
pitch lag is estimated in every other subframe or once per frame based on the
perceptually weighted speech signal.
Then the following operations are repeated for each subframe:
\- The target signal _x(n)_ is computed by filtering the LP residual through
the weighted synthesis filter {width="0.5965277777777778in"
height="0.20833333333333334in"} with the initial states of the filters having
been updated by filtering the error between LP residual and excitation (this
is equivalent to the common approach of subtracting the zero input response of
the weighted synthesis filter from the weighted speech signal).
\- The impulse response, _h(n)_ of the weighted synthesis filter is computed.
\- Closed‑loop pitch analysis is then performed (to find the pitch lag and
gain), using the target _x(n)_ and impulse response _h(n)_ , by searching
around the open‑loop pitch lag. Fractional pitch with 1/4th or 1/2nd of a
sample resolution (depending on the mode and the pitch lag value) is used. The
interpolating filter in fractional pitch search has low pass frequency
response. Further, there are two potential low-pass characteristics in the the
adaptive codebook and this information is encoded with 1 bit.
\- The target signal _x(n)_ is updated by removing the adaptive codebook
contribution (filtered adaptive codevector), and this new target, _x~2~(n)_ ,
is used in the fixed algebraic codebook search (to find the optimum
innovation).
\- The gains of the adaptive and fixed codebook are vector quantified with 6or
7 bits (with moving average (MA) prediction applied to the fixed codebook
gain).
\- Finally, the filter memories are updated (using the determined excitation
signal) for finding the target signal in the next subframe.
The bit allocation of the AMR-WB codec modes is shown in Table 1. In each 20
ms speech frame, 132, 177, 253, 285, 317, 365, 397, 461 and 477 bits are
produced, corresponding to a bit-rate of 6.60, 8.85 ,12.65, 14.25, 15.85,
18.25, 19.85, 23.05 or 23.85 kbit/s. More detailed bit allocation among the
codec parameters is given in tables 12a-12i. Note that the most significant
bits (MSB) are always sent first.
Table 1: Bit allocation of the AMR-WB coding algorithm for 20 ms frame
* * *
Mode Parameter 1st subframe 2nd subframe 3rd subframe 4th subframe total per
frame VAD-flag 1 **23.85 kbit/s** ISP 46 LTP-filtering 1 1 1 1 4 Pitch delay 9
6 9 6 30 Algebraic code 88 88 88 88 352 Codebook gain 7 7 7 7 28 HB-energy 4 4
4 4 16 **Total** 477 VAD-flag 1 **23.05 kbit/s** ISP 46 LTP-filtering 1 1 1 1
4 Pitch delay 9 6 9 6 30 Algebraic code 88 88 88 88 352 Gains 7 7 7 7 28 Total
461 VAD-flag 1 **19.85 kbit/s** ISP 46 LTP-filtering 1 1 1 1 4 Pitch delay 9 6
9 6 30 Algebraic code 72 72 72 72 288 Codebook gain 7 7 7 7 28 Total 397 VAD-
flag 1 **18.25 kbit/s** ISP 46 LTP-filtering 1 1 1 1 4 Pitch delay 9 6 9 6 30
Algebraic code 64 64 64 64 256 Gains 7 7 7 7 28 Total 365 VAD-flag 1 **15.85
kbit/s** ISP 46 LTP-filtering 1 1 1 1 4 Pitch delay 9 6 9 6 30 Algebraic code
52 52 52 52 208 Gains 7 7 7 7 28 Total 317 VAD-flag 1 **14.25 kbit/s** ISP 46
LTP-filtering 1 1 1 1 4 Pitch delay 9 6 9 6 30 Algebraic code 44 44 44 44 176
Gains 7 7 7 7 28 Total 285 VAD-flag 1 **12.65 kbit/s** ISP 46 LTP-filtering 1
1 1 1 4 Pitch delay 9 6 9 6 30 Algebraic code 36 36 36 36 144 Gains 7 7 7 7 28
Total 253 VAD-flag 1 **8.85 kbit/s** ISP 46 Pitch delay 8 5 8 5 26 Algebraic
code 20 20 20 20 80 Gains 6 6 6 6 24 Total 177 VAD-flag 1 **6.60 kbit/s** ISP
36 Pitch delay 8 5 5 5 23 Algebraic code 12 12 12 12 48 Gains 6 6 6 6 24 Total
132
* * *
## 4.4 Principles of the adaptive multi-rate speech decoder
The signal flow at the decoder is shown in Figure 3. At the decoder, the
transmitted indices are extracted from the received bitstream. The indices are
decoded to obtain the coder parameters at each transmission frame. These
parameters are the ISP vector, the 4 fractional pitch lags, the 4 LTP
filtering parameters, the 4 innovative codevectors, and the 4 sets of vector
quantized pitch and innovative gains. In 23.85 kbit/s mode, also high-band
gain index is decoded. The ISP vector is converted to the LP filter
coefficients and interpolated to obtain LP filters at each subframe. Then, at
each 64-sample subframe:
\- The excitation is constructed by adding the adaptive and innovative
codevectors scaled by their respective gains.
\- The 12.8 kHz speech is reconstructed by filtering the excitation through
the LP synthesis filter.
\- The reconstructed speech is de-emphasized.
Finally, the reconstructed speech is upsampled to 16 kHz and high-band speech
signal is added to the frequency band from 6 kHz to 7 kHz.
## 4.5 Sequence and subjective importance of encoded parameters
The encoder will produce the output information in a unique sequence and
format, and the decoder must receive the same information in the same way. In
table 12a-12i, the sequence of output bits and the bit allocation for each
parameter is shown.
The different parameters of the encoded speech and their individual bits have
unequal importance with respect to subjective quality. The output and input
frame formats for the AMR wideband speech codec are given in [2], where a
reordering of bits take place.
# 5 Functional description of the encoder
In this clause, the different functions of the encoder represented in Figure 2
are described.
## 5.1 Pre**‑** processing
The encoder performs the analysis of the LPC, LTP and fixed codebook
parameters at 12.8 kHz sampling rate. Therefore, the input signal has to be
decimated from 16 kHz to 12.8 kHz. The decimation is performed by first
upsampling by 4, then filtering the output through lowpass FIR filter
_H~decim~_(_z_) that has the cut off frequency at 6.4 kHz. Then, the signal is
downsampled by 5. The filtering delay is compensated by adding zeroes into the
end of the input vector.
After the decimation, two pre-processing functions are applied to the signal
prior to the encoding process: high-pass filtering and pre-emphasizing (and
signal down-scaling).
(Down-scaling consists of dividing the input by a factor of 2 to reduce the
possibility of overflows in the fixed-point implementation.)
The high-pass filter serves as a precaution against undesired low frequency
components. A filter at a cut off frequency of 50 Hz is used, and it is given
by
{width="2.861111111111111in" height="0.4166666666666667in"} ( 4 )
(Both down-scaling and high-pass filtering are combined by dividing the
coefficients at the numerator of _H~h1~(z)_ by 2.)
In the pre-emphasis, a first order high-pass filter is used to emphasize
higher frequencies, and it is given by
{width="1.4861111111111112in" height="0.25in"} ( 5 )
## 5.2 Linear prediction analysis and quantization
Short-term prediction, or LP, analysis is performed once per speech frame
using the autocorrelation approach with 30 ms asymmetric windows. An overhead
of 5 ms is used in the autocorrelation computation. The frame structure is
depicted below.
{width="3.3631944444444444in" height="0.95in"}
The autocorrelations of windowed speech are converted to the LP coefficients
using the Levinson-Durbin algorithm. Then the LP coefficients are transformed
to the ISP domain for quantization and interpolation purposes. The
interpolated quantized and unquantized filters are converted back to the LP
filter coefficients (to construct the synthesis and weighting filters at each
subframe).
### 5.2.1 Windowing and auto**‑** correlation computation
LP analysis is performed once per frame using an asymmetric window. The window
has its weight concentrated at the fourth subframe and it consists of two
parts: the first part is a half of a Hamming window and the second part is a
quarter of a Hamming-cosine function cycle. The window is given by:
{width="2.411111111111111in" height="0.7041666666666667in"} ( 6 )
where the values _L~1~=256_ and _L~2~=128_ are used.
The autocorrelations of the windowed speech _s\'(n),n=0,...,383_ are computed
by
{width="2.2777777777777777in" height="0.4861111111111111in"} ( 7 )
and a 60 Hz bandwidth expansion is used by lag windowing the autocorrelations
using the window [2]
{width="2.4722222222222223in" height="0.5416666666666666in"} ( 8 )
where _f~0~=60_ Hz is the bandwidth expansion and _f~s~=12800_ Hz is the
sampling frequency. Further, _r(0)_ is multiplied by the white noise
correction factor 1.0001 which is equivalent to adding a noise floor at -40
dB.
### 5.2.2 Levinson**‑** Durbin algorithm
The modified autocorrelations {width="1.0833333333333333in"
height="0.19375in"} and {width="1.8333333333333333in"
height="0.2638888888888889in"} are used to obtain the LP filter coefficients
_a~k~,k=1,...,16_ by solving the set of equations.
{width="2.1527777777777777in" height="0.4861111111111111in"} ( 9 )
The set of equations in (9) is solved using the Levinson-Durbin algorithm [2].
This algorithm uses the following recursion:
{width="2.611111111111111in" height="1.7361111111111112in"}
The final solution is given as {width="0.5965277777777778in"
height="0.2638888888888889in"}_,j=1,...,16_.
The LP filter coefficients are converted to the ISP representation [4] for
quantization and interpolation purposes. The conversions to the ISP domain and
back to the LP filter domain are described in the next two sections.
### 5.2.3 LP to ISP conversion
The LP filter coefficients _a~k~, k=1,...,16_ , are converted to the ISP
representation for quantization and interpolation purposes. For a 16th order
LP filter, the ISPs are defined as the roots of the sum and difference
polynomials
{width="1.4861111111111112in" height="0.2361111111111111in"} ( 10 )
and
{width="1.5138888888888888in" height="0.2361111111111111in"} ( 11 )
respectively. (The polynomials _f\'~1~(z)_ and _f\'~2~(z)_ are symmetric and
antisymmetric, respectively). It can be proven that all roots of these
polynomials are on the unit circle and they alternate each other [5].
_f\'~2~(z)_ has two roots at _z_ = 1 (_ω_ =0) and _z_ = -1 (_ω_ = _π_). To
eliminate these two roots, we define the new polynomials
{width="0.8055555555555556in" height="0.2361111111111111in"} ( 12 )
and
{width="1.3465277777777778in" height="0.2361111111111111in"} ( 13 )
Polynomials _f~1~(z)_ and _f~2~(z)_ have 8 and 7 conjugate roots on the unit
circle $\left( e^{\pm \text{jw}_{i}} \right)$ respectively. Therefore, the
polynomials can be written as
{width="2.2777777777777777in" height="0.3888888888888889in"} ( 14 )
and
{width="2.3055555555555554in" height="0.3888888888888889in"} ( 15 )
where _q~i~=cos(ω~i~)_ with _ω~i~_ being the immittance spectral frequencies
(ISF) and _a_[16] is the last predictor coefficient. ISFs satisfy the ordering
property {width="1.5694444444444444in" height="0.20833333333333334in"}. We
refer to $q_{i}$as the ISPs in the cosine domain.
Since both polynomials _f_ ~1~_(z)_ and _f_ ~2~_(z)_ are symmetric only the
first 8 and 7 coefficients of each polynomial, respectively, and the last
predictor coefficient need to be computed.
The coefficients of these polynomials are found by the recursive relations
> for _i_ =0 to 7
{width="1.9305555555555556in" height="0.5in"} ( 16 )
{width="0.7361111111111112in" height="0.20833333333333334in"}
where _m_ =16 is the predictor order, and {width="1.2083333333333333in"
height="0.20833333333333334in"}.
The ISPs are found by evaluating the polynomials _F_ ~1~_(z)_ and _F_ ~2~_(z)_
at 100 points equally spaced between 0 and $p$and checking for sign changes. A
sign change signifies the existence of a root and the sign change interval is
then divided 4 times to better track the root. The Chebyshev polynomials are
used to evaluate _F~1~(z)_ and _F~2~(z)_ [6]. In this method the roots are
found directly in the cosine domain {_q~i~_}. The polynomials _F~1~(z)_ and
_F~2~(z)_ evaluated at$z = e^{\text{jw}}$can be written as
{width="1.2361111111111112in" height="0.2361111111111111in"} and
{width="1.2777777777777777in" height="0.2361111111111111in"} ( 17 )
with
{width="1.9722222222222223in" height="0.4861111111111111in"} and
{width="2.0277777777777777in" height="0.4861111111111111in"} ( 18 )
where _T~m~_ =cos(_mω_) is the _m_ th order Chebyshev polynomial, _f(i)_ are
the coefficients of either _F_ ~1~_(z)_ or _F_ ~2~_(z)_ , computed using the
equations in (16). The polynomial _C(x)_ is evaluated at a certain value of
_x_ = cos(_ω_) using the recursive relation:
{width="2.138888888888889in" height="1.0555555555555556in"}
where _n~f~_ =8 in case of _C_ ~1~(_x_) and _n~f~_ =7 in case of _C_ ~2~(_x_),
with initial values _b_ ~nf~=_f_(0) and _b_ ~nf+1~=0. The details of the
Chebyshev polynomial evaluation method are found in [6].
### 5.2.4 ISP to LP conversion
Once the ISPs are quantized and interpolated, they are converted back to the
LP coefficient domain $\left{ a_{k} \right}$. The conversion to the LP domain
is done as follows. The coefficients of _F_ ~1~(_z_) and _F_ ~2~(_z_) are
found by expanding Equations (14) and (15) knowing the quantized and
interpolated ISPs _q~i~_ =_,i_ =0,...,_m_ -1, where _m=_ 16\. The following
recursive relation is used to compute _f_ ~1~_(z)_
{width="3.0277777777777777in" height="1.4305555555555556in"}
with initial values _f_ ~1~(0)=1 and _f_ ~1~(1)=-2 _q_ ~0~. The coefficients
_f_ ~2~(_i_) are computed similarly by replacing _q_ ~2 _i_ -2~ by _q_ ~2 _i_
-1~ and _m_ /2 by _m_ /2-1, and with intial conditions _f_ ~2~(0)=1 and _f_
~2~(1)=-2 _q_ ~1~.
Once the coefficients _f_ ~1~_(z)_ and _f_ ~2~_(z)_ are found, _F_ ~2~(_z_) is
multiplied by 1-_z_ ^-2^, to obtain _F\'_ ~2~(_z_); that is
{width="2.611111111111111in" height="0.4861111111111111in"} ( 19 )
Then _F\'_ ~1~(_z_) and _F\'_ ~2~(_z_) are multiplied by 1+_q_ ~m-1~ and 1-_q_
~m-1~, respectively. That is
{width="2.5416666666666665in" height="0.4861111111111111in"}
Finally the LP coefficients are found by
{width="2.986111111111111in" height="0.9305555555555556in"} ( 20 )
This is directly derived from the relation {width="1.4583333333333333in"
height="0.2361111111111111in"}, and considering the fact that _F\'_ ~1~(_z_)
and _F\'_ ~2~(_z_) are symmetric and antisymmetric polynomials, respectively.
### 5.2.5 Quantization of the ISP coefficients
The LP filter coefficients are quantized using the ISP representation in the
frequency domain; that is
{width="2.2916666666666665in" height="0.8888888888888888in"} ( 21 )
where _f~i~_ are the ISFs in Hz [0,6400] and _f~s~_ =12800 is the sampling
frequency. The ISF vector is given by {width="0.1527777777777778in"
height="0.19375in"}= [_f_ ~0~_f_ ~1~,...,_f_ ~15~], with _t_ denoting
transpose.
A 1st order MA prediction is applied, and the residual ISF vector is
quantified using a combination of split vector quantization (SVQ) and multi-
stage vector quantization (MSVQ). The prediction and quantization are
performed as follows. Let {width="0.2777777777777778in"
height="0.20833333333333334in"} denote the mean‑removed ISF vector at frame
{width="0.1388888888888889in" height="0.1388888888888889in"}. The prediction
residual vector **r**(_n_) is given by:
{width="1.0138888888888888in" height="0.20833333333333334in"} ( 22 )
where **p**(_n_) is the predicted LSF vector at frame _n_. First order
moving‑average (MA) prediction is used where:
{width="0.94375in" height="0.3611111111111111in"}, ( 23 )
where {width="0.44375in" height="0.20833333333333334in"} is the quantized
residual vector at the past frame.
The ISF residual vector {width="0.1111111111111111in" height="0.125in"}is
quantized using split-multistage vector quantization S-MSVQ. The vector is
split into 2 subvectors **r** ~1~(_n_) and **r** ~2~(_n_) of dimensions 9 and
7, respectively. The 2 subvectors are quantized in two stages. In the first
stage **r** ~1~(_n_) is quantized with 8 bits and **r** ~2~(_n_) with 8 bits.
For 8.85 ,12.65, 14.25, 15.85, 18.25, 19.85, 23.05 or 23.85 kbit/s modes, the
quantization error vectors {width="1.3194444444444444in"
height="0.2638888888888889in"} are split in the next stage into 3 and 2
subvectors, respectively. The subvectors are quantized using the bit-rates
described in Table 2.
Table 2. Quantization of ISP vector for the 8.85 ,12.65, 14.25, 15.85, 18.25,
19.85, 23.05 or 23.85 kbit/s modes
+-------------+-------------+-------------+-------------+-------------+ | 1. | | | | | | UNQUANTIZED | | | | | | 16-E | | | | | | LEMENT-LONG | | | | | | ISP VECTOR | | | | | +-------------+-------------+-------------+-------------+-------------+ | 2. STAGE 1 | 2. STAGE 1 | | | | | ( | 333334in"}) | | | | | 8 bits | 8 bits | | | | +-------------+-------------+-------------+-------------+-------------+ | > 3\. STAGE | > 3\. STAGE | > 3\. STAGE | > 3\. STAGE | > 3\. STAGE | | > 2 | > 2 | > 2 | > 2 | > 2 | | | | | | | | ( | 111111in"}) | | | > 7 bits | > 7 bits | | | | > 6 bits | | | > 5 bits | > 5 bits | +-------------+-------------+-------------+-------------+-------------+
For 6.60 kbit/s mode, the quantization error vectors
{width="1.3194444444444444in" height="0.2638888888888889in"} are split in the
next stage into 2 and 1 subvectors, respectively. The subvectors are quantized
using the bit-rates described in Table 3.
**Ta** ble 3. Quantization of ISP vector for the 6.60 kbit/s mode
+----------------------+----------------------+----------------------+ | 1. UNQUANTIZED | | | | 16-ELEMENT-LONG ISP | | | | VECTOR | | | +----------------------+----------------------+----------------------+ | 2. STAGE 1 | 2. STAGE 1 | | | ( | 833333333333334in"}) | | | 8 bits | 8 bits | | +----------------------+----------------------+----------------------+ | > 3\. STAGE 2 | > 3\. STAGE 2 | > 3\. STAGE 2 | | | | | | ( | | 361111111111111in"}) | | | > 7 bits | | | > 7 bits | | > 6 bits | +----------------------+----------------------+----------------------+
A squared error ISP distortion measure is used in the quantization process. In
general, for an input ISP or error residual subvector **r** _~i~_ ,_i_ =1,2
and a quantized vector at index _k_ , {width="0.18055555555555555in"
height="0.2361111111111111in"}, the quantization is performed by finding the
index _k_ which minimizes
{width="0.9722222222222222in" height="0.5138888888888888in"}, ( 24 )
where _m_ and _n_ are the first and last elements of the subvector.
### 5.2.6 Interpolation of the ISPs
The set of quantized (and unquantized) LP parameters is used for the fourth
subframe whereas the first, second, and third subframes use a linear
interpolation of the parameters in the adjacent frames. The interpolation is
performed on the ISPs in the $q$domain. Let {width="0.2638888888888889in"
height="0.2125in"} be the ISP vector at the 4th subframe of the frame, and
{width="0.3611111111111111in" height="0.2361111111111111in"} the ISP vector at
the 4th subframe of the past frame _n_ -1. The interpolated ISP vectors at the
1st, 2nd, and 3rd subframes are given by
{width="1.625in" height="0.7361111111111112in"}
The same formula is used for interpolation of the unquantized ISPs. The
interpolated ISP vectors are used to compute a different LP filter at each
subframe (both quantized and unquantized) using the ISP to LP conversion
method described in Section 5.2.4.
## 5.3 Perceptual weighting
The traditional perceptual weighting filter {width="1.75in"
height="0.2361111111111111in"}has inherent limitations in modelling the
formant structure and the required spectral tilt concurrently. The spectral
tilt is more pronounced in wideband signals due to the wide dynamic range
between low and high frequencies. A solution to this problem is to introduce
the preemphasis filter at the input, compute the LP filter _A_(_z_) based on
the preemphasized speech **_s_**(_n_), and use a modified filter _W_(_z_) by
fixing its denominator. This structure substantially decouples the formant
weighting from the tilt.
A weighting filter of the form {width="1.6111111111111112in"
height="0.2222222222222222in"} is used, where {width="1.2222222222222223in"
height="0.4166666666666667in"} and _β_ ~1~=0.68.
Because _A_(_z_) is computed based on the preemphasized speech signal
_s_(_n_), the tilt of the filter _1/A(z/γ~1~)_ is less pronounced compared to
the case when _A_(_z_) is computed based on the original speech. Since
deemphasis is performed at the decoder end, it can be shown that the
quantization error spectrum is shaped by a filter having a transfer function
_W ^-1^_(_z_)_H~de-emph~(z)=1/A(z/γ~1~)_. Thus, the spectrum of the
quantization error is shaped by a filter whose transfer function is
_1/A(z/γ~1~),_ with _A_(_z_) computed based on the preemphasized speech
signal.
## 5.4 Open‑loop pitch analysis
Depending on the mode, open-loop pitch analysis is performed once per frame
(each 10 ms) or twice per frame (each 10 ms) to find two estimates of the
pitch lag in each frame. This is done in order to simplify the pitch analysis
and confine the closed loop pitch search to a small number of lags around the
open-loop estimated lags.
Open-loop pitch estimation is based on the weighted speech signal $s_{w}(n)$
which is obtained by filtering the input speech signal through the weighting
filter {width="1.6111111111111112in" height="0.2222222222222222in"}, where
{width="1.2222222222222223in" height="0.4166666666666667in"} and _β_ ~1~=0.68.
That is, in a subframe of size _L_ , the weighted speech is given by
{width="3.3055555555555554in" height="0.4861111111111111in"} ( 25 )
The open-loop pitch analysis is performed to a signal decimated by two. The
decimated signal is obtained by filtering $s_{w}(n)$ through a fourth order
FIR filter {width="0.6388888888888888in" height="0.20833333333333334in"} and
then downsampling the output by two to obtain the signal
{width="0.4861111111111111in" height="0.25in"}.
### 5.4.1 6.60 kbit/s mode
Open-loop pitch analysis is performed once per frame (every 20 ms) to find an
estimate of the pitch lag in each frame.
The open-loop pitch analysis is performed as follows. First, the correlation
of decimated weighted speech is determined for each pitch lag value _d_ by:
{width="3.111111111111111in" height="0.4722222222222222in"}, ( 26 )
where _w(d)_ is a weighting function. The estimated pitch-lag is the delay
that maximises the weighted correlation function _C(d)_. The weighting
emphasises lower pitch lag values reducing the likelihood of selecting a
multiple of the correct delay. The weighting function consists of two parts: a
low pitch lag emphasis function, _w~l~(d)_ , and a previous frame lag
neighbouring emphasis function, _w~n~(d)_ :
{width="1.0965277777777778in" height="0.20833333333333334in"}. ( 27 )
The low pitch lag emphasis function is a given by:
{width="0.8333333333333334in" height="0.20833333333333334in"} ( 28 )
where _cw(d)_ is defined by a table in the fixed point computational
description. The previous frame lag neighbouring emphasis function depends on
the pitch lag of previous speech frames:
{width="2.3055555555555554in" height="0.4583333333333333in"} ( 29 )
where _T~old~_ is the median filtered pitch lag of 5 previous voiced speech
half-frames and _v_ is an adaptive parameter. If the frame is classified as
voiced by having the open-loop gain _g_ >0.6, then the _v_ -value is set to
1.0 for the next frame. Otherwise, the _v_ -value is updated by _v_ =0.9 _v_.
The open loop gain is given by:
{width="1.94375in" height="0.9722222222222222in"} ( 30 )
where _d~max~_ is the pitch delay that maximizes _C(d)_. The median filter is
updated only during voiced speech frames. The weighting depends on the
reliability of the old pitch lags. If previous frames have contained unvoiced
speech or silence, the weighting is attenuated through the parameter _v_.
### 5.4.2 8.85, 12.65, 14.25, 15.85, 18.25, 19.85, 23.05 and 23.85 kbit/s
modes
Open-loop pitch analysis is performed twice per frame (every 10 ms) to find
two estimates of the pitch lag in each frame.
The open-loop pitch analysis is performed as follows. First, the correlation
of decimated weighted speech is determined for each pitch lag value _d_ by:
{width="2.6666666666666665in" height="0.4861111111111111in"}, ( 31 )
where _w(d)_ is a weighting function. The estimated pitch-lag is the delay
that maximises the weighted correlation function _C(d)_. The weighting
emphasises lower pitch lag values reducing the likelihood of selecting a
multiple of the correct delay. The weighting function consists of two parts: a
low pitch lag emphasis function, _w~l~(d)_ , and a previous frame lag
neighbouring emphasis function, _w~n~(d)_ :
{width="1.0965277777777778in" height="0.20833333333333334in"}. ( 32 )
The low pitch lag emphasis function is given by:
{width="0.8333333333333334in" height="0.20833333333333334in"} ( 33 )
where _cw(d)_ is defined by a table in the fixed point computational
description. The previous frame lag neighbouring emphasis function depends on
the pitch lag of previous speech frames:
{width="2.3055555555555554in" height="0.4583333333333333in"} ( 34)
where _T~old~_ is the median filtered pitch lag of 5 previous voiced speech
half-frames and _v_ is an adaptive parameter. If the frame is classified as
voiced by having the open-loop gain _g_ >0.6, then the _v_ -value is set to
1.0 for the next frame. Otherwise, the _v_ -value is updated by _v_ =0.9 _v_.
The open loop gain is given by:
{width="1.9305555555555556in" height="0.9722222222222222in"} ( 35)
where _d~max~_ is the pitch delay that maximizes _C(d)_. The median filter is
updated only during voiced speech frames. The weighting depends on the
reliability of the old pitch lags. If previous frames have contained unvoiced
speech or silence, the weighting is attenuated through the parameter _v_.
## 5.5 Impulse response computation
The impulse response, _h(n)_ , of the weighted synthesis filter
{width="2.2222222222222223in" height="0.25in"} is computed each subframe. This
impulse response is needed for the search of adaptive and fixed codebooks. The
impulse response _h(n)_ is computed by filtering the vector of coefficients of
the filter _A_(_z/γ_ ~1~) extended by zeros through the two filters
{width="0.44375in" height="0.2361111111111111in"}and
{width="0.7083333333333334in" height="0.2222222222222222in"}.
## 5.6 Target signal computation
The target signal for adaptive codebook search is usually computed by
subtracting the zero-input response of the weighted synthesis filter
{width="2.2222222222222223in" height="0.25in"} from the weighted speech signal
{width="0.375in" height="0.20833333333333334in"}. This is performed on a
subframe basis.
An equivalent procedure for computing the target signal, which is used in this
codec, is the filtering of the LP residual signal _r(n)_ through the
combination of synthesis filter {width="0.44375in"
height="0.2361111111111111in"} and the weighting filter
{width="1.1805555555555556in" height="0.2222222222222222in"}. After
determining the excitation for the subframe, the initial states of these
filters are updated by filtering the difference between the LP residual and
excitation. The memory update of these filters is explained in Section 5.10.
The residual signal _r(n)_ which is needed for finding the target vector is
also used in the adaptive codebook search to extend the past excitation
buffer. This simplifies the adaptive codebook search procedure for delays less
than the subframe size of 64 as will be explained in the next section. The LP
residual is given by
{width="2.1805555555555554in" height="0.4861111111111111in"} ( 36 )
## 5.7 Adaptive codebook
Adaptive codebook search is performed on a subframe basis. It consists of
performing closed loop pitch search, and then computing the adaptive
codevector by interpolating the past excitation at the selected fractional
pitch lag.
The adaptive codebook parameters (or pitch parameters) are the delay and gain
of the pitch filter. In the search stage, the excitation is extended by the LP
residual to simplify the closed-loop search.
In 12.65, 14.25, 15.85, 18.25, 19.85, 23.05 or 23.85 kbit/s modes, in the
first and third subframes, a fractional pitch delay is used with resolutions
1/4 in the range[34, 127{width="0.1527777777777778in"
height="0.3611111111111111in"}], resolutions 1/2 in the range [128,
159{width="0.1527777777777778in" height="0.3611111111111111in"}], and integers
only in the range [160, 231]. For the second and fourth subframes, a pitch
resolution of 1/4 is always used in the range [_T_ ~1~-8, _T_
~1~+7{width="0.1527777777777778in" height="0.3611111111111111in"}], where _T_
~1~ is nearest integer to the fractional pitch lag of the previous (1st or
3rd) subframe.
In 8.85 kbit/s mode, in the first and third subframes, a fractional pitch
delay is used with resolutions 1/2 in the range [34,
91{width="0.1527777777777778in" height="0.3611111111111111in"}], and integers
only in the range [92, 231]. For the second and fourth subframes, a pitch
resolution of 1/2 is always used in the range [_T_ ~1~-8, _T_
~1~+7{width="0.1527777777777778in" height="0.3611111111111111in"}], where
{width="0.1527777777777778in" height="0.20833333333333334in"} is nearest
integer to the fractional pitch lag of the previous (1st or 3rd) subframe.
In 6.60 kbit/s mode, in the first subframe, a fractional pitch delay is used
with resolutions 1/2 in the range [34,91{width="0.1527777777777778in"
height="0.3611111111111111in"}], and integers only in the range [92, 231]. For
the second, third and fourth subframes, a pitch resolution of 1/2 is always
used in the range [_T_ ~1~-8, _T_ ~1~+7{width="0.1527777777777778in"
height="0.3611111111111111in"}], where {width="0.1527777777777778in"
height="0.20833333333333334in"} is nearest integer to the fractional pitch lag
of the first subframe.
Closed-loop pitch analysis is performed around the open-loop pitch estimates
on a subframe basis. In 8.85, 12.65, 14.25, 15.85, 18.25, 19.85, 23.05 or
23.85 kbit/s modes, in the first (and third) subframe the range _T~op~_ ±7,
bounded by 34...231, is searched. In 6.60 kbit/s mode, in the first subframe
the range _T~op~_ ±7, bounded by 34...231, is searched. For all the modes, for
the other subframes, closed-loop pitch analysis is performed around the
integer pitch selected in the previous subframe, as described above. In 12.65,
14.25, 15.85, 18.25, 19.85, 23.05 or 23.85 kbit/s modes, the pitch delay is
encoded with 9 bits in the first and third subframes and the relative delay of
the other subframes is encoded with 6 bits. In 8.85 kbit/s mode, the pitch
delay is encoded with 8 bits in the first and third subframes and the relative
delay of the other subframes is encoded with 5 bits. In 6.60 kbit/s mode, the
pitch delay is encoded with 8 bits in the first subframe and the relative
delay of the other subframes is encoded with 5 bits.
The closed loop pitch search is performed by minimizing the mean-square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term
{width="1.5277777777777777in" height="0.6666666666666666in"} ( 37 )
where _x(n)_ is the target signal and _y~k~(n)_ is the past filtered
excitation at delay $k$ (past excitation convolved with _h(n)_). Note that the
search range is limited around the open-loop pitch as explained earlier.
The convolution _y~k~(n)_ is computed for the first delay in the searched
range, and for the other delays, it is updated using the recursive relation
{width="1.8465277777777778in" height="0.20833333333333334in"} ( 38 )
where u(n),_n_ =--(231+17),...,63, is the excitation buffer. Note that in
search stage, the samples {width="0.9861111111111112in" height="0.19375in"} ,
are not known, and they are needed for pitch delays less than 64. To simplify
the search, the LP residual is copied to _u(n)_ in order to make the relation
in Equation (38) valid for all delays.
Once the optimum integer pitch delay is determined, the fractions from
{width="0.18055555555555555in" height="0.2361111111111111in"} to
{width="0.1388888888888889in" height="0.2638888888888889in"} with a step of
{width="0.1388888888888889in" height="0.2638888888888889in"} around that
integer are tested. The fractional pitch search is performed by interpolating
the normalized correlation in Equation (37) and searching for its maximum.
Once the fractional pitch lag is determined, _v\'(n)_ is computed by
interpolating the past excitation signal _u_(_n_) at the given phase
(fraction). (The interpolation is performed using two FIR filters (Hamming
windowed sinc functions); one for interpolating the term in Equation (34) with
the sinc truncated at ±17 and the other for interpolating the past excitation
with the sinc truncated at ±63). The filters have their cut-off frequency (-3
dB) at 6000 Hz in the oversampled domain, which means that the interpolation
filters exhibit low-pass frequency response Thus, even when the pitch delay is
an integer value, the adaptive codebook excitation consists of a low-pass
filtered version of the past excitation at the given delay and not a direct
copy thereof. Further, for delays smaller than the subframe size, the adaptive
codebook excitation is completed based on the low-pass filtered interpolated
past excitation and not by repeating the past excitation.
In order to enhance the pitch prediction performance in wideband signals, a
frequency-dependant pitch predictor is used. This is important in wideband
signals since the periodicity doesn\'t necessarily extend over the whole
spectrum. In this algorithm, there are two signal paths associated to
respective sets of pitch codebook parameters, wherein each signal path
comprises a pitch prediction error calculating device for calculating a pitch
prediction error of a pitch codevector from a pitch codebook search device.
One of these two paths comprises a low-pass filter for filtering the pitch
codevector and the pitch prediction error is calculated for these two signal
paths. The signal path having the lowest calculated pitch prediction error is
selected, along with the associated pitch gain.
The low pass filter used in the second path is in the form _B~LP~_(_z_)=0.18
_z_ +0.64+0.18 _z_ ^-1^. Note that 1 bit is used to encode the chosen path.
Thus, for 12.65, 14.25, 15.85, 18.25, 19.85, 23.05 or 23.85 kbit/s modes,
there are two possibilities to generate the adaptive codebook _v_(_n_),
{width="0.69375in" height="0.20833333333333334in"} in the first path, or
{width="1.8333333333333333in" height="0.4722222222222222in"}in the second
path, where **b** _~LP~_ =[0.18,0.64,0.18]. The path which results in minimum
energy of the target signal _x_ ~2~(_n_) defined in Equation (40) is selected
for the filtered adaptive codebook vector. For 6.60 and 8.85 kbit/s modes,
_v_(_n_) is always {width="1.8333333333333333in"
height="0.4722222222222222in"}.
The adaptive codebook gain is then found by
{width="3.0in" height="0.625in"} ( 39 )
where {width="1.0555555555555556in" height="0.19375in"} is the filtered
adaptive codebook vector (zero-state response of {width="0.6388888888888888in"
height="0.19375in"} to _v~i~_(_n_)). To insure stability, the adaptive
codebook gain _g~p~_ is bounded by 0.95, if the adaptive codebook gains of the
previous subframes have been small and the LP filters of the previous
subframes have been close to being unstable.
## 5.8 Algebraic codebook
### 5.8.1 Codebook structure
The codebook structure is based on interleaved single-pulse permutation (ISPP)
design. The 64 positions in the codevector are divided into 4 tracks of
interleaved positions, with 16 positions in each track. The different
codebooks at the different rates are constructed by placing a certain number
of signed pulses in the tracks (from 1 to 6 pulses per track). The codebook
index, or codeword, represents the pulse positions and signs in each track.
Thus, no codebook storage is needed, since the excitation vector at the
decoder can be constructed through the information contained in the index
itself (no lookup tables).
An important feature of the used codebook is that it is a dynamic codebook
consisting of an algebraic codebook followed by an adaptive prefilter _F_(_z_)
which enhances special spectral components in order to improve the synthesis
speech quality. A prefilter relevant to wideband signals is used whereby
_F_(_z_) consists of two parts: a periodicity enhancement part 1/(1-0.85 _z_
^-_T_ ^) and a tilt part (1 -- _β_ ~1~ _z_ ^-1^), where _T_ is the integer
part of the pitch lag and _β_ ~1~ is related to the voicing of the previous
subframe and is bounded by [0.0,0.5]. The codebook search is performed in the
algebraic domain by combining the filter _F_(_z_) with the weighed synthesis
filter prior to the coddedbook search. Thus, the impulse response _h_(_n_)
must be modified to include the prefilter _F_(_z_). That is,
{width="1.3465277777777778in" height="0.2222222222222222in"}.
The codebook structures of different bit rates are given below.
#### 5.8.1.1 23.85 and 23.05 kbit/s mode
In this codebook, the innovation vector contains 24 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 64 positions in a subframe are
divided into 4 tracks, where each track contains six pulses, as shown in Table
4.
Table 4. Potential positions of individual pulses in the algebraic codebook,
23.85 and 23.05 kbit/s
* * *
Track Pulse Positions 1 i0, i4, i8, i12, i16, i20 0, 4, 8, 12, 16, 20, 24, 28,
32 36, 40, 44, 48, 52, 56, 60 2 i1, i5, i9, i13, i17, i21 1, 5, 9, 13, 17, 21,
25, 29, 33, 37, 41, 45, 49, 53, 57, 61 3 i2, i6, i10, i14, i18, i22 2, 6, 10,
14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62 4 i3, i7, i11, i15, i19,
i23 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63
* * *
The six pulses in one track are encoded with 22 bits.
This gives a total of 88 bits (22+22+22+22) for the algebraic code.
#### 5.8.1.2 19.85 kbit/s mode
In this codebook, the innovation vector contains 18 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 64 positions in a subframe are
divided into 4 tracks, where each of the first two tracks contains five pulses
and each of the other tracks contains four pulses, as shown in Table 5.
Table 5. Potential positions of individual pulses in the algebraic codebook,
19.85 kbit/s
* * *
Track Pulse Positions 1 i0, i4, i8, i12, i16 0, 4, 8, 12, 16, 20, 24, 28, 32
36, 40, 44, 48, 52, 56, 60 2 i1, i5, i9, i13, i17 1, 5, 9, 13, 17, 21, 25, 29,
33, 37, 41, 45, 49, 53, 57, 61 3 i2, i6, i10, i14 2, 6, 10, 14, 18, 22, 26,
30, 34, 38, 42, 46, 50, 54, 58, 62 4 i3, i7, i11, i15 3, 7, 11, 15, 19, 23,
27, 31, 35, 39, 43, 47, 51, 55, 59, 63
* * *
The five pulses in one track are encoded with 20 bits. The four pulses in one
track is encoded with 16 bits.
This gives a total of 72 bits (20+20+16+16) for the algebraic code.
#### 5.8.1.3 18.25 kbit/s mode
In this codebook, the innovation vector contains 16 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 64 positions in a subframe are
divided into 4 tracks, where each track contains four pulses, as shown in
Table 6.
Table 6. Potential positions of individual pulses in the algebraic codebook,
18.25 kbit/s
* * *
Track Pulse Positions 1 i0, i4, i8, i12 0, 4, 8, 12, 16, 20, 24, 28, 32 36,
40, 44, 48, 52, 56, 60 2 i1, i5, i9, i13 1, 5, 9, 13, 17, 21, 25, 29, 33, 37,
41, 45, 49, 53, 57, 61 3 i2, i6, i10, i14 2, 6, 10, 14, 18, 22, 26, 30, 34,
38, 42, 46, 50, 54, 58, 62 4 i3, i7, i11, i15 3, 7, 11, 15, 19, 23, 27, 31,
35, 39, 43, 47, 51, 55, 59, 63
* * *
The four pulses in one track are encoded with 16 bits.
This gives a total of 64 bits (16+16+16+16) for the algebraic code.
#### 5.8.1.4 15.85 kbit/s mode
In this codebook, the innovation vector contains 12 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 64 positions in a subframe are
divided into 4 tracks, where each track contains three pulses, as shown in
Table 7.
Table 7. Potential positions of individual pulses in the algebraic codebook,
15.85 kbit/s
* * *
Track Pulse Positions 1 i0, i4, i8 0, 4, 8, 12, 16, 20, 24, 28, 32 36, 40, 44,
48, 52, 56, 60 2 i1, i5, i9 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49,
53, 57, 61 3 i2, i6, i10 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54,
58, 62 4 i3, i7, i11 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59,
63
* * *
The three pulses in one track are encoded with 13 bits.
This gives a total of 52 bits (13+13+13+13) for the algebraic code.
#### 5.8.1.5 14.25 kbit/s mode
In this codebook, the innovation vector contains 10 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 64 positions in a subframe are
divided into 4 tracks, where each track contains two or three pulses, as shown
in Table 8.
Table 8. Potential positions of individual pulses in the algebraic codebook,
14.25 kbit/s
* * *
Track Pulse Positions 1 i0, i4, i8 0, 4, 8, 12, 16, 20, 24, 28, 32 36, 40, 44,
48, 52, 56, 60 2 i1, i5, i9 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49,
53, 57, 61 3 i2, i6 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58,
62 4 i3, i7 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63
* * *
Each two pulse positions in one track are encoded with 8 bits (4 bits for the
position of every pulse), and the sign of the first pulse in the track is
encoded with 1 bit.
The three pulse in one track are encoded with 13 bits.
This gives a total of 44 bits (13+13+9+9) for the algebraic code.
#### 5.8.1.6 12.65 kbit/s mode
In this codebook, the innovation vector contains 8 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 64 positions in a subframe are divided
into 4 tracks, where each track contains two pulses, as shown in Table 9.
Table 9. Potential positions of individual pulses in the algebraic codebook,
12.65 kbit/s
* * *
Track Pulse Positions 1 i0, i4 0, 4, 8, 12, 16, 20, 24, 28, 32 36, 40, 44, 48,
52, 56, 60 2 i1, i5 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57,
61 3 i2, i6 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62 4 i3,
i7 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63
* * *
Each two pulse positions in one track are encoded with 8 bits (total of 32
bits, 4 bits for the position of every pulse), and the sign of the first pulse
in the track is encoded with 1 bit (total of 4 bits). This gives a total of 36
bits for the algebraic code.
#### 5.8.1.7 8.85 kbit/s mode
In this codebook, the innovation vector contains 4 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 64 positions in a subframe are divided
into 4 tracks, where each track contains one pulse, as shown in Table 10.
Table 10. Potential positions of individual pulses in the algebraic codebook,
8.85 kbit/s
* * *
Track Pulse Positions 1 i0 0, 4, 8, 12, 16, 20, 24, 28, 32 36, 40, 44, 48, 52,
56, 60 2 i1 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61 3 i2
2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62 4 i3 3, 7, 11,
15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63
* * *
Each pulse position in one track are encoded with 4 bits and the sign of the
pulse in the track is encoded with 1 bit. This gives a total of 20 bits for
the algebraic code.
#### 5.8.1.8 6.60 kbit/s mode
In this codebook, the innovation vector contains 2 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 64 positions in a subframe are divided
into 2 tracks, where each track contains one pulse, as shown in Table 11.
Table 11. Potential positions of individual pulses in the algebraic codebook,
6.60 kbit/s
* * *
Track Pulse Positions 1 i0 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62 2 i1 1,
3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41,
43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63
* * *
Each pulse position in one track are encoded with 5 bits and the sign of the
pulse in the track is encoded with 1 bit. This gives a total of 12 bits for
the algebraic code.
### 5.8.2 Pulse indexing
In the above section, the number of bits needed to encode a number of pulses
in a track was given. In this section, the procedures used for encoding from 1
to 6 pulses per track will be described. The description will be given for the
case of 4 tracks per subframe, with 16 positions per track and pulse spacing
of 4 (which is the case for all modes except the 6.6 kbit/s mode).
_[Encoding 1 signed pulse per track]{.underline}_
The pulse position index is encoded with 4 bits and the sign index with 1 bit.
The position index is given by the pulse position in the subframe divided by
the pulse spacing (integer division). The division remainder gives the track
index. For example, a pulse at position 31 has a position index of 31/4 = 7
and it belong to the track with index 3 (4^th^ track).
The sign index here is set to 0 for positive signs and 1 for negative signs.
The index of the signed pulse is given by
I~1p~= _p_ +_s_ ×2 _^M^_
where p is the position index, s is the sign index, and M=4 is the number of
bits per track.
_[Encoding 2 signed pulses per track]{.underline}_
In case of two pulses per track of _K_ =2 _^M^_ potential positions (here
M=4), each pulse needs 1 bit for the sign and _M_ bits for the position, which
gives a total of 2 _M_ +2 bits. However, some redundancy exists due to the
unimportance of the pulse ordering. For example, placing the first pulse at
position p and the second pulse at position q is equivalent to placing the
first pulse at position q and the second pulse at position p. One bit can be
saved by encoding only one sign and deducing the second sign from the ordering
of the positions in the index. Here the index is given by
I~2p~ = p~1~ + p~0~×2^M^ + s×2^2M^
where s is the sign index of the pulse at position index p~0~. If the two
signs are equal then the smaller position is set to p~0~ and the larger
position is set to p~1~. On the other hand, of the two signs are not equal
then the larger position is set to p~0~ and the smaller position is set to
p~1~. At the decoder, the sign of the pulse at position p~0~ is readily
available. The second sign is deduced from the pulse ordering. If p~0~ is
larger than p~1~ then the sign of the pulse at position p~1~ is opposite to
that at position p~0~. If this is not the case then the two signs are set
equal
_[Encoding 3 signed pulses per track]{.underline}_
In case of three pulses per track, similar logic can be used as in the case of
two pulses. For a track with 2^M^ positions, 3M+1 bits are needed instead of
3M+3 bits. A simple way of indexing the pulses is to divide the track
positions in two sections (or halves) and identify a section that contains at
least two pulses. The number of positions in the section is _K_ /2 = 2 _^M^_
/2 = 2^_M_ -1^, which can be represented with _M_ -1 bits. The two pulses in
the section containing at least two pulses are encoded with the procedure for
encoding 2 signed pulses which requires 2(M-1)+1 bits and the remaining pulse
which can be anywhere in the track (in either section) is encoded with the M+1
bits. Finally, the index of the section that contains the two pulses is
encoded with 1 bit. Thus the total number of required bits is 2(M-1)+1 + M+1 +
1 = 3M+1.
A simple way of checking if two pulses are positioned in the same section is
done by checking whether the most significant bits (MSB) of their position
indices are equal or not. Note that a MSB of 0 means that the position belongs
to the lower half of the track (0-7) and MSB of 1 means it belongs to the
upper half (8-15). If the two pulses belong to the upper half, they need to be
shifted to the range (0-7) before encoding them using 2×3+1 bits. This can be
done by masking the _M_ -1 least significant bits (LSB) with a mask consisting
of _M_ -1 ones (which corresponds to the number 7 in this case).
The index of the 3 signed pulses is given by
> I~3p~ = I~2p~ +k×2^2M-1^+ I~1p~×2^2M^
where I~2p~ is the index of the two pulses in the same section, k is the
section index (0 or 1), and I~1p~ is the index of the third pulse in the
track.
_[Encoding 4 signed pulses per track]{.underline}_
The 4 signed pulses in a track of length _K_ =2 _^M^_ can be encoded using 4
_M_ bits. Similar to the case of 3 pulses, the _K_ positions in the track are
divided into 2 sections (two halves) where each section contains _K_ /2=8
positions. Here we denote the sections as Section A with positions 0 to _K_
/2-1 and Section B with positions _K_ /2 to _K_ -1. Each section can contain
from 0 to 4 pulses. The table below shows the 5 cases representing the
possible number of pulses in each section:
* * *
_case_ _Pulses in Section A_ _Pulses in Section B_ _Bits needed_ 0 0 4 4 _M_
-3 1 1 3 4 _M_ -2 2 2 2 4 _M_ -2 3 3 1 4 _M_ -2 4 4 0 4 _M_ -3
* * *
In cases 0 or 4, the 4 pulses in a section of length _K/2_ =2^_M_ -1^ can be
encoded using 4(_M_ -1)+1=4 _M_ -3 bits (this will be explained later on).
In cases 1 or 3, the 1 pulse in a section of length _K/2_ =2^_M_ -1^ can be
encoded with _M_ -1+1 = _M_ bits and the 3 pulses in the other section can be
encoded with 3(_M_ -1)+1 = 3 _M_ -2 bits. This gives a total of _M_ +3 _M_ -2
= 4 _M_ -2 bits.
In case 2, the pulses in a section of length _K/2_ =2^_M_ -1^ can be encoded
with 2(_M_ -1)+1 = 2 _M_ \--1 bits. Thus for both sections, 2(2 _M_ \--1) = 4
_M_ \--2 bits are required.
Now the case index can be encoded with 2 bits (4 possible cases) assuming
cases 0 and 4 are combined. Then for cases 1, 2, or 3, the number of needed
bits is 4 _M_ -2. This gives a total of 4 _M_ -2 + 2 = 4 _M_ bits. For cases 0
or 4, one bit is needed for identifying either case, and 4 _M_ -3 bits are
needed for encoding the 4 pulses in the section. Adding the 2 bits needed for
the general case, this gives a total of 1+4 _M_ -3+2= 4 _M_ bits.
The index of the 4 signed pulses is given by
I~4p~ = I~AB~ + k×2^4M-2^
where k is the case index (2 bits), and I~AB~ is the index of the pulses in
both sections for each individual case.
For cases 0 and 1, I~AB~ is given by
I~AB_0,4~ = I~4p_section~ + j×2^4M-3^
where j is a 1-bit index identifying the section with 4 pulses and
I~4p_section~ is the index of the 4 pulses in that section (which requires
4M-3 bits).
For case 1, I~AB~ is given by
I~AB_1~ = I~3p_B~ + I~1p_A~ ×2^3(M-1)+1^
where I~3p_B~ is the index of the 3 pulses in Section B (3(M-1)+1 bits) and
I~1p_A~ is the index of the pulse in Section A ((M-1)+1 bits).
For case 2, I~AB~ is given by
I~AB_2~ = I~2p_B~ + I~2p_A~ ×2^2(M-1)+1^
where I~2p_B~ is the index of the 2 pulses in Section B (2(M-1)+1 bits) and
I~2p_A~ is the index of the two pulses in Section A (2(M-1)+1 bits).
Finally, for case 3, I~AB~ is given by
I~AB_3~ = I~1p_B~ + I~3p_A~ ×2^M^
where I~1p_B~ is the index of the pulse in Section B ((M-1)+1 bits) and
I~3p_A~ is the index of the 3 pulses in Section A (3(M-1)+1 bits).
For cases 0 and 4, it was mentioned that the 4 pulses in one section are
encoded using 4(_M_ -1)+1 bits. This is done by further dividing the section
into 2 subsections of length _K_ /4=2^_M_ -2^ (=4 in this case); identifying a
subsection that contains at least 2 pulses; coding the 2 pulses in that
subsection using 2(_M_ -2)+1=2 _M_ -3 bits; coding the index of the subsection
that contains at least 2 pulses using 1 bit; and coding the remaining 2
pulses, assuming that they can be anywhere in the section, using 2(_M_ -1)+1=2
_M_ -1 bits. This gives a total of (2M-3)+(1)+(2M-1) = 4M-3 bits
_[Encoding 5 signed pulses per track]{.underline}_
The 5 signed pulses in a track of length _K_ =2 _^M^_ can be encoded using 5
_M_ bits. Similar to the case of 4 pulses, the _K_ positions in the track are
divided into 2 sections A and B. Each section can contain from 0 to 5 pulses.
A simple approach to encode the 5 pulses is to identify a section that
contains at least 3 pulses and to encode the 3 pulses in that section using
3(_M_ -1)+1= 3 _M_ -2 bits, and to encode the remaining 2 pulses in the whole
track using 2 _M_ +1 bits. This gives 5 _M_ -1 bits. An extra bit is needed to
identify the section that contains at least 3 pulses. Thus a total of 5 _M_
bits are needed to encode the 5 signed pulses.
The index of the 5 signed pulses is given by
I~5p~ = I~2p~ + I~3p~×2^2M^ + k×2^5M-1^
Where k is the index of the section that contains at least 3 pulses, I~3p~ is
the index of the 3 pulses in that section (3(M-1)+1 bits), and I~2p~ is the
index of the remaining 2 pulses in the track (2M+1 bits).
_[Encoding 6 signed pulses per track]{.underline}_
The 6 signed pulses in a track of length _K_ =2 _^M^_ are encoded using 6 _M_
-2 bits. Similar to the case of 5 pulses, the _K_ positions in the track are
divided into 2 sections A and B. Each section can contain from 0 to 6 pulses.
The table below shows the 7 cases representing the possible number of pulses
in each sections:
* * *
_case_ _Pulses in Section A_ _Pulses in Section B_ _Bits needed_ 0 0 6 6 _M_
-5 1 1 5 6 _M_ -5 2 2 4 6 _M_ -5 3 3 3 6 _M_ -4 4 4 2 6 _M_ -5 5 5 1 6 _M_ -5
6 6 0 6 _M_ -5
* * *
Note that cases 0 and 6 are similar except that the 6 pulses are in different
section. Similarly, cases 1 and 5 as well as cases 2 and 4 differ only in the
section that contains more pulses. Therefore these cases can be coupled and an
extra bit can be assigned to identify the section that contains more pulses.
Since these cases initially need 6 _M_ -5 bits, the coupled cases need 6 _M_
-4 bits taking into account the Section bit. Thus, we have now 4 states of
coupled cases, that is (0,6), (1,5), (2,4), and (3),with 2 extra bits needed
for the state. This gives a total of 6 _M_ -4+2=6 _M_ -2 bits for the 6 signed
pulses.
In cases 0 and 6, 1 bit is needed to identify the section which contains 6
pulses. 5 pulses in that section are encoded using 5(_M_ -1) bits (since the
pulses are confined to that section), and the remaining pulse is encoded using
(_M_ -1)+1 bits. Thus a total of 1+5(_M_ -1)+_M_ =6 _M_ -4 bits are needed for
this coupled case. Extra 2 bits are needed to encode the state of the coupled
case, giving a total of 6 _M_ -2 bits. For this coupled case, the index of the
6 pulses is given by
I~6p~ = I~1p~ + I~5p~×2^M^+ j×2^6M-5^ + k×2^6M-4^
where k is the index of the coupled case (2 bits), j is the index of the
section containing 6 pulses (1 bit), I~5p~ is the index of 5 pulses in that
section (5(M-1) bits), and I~1p~ is the index of the remaining pulse in that
section ((M-1)+1 bits).
In cases 1 and 5, 1 bit is needed to identify the section which contains 5
pulses. The 5 pulses in that section are encoded using 5(_M_ -1) bits and the
pulse in the other section is encoded using (_M_ -1)+1 bits. For this coupled
case, the index of the 6 pulses is given by
I~6p~ = I~1p~ + I~5p~×2^M^+ j×2^6M-5^ + k×2^6M-4^
where k is the index of the coupled case (2 bits), j is the index of the
section containing 5 pulses (1 bit), I~5p~ is the index of the 5 pulses in
that section (5(M-1) bits), and I~1p~ is the index of the pulse in the other
section ((M-1)+1 bits).
In cases 2 or 4, 1 bit is needed to identify the section which contains 4
pulses. The 4 pulses in that section are encoded using 4(_M_ -1) bits and the
2 pulses in the other section are encoded using 2(_M_ -1)+1 bits. For this
coupled case, the index of the 6 pulses is given by
I~6p~ = I~2p~ + I~4p~×2^2(M-1)+1^ + j×2^6M-5^ + k×2^6M-4^
where k is the index of the coupled case (2 bits), j is the index of the
section containing 4 pulses (1 bit), I~4p~ is the index of 4 pulses in that
section (4(M-1) bits), and I~2p~ is the index of the 2 pulses in the other
section (2(M-1)+1 bits).
In case 3, the 3 pulses in each section are encoded using 3(_M_ -1)+1 bits in
each Section. For this case, the index of the 6 pulses is given by
I~6p~ = I~3pB~ + I~3pA~×2^3(M-1)+1^ + k×2^6M-4^
where k is the index of the coupled case (2 bits), I~3pB~ is the index of 3
pulses Section B (3(M-1)+1 bits), and I~3pA~ is the index of the 3 pulses in
Section A (3(M-1)+1 bits).
### 5.8.3 Codebook search
The algebraic codebook is searched by minimizing the mean square error between
the weighted input speech and the weighted synthesis speech. The target signal
used in the closed-loop pitch search is updated by subtracting the adaptive
codebook contribution. That is
{width="2.19375in" height="0.2222222222222222in"} ( 40 )
where$y(n) = v(n) \ast h(n)$ is the filtered adaptive codebook vector and
_g~p~_ is the unquantized adaptive codebook gain.
The matrix **H** is defined as the lower triangular Toeplitz convolution
matrix with diagonal _h_(0) and lower diagonals _h_(1),...,_h_(63), and
{width="0.5555555555555556in" height="0.2361111111111111in"} is the
correlation between the target signal _x_ ~2~(_n_) and the impulse response
_h_(_n_) (also known as the backward filtered target vector), and
{width="0.5833333333333334in" height="0.19375in"} is the matrix of
correlations of _h_(_n_).
The elements of the vector **d** are computed by
{width="2.19375in" height="0.4861111111111111in"} ( 41 )
and the elements of the symmetric matrix$F$ are computed by
{width="3.2222222222222223in" height="0.5in"} ( 42 )
If **c** _~k~_ is the algebraic codevector at index _k_ , then the algebraic
codebook is searched by maximizing the search criterion
{width="2.111111111111111in" height="0.4583333333333333in"} (43)
The vector **d** and the matrix **Φ** are usually computed prior to the
codebook search.
The algebraic structure of the codebooks allows for very fast search
procedures since the innovation vector **c** _~k~_ contains only a few nonzero
pulses. The correlation in the numerator of Equation (43) is given by
$C = \sum_{i = 0}^{N_{p} - 1}{a_{i}d(m_{i})}$ ( 44 )
where _m~i~_ is the position of the _i_ th pulse, _a~i~_ is its amplitude, and
_N~p~_ is the number of pulses. The energy in the denominator of Equation (43)
is given by
{width="2.5in" height="0.5138888888888888in"} ( 45 )
To simplify the search procedure, the pulse amplitudes are predetermined based
on a certain reference signal _b_(_n_). In this so-called signal-selected
pulse amplitude approach, the sign of a pulse at position _i_ is set equal to
the sign of the reference signal at that position. Here, the reference signal
_b_(_n_) is given by
{width="1.8194444444444444in" height="0.5277777777777778in"} (46)
where {width="0.5416666666666666in" height="0.22152777777777777in"}is the
energy of the signal _d_(_n_) and {width="0.7in" height="0.2in"} is the energy
of the signal $r_{\text{LTP}}(n)$ which is the residual signal after long term
prediction. The scaling factor _α_ controls the amount of dependence of the
reference signal on _d_(_n_), and it is lowered as the bit rate is increased.
Here _α_ =2 for 6.6 and 8.85 modes; _α_ =1 for 12.65, 14.25, and 15.85 modes;
_α_ =0.8 for 18.25 mode; _α_ =0.75 for 19.85 mode; and _α_ =0.5 for 23.05 and
23.85 modes.
To simplify the search the signal _d_(_n_) and matrix **Φ** are modified to
incorporate the pre-selected signs. Let _s~b~_(n) denote the vector containing
the signs of _b_(_n_). The modified signal _d\'_(_n_) is given by
{width="1.25in" height="0.25in"} _n_ =0,...,_N_ -1
and the modified autocorrelation matrix **Φ\'** is given by
{width="1.5173611111111112in" height="0.21875in"}, _i_ =0,...,_N_ -1; j=_i_
,...,_N_ -1.
The correlation at the numerator of the search criterion _Q~k~_ is now given
by
{width="1.0in" height="0.5in"}
and the energy at the denominator of the search criterion _Q~k~_ is given by
{width="2.4166666666666665in" height="0.5138888888888888in"}
The goal of the search now is to determine the codevector with the best set of
_N~p~_ pulse positions assuming amplitudes of the pulses have been selected as
described above. The basic selection criterion is the maximization of the
above mentioned ratio _Q~k~_.
In order to reduce the search complexity, a fast search procedure known as
depth-first tree search procedure is used, whereby the pulse positions are
determined _N~m~_ pulses at a time. More precisely, the _N~p~_ available
pulses are partitioned into _M_ non-empty subsets of _N~m~_ pulses
respectively such that _N_ ~1~+_N_ ~2~...+_N~m~_...+_N~M~_ = _N~p~_. A
particular choice of positions for the first _J_ = _N_ ~1~+_N_ ~2~...+_N~m~_
~-1~ pulses considered is called a level-_m_ path or a path of length _J_. The
basic criterion for a path of _J_ pulse positions is the ratio _Q~k~_(_J_)
when only the _J_ relevant pulses are considered.
The search begins with subset #1 and proceeds with subsequent subsets
according to a tree structure whereby subset _m_ is searched at the _m_ ^th^
level of the tree. The purpose of the search at level 1 is to consider the _N_
~1~ pulses of subset #1 and their valid positions in order to determine one,
or a number of, candidate path(s) of length _N_ ~1~ which are the tree nodes
at level l. The path at each terminating node of level _m_ -1 is extended to
length _N_ ~1~+_N_ ~2~...+_N~m~_ at level _m_ by considering _N~m~_ new pulses
and their valid positions. One, or a number of, candidate extended path(s) are
determined to constitute level-_m_ nodes. The best codevector corresponds to
that path of length _N~p~_ which maximizes the criterion _Q~k~_(_N~p~_) with
respect to all level-_M_ nodes.
A special form of the depth-first tree search procedure is used here, in which
two pulses are searched at a time, that is, _N~m~_ =2, and these 2 pulses
belong to two consecutive tracks. Further, instead of assuming that the matrix
**Φ** is precomputed and stored, which requires a memory of _N_ × _N_ words
(64×64= 4k words), a memory-efficient approach is used which reduces the
memory requirement. In this approach, the search procedure is performed in
such a way that only a part of the needed elements of the correlation matrix
are precomputed and stored. This part corresponds to the correlations of the
impulse response corresponding to potential pulse positions in consecutive
tracks, as well as the correlations corresponding to _φ_(_j_ ,_j_), _j_
=0,...,_N_ -1 (that is the elements of the main diagonal of matrix **Φ**).
In order to reduce complexity, while testing possible combinations of two
pulses, a limited number of potential positions of the first pulse are tested.
Further, in case of large number of pulses, some pulses in the higher levels
of the search tree are fixed. In order to guess intelligently which potential
pulse positions are considered for the first pulse or in order to fix some
pulse positions, a \"pulse-position likelihood-estimate vector\" **b** is
used, which is based on speech-related signals. The _p_ ^th^ component
_b_(_p_) of this estimate vector **b** characterizes the probability of a
pulse occupying position _p_ (_p_ = 0, 1, ... _N_ -1) in the best codevector
we are searching for. Here the estimate vector **b** is the same vector used
for preselecting the amplitudes and given in Equation (46).
The search procedures for all bit rate modes are similar. Two pulses are
searched at a time, and these two pulses always correspond to consecutive
tracks. That is the two searched pulses are in tracks T~0~-T~1~, T~1~-T~2~,
T~2~-T~3~, or T~3~-T~0~.
Before searching the positions, the sign of at pulse a potential position _n_
is set the sign of _b_(_n_) at that position. Then the modified signal
_d\'_(_n_) is computed as described above by including the predetermined
signs.
For the first 2 pulses (1^st^ tree level), the correlation at the numerator of
the search criterion is given by
{width="1.19375in" height="0.20833333333333334in"}.
and the energy at the denominator of the search criterion _Q~k~_ is given by
{width="2.4027777777777777in" height="0.20833333333333334in"}
where the correlations {width="0.7638888888888888in"
height="0.2638888888888889in"} has been modified to include the preselected
signs at positions _m~i~_ and _m~j~_.
For subsequent levels, the numerator and denominator are updated by adding the
contribution of two new pulses. Assuming that two new pulses at a certain tree
level with positions _m~k~_ and _m~k+~_ ~1~ from two consecutive tracks are
searched, then the updated value of _R_ is given by
{width="1.5555555555555556in" height="0.20833333333333334in"} (47)
and the updated energy is given by
{width="4.402777777777778in" height="0.20833333333333334in"} (48)
where _R~hv~_(_m_) is the correlation between the impulse response _h_(_n_)
and a vector _v~h~_(_n_) containing the addition of delayed versions of
impulse response at the previously determined positions. That is,
{width="1.4166666666666667in" height="0.4722222222222222in"}
and
{width="1.8465277777777778in" height="0.4722222222222222in"}
At each tree level, the values of _R~hv~_(_m_) are computed online for all
possible positions in each of the two tracks being tested. It can be seen from
Equation (48) that only the correlations {width="0.8888888888888888in"
height="0.25in"} corresponding to pulse positions in two consecutive tracks
need to be stored (4×16×16 words), along with the correlations
{width="0.7916666666666666in" height="0.25in"}corresponding to the diagonal of
the matrix **Φ** (64 words). Thus the memory requirement in the present
algebraic structure is 1088 words instead of 64×64=4096 words.
The search procedures at the different bit rates modes are similar. The
difference is in the number of pulses, and accordingly, the number of levels
in the tree search. In order to keep a comparable search complexity across the
different codebooks, the number of tested positions is kept similar.
The search in the 12.65 kbit/s mode will be described as an example. In this
mode, 2 pulses are placed in each track giving a total of 8 pulses per
subframe of length 64. Two pulses are searched at a time, and these two pulses
always correspond to consecutive tracks. That is the two searched pulses are
in tracks T~0~-T~1~, T~1~-T~2~, T~2~-T~3~, or T~3~-T~0~. The tree has 4 levels
in this case. At the first level, pulse P~0~ is assigned to track T~0~ and
pulse P~1~ to track T~1~. In this level, no search is performed and the two
pulse positions are set to the maximum of _b_(_n_) in each track. In the
second level, pulse P~2~ is assigned to track T~2~ and pulse P~3~ to track
T~3~. 4 positions for pulse P~2~ are tested against all 16 positions of pulse
P~3~. The 4 tested positions of P~2~ are determined based on the maxima of
_b_(_n_) in the track. In the third level, pulse P~4~ is assigned to track
T~1~ and pulse P~5~ to track T~2~. 8 positions for pulse P~4~ are tested
against all 16 positions of pulse P~5~. Similar to the previous search level,
the 8 tested positions of P~4~ are determined based on the maxima of _b_(_n_)
in the track. In the fourth level, pulse P~6~ is assigned to track T~3~ and
pulse P~7~ to track T~0~. 8 positions for pulse P~6~ are tested against all 16
positions of pulse P~7~. Thus the total number of tested combination is
4×16+8×16+8×16=320. The whole process is repeated 4 times (4 iterations) by
assigning the pulses to different tracks. For example, in the 2^nd^ iteration,
pulses P~0~ to P~7~ are assigned to tracks T~1~, T~2~, T~3~, T~0~, T~2~, T~3,~
T~0~, and T~1~, respectively. Thus the total number of tested position
combinations is 4×320=1280.
As another search example, in the 15.85 kbit/s mode, 3 pulses are placed in
each track giving a total of 12 pulses. There are 6 levels in the tree search
whereby two pulses are searched in each level. In the first two levels, 4
pulses are set to the maxima of _b_(_n_). In the subsequent 4 levels, the
number of tested combinations are 4×16, 6×16, 8×16, and 8×16, respectively. 4
iterations are used giving a total of 4×26×16=1664 combinations.
## 5.9 Quantization of the adaptive and fixed codebook gains
The adaptive codebook gain (pitch gain) and the fixed (algebraic) codebook
gain are vector quantized using a 6-bit codebook for modes 8.85 and 6.60
kbit/s and using a 7-bit codebook for all the other modes.
The fixed codebook gain quantization is performed using MA prediction with
fixed coefficients. The 4th order MA prediction is performed on the innovation
energy as follows. Let _E_(_n_) be the mean-removed innovation energy (in dB)
at subframe _n_ , and given by
{width="2.0277777777777777in" height="0.5138888888888888in"} ( 49)
where _N_ =64 is the subframe size, _c_(_i_) is the fixed codebook excitation,
and {width="0.44375in" height="0.19375in"} dB is the mean of the innovation
energy. The predicted energy is given by
{width="1.2083333333333333in" height="0.4861111111111111in"} ( 50)
where [_b_ ~1~ _b_ ~2~ _b_ ~3~ _b_ ~4~]=[05.,0.4,0.3,0.2] are the MA
prediction coefficients, and $\hat{R}(k)$ is the quantized energy prediction
error at subframe _k_. The predicted energy is used to compute a predicted
fixed-codebook gain _g_ \'_~c~_ as in Equation (49) (by substituting _E_(_n_)
by $\overset{\sim}{E}(n)$ and _g~c~_ by _g_ \'_~c~_). This is done as follows.
First, the mean innovation energy is found by
$E_{i} = \text{10}\text{\ log\ }\left( \frac{1}{N}\sum_{i = 0}^{N -
1}{}c^{2}(i) \right)$ ( 51)
and then the predicted gain _g_ \'_~c~_ is found by
$g_{c}^{'} = \text{10}^{0\text{.}\text{05}(\overset{\sim}{E}(n) + \overline{E}
- E_{i})}\text{.}$ ( 52)
A correction factor between the gain _g~c~_ and the estimated one _g_ \'_~c~_
is given by
$g = \frac{g_{c}}{g_{c}^{'}}\text{.}$ ( 53)
Note that the prediction error is given by
$R(n) = E(n) - \overset{\sim}{E}(n) = \text{20}\text{log}(g)\text{.}$ ( 54)
The pitch gain, _g~p~_ , and correction factor γ are jointly vector quantized
using a 6-bit codebook for modes 8.85 and 6.60 kbit/s, and 7-bit codebook for
other modes. The gain codebook search is performed by minimizing the mean-
square of the weighted error between original and reconstructed speech which
is given
$E = x^{t}x + g_{p}^{2}y^{t}y + g_{c}^{2}z^{t}z - 2g_{p}x^{t}y - 2g_{c}x^{t}z
+ 2g_{p}g_{c}y^{t}z,$ ( 55)
where the _x_ is the target vector, _y_ is the filtered adaptive codebook
vector, and _z_ is the filtered fixed codebook vector. (Each gain vector in
the codebook also has an element representing the quantized energy prediction
error.) The quantized energy prediction error associated with the chosen gains
is used to update $\hat{R}\left( n \right)$. In the search, only the 64
codevectors that are closest to the unquantized pitch gain, _g~p~_ , are taken
into account.
## 5.10 Memory update
An update of the states of the synthesis and weighting filters is needed in
order to compute the target signal in the next subframe.
After the two gains have been quantized, the excitation signal, _u_(_n_), in
the present subframe is found by
{width="2.236111111111111in" height="0.2222222222222222in"} ( 56)
where {width="0.18055555555555555in" height="0.2222222222222222in"} and
{width="0.16666666666666666in" height="0.20833333333333334in"} are the
quantized adaptive and fixed codebook gains, respectively, _v~i~_(_n_) the
adaptive codebook vector (interpolated past excitation), and _c_(_n_) is the
fixed codebook vector (algebraic code including pitch sharpening). The states
of the filters can be updated by filtering the signal _r_(_n_)− _u_(_n_)
(difference between residual and excitation) through the filters
{width="0.44375in" height="0.2222222222222222in"} and
{width="1.1805555555555556in" height="0.2222222222222222in"} for the 64 sample
subframe and saving the states of the filters. This would require 3
filterings. A simpler approach which requires only one filtering is as
follows. The local synthesis speech, {width="0.2777777777777778in"
height="0.19375in"}, is computed by filtering the excitation signal through
{width="0.44375in" height="0.2222222222222222in"}. The output of the filter
due to the input _r_(_n_)− _u_(_n_) is equivalent to {width="1.0in"
height="0.19375in"}. So the states of the synthesis filter {width="0.44375in"
height="0.2222222222222222in"} are given by _e_(_n_),_n_ =48,...,63. Updating
the states of the filter {width="1.1805555555555556in"
height="0.2222222222222222in"} can be done by filtering the error signal
_e_(_n_) through this filter to find the perceptually weighted error
_e~w~_(_n_). However, the signal _e~w~_(_n_) can be equivalently found by
{width="1.7638888888888888in" height="0.2222222222222222in"} ( 57)
Since the signals _x_(_n_), _y_(_n_), and _z_(_n_) are available, the states
of the weighting filter are updated by computing _e~w~_(_n_) as in Equation
(54) for {width="0.75in" height="0.18055555555555555in"}. This saves two
filterings.
## 5.11 High-band gain generation
In order to compute the high band gain for 23.85 kbit/s mode, 16 kHz input
speech is filtered through a band-pass FIR filter _H~HB~_(_z_) which has the
passband from 6.4 to 7 kHz. The high band gain _g~HB~_ is obtained by
{width="1.2638888888888888in" height="0.9027777777777778in"} ( 58)
where _s~HB~_(_i_) is band-pass filtered input speech and _s~HB2~_(_i_) is
high-band speech synthesis obtained from high-band excitation _u~HB~_ ~2~(_i_)
filtered through high-band synthesis filter _A~HB~_(_z_) described in Section
6.3.2.2.
# 6 Functional description of the decoder
The function of the decoder consists of decoding the transmitted parameters
(LP parameters, adaptive codebook vector, adaptive codebook gain, fixed
codebook vector, fixed codebook gain and high-band gain) and performing
synthesis to obtain the reconstructed speech. The reconstructed speech is then
postprocessed and upsampled (and upscaled). Finally high-band signal is
generated to the frequency band from 6 to 7 kHz. The signal flow at the
decoder is shown in Figure 3.
## 6.1 Decoding and speech synthesis
The decoding process is performed in the following order:
**Decoding of LP filter parameters:** The received indices of ISP quantization
are used to reconstruct the quantized ISP vector. The interpolation described
in Section 5.2.6 is performed to obtain 4 interpolated ISP vectors
(corresponding to 4 subframes). For each subframe, the interpolated ISP vector
is converted to LP filter coefficient domain _a~k~_ , which is used for
synthesizing the reconstructed speech in the subframe.
The following steps are repeated for each subframe:
1\. **Decoding of the adaptive codebook vector:** The received pitch index
(adaptive codebook index) is used to find the integer and fractional parts of
the pitch lag. The adaptive codebook vector _v_(_n_) is found by interpolating
the past excitation _u_(_n_) (at the pitch delay) using the FIR filter
described in Section 5.7. The received adaptive filter index is used to find
out whether the filtered adaptive codebook is _v_ ~1~(_n_)= _v_(_n_) or
{width="2.5416666666666665in" height="0.20833333333333334in"}.
2\. **Decoding of the innovative vector:** The received algebraic codebook
index is used to extract the positions and amplitudes (signs) of the
excitation pulses and to find the algebraic codevector _c_(_n_). If the
integer part of the pitch lag is less than the subframe size 64, the pitch
sharpening procedure is applied which translates into modifying _c_(_n_) by
filtering it through the adaptive prefilter _F_(_z_) which consists of two
parts: a periodicity enhancement part 1/(1-0.85 _z_ ^− _T_ ^) and a tilt part
(1 -- _β_ ~1~ _z_ ^−1^), where _T_ is the integer part of the pitch lag and
_β_ ~1~(_n_) is related to the voicing of the previous subframe and is bounded
by [0.0,0.5].
3\. **Decoding of the adaptive and innovative codebook gains:** The received
index gives the fixed codebook gain correction factor
{width="0.1388888888888889in" height="0.2222222222222222in"}. The estimated
fixed codebook gain _g\'~c~_ is found as described in Section 5.8. First, the
predicted energy for every subframe _n_ is found by
{width="1.19375in" height="0.4861111111111111in"} ( 59)
and then the mean innovation energy is found by
{width="1.5138888888888888in" height="0.4861111111111111in"} ( 60)
The predicted gain{width="0.16666666666666666in"
height="0.2361111111111111in"} is found by
{width="1.2222222222222223in" height="0.2638888888888889in"} ( 61)
The quantized fixed codebook gain is given by
{width="0.5416666666666666in" height="0.2361111111111111in"} ( 62)
4\. **Computing the reconstructed speech:** The following steps are for _n_ =
0, ..., 63. The total excitation is constructed by:
{width="1.9583333333333333in" height="0.2361111111111111in"} ( 63)
Before the speech synthesis, a post-processing of excitation elements is
performed.
5\. **Anti-sparseness processing (6.60 and 8.85 kbit/s modes):** An adaptive
anti-sparseness post-processing procedure is applied to the fixed codebook
vector _c_(_n_) in order to reduce perceptual artifacts arising from the
sparseness of the algebraic fixed codebook vectors with only a few non-zero
samples per subframe. The anti-sparseness processing consists of circular
convolution of the fixed codebook vector with an impulse response. Three pre-
stored impulse responses are used and a number _impNr_ =0,1,2 is set to select
one of them. A value of 2 corresponds to no modification, a value of 1
corresponds to medium modification, while a value of 0 corresponds to strong
modification. The selection of the impulse response is performed adaptively
from the adaptive and fixed codebook gains. The following procedure is
employed:
> {width="1.1666666666666667in" height="1.2361111111111112in"}
Detect onset by comparing the fixed codebook gain to the previous fixed
codebook gain. If the current value is more than three times the previous
value an onset is detected.
If not onset and _impNr_ =0, the median filtered value of the current and the
previous 4 adaptive codebook gains are computed. If this value is less than
0.6, _impNr_ =0.
If not onset, the _impNr_ -value is restricted to increase by one step from
the previous subframe.
If an onset is declared, the _impNr_ -value is increased by one if it is less
than 2.
In case of 8.85 kbit/s mode, the _impNr_ -value is increased by one.
6\. **Noise enhancer:** A nonlinear gain smoothing technique is applied to the
fixed codebook gain {width="0.18055555555555555in"
height="0.20833333333333334in"}in order to enhance excitation in noise. Based
on the stability and voicing of the speech segment, the gain of the fixed
codebook is smoothed in order to reduce fluctuation in the energy of the
excitation in case of stationary signals. This improves the performance in
case of stationary background noise.
The voicing factor is given by _λ_ =0.5(1-_r~v~_) with _r~v~_ =(_E~v~_
-_E~c~_)/(_E~v~_ +_E~c~_), where _E~v~_ and _E~c~_ are the energies of the
scaled pitch codevector and scaled innovation codevector, respectively. Note
that since the value of _r~v~_ is between \--1 and 1, the value of _λ_ is
between 0 and 1. Note that the factor _λ_ is related to the amount of
unvoicing with a value of 0 for purely voiced segments and a value of 1 for
purely unvoiced segments.
A stability factor _θ_ is computed based on a distance measure between the
adjacent LP filters. Here, the factor _θ_ is related to the ISP distance
measure and it is bounded by 0≤ _θ_ ≤1, with larger values of _θ_
corresponding to more stable signals.
Finally, a gain smoothing factor _S~m~_ is given by
_S~m~_ = _λθ._ (64)
The value of _S~m~_ approaches 1 for unvoiced and stable signals, which is the
case of stationary background noise signals. For purely voiced signals or for
unstable signals, the value of _S~m~_ approaches 0.
An initial modified gain _g_ ~0~ is computed by comparing the fixed codebook
gain {width="0.17777777777777778in" height="0.21458333333333332in"}to a
threshold given by the initial modified gain from the previous subframe, _g_
~-1~. If {width="0.17777777777777778in" height="0.21458333333333332in"} is
larger or equal to _g_ ~-1~, then _g_ ~0~ is computed by decrementing
{width="0.17777777777777778in" height="0.21458333333333332in"} by 1.5 dB
bounded by _g_ ~0~≥ _g_ ~-1~. If {width="0.17777777777777778in"
height="0.21458333333333332in"} is smaller than _g_ ~-1~, then _g_ ~0~ is
computed by incrementing {width="0.17777777777777778in"
height="0.21458333333333332in"} by 1.5 dB bounded by _g_ ~0~≤ _g_ ~-1~.
Finally, the gain is update with the value of the smoothed gain as follows
{width="1.5965277777777778in" height="0.25in"}, ( 65)
**7\. Pitch enhancer:** A pitch enhancer procedure modifies the total
excitation {width="0.3055555555555556in" height="0.19375in"}by filtering the
fixed codebook excitation through an innovation filter whose frequency
response emphasizes the higher frequencies more than lower frequencies, and
whose coefficients are related to the periodicity in the signal. A filter of
the form
{width="1.625in" height="0.25in"}, ( 66)
where _c~pe~_ =0.125(1+ _r~v~_), with _r~v~_ =(_E~v~_ -_E~c~_)/(_E~v~_
+_E~c~_) as described above. The filtered fixed codevector is given by
{width="2.125in" height="0.2222222222222222in"} ( 67)
and the updated excitation is given by
{width="1.4166666666666667in" height="0.2222222222222222in"} ( 68)
The above procedure can be done in one step by updating the excitation as
follows
{width="2.2083333333333335in" height="0.2222222222222222in"} ( 69)
8\. **Post-processing of excitation elements (6.60 and 8.85 kbit/s modes):** A
post‑processing of excitation elements procedure is applied to the total
excitation {width="0.3055555555555556in" height="0.19375in"}by emphasizing the
contribution of the adaptive codebook vector:
{width="2.3055555555555554in" height="0.4861111111111111in"} (70)
Adaptive gain control (AGC) is used to compensate for the gain difference
between the non‑emphasized excitation _u_(_n_) and emphasized excitation
{width="0.2916666666666667in" height="0.20833333333333334in"} The gain scaling
factor _η_ for the emphasized excitation is computed by:
{width="1.8194444444444444in" height="0.875in"} ( 71)
The gain‑scaled emphasized excitation signal {width="0.3055555555555556in"
height="0.20833333333333334in"} is given by:
> {width="0.7638888888888888in" height="0.20833333333333334in"}. ( 72)
The reconstructed speech for the subframe of size 64 is given by
{width="2.5in" height="0.4861111111111111in"} (73)
where {width="0.1527777777777778in" height="0.20833333333333334in"} are the
interpolated LP filter coefficients.
The synthesis speech {width="0.2777777777777778in" height="0.19375in"} is then
passed through an adaptive postprocessing which is described in the following
section.
## 6.2 High-pass filtering, up-scaling and interpolation
The high-pass filter serves as a precaution against undesired low frequency
components. The signal is filtered through the high-pass filter _H~h~_
~1~(_z_) and de-emphasis filter _H~de_emph~_(_z_).
Finally, the signal is upsampled to 16 kHz to obtain the lower band synthesis
signal {width="0.4305555555555556in" height="0.20833333333333334in"}.
{width="0.4305555555555556in" height="0.20833333333333334in"} is produced by
first upsampling the lower band synthesis {width="0.5in"
height="0.20833333333333334in"} at 12.8 kHz by 5, then filtering the output
through _H~decim~_(_z_), and finally downsampling it by 4.
(Up-scaling consists of multiplying the output from the high-pass filtering by
a factor of 2 in order to compensate the down-scaling at the pre-processing
stage.)
## 6.3 High frequency band
For the higher frequency band (6.4 -- 7.0 kHz), excitation is generated to
model the highest frequencies. The high frequency content is generated by
filling the upper part of the spectrum with a white noise properly scaled in
the excitation domain, then converted to the speech domain by shaping it with
a filter derived from the same LP synthesis filter used for synthesizing the
down-sampled signal.
### 6.3.1 Generation of high-band excitation
The high-band excitation is obtained by first generating white noise _u~HB~_
~1~(_n_). The power of the high-band excitation is set equal to the power of
the lower band excitation _u_ ~2~(_n_) which means that
{width="2.611111111111111in" height="0.5277777777777778in"}. ( 74)
Finally the high-band excitation is found by
{width="1.2777777777777777in" height="0.20833333333333334in"}, (75 )
where {width="0.2777777777777778in" height="0.20833333333333334in"}is a gain
factor.
In the 23.85 kbit/s mode,{width="0.2777777777777778in"
height="0.20833333333333334in"}is decoded from the received gain index.
In 6.60, 8.85, 12.65, 14.25, 15.85, 18.25, 19.85 and 23.05 kbit/s modes,
_g~HB~_ is estimated using voicing information bounded by [0.1,1.0]. First,
tilt of synthesis _e~tilt~_ is found
{width="2.2222222222222223in" height="0.4861111111111111in"} (76 )
where {width="0.3888888888888889in" height="0.2222222222222222in"} is high-
pass filtered lower band speech synthesis {width="0.5138888888888888in"
height="0.20833333333333334in"} with cut-off frequency of 400 Hz. The
${\hat{g}}_{\text{HB}}$ is then found by
{width="1.7222222222222223in" height="0.20833333333333334in"}, ( 77 )
where _g~SP~_ _=_ 1 - _e~tilt~_ is gain for speech signal, _g~BG~_ _=_ 1.25
_g~SP~_ is gain for background noise signal, and _w~SP~_ is a weighting
function set to 1, when VAD is ON, and 0 when VAD is OFF. _g~HB~_ is bounded
between [0.1, 1.0]. In case of voiced segments where less energy is present at
high frequencies, _e~tilt~_ approaches 1 resulting in a lower gain _g~HB~_.
This reduces the energy of the generated noise in case of voiced segments.
### 6.3.2 LP filter for the high frequency band
#### 6.3.2.1 6.60 kbit/s mode
The high-band LP synthesis filter _A~HB~_(_z_) is found by extrapolating the
quantized ISF vector **f** into 20th order ISF vector **f** _~e~_. First,
maximum of the autocorrelation _C~max~_(_i_) of ISF vector difference vector
{width="1.875in" height="0.20833333333333334in"} is obtained. Then new 16kHz
ISF vector _f~e~\'_(_i_) is computed by
{width="4.041666666666667in" height="0.4583333333333333in"}. (78 )
An approximation of the last element of new ISF
vector{width="0.2638888888888889in" height="0.20833333333333334in"}is updated
based on lower frequency coefficients. New extrapolated ISF vector difference
vector {width="0.3888888888888889in" height="0.20833333333333334in"} is
{width="2.44375in" height="0.20833333333333334in"}, (79 )
where _c~scale~_ scales {width="0.3888888888888889in"
height="0.20833333333333334in"} so that _f~e~_(19) will be equal to _f~e~_
~19~. In order to insure stability,{width="0.3888888888888889in"
height="0.20833333333333334in"} is bounded by
{width="2.0694444444444446in" height="0.20833333333333334in"}. (80)
Finally, the extrapolated ISF vector {width="0.1527777777777778in"
height="0.20833333333333334in"}is obtained by
{width="2.25in" height="0.6527777777777778in"}. (81 )
**f** _~e~_ is converted to cosine domain to obtain
{width="0.18055555555555555in" height="0.20833333333333334in"}with 16000 Hz
sampling rate. The high-band LP synthesis filter _A~HB~_(_z_) is obtained by
converting {width="0.18055555555555555in" height="0.20833333333333334in"} to
LP filter as described in 5.2.4 with _m_ =20.
#### 6.3.2.2 8.85, 12.65, 14.25, 15.85, 18.25, 19.85, 23.05 or 23.85 kbit/s
modes
The high-band LP synthesis filter _A~HB~_(_z_) is weighted low-band LP
synthesis filter
{width="1.0694444444444444in" height="0.2916666666666667in"}, (82)
where _Â_(_z_) is the interpolated LP synthesis filter.
{width="0.3055555555555556in" height="0.2361111111111111in"} has been computed
analysing signal with the sampling rate of 12.8 kHz but it is now used for a
16 kHz signal. Effectively, this means that the frequency response _FR_
~16~(_f_) of _A~HB~_(_z_) is obtained by
{width="1.5277777777777777in" height="0.3611111111111111in"} ( 83)
where _FR_ ~12.8~(_f_) is the frequency response of _A_(_z_). This means that
the band 5.1 -- 5.6 kHz in 12.8 kHz domain will be mapped to 6.4 -- 7.0 kHz in
16 kHz domain.
### 6.3.3 High band synthesis
_u~HB~_(_n_) is filtered through _A~HB~_(_z_). The output of this high-band
synthesis _s~HB~_(_n_) is filtered through a band-pass FIR filter _H~HB~_(_z_)
which has the passband from 6 to 7 kHz. Finally, _s~HB~_ is added to
synthesized speech {width="0.4305555555555556in"
height="0.20833333333333334in"} to produce the synthesized output speech
signal {width="0.5416666666666666in" height="0.2222222222222222in"}.
# 7 Detailed bit allocation of the adaptive multi-rate wideband codec
The detailed allocation of the bits in the adaptive multi-rate wideband speech
encoder is shown for each mode in table 12a-12i. These tables show the order
of the bits produced by the speech encoder. Note that the most significant bit
(MSB) of each codec parameter is always sent first.
Table 12a: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 477 bits/20 ms, 23.85 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s68 Codebook
Index1 for track 1 s69 -- s79 Codebook Index1 for track 2 ss80 --s90 Codebook
Index1 for track 3 s91-s101 Codebook Index1 for track 4 s102-s112 Codebook
Index2 for track 1 s113-s123 Codebook Index2 for track 2 s124 -- s134 Codebook
Index2 for track 3 s135 -- s145 Codebook Index2 for track 4 s146 -- s152
codebook gains s153 -- s156 High-band energy subframe 2  
s157 -- s162 adaptive codebook index (relative) s163 -- s262 same description
as s57 -- s156 subframe 3  
s263 -- s371 same description as s48 -- s156 subframe 4  
s372 -- s477 same description as s157 -- s262
* * *
Table 12b: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 461 bits/20 ms, 23.05 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s68 Codebook
Index1 for track 1 s69 -- s79 Codebook Index1 for track 2 ss80 --s90 Codebook
Index1 for track 3 s91-s101 Codebook Index1 for track 4 s102-s112 Codebook
Index2 for track 1 s113-s123 Codebook Index2 for track 2 s124 -- s134 Codebook
Index2 for track 3 s135 -- s145 Codebook Index2 for track 4 s146 -- s152
codebook gains subframe 2  
s153 -- s158 adaptive codebook index (relative) s159 -- s254 same description
as s57 -- s152 subframe 3  
s255 -- s359 same description as s48 -- s152 subframe 4  
s360 -- s461 same description as s153 -- s254
* * *
Table 12c: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 397 bits/20 ms, 19.85 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s67 Codebook
Index1 for track 1 s68 -- s77 Codebook Index1 for track 2 s78 -- s79 Pulse
Selector for track 3 s80 -- s81 Pulse Selector for track 4 s82 -- s91 Codebook
index2 for track 1 s92 -- s101 Codebook index2 for track 2 s102 -- s115
Codebook index for track 3 s116 -- s129 Codebook index for track 4 s130 --
s136 VQ gain subframe 2  
s137 -- s142 adaptive codebook index (relative) s143 -- s222 same description
as s57 -- s136 subframe 3  
s223 -- s311 same description as s48 -- s136 subframe 4  
s312 -- s397 same description as s137 -- s222
* * *
Table 12d: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 365 bits/20 ms, 18.25 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s59 Pulse
Selector for track 1 s60 -- s61 Pulse Selector for track 2 s62 -- s63 Pulse
Selector for track 3 s64 -- s65 Pulse Selector for track 4 s66 -- s79 Codebook
index for track 1 s80 -- s93 Codebook index for track 2 s94 -- s107 Codebook
index for track 3 s108 -- s121 Codebook index for track 4 s122 -- s128 VQ gain
subframe 2  
s129 -- s134 adaptive codebook index (relative) s135 -- s206 same description
as s57 -- s128 subframe 3  
s207 -- s287 same description as s48 -- s128 subframe 4  
s288 -- s365 same description as s129 -- s206
* * *
Table 12e: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 317 bits/20 ms, 15.85 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s70 Codebook
index for track 1 s71 -- s83 Codebook index for track 2 s84 -- s96 Codebook
index for track 3 s97 -- s109 Codebook index for track 4 s110 -- s116 VQ gain
subframe 2  
s117 -- s122 adaptive codebook index (relative) s123 -- s182 same description
as s57 -- s116 subframe 3  
s183 -- s251 same description as s48 -- s116 subframe 4  
s252 -- s317 same description as s117 -- s182
* * *
Table 12f: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 285 bits/20 ms, 14.25 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s70 Codebook
index for track 1 s71 -- s83 Codebook index for track 2 s84 -- s92 Codebook
index for track 3 s93 -- s101 Codebook index for track 4 s102 -- s108 VQ gain
subframe 2  
s109 -- s114 adaptive codebook index (relative) s115 -- s166 same description
as s57 -- s108 subframe 3  
s167 -- s227 same description as s48 -- s108 subframe 4  
s228 -- s285 same description as s109 -- s166
* * *
Table 12g: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 253 bits/20 ms, 12.65 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s56 adaptive codebook index s57 LTP-filtering-flag s58 -- s66 Codebook
index for track 1 s67 -- s75 Codebook index for track 2 s76 -- s84 Codebook
index for track 3 s85 -- s93 Codebook index for track 4 s94 -- s100 VQ gain
subframe 2  
s101 -- s106 adaptive codebook index (relative) s107 -- s150 same description
as s57 -- s100 subframe 3  
s151 -- s203 same description as s48 -- s100 subframe 4  
s204 -- s253 same description as s101 -- s150
* * *
Table 12h: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 177 bits/20 ms, 8.85 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 ‑ s23 index of 3rd ISP subvector s24 --
s30 index of 4th ISP subvector s31 -- s37 index of 5th ISP subvector s38 --
s42 index of 6th ISP subvector s43 -- s47 index of 7th ISP subvector subframe
1  
s48 -- s55 adaptive codebook index s56 -- s60 Codebook index for track 1 s61
-- s65 Codebook index for track 2 s66 -- s70 Codebook index for track 3 s71 -
s75 Codebook index for track 4 s76 -- s81 VQ gain subframe 2  
s82 -- s86 adaptive codebook index (relative) s87 -- s112 same description as
s56 -- s81 subframe 3  
s113 -- s146 same description as s48 -- s81 subframe 4  
s147 -- s177 same description as s82 -- s112
* * *
Table 12i: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 132 bits/20 ms, 6.60 kbit/s mode
* * *
Bits (MSB‑LSB) Description s1 VAD-flag s2 -- s9 index of 1st ISP subvector s10
-- s17 index of 2nd ISP subvector s18 -- s24 index of 3rd ISP subvector s25 --
s31 index of 4th ISP subvector s32 -- s37 index of 5th ISP subvector subframe
1  
s38 -- s45 adaptive codebook index s46 - 57 Codebook Index s58 -- s63 VQ gain
subframe 2  
s64 -- s68 adaptive codebook index (relative) s69 -- s86 same description as
s46 -- s63 subframe 3  
s87 -- s109 same description as s64 -- s86 subframe 4  
s110 -- s132 same description as s64 -- s86
* * *
# 8 Homing sequences
## 8.1 Functional description
The adaptive multi-rate wideband speech codec is described in a bit‑exact
arithmetic to allow easy type approval as well as general testing of correct
operation of the adaptive multi-rate wideband speech codec.
The response of the codec to a predefined input sequence can only be foreseen
if the internal state variables of the codec are in a predefined state at the
beginning of the experiment. Therefore, the codec has to be put in a so called
home state before a bit‑exact test can be performed. This is usually done by a
reset (a procedure in which the internal state variables of the codec are set
to their defined initial values). The codec mode of the speech encoder and
speech decoder shall be set to the tested codec mode by external means at
reset.
To allow a reset of the codec in remote locations, special homing frames have
been defined for the encoder and the decoder, thus enabling a codec homing by
inband signalling.
The codec homing procedure is defined in such a way, that in either direction
(encoder or decoder) the homing functions are called after the processing of
the homing frame. The output corresponding to the first homing frame is
therefore dependent on the used codec mode and the codec state when receiving
that frame and hence usually not known. The response of the encoder to any
further homing frame is by definition the corresponding decoder homing frame
for the used codec mode. The response of the decoder to any further homing
frame is by definition the encoder homing frame. This procedure allows homing
of both the encoder and decoder from either side, if a loop back configuration
is implemented, taking proper framing into account.
## 8.2 Definitions
**Encoder homing frame:** The encoder homing frame consists of 320 identical
samples, each 13 bits long, with the least significant bit set to \"one\" and
all other bits set to \"zero\". When written to 16‑bit words with left
justification, the samples have a value of 0008 hex. The speech decoder has to
produce this frame as a response to the second and any further decoder homing
frame if at least two decoder homing frames were input to the decoder
consecutively. The encoder homing frame is identical for all codec modes.
**Decoder homing frame:** There exist nine different decoder homing frames,
which correspond to the nine AMR-WB codec modes. Using one of these codec
modes, the corresponding decoder homing frame is the natural response of the
speech encoder to the second and any further encoder homing frame if at least
two encoder homing frames were input to the encoder consecutively. In [4], for
each decoder homing frame the parameter values are given.
## 8.3 Encoder homing
Whenever the adaptive multi-rate wideband speech encoder receives at its input
an encoder homing frame exactly aligned with its internal speech frame
segmentation, the following events take place:
Step 1: The speech encoder performs its normal operation including VAD and SCR
and produces in accordance with the used codec mode a speech parameter frame
at its output which is in general unknown. But if the speech encoder was in
its home state at the beginning of that frame, then the resulting speech
parameter frame is identical to that decoder homing frame, which corresponds
to the used codec mode (this is the way how the decoder homing frames were
constructed).
Step 2: After successful termination of that operation the speech encoder
provokes the homing functions for all sub‑modules including VAD and SCR and
sets all state variables into their home state. On the reception of the next
input frame, the speech encoder will start from its home state.
NOTE: Applying a sequence of N encoder homing frames will cause at least N‑1
decoder homing frames at the output of the speech encoder.
## 8.4 Decoder homing
Whenever the speech decoder receives at its input a decoder homing frame,
which corresponds to the used codec mode, then the following events take
place:
Step 1: The speech decoder performs its normal operation and produces a speech
frame at its output which is in general unknown. But if the speech decoder was
in its home state at the beginning of that frame, then the resulting speech
frame is replaced by the encoder homing frame. This would not naturally be the
case but is forced by this definition here.
Step 2: After successful termination of that operation the speech decoder
provokes the homing functions for all sub‑modules including the comfort noise
generator and sets all state variables into their home state. On the reception
of the next input frame, the speech decoder will start from its home state.
NOTE 1: Applying a sequence of N decoder homing frames will cause at least N‑1
encoder homing frames at the output of the speech decoder.
NOTE 2: By definition (!) the first frame of each decoder test sequence must
differ from the decoder homing frame at least in one bit position within the
parameters for LPC and first subframe. Therefore, if the decoder is in its
home state, it is sufficient to check only these parameters to detect a
subsequent decoder homing frame. This definition is made to support a
delay‑optimized implementation in the TRAU uplink direction.
{width="5.833333333333333in" height="2.2930555555555556in"}
Figure 1 Simplified block diagram of the CELP synthesis model
{width="6.649305555555555in" height="3.941666666666667in"}
Figure 2 Detailed block diagram of the ACELP encoder
{width="6.613888888888889in" height="2.4069444444444446in"}
Figure 3 Detailed block diagram of the ACELP decoder
# 9 Bibliography
1) M.R. Schroeder and B.S. Atal, \"Code‑Excited Linear Prediction (CELP): High
quality speech at very low bit rates,\" in Proc. _ICASSP\'85_ , pp. 937‑940,
1985.
2) L.R. Rabiner and R.W. Schaefer. _Digital processing of speech signals_.
Prentice‑Hall Int., 1978.
3) F. Itakura, \"Line spectral representation of linear predictive
coefficients of speech signals,\" _J. Acoust. Soc. Amer._ , vol. 57,
Supplement no. 1, S35, 1975.
4) Y. Bistritz and S. Pellerm, \"Immittance Spectral Pairs (ISP) for speech
encoding,\" in _Proc. ICASSP\'93_ , pp. II-9 - II-12.
5) K.K Paliwal and B.S. Atal, \"Efficient vector quantization of LPC
parameters at 24 bits/frame\", _IEEE Trans. Speech and Audio Processing_ ,
vol. 1, no 1, pp. 3‑14, 1993.
6) P. Kabal and R.P. Ramachandran, \"The computation of line spectral
frequencies using Chebyshev polynomials\", _IEEE Trans. on ASSP_ , vol. 34,
no. 6, pp. 1419‑1426, Dec. 1986.
7) K. Järvinen, J. Vainio, P. Kapanen, T. Honkanen, P. Haavisto, R. Salami, C.
Laflamme, and J.-P. Adoul, \"GSM enhanced full rate speech codec\", in _Proc.
ICASSP\'97_ , pp. 771‑774.
8) T. Honkanen, J. Vainio, K. Järvinen, P. Haavisto, R. Salami, C. Laflamme,
and J.-P. Adoul, \"Enhanced full rate speech codec for IS-136 digital cellular
system\", in _Proc. ICASSP\'97_ , pp. 731‑734.
9) R. Hagen, E. Ekudden, B. Johansson, and W.B. Kleijn, \"Removal of sparse-
excitation artifacts in CELP\", in _Proc. ICASSP\'98_ , pp. I-145‑I-148.
#
# Foreword
This Technical Report has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
The present document\'s **objectives are to:**
a) Investigate whether battery efficient \'device to enterprise\' mechanisms
to provide sufficient security exist.
b) Investigate potential enhancements to 3GPP\'s security architecture(s) that
enable the Home Operator to be able to offer well guaranteed security to
enterprises e.g. to provide security between the UE and a node in the home
operator domain.
c) Both S1 and Gb based architectures should be considered when undertaking b,
above.
The impacts of relevant authentication and key agreement procedures are also
presented.
**The following should be taken into account for the study:**
\- The potential solutions should aim at minimising the energy consumption of
devices to help meet the objective of a ten year battery life in the extended
coverage situation and take into consideration the very low data rate
capability of the radio interface when using the Energy Consumption Evaluation
Methodology described in TR 45.820.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TR 41.001: \"GSM Release specifications\".
[3] Void
[4] IETF Transport Layer Security (tls) Working Group, Charter,
http://datatracker.ietf.org/wg/tls/charter/
[5] IETF RFC 7252: \"The Constrained Application Protocol (CoAP)\".
[6] I-D draft-ypoeluev-tls-m2mcertificate-00 \"Transport Layer Security (TLS)
and Datagram Transport Layer Security (DTLS) Authentication Using M2M
Certificate\".
[7] I-D draft-ietf-tls-cached-info-19 \"Transport Layer Security (TLS) Cached
Information Extension\".
[8] I-D draft-ietf-tls-tls13-05: \"The Transport Layer Security (TLS) Protocol
Version 1.3\".
[9] IETF RFC 5246: \"The Transport Layer Security (TLS) Protocol Version
1.2\".
[10] I-D draft-ietf-dice-profile-13: \"A TLS/DTLS Profile for the Internet of
Things\".
[11] 3GPP TS 23.060: \"General Packet Radio Service (GPRS); Service
description; Stage 2\".
[12] 3GPP TS 24.008: \"Mobile radio interface Layer 3 specification; Core
network protocols; Stage 3\".
[13] 3GPP TS 48.018: \"General Packet Radio Service (GPRS); Base Station
System (BSS) - Serving GPRS Support Node (SGSN); BSS GPRS protocol (BSSGP)\".
[14] 3GPP TS 44.064: \"Mobile Station - Serving GPRS Support Node (MS-SGSN);
Logical Link Control (LLC) Layer Specification\".
[15] 3GPP TS 44.065: \"Mobile Station (MS) - Serving GPRS Support Node (SGSN);
Subnetwork Dependent Convergence Protocol (SNDCP)\".
[16] 3GPP TS 23.401: \"General Packet Radio Service (GPRS) enhancements for
Evolved Universal Terrestrial Radio Access Network (E-UTRAN) access\".
[17] Void.
[18] 3GPP TS 36.413: \"Evolved Universal Terrestrial Radio Access Network
(E-UTRAN); S1 Application Protocol (S1AP)\".
[19] 3GPP TS 33.187: \"Security aspects of Machine-Type Communications (MTC)
and other mobile data applications communications enhancements\".
[20] 3GPP TS 33.220: \"Generic Authentication Architecture (GAA); Generic
Bootstrapping Architecture (GBA)\".
[21] 3GPP TS 33.223: \"Generic Authentication Architecture (GAA); Generic
Bootstrapping Architecture (GBA) Push function\".
[22] 3GPP TS 22.368: \"Service requirements for Machine-Type Communications
(MTC); Stage 1\".
[23] 3GPP TS 36.323: \"Evolved Universal Terrestrial Radio Access (E-UTRA);
Packet Data Convergence Protocol (PDCP) specification\".
[24] 3GPP TS 29.281: \"General Packet Radio System (GPRS) Tunnelling Protocol
User Plane (GTPv1-U)\".
[25] 3GPP TR 45.820: \"Cellular system support for ultra-low complexity and
low throughput Internet of Things (CIoT)\".
[26] NIST SP 800-38D.
[27] 3GPP TS 33.102: \"3G security; Security architecture\".
[28] 3GPP TS 33.401: \"3GPP System Architecture Evolution (SAE); Security
architecture\".
[29] 3GPP TS 29.060: \"General Packet Radio Service (GPRS); GPRS Tunnelling
Protocol (GTP) across the Gn and Gp interface\".
[30] 3GPP TS 24.301: \"Non-Access-Stratum (NAS) protocol for Evolved Packet
System (EPS); Stage 3\".
[31] 3GPP TS 23.002: \"Network architecture\".
[32] IETF RFC 6347.: \"Datagram Transport Layer Security\" [33] IETF RFC 4492.
\"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security
(TLS) \".
[34] 3GPP TS 24.109: \"Bootstrapping interface (Ub) and network application
function interface (Ua); Protocol details\".
[35] 3GPP TS 33.222: \"Generic Authentication Architecture (GAA); Access to
network application functions using Hypertext Transfer Protocol over Transport
Layer Security (HTTPS)\".
[36] IETF RFC 4303: \"IP Encapsulation Security Payload (ESP)\".
[37] 3GPP TS 33.210: \"Network Domain Security (NDS); IP network layer
security\".
[38] 3GPP TS 55.241: \" Specification of the GIA4 integrity algorithm for
GPRS; GIA4 specification\".
[39] 3GPP TS 55.251: \" Specification of the GEA5 encryption and GIA5
integrity algorithms for GPRS; GEA5 and GIA5 specification\".
[40] 3GPP TS 35.205: \"3G Security; Specification of the MILENAGE Algorithm
Set: An example algorithm set for the 3GPP authentication and key generation
functions f1, f1*, f2, f3, f4, f5 and f5*; Document 1: General\".
[41] 3GPP TS 35.215: \"Specification of the 3GPP Confidentiality and Integrity
Algorithms UEA2 & UIA2; Document 1: UEA2 and UIA2 specifications\".
[42] 3GPP TS 35.401: \"\"
[43] 3GPP TS 35.221: \" Specification of the 3GPP Confidentiality and
Integrity Algorithms EEA3 & EIA3; Document 1: EEA3 and EIA3 specifications\".
[44] IETF RFC 7296: \"Internet Key Exchange Protocol Version 2 (IKEv2)\"
[45] 3GPP TS 33.310: \"Network Domain Security (NDS); Authentication Framework
(AF)\"
[46] 3GPP TS 23.682:\" Architecture enhancements to facilitate communications
with packet data networks and applications\"
[47] 3GPP TS 43.020: \"Security related network functions\"
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
**E2m:** End to middle
**Gb architecture:** a system architecture described in TS 23.060 [11] that
uses the protocols defined in e.g. 3GPP TSs 24.008 [12], 48.018 [13], 44.064
[14] and 44.065 [15].
Note 1: It implies the use of a USIM application.
**S1 architecture:** a system architecture described in TS 23.401 [16] that
uses the protocols defined in e.g. 3GPP TSs 24.301 [30] and 36.413 [18].
Note 2 : It implies the use of a USIM application.
## 3.2 Symbols
For the purposes of the present document, the following symbols apply:
\|\| Concatenation
 Communication between
## 3.3 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply.\ An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
AKA Authentication and Key Agreement
AMF Authentication Management Field
AuC Authentication Centre
cIoT Cellular Internet of Things
CK Ciphering Key
CK\' replacement CK for ait interface security to withhold CK from the visited
network
CoAP Constrained Application Protocol
DH Diffie-Hellman
DLTS Datagram Transport Layer Security
E-UTRAN Evolved Universal Terrestrial Radio Access Network
E2E End to End
EESE End to End Security Endpoint
EMKS End to Middle Key Server
EMSE E2M Security Endpoint
EPS Evolved Packet System
GBA Generic Bootstrapping Architecture
GERAN GSM EDGE Radio Access Network
GGSN Gateway GPRS Support Node
GTP GPRS Tunnelling Protocol
HLR Home Location Registry
HSS Home Subscriber Server
IK Integrity Key
IK\' replacement for IK for air interface security to withhold IK from the
visited network
IoT Internet of Things
KDF Key Derivation Function
LLC Logical Link Controller
MME Mobility Management Entity
MTC Machine Type Communications
P-GW PDN Gateway
PDN Packet Data Network
PLMN Public Land Mobile Network
S-GW Serving Gateway
SGSN Serving GPRS Support Node
SQN Sequence Number
TLS Transport Layer Security
UE User Equipment
UMTS Universal Mobile Telecommunication System
UP User Plane
USIM Universal Subscriber Identity Module
# 4 Background and key objectives
## 4.0 Motivation
End-to-end security protocols e.g. DTLS between the MS and an application
server provides one way of securing the communication between MS and a
cellular IoT application server, irrespective of the nature of the security
over the radio access and within the cellular network domain (including both
the home network and visited network).
One of the main drawbacks of supporting existing end-to-end security protocols
for Cellular IoT devices is the amount of security related signalling --
protocol overheads like DTLS handshakes - that needs to be exchanged between
MS and the application server before any useful information can be sent
(usually a small data packet). The signalling overhead will not only reduce
the radio access capacity but, more importantly, increase the energy
consumption by the M2M device. This may make the objective of having devices
lasting for years with standard battery power unachievable.
From an application level perspective, the customer may not be satisfied with
relying on the user plane security between MS and a visited SGSN (assuming
this is implemented) and between the GGSN and the application server since
there is a gap in user plane security between the visited SGSN and the GGSN
(especially when NDS/IP is not implemented). It is to be noted that the
communication between a visited SGSN and GGSN may run over thousands of
Kilometres.
Key: User plane may be encrypted
No user plane encryption
Figure 4.0-1: User plane security gap between SGSN and GGSN
If user plane security could be extended to the GGSN, or to a nearby MTC
server, this may remove the need for additional end-to-end security, which
will in turn improve both the radio access capacity and the MS energy
consumption. Otherwise, the signalling exchange over the radio access to
establish application level security need to be optimised.
The above argument refers to the Gb architecture, but applies equally to the
S1 architecture (Serving Gateway replacing SGSN, and PDN gateway replacing
GGSN, as appropriate). The terms \"Gb architecture\" and \"S1 architecture\"
are defined in the next clause.
It is recognised that lawful interception regulations may sometimes prohibit
confidentiality from being applied between device and home network,
particularly in a roaming scenario -- see the paragraph beginning \"When local
or regional regulation allows ...\" in clause 5.1.3.
## 4.1 Architectural assumptions
The following should be taken into account:
\- Security aspects need to be investigated to be compatible with both Gb and
S1 architectures.
\- \"Gb architecture\" implies a system architecture described in TS 23.060
[11] that uses the protocols defined in e.g. 3GPP TSs 24.008 [12], 48.018
[13], 44.064 [14] and 44.065 [15]. It implies the use of a USIM application.
\- \"S1 architecture\" implies a system architecture described in TS 23.401
[16] that uses the protocols defined in e.g. 3GPP TSs 24.301 [30] and 36.413
[18]. It implies the use of a USIM application.
\- Roaming is supported.
\- The UE will roam in countries where encryption is allowed and where
encryption is not used. SA1 adds that saying that there will be some UEs for
which their HPLMN operator does not expect the UE to roam between countries
allowing encryption and countries not allowing encryption.
\- Inter-RAT mobility is not supported. SA2 has the same understanding. SA1
doesn\'t exclude the fact that some devices vendor may implement a multi-RAT
UE which would perform PLMN reselection between those different RATs, but they
do not precise whether security aspects should be addressed.
\- GERAN believes that subscriptions used to access cellular IoT (CIoT) are
not expected to be used for other 3GPP RATs and subscriptions used for other
3GPP RATs are not expected to be used to access CIoT. SA1 believes that in
general 3GPP subscriptions can be used on any 3GPP access technology.
## 4.2 Clarification of \"device to enterprise security\" term
\"Device to Enterprise\" security refers to a broader scope which could be
made from the following, non-exhaustive, combinations:
\- security between the Enterprise and the MTC device;
\- OR security between the Enterprise and the HPLMN, then security between the
HPLMN and the MTC device;
\- OR security between the Enterprise and the HPLMN, then security between the
HPLMN and the VPLMN, then security between the VPLMN and the MTC device.
For those combinations described above, the security protection being applied
to a communication would traverse intermediaries which are not able to perform
security operations on the data being exchanged between those two endpoints.
For instance the \"security between the HPLMN and the MTC device\" of user
plane data may traverse a VPLMN and a GRX network which will not be able to
perform security operation (e.g. MAC verification) on those exchanged user
plane data between those two endpoints.
Figure 4.2-1: High level ecosystem
## 4.3 \"Device to enterprise\" user plane protection
In clause 7 \"Security procedures for secure connection\" of 3GPP TS 33.187
[19], GBA (see 3GPP TS 33.220 [20]) and GBAPush (see 3GPP TS 33.223 [21]) were
selected as the preferred optional features for addressing the SA1 requirement
in \"Secure Connection\" in clause 7.2.10 and the use case \"End-to-end
security for roaming MTC devices\" in Annex A of 3GPP TS 22.368 [22].
Many current MTC users implement \"device to enterprise\" security. It is
believed that these security mechanisms incur a significant data overhead by
e.g. frequent security key renegotiation, and, that this data overhead could
severely impact the useful battery life of such devices.
This document intends to perform a study of those \"device to enterprise\"
security solutions and discover whether they are fit for purpose.
## 4.4 \"Device to HPLMN\" user plane protection
In that study, it is needed to \"**Investigate potential enhancements to
3GPP\'s security architecture(s) that enable the Home Operator to be able to
offer well guaranteed security to enterprises e.g. to provide security between
the UE and a node in the home operator domain.\"**. End-to-middle security
(e2m security) denotes security between an UE and a server that is not the
communication endpoint. This server can reside in the HPLMN or in a third
party network. If the latter the server needs to be authorised to obtain
cryptographic keys from the HPLMN. Also it is needed to consider both Gb and
S1 based architectures in this study.
In GPRS system, the user plane data is carried over the following nodes:
UE  BSS  SGSN  GGSN
In EPS system the user plane data is carried over the following nodes:
UE  eNB  S-GW P-GW
When a S4 SGSN is used, the user plane data is carried over the following
nodes:
UE  BSS  SGSN  S-GW  P-GW
In GPRS system, the user plane data is carried in LLC frames between the UE
and the SGSN. LLC frames are confidentiality protected between the UE and the
SGSN (see 3GPP TS 44.064 [14]).
In EPS system, the user plane data is carried in PDCP PDUs (see 3GPP TS 36.323
[23]) between the UE and the eNB that may be confidentiality protected.
GTP-U (see 3GPP TS 29.281 [24]) packets carry the user plane data between:
\- the SGSN and the GGSN,
\- the SGSN and the S-GW if S4 interface is used,
\- the eNB and the S-GW,
\- the S-GW and the P-GW.
In the roaming case, the user plane data is carried between the SGSN and GGSN
in a GPRS system (resp. S-GW and P-GW in an EPS system) over a GRX/IPX network
(a.k.a inter-PLMN backbone network). The GRX/IPX network is intended to be a
trusted network which interconnects several PLMN and service providers either
with a direct communication link or through an third parties called GRX/IPX
providers. Two PLMNs may communicate over a selected inter-PLMN backbone
network that includes border gateway security functionalities (see clause
\"Packet Domain PLMN Backbone Networks\" in clause 5.4.2 of 3GPP TS 23.060
[11]) however those security functionalities aren\'t uniformly used.
The user plane data is protected with key derived from GSM/UMTS AKA between
the UE and the SGSN for GPRS systems.
The user plane data is protected with keys derived from EPS AKA between the UE
and the eNB for EPS systems.
NDS/IP is used between the eNB and S-GW for EPS systems.
## 4.5 Battery usage challenges
According to the FS_IoT_LC Study Item in GP-140421, the types of the devices
under study are required to last 10 years on 5Wh battery capacity only.
Consequently, reducing the power consumption for security procedures should be
taken into account.
A methodology for assessing the battery performance metrics of a particular
RAT is described in clause 5.4 of TR 45.820 [25].
## 4.6 Cellular IoT traffic model
Cellular IoT traffic models are described in Annex E of TR 45.820 [25].
# 5 Key issues
## 5.1 Issue 1: N-PDU data tampering and eavesdropping
### 5.1.1 Issue description
Although the air interface may provide confidentiality protection (e.g. with
GEA4), the following interfaces are not required to provide data
confidentiality: Gp, Gn, S5, S8. This means that N-PDUs exchanged between the
MTC device and the GGSN (resp. the P-GW) aren\'t consistently confidentiality
protected.
Also the air interface, Gp, Gn, S5 and S8 do not provide integrity protection
to plaintext or ciphered N-PDUs.
### 5.1.2 Threat description
In the cellular IoT case, battery constraints mean that higher layer
protection (e.g. end to end TLS) is less likely to be present than for other
sensitive data carried over cellular connections. The N-PDU packets are
therefore likely to be subject to eavesdropping when carried over a GRX/IPX
network, thus leaking sensitive data to an eavesdropper or to the visiting
network.
In the cellular IoT case, battery constraints mean that higher layer
protection (e.g. end to end TLS) is less likely to be present than for other
sensitive data carried over cellular connections. The N-PDU packets are
therefore likely to be tampered with at the air interface or over a GRX/IPX
network, thus sending false/negative reports to the home network.
### 5.1.3 Security requirements
There should be a mechanism that provides integrity protection to the
transmitted N-PDUs between the MTC device and a node within or beyond the home
network.
When local or regional regulation allows, it should be possible to provide
confidentiality protection to the transmitted N-PDUs that only the UE and a
node within or beyond the home network should be able to encrypt/decrypt.
## 5.2 Issue 2: Efficient user data protection challenges
### 5.2.1 Issue description
N-PDUs may consist of the encapsulation of the following protocols: IP, UDP or
TCP, TLS/DTLS, Application-level protocol such as HTTP or COAP. Other
protocols could be used or could even be omitted from the N-DPU e.g. no IP
header.
The maximum size of a MAR exception message is 200 bytes but let\'s assume
that the N-PDU should not be greater than 200 bytes, then the following
numbers are for consideration:
\- An uncompressed IPv4 header may be 20 bytes, while an IPv6 header may be 40
bytes.
\- A compressed IPv4/IPv6 header may be 4 bytes while an UDP header is 8 bytes
long. The best case is that the application payload ends up with 188 bytes
allocated.
\- In a year time, a total of 73000 bytes of N-PDU may be exchanged if 200
bytes long MAR exception reports are exchanged on a daily basis.
\- Assuming that a block cipher algorithm of 16 bytes block size is used, the
best case is that the plaintext message is 192 bytes, then 176 bytes (192
minus 16), then 160 bytes (176 minus 16) of usable data.
Theseremainders might be used for something else such as a MAC. The table
5.2.1-1 below summarizes this potential distribution in case both
confidentiality and integrity protection are provided.
Table 5.2.1-1
###
### 5.2.2 Threat description
### 5.2.3 Security requirements
The minimum key size for providing data confidentiality and/or integrity
should be 128 bits.
If HMAC is used to protect an entire N-PDU, the computed or transmitted MAC
value should not be less than 64 bits. The HMAC key should at least be
refreshed every year.
If AES-GCM, which is an authenticated encryption algorithm, is used to protect
an entire N-PDU, the length of MAC may be 64 bits. However, the integrity key
should be refreshed after being used to protect plaintexts/ciphertexts of
cumulated length of 2^15^ bytes (meaning a key update two times a year).
NOTE 1: The values above are based on requirements and guidelines from
Appendix C of NIST SP 800-38D [26].
If AES-CMAC is used to protect an entire N-PDU, the length of MAC may be 64
bits. However, the integrity key should be refreshed after being used to
protect plaintexts/ciphertexts of cumulated length of 2^48^ messages when the
block size is 128 bits.
NOTE 2: The values above are based on requirements and guidelines from
Appendix B of NIST SP 800-38B [26].
The values above are presented only as indications of how often (as a minimum)
keys are likely to be updated. Key refresh will be done based on operator
policy -- there is no expectation of it being enforced by the 3GPP standard.
## 5.3 Issue 3: \"VPLMN Specific Needs\"
### 5.3.1 Issue description
Devices that roam in a visited network are subject to the regulations of the
country of the visited network. A visited network might have certain
requirements with respect to what (types of) algorithms are allowed. In
particular, for end-to-end and end-to-middle security, lawful interception
regulations in some countries might forbid the use of (some) encryption
algorithms. Other countries however might allow this type of end-to-end and
end-to-middle security and other countries again might forbid or allow
specific CIoT devices to use end-to-end and end-to-middle security.
### 5.3.2 Threat description
### 5.3.3 Security requirements
Solutions dealing with end-to-end and end-to-middle security should have
mechanisms to deal with the regulations depending on the class of CIoT UE
device and the regulations applying to the visited network.
## 5.4 Issue 4: End-to-end security
### 5.4.1 Issue description
Requirements with respect to end-to-end security of large scale CIoT
deployments could be driven by the requirements of large corporations using
CIoT for their specific needs. In particular, multinationals, such as mining
and oil companies that use the CIoT UEs for measurement devices will want to
have:
\- End-to-end security, in particular with respect to the integrity of the
measurement data;
\- Control over the key material, in particular with respect to how often keys
should be refreshed.
### 5.4.2 Threat description
The threat in these cases is out of the scope of 3GPP, meaning that a
violation of the integrity will cause a problem somewhere outside of the 3GPP
or operators\' domains. For example, the threat from a violation of the
integrity of measurements could range from a wrong decision leading to a less
than optimal processing in the plants to deadly mistakes based on
misinformation.
### 5.4.3 Security requirements
The end-user should have control over the frequency of derivation of the key
material.
The key-material exchange between the end-users premises and the network
should be minimized.
Higher level key material should not leave the 3GPP or operators domain.
# 6 Candidate solutions
## 6.0 General
Clause 6 details processes that may eventually be in a normative document. For
clarity, shalls and shoulds are included in clause 6 however as this document
is a TR all text in clause 6 is informative and not mandatory.
## 6.1 Solution #1: \"UE to HPLMN\" security solutions based on UMTS/EPS AKA
enhancements.
### 6.1.1 Introduction
In clause 6.1, \"e2m\" refers to a UE to HPLMN security association.
The following defines enhanced authentication and key agreement procedures for
mobile network with a Cellular Internet-of-Things RAT which extends the UMTS
AKA (See 3GPP TS 33.102 [27], clause 6.3) and EPS AKA (3GPP TS 33.401 [28],
clause 6.1) procedures:
\- While remaining compatible with existing security procedures between the UE
and the E-UTRAN defined in 3GPP TS 33.401 [28].
\- While remaining compatible with existing security procedures between the UE
and the GERAN when UMTS AKA is used as defined in 3GPP TS 33.102 [27].
\- To derive additional keys (from IK, and from CK under specific
circumstance) securing data in an end-to-end fashion between the UE and a
network node within the Home PLMN.
\"UE to HPLMN\" protection of the user plane data is being provided from the
UE to the home network. The new security functionalities the HPLMN needs to
support can be implemented as a new network function called HPLMN Security
Endpoint (HSE). The HSE may also be collocated with the GGSN/P-GW.
The new keys shared between UE and HSE are called e2mKEYSET. If e2m security
uses separate encryption and integrity algorithms then this keyset will
include a cipher key and an integrity key; if e2m security uses a combined
authenticated encryption algorithm then this keyset will consist of a single
key.
The UE (resp. \"UE to HPLMN\" security functionality) uses the relevant key to
generate/verify a signature/MAC or cipher/decipher the user plane data.
### 6.1.2 Solution description
#### 6.1.2.1 \"UE to HPLMN\" security solution with HSE context establishment
procedure
**Key Establishment Procedure:**
Figure 6.1.2.1-1: Procedure Diagram
Steps:
0\. In addition to the generated authentication vectors as defined in UMTS AKA
(resp. EPS AKA), the HSS/HLR:
\- in the case of UMTS AKA:
> \- derives CK´/IK´ from a concatenation of CK and IK, see clause 6.1.2.4
> (CK´/IK´ will be used for air interface security) and sets AMF bit to 1 to
> indicate to the USIM that KDF is required to be done on CK to obtain the
> usable air interface ciphering and integrity keys;
>
> \- derives e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4;
>
> \- derives e2mKEYSET_ID from a concatenation of CK and IK, see clause
> 6.1.2.4.
\- in the case of EPS AKA:
> \- from CK and IK, as well as deriving K~ASME~ in the usual way, also
> derives e2mKEYSET and e2mKEYSET_ID, see clause 6.1.2.4;
\- sets an AMF bit to 1 to indicate to the UE whether e2m keys should be
derived;
\- builds the AV. For the UMTS AKA case, CK/IK is replaced with the newly
generated CK´/IK´.
> 1a. Distribution of AV to the SGSN/MME
_NOTE 1: It is recommended to distribute only one_ AV at a time as the
frequency of AKA runs is very low in the MTC scenario.
1b. The HSS/HLR pushes to the HSE the following pair:
\- e2mKEYSET
\- e2mKEYSET_ID
\- optionally the IMSI
2\. SGSN sends the authenticate request message to the UE as defined in TS
33.102 [27] (resp. TS 33.401 [28]).
3\. USIM runs UMTS/EPS AKA, and if the AMF bit indicating that additional key
derivation is to be done is set to 1, performs the following additional key
derivations:
\- in the case of UMTS AKA:
> \- CK´/IK´ (used for Air IF sec) from a concatenation of CK and IK, see
> clause 6.1.2.4;
>
> \- e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4;
>
> \- e2mKEYSET_ID from a concatenation of CK and IK, see clause 6.1.2.4.
\- in the case of EPS AKA:
> \- e2mKEYSET and e2mKEYSET_ID from CK and IK, see clause 6.1.2.4.
4\. The UE sends the authenticate response message to the SGSN/MME as defined
in TS 33.102 [27] (resp. TS 33.401 [28]).
5a. If no PDP context exist, the UE sends the Activate PDP context request
message to the SGSN/MME with a PCO IE which should contain the e2mKEYSET_ID
associated with the e2m keys to be used for the protection of the N-PDUs. The
PCO IE will be transparently transmitted to the GGSN/P-GW as specified in 3GPP
TS 29.060 [29].
5b. If an Update PDP Context request message is instead sent by the UE to the
SGSN/MME, a PCO IE shall also be included in the message with the e2mKEYSET_ID
associated with the e2m keys to be used for the protection of the N-PDUs. The
PCO IE will be transparently transmitted to the GGSN/P-GW as specified in 3GPP
TS 29.060 [29].
6\. The GGSN/P-GW forwards the e2mKEYSET_ID along with the IMSI indicated in
the Activate/Update PDP context message and the TEID as a triplet to the HSE.
6a. The HSE matches the information in the triplet with the recently pushed
e2mKEYSET_ID and e2mKEYSET.
Note 2: If the HSE does not have a record of the received e2mKEYSET_ID within
its memory, then:
> \- The HSE sends an error message back to the GGSN/P-GW, including the IMSI.
>
> \- On receipt of this error message, the GGSN/P-GW sends an error message to
> the UE in a PCO IE as specified in 3GPP TS 29.060 [29].
>
> \- On receipt of this error message, the UE sends a message to the SGSN/MME
> requesting a new authentication exchange using newly generated
> authentication vectors.
NOTE 3: This will be a newly standardised feature. Newly defined
parameterisations of the Tracking Area Update and/or Routing Area Update
messages (with new cause codes, and minimal additional information) may be
used for this. Specially, a new Update Type can be defined to indicate a
request for reauthentication, and for this Update Type the RAU/TAU message
should be made as short as possible by making as many fields optional as
possible (including, potentially, some that are mandatory today).
Alternatively, new message types may be defined in 3GPP TS 24.008 [12] and
3GPP TS 24.301 [30].
> \- The new authentication exchange causes the whole process defined here to
> restart, in particular creating new e2m keys to be pushed to the HSE.
7\. The HSE is ready to provide confidentiality and/or integrity protection to
the N-PDUs.
The HSE will need a way to flush out e2m key pairs that are never used, rather
than retaining them indefinitely. There seems no need to standardise a
mechanism for this, but a time-based approach is recommended, deleting keys
that remain unused for a specified period after they are generated. The
process defined above includes a way to recover if an e2m key pair is deleted
that would eventually have been used.
#### 6.1.2.2 \"UE to HPLMN\" security solution with HLR push procedure --
Alternative
Figure 6.1.2.2-1: Procedure Diagram
**Procedure:**
Steps:
0\. In addition to the generated authentication vectors as defined in UMTS AKA
(resp. EPS AKA), the HLR/HSS:
\- in the case of UMTS AKA:
> \- derives CK´/IK´ from a concatenation of CK and IK, see clause 6.1.2.4
> (CK´/IK´ will be used for air interface security) and sets AMF bit to 1 to
> indicate to the USIM that KDF is required to be done on CK to obtain the
> usable air interface ciphering and integrity keys.
>
> \- derives e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4.
\- in the case of EPS AKA:
> \- from CK and IK, as well as deriving K~ASME~ in the usual way, also
> derives e2mKEYSET, see clause 6.1.2.4.
\- sets an AMF bit to 1 to indicate to the UE whether e2m keys should be
derived.
\- While building the AV and for the UMTS AKA case only, replaces CK/IK with
the newly generated CK´/IK´.
> 1\. Distribution of AV to the SGSN/MME
_NOTE 1: It is recommended to distribute only one_ AV at a time as the
frequency of AKA runs is very low in the MTC scenario.
2\. The SGSN/MME sends the authenticate request message to the UE as defined
in TS 33.102 [27] (resp. TS 33.401 [28]).
3\. The USIM runs UMTS/EPS AKA, and if the AMF bit indicating that additional
key derivation is to be done is set to 1, performs the following additional
key derivations:
\- in the case of UMTS AKA:
> \- CK´/IK´ (used for Air IF sec) from a concatenation of CK and IK, see
> clause 6.1.2.4
>
> \- e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4
\- in the case of EPS AKA:
> \- e2mKEYSET from CK and IK, see clause 6.1.2.4
4\. The UE sends the authenticate response message to the SGSN/MME as defined
in TS 33.102 [27] (resp. TS 33.401 [28]).
5\. Upon successful UMTS AKA (resp. EPS AKA) authentication result and
successful PDP context activation as defined in 23.002 [31] (Resp. PDN
Connectivity Request, see 3GPP TS 23.401 [16]), the SGSN/MME sends a
notification message to the HLR/HSS with the IMSI, the SQN value (or RAND) and
the GGSN/P-GW address as parameters.
6\. The HLR/HSS pushes e2mKEYSET to the HSE.
7\. UE initiates establishment of PDP Context at the GGSN/PGW. The need for
the E2M security is indicated.
8\. The GGSN/P-GW forwards the e2mKEYSET_ID along with the IMSI indicated in
the Activate/Update PDP context message and the TEID as a triplet to the HSE.
The HSE matches the information in the triplet with the recently received
e2mKEYSET_ID and e2mKEYSET from the HSS.
> Note 2: If the HLR/HSS does not have a record of the received e2mKEYSET_ID
> within its memory, then:
>
> \- The HLR/HSS sends an error message back to the GGSN/P-GW, including the
> IMSI.
>
> \- On receipt of this error message, the GGSN/P-GW sends an error message to
> the UE.
>
> \- On receipt of this error message, the UE sends a message to the SGSN/MME
> requesting a new authentication exchange using newly generated
> authentication vectors for example using an adaptation of the Tracking Area
> Update request as explained in Note 3 of section 6.1.2.1.
>
> \- The new authentication exchange causes the whole process defined here to
> restart, in particular creating a new e2m KEYSET to be pushed to the
> HLR/HSS.
#### 6.1.2.3 \"UE to HPLMN\" security solution with HSE pull procedure
**Key Establishment Procedure:**
Figure 6.1.2.3-1: Process flow diagram
Steps:
0\. In addition to the generated authentication vectors as defined in UMTS AKA
(resp. EPS AKA), the HLR/HSS:
\- in the case of UMTS AKA:
> \- derives CK´/IK´ from a concatenation of CK and IK, see clause 6.1.2.4
> (CK´/IK´ will be used for air interface security) and sets AMF bit to 1 to
> indicate to the USIM that KDF is required to be done on CK to obtain the
> usable air interface ciphering and integrity keys;
>
> \- derives e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4.
\- in the case of EPS AKA:
> \- from CK and IK, as well as deriving K~ASME~ in the usual way, also
> derives e2mKEYSET, see clause 6.1.2.4;
>
> \- sets an AMF bit to 1 to indicate to the SGSN/MME/UE whether E2E keys
> should be derived;
>
> \- While building the AV and for the UMTS AKA case only, replaces CK/IK with
> the newly generated CK´/IK´.
>
> NOTE 1: The HSS keeps CK and IK in memory for a short period of time, e.g. a
> couple of minutes so that the HSE can pull the key set.
>
> 1\. Distribution of AV to the SGSN/MME
_NOTE 2: It is recommended to distribute only one_ AV at a time as the
frequency of AKA runs is very low in the MTC scenario.
2\. The SGSN/MME sends the authenticate request message to the UE as defined
in TS 33.102 [27] (resp. TS 33.401 [28]).
3\. The USIM runs UMTS/EPS AKA, and if the AMF bit indicating that additional
key derivation is to be done is set to 1, performs the following additional
key derivations:
\- in the case of UMTS AKA:
> \- CK´/IK´ (used for Air IF sec) from a concatenation of CK and IK, see
> clause 6.1.2.4;
>
> \- e2mKEYSET from a concatenation of CK and IK, see clause 6.1.2.4.
\- in the case of EPS AKA:
> \- e2mKEYSET from CK and IK, see clause 6.1.2.4.
4\. The UE sends the authenticate response message to the SGSN/MME as defined
in TS 33.102 [27] (resp. TS 33.401 [28]).
5a. If no PDP context exist, the UE sends the Activate PDP context request
message to the SGSN/MME with a PCO IE which should contain the SQN value (or
RAND) from the AV and associated IMSI to the GGSN. The PCO IE will be
transparently transmitted to the GGSN/P-GW as specified in 3GPP TS 29.060
[29].
5b. If an Update PDP Context request message is instead sent by the UE to the
SGSN/MME, a PCO IE shall also be included in the message. The PCO IE should
contain the SQN value (or RAND) and associated IMSI. The PCO IE within the
Update PDP Context request message will be transparently transmitted to the
GGSN/P-GW as specified in 3GPP TS 29.060 [29].
6\. The GGSN/P-GW forwards the SQN value (or RAND) along with the IMSI
indicated in the Activate/Update PDP context message and the TEID as a triplet
to the HSE.
7 & 8\. The HSE fetches e2mKEYSET from the HSS/HLR by providing the SQN value
(or RAND) and associated IMSI
_Editor\'s n_ ote: it is FFS whether and how E2E CK/IK key could be retained
or recreated by the HLR/HSS in order to be pulled by the HSE.
9\. The HSE is ready to provide confidentiality and/or integrity protection to
the N-PDUs.
#### 6.1.2.4 Key derivation rules
The following is one possible way of implementing the key derivation rules.
Other possible implementations options may be defined.
The key derivation function should be supported by the UICC and the HLR/HSS
and is written as KDF (Key, S) below.
The key derivation algorithm KDF should be HMAC SHA 256 (as defined in 3GPP TS
33.220 [20]).
For the UMTS AKA case, the following key derivation applies:
  * CK´\|\|IK´ = KDF (CK\|\|IK, key type 1).
NOTE 1: CK´ goes from bit 0 to bit 127, IK´ goes from bit 128 to bit 255\. Key
type 1 is an ASCII string pointing to the purpose of the key use, e.g.
\"VPLMN_CIoT\".
  * e2mKEYSET = KDF (CK\|\|IK, key type 2).
NOTE 2: If e2mKEYSET includes more than 256 bits of key material, then
multiple instances of KDF are used with different key type strings (key type
2A, key type 2B, etc).
  * If the solution requires an e2mKEYSET_ID then e2mKEYSET_ID = KDF > (CK\|\|IK, key type 3).
For the EPS AKA case, the derivation of e2mKEYSET and e2mKEYSET_ID (if
required) is the same as in the UMTS AKA case. For the visited network,
though, K~ASME~ is derived as usual.
NOTE 3: If an AKA algorithm such as TUAK were used, that can generate 256-bit
CK and IK, then the key derivation formulae above could be different, with
keys for the visited network security generated purely from CK, and keys for
the e2m security derived purely from IK. 256-bit CK and IK are currently
outside the scope of 3GPP standards, however.
#### 6.1.2.5 Solution variant: End to Middle Key Server
Solution #2 uses an End to Middle Key Server (EMKS) (see clauses 6.2.2.1,
6.2.2.2), which sits logically between the HLR/HSS and what is called the EMSE
(the equivalent of the HSE in this solution). This can be added as a variant
to any of the solution #1 options described above. With this variant, there is
no difference to how keys are derived for the visited network, but the e2m key
is done differently, in two steps:
1\. Whenever an Authentication Information Request from the SGSN or the MME
arrives at the HLR/HSS, then the HLR/HSS checks the subscription profile for
the need to derive an e2m_int_key. If needed according to the subscription
profile, the HLR/HSS derives e2m_int_key from CK, IK and a string pointing to
the purpose of the key use, namely e2m security for CIoT, where the derivation
of e2m_int_key has the form.
e2m_int_key = KDF (CK\|\|IK, string)
> and the string could be set to e.g. \"e2m_ CIoT\".
2\. The EMKS derives e2m_key from e2m_int_key, using the key derivation rule.
e2mKEYSET = KDF (e2m_int_key, key type 2)
and if necessary also
e2mKEYSET_ID = KDF (e2m_int_key, key type 3)
where key type 2 and key type 3 are as described in clause 6.1.2.4.
In all cases, keys are delivered from HLR/HSS to EMKS; either push or pull can
be used from EMKS to HSE, according to the particular solution option.
#### 6.1.2.6 Solution variant: key derivation on the ME (EPS AKA only)
In all of the solution descriptions above, new key derivation operations are
required on the USIM. (From a concatenation of CK and IK, the USIM derives one
or more of CK´/IK´, e2mKEYSET, e2mKEYSET_ID, according to the particular
solution variant. An AMF bit is used to indicate whether these additional key
derivations are required.)
In the case of EPS AKA, new key derivation is only required to produce
e2mKEYSET and (in one variant) e2mKEYSET_ID. Rather than doing this on the
USIM, an alternative is for the new key derivation options to be performed by
the ME. In this case the USIM does nothing new -- it just generates CK and IK
as usual. Key derivation operations are illustrated in Figure 6.1.2.6-1.
Figure 6.1.2.6-1: Key derivation
Use of the AMF bit is no longer necessary if this variant is adopted.
### 6.1.3 Solution evaluation
All of the variants in this clause create an e2m keyset, shared between UE and
HSE, that can be used to provide confidentiality (where permitted) and
integrity. This contributes towards satisfying key issue #1. However, this
solution does not on its own specify what confidentiality and integrity
mechanism (e.g. TLS, IPsec) makes use of the shared keyset.
Key issue 2 is satisfied well as long as keys are relatively long lived (both
device-to-visited-network keys and e2m keys), so that authentication
challenges and responses on the air interface are infrequent.
The solution requires new functionality in the HSS. It also requires new
functionality in the USIM, except in the solution variant \"key derivation on
the ME (EPS AKA only)\" in clause 6.1.2.C.
It seems necessary to keep the visited network and e2m security associations
synchronised: if keys are updated for one, then they need to be updated for
the other too.
Variant 6.1.2.2 requires the HLR/HSS to retain an e2m key pair until a
notification message is received from the SGSN/MME. This type of stateful
behaviour is not standard in today\'s HLRs. Adopting the End to Middle Key
Server solution variant (clause 6.1.2.5) avoids this problem.
## 6.2 Solution #2: \"End-to-middle security based on AKA\"
### 6.2.1 Introduction
The present solution builds on solution#1. It is presented as a delta
description to solution#1, i.e. the description of the present solution
contains only those elements that differ from solution#1.
Solution#1 is explicitly meant for \"mobile network with a Cellular Internet-
of-Things RAT\". The present solution can be used for CIoT as well (which is
why it is included in the present document). It should be noted, though, that
there is no technical reason why the present solution should be restricted to
the CIoT use case; it can provide e2m security whenever AKA is run in a mobile
network.
While solution#1terminates the additional user plane protection in a HPLMN
Security Endpoint (HSE) the present solution is applicable to any endpoint,
called \"E2M Security Endpoint\" (EMSE), that is authorised to obtain e2m keys
from the E2M Key Server (EMKS). The EMKS derives an e2m key from an
intermediate key (e2m_int_key) the EMKS obtains from the HSS.
An EMSE may reside in an operator\'s home network, but also in a trusted third
party domain (e.g. a CIoT application provider platform). The EMKS always
resides in an operator\'s home network.
There may be multiple instances of an EMSE, with which a UE engages
simultaneously or sequentially. There is typically only one instance of an
EMKS per HSS.
As usual in 3GPP standardisation, EMSE and EMKS denote functional entities
that could be implemented stand-alone or combined with HSS or GGSN or P-GW.
EMSE and EMKS could also be combined. The advantage of introducing the EMKS is
that the HSS could continue to operate in a stateless fashion.
### 6.2.2 Solution description
#### 6.2.2.1 End-to-middle security solution based on AKA
**Transparency for core network nodes** :\ SGSNs, GGSNs, MMEs, S-GWs, P-GWs
may work with the present solution without any CIoT-specific enhancements.
This is not to say that such enhancements would not be useful for certain use
cases, but it means that there is no mandatory pre-condition on the UMTS or
EPS core network elements. This transparency of the solution for the core
network is important for deployments as many operators may be reluctant to
upgrade their core networks for the purpose of supporting CIoT. (To be sure,
the HSS and HLR would need CIoT-specific enhancements.)
**Transparency for the USIM** :\ The possibility to re-use USIMs without CIoT-
specific additions is important as particular CIoT use cases may not warrant
the modification of USIMs for their purposes. The present solution can re-use
existing USIMs. CIoT specific operations can be done in the ME.
In contrast to the present solution, solution#1 has the following text: \"USIM
... performs the following additional key derivations: - CK´/IK´...\" and
again \"The key derivation function should be supported by the UICC...\".
These key derivations on the USIM are CIoT-specific. (This does not apply to
the solution variant \"key derivation on the ME (EPS AKA only)\" in clause
6.1.2.6.)
**Push vs. pull procedures**
The present solution can work with any of the push or pull procedure variants
from solution#1 that are used to transport the e2m key from the EMKS to the
EMSE. For transporting the intermediate key e2m_int_key from the HSS to the
EMKS, only a push procedure is used.
#### 6.2.2.2 Key derivation rules
As for solution#1, the present solution uses a new key pair CK´, IK´for UMTS
PS or GPRS access security between UE and SGSN. For EPS, K~ASME~ can be re-
used as defined today.
The present solution differs from solution#1 in the derivation of the
additional user plane key. In solution#1, this key is called \"e2mKEYSET\". It
is used between UE and HSE. In the present solution, this key is called
\"e2m_key\". It is used between UE and EMSE.
The e2m key is derived in two steps:
(1) Whenever an Authentication Information Request from the SGSN or the MME
arrives at the HSS, then the HSS checks the subscription profile for the need
to derive an e2m_int_key. The HSS then generates authentication vectors and
sends them back to the SGSN or MME. If needed according to the subscription
profile, the HSS derives e2m_int_key from CK, IK using a specific FC value,
where the derivation of e2m_int_key has the form
e2m_int_key = KDF (CK\|\|IK,)
. The HSS sends e2m_int_key to the EMKS.
(2) The EMKS derives e2m_key from e2m_int_key. As there may be multiple
instances of EMSE it becomes necessary to include an identifier of the EMSE in
the key derivation in order to achieve key separation between EMSEs. The
following is the key derivation rule:
e2m_key = KDF (e2m_int_key, EMSE_Id, string)
NOTE: A specific FC value is allocated for the purpose of the derivations of
the keys in step 1) and step 2).
#### 6.2.2.3 Usage of e2m security
Solution#1 (except for the solution variant \"key derivation on the ME (EPS
AKA only)\" in clause 6.1.2.C) mentions the use of a, yet to be specified, bit
in the Authentication Management Field (AMF) to indicate to the UE whether the
UE has to derive the keys CK´ and IK´ for access security. The information on
whether this specific AMF-bit is to be set or not needs to be fed into the
Authentication Centre. How this information is stored and fed into the AuC
does not need to be standardised from an interoperability point of view.
However, it may be beneficial to do so for HSS or HLR vendors as
standardisation would reduce the number of implementation variants requested
by customers.
As the information on whether this specific AMF-bit is to be set is
subscriber-specific it should be stored in the subscriber records. However, it
is not part of the subscriber profile that is sent to the serving node.
NOTE: The use of an AMF bit, as described above, is still open. If used it
would imply that there are two kinds of AKA runs: (1) AMF bit set: access
security keys for use between UE and SGSN and e2m keys for use between UE and
EMSE are derived; (2) AMF bit not set: only access keys are derived. The third
case, namely an AKA run that establishes ONLY e2m keys, should not arise as it
would necessitate significant changes to the security as defined today between
UE and SGSN: the SGSN would have to support running an AKA without deriving
access keys, and, in particular, the SGSN would have to interpret the AMF bit.
Cf., however, solution#3 where a different approach is taken to decouple AKA
runs for access security from AKA runs for e2m security.
### 6.2.3 Solution evaluation
Solution 2 generalises solution 1. Solution 2 enables using the simplified key
agreement mechanism for IoT purposes not only for IoT servers (EMSEs) residing
in the operator\'s home network, but also for EMSEs residing in third party
networks, if so desired. Furthermore, solution 2 leaves the possibility open
to provide an end-to-middle key that was agreed according to the procedures in
this clause to any application layer security protocol based on shared keys.
Finally, solution 2 is not limited to protocols and architectures that require
GGSN support for the distribution and use of the end-to-middle key.
## 6.3 Solution #3: \"Independent VPLMN and e2m security associations\"
### 6.3.1 Introduction
Solutions #1 and #2 use a single AKA run, with additional subsequent key
derivations, to derive both e2m keys and keys for the usual UE-to-VPLMN
security. This achieves efficiency, but comes with some challenges in terms of
maintaining the synchronisation between the e2m and UE-to-VPLMN security
associations.
The present solution, by contrast, uses separate, independent AKA runs for the
e2m and UE-to-VPLMN key derivations. This simplifies some issues, at the cost
of more AKA runs (with the consequent battery drain implications).
This solution can be used with a HPLMN Security Endpoint (HSE), as described
in solution #1, or with a more general e2m Security Endpoint (EMSE) as
described in solution #2. The following text refers to the HSE, but an EMSE
could be used instead.
### 6.3.2 Solution description
#### 6.3.2.1 Independent VPLMN and e2m security associations
The AKA operations, key derivations and overall security flow for the
\"traditional\" UE-to-VPLMN security are unchanged in this solution.
A new domain is defined for e2m security-- neither Circuit Switched (CS) nor
the usual Packet Switched (PS) but Home Packet Switched (HPS). The USIM
maintains a separate HPS key set, with associated CKSN and KSI (in the same
way that USIM already maintains separate CS and PS keysets).
Whenever the GGSN/PGW gets a Create Session Request from the S-GW it starts an
AKA run. The P-GW is informed about the fact that the requesting UE is a CIoT
UE through either:
> \- The use of a PCRF. The PCRF informs the P-GW during the IP CAN session
> setup that this particular UE is a CIoT UE. The P-GW obtains the IMSI either
> through the PCRF IP CAN Session Setup message or through the Create Session
> Request message that it got from the S-GW. In either way, the IMSI is
> forwarded to the HSE to obtain the AV.
>
> \- By means of the subscription profile stored in the HSS. The S-GW or the
> P-GW could obtain the subscription profile. If it is possible for the S-GW
> to obtain the subscription profile, it could inform the P-GW that this
> particular UE is a CIoT UE. In case the S-GW does not obtain the
> subscription profile the P-GW could request the subscription profile itself
> and find out that this UE is a CIoT UE. The IMSI is obtained through the
> Create Session Request and forwarded to the HSE.
Subsequent AKA runs piggy back on the same mechanism. Whenever a new session
between the P-GW and CIoT UE is established, the HSE is triggered, requests a
fresh AV and performs an AKA run. The sessions expire according to a policy
set in the subscription profile. The term session refers to the data bearer
between P-GW and CIoT. This implies that the UE keeps the CIoT security
context in memory whenever the UE goes to sleep / idle mode.
The HSE requests an AKA vector from the HLR/HSS. Note: if the HLR/HSS uses the
array scheme for SQN management (see TS 33.102 [27] clauses C.1.2 and also
clause C.3.4) then it may use a set of IND values exclusively for the HPS
domain. In the EPS AKA case, where the AV will contain K~ASME~, the PLMN ID
used as input for the derivation of K~ASME~ should refer to the HPLMN, but
should be different from the PLMN_ID that would be used for that network in
regular (non-e2m) K~ASME~ derivation.
The HSE derives e2mKEYSET from CK/IK (UMTS AKA case) or from K~ASME~ (EPS AKA
case) using the key derivation KDF defined in 3GPP TS 33.220 [20]:
\- e2mKEYSET = KDF (CK\|\|IK, key type).
NOTE: key type is an ASCII string specific to this key derivation operation,
e.g. \"e2m_CIoT\". If e2mKEYSET includes more than 256 bits of key material,
then multiple instances of KDF are used with different key type strings (key
type A, key type B, etc.).
The HSE formulates an authentication challenge message, containing all the
same AV fields as a standard authentication challenge, which it delivers to
the GGSN/P-GW. The GGSN/P-GW sends this challenge message to the UE, via the
PCO channel.
The USIM runs UMTS/EPS AKA as normal. The USIM also derives e2mKEYSET,
following the same derivation rule as the HSE.
The UE sends the authentication response to the GGSN/P-GW via the PCO channel.
The GGSN/P-GW passes this response to the HSE, which validates it against the
expected response. Assuming that the authentication is successful, e2mKEYSET
is now shared between the HSE and the UE, ready to be used to provide
confidentiality and/or integrity protection to the N-PDUs.
### 6.3.3 Solution evaluation
This solution creates an e2m keyset, shared between UE and HSE, that can be
used to provide confidentiality (where permitted) and integrity. This
contributes towards satisfying key issue #1. However, this solution does not
on its own specify what confidentiality and integrity mechanism (e.g. TLS,
IPsec) makes use of the shared keyset.
Key issue 2 is satisfied well as long as keys are relatively long lived (both
device-to-visited-network keys and e2m keys), so that authentication
challenges and responses are infrequent (both the usual challenges from the
VPLMN and the e2m challenges delivered over the PCO channel). The solution is
not optimised to the same extent as solutions #1 or #2, because provisioning
the two sets of shared keys requires two authentication challenges and
responses, not one. However, there is a gain in simplicity, because there is
no need to keep the two security associations in sync -- either can be updated
at any time with no impact on the other.
This solution has no impact on the HLR/HSS, unlike solutions #1 and #2.
## 6.4 Solution #4: \"Security policies\"
### 6.4.1 Introduction
This clause includes some security policy requirements and/or preferences that
can be sent from the home network to the visited network, and applied in the
visited network. These may be used irrespective of which key sharing solution
is preferred from previous clauses. They may also be applied in a broader
context -- they are not specific to battery constrained use cases or to IoT
use cases.
### 6.4.2 Solution description
#### 6.4.2.1 Authentication and key usage policy
The battery lifetime of CIoT devices could benefit from a reduced
authentication frequency and, hence, a prolonged lifetime of keys. The visited
network may not know about the need for a CIoT-specific authentication and key
usage policy. It needs to be told by the home network.
On the other hand, the home network may know more about the security
requirements applying to individual devices, and may know that there should be
a certain minimum frequency at which visited network keys are changed. In
solutions #1 and #2, where visited network and e2m keys are in effect derived
simultaneously, this could also be a mechanism for the home network to ensure
/ request that e2m keys are changed with a certain minimum frequency.
It is proposed to include a new field in the GPRS, 3G or 4G subscriber
profiles that determines the authentication and key usage policy required for
this subscriber. Including this information in the subscriber profile has two
benefits:
\- The specifications of the interfaces between serving node and HLR or HSS
need not be modified as subscriber profiles can be carried over these
interfaces today.
\- The solution can remain transparent for core network nodes as an SGSN or an
MME that does not understand the new field in the subscriber profile simply
ignores it.
#### 6.4.2.2 Algorithm policy
It is proposed to include a new field in the GPRS, 3G or 4G subscriber
profiles that specifies which cryptographic algorithms are allowed to be used
for radio interface security for this subscriber (including both AS and NAS in
the 4G case).
Including this information in the subscriber profile has the same benefits as
for the previous point. This may be particularly beneficial for IoT devices
that have very long lifetimes, where there is a higher risk of weaknesses
appearing in an algorithm during that lifetime.
Conversely, if the visited network is able to indicate to the home network
what security features / algorithms the visited network will use, the home
network may use this in determining its own e2m security policy.
#### 6.4.2.3 VPLMN Specific Algorithm policies
Different Visited PLMNs will have different requirements with respect to
whether end-to-end or end-to-middle encryption is allowed from a Lawful
Interception perspective. These LI requirements may depend on the type of
subscription and the type of device used. To cater for these requirements, it
is proposed to include a new field into the GPRS, 3G or 4G subscriber profile
that specifies to which class of devices the CIoT UE belongs. What algorithms
are allowed might also be subject to regulations or Lawful Interception.
_Editor\'s Note: The expertise of SA3-LI is required to determine whether LI
requirements in the VPLMN may indeed depend on the type of subscription and
the type of device used, and whether information obtained from the HPLMN would
be useful for the VPLMN in fulfilling its LI requirements. The usefulness of
the proposed field in the subscriber profile depends on the answers from
SA3-LI. It is ffs how the SGSN could learn about the type of device used as
the subscriber profile contains only subscription-related information._
Additionally, roaming contracts should specify for which classes of CIoT UEs
which encryption algorithms are allowed. During an AKA run, these policies
will have to be enforced by the home network.
### 6.4.3 Solution evaluation
The authentication and key usage policy can help with key issue #2, ensuring
that authentication challenges and responses are not too frequent.
The algorithm policy does not address the specific security requirements
identified in clause 5.1.3, but can help to ensure that the visited network
security is as good as possible, reducing some of the tampering and
eavesdropping risks identified in clause 5.1.
The VPLMN Specific Algorithm Policies addresses key issue 5.3 if applied to
the solutions that provide end-to-end and end-to-middle security.
## 6.5 Solution #5: \"End-to-end security solution\"
### 6.5.1 Introduction
The present solution builds on solutions #3 by reusing components and
mechanisms already introduced in that solution. Solutions #3 was initially
meant to be used for end-to-middle, but parts can be used with only minor
modifications for end-to-end security. This clause describes how an end-to-end
solution is constructed based on the components from solution #3.
### 6.5.2 Solution Description
#### 6.5.2.1 Specific e2e security association
This clause of the solution is based on solution #3 where it is proposed to
have two separate key runs, one for the UE-to-VLPMN and one for the CIoT
purpose. In this solution, it is proposed to extend this feature to have an
additional set of keys for UE-to-Enterprise security.
In solution #3 an e2mKEYSET is derived and used in an HSE / EMSE to terminate
the secure connection. In this solution, a new security end point node in the
network of the enterprise is defined. The new node inside the enterprise
network will be called EESE (End-to-End Security Endpoint). An EESE is
basically an EMSE that is located in the enterprise network or even integrated
with the CIoT application platform. The EESE may have interfaces that the EMSE
does not have.
As described in solution #3, the UE and HSS derive an e2mKEYSET in a separate
AKA run for a newly created HPS domain. In this solution, it is proposed to
add another domain, the EnPS (Enterprise Packed Switched) domain and derive a
key specifically for this domain. The HSS can distinguish between the two
domains based on a new field in the subscriber profile that indicates whether
for a CIoT UE the EnPS domain is applicable. It is proposed to derive the key
as follows:
e2e_int_key = KDF(CK\|\|IK, string),
where the string can be set to \"CIoT End-to-end\". The HSS forwards the
e2e_int_key to the EMKS inside the operator\'s network and the EESE can obtain
the e2e_int_key from the EMKS. Contrary to solution #3, the e2e_int_key will
be used to derive further e2eKEYSETs which are the keys used for securing the
data transfer between EESE and UE.
#### 6.5.2.2 Derivation of e2eKEYSET
The e2eKEYSET is derived according to:
e2eKEYSET = KDF(e2e_int_key, RAND),
where a RAND is introduced to ensure that derivation of the e2eKEYSET is
unpredictable.
It is proposed that the EESE is the source of the RAND and to let the EESE
transport the RAND to the UE. Alternatively, in case the EESE might not have a
reliable random source available, the operator could provide the random to the
EESE via the EMKS. Furthermore, the EESE derives the e2eKEYSET based on the
RAND that is optionally provided by the EMKS.
#### 6.5.2.3 Triggering the key derivation
In order to ensure that both the UE and the EESE have the same keys and do the
key derivation at the same time, it is necessary to trigger the key
derivation. In this solution, the key derivation trigger is exchanged over the
existing connection as a control message. What happens is as follows:
1\. Upon deriving a e2eKEYSET a timer t~e2e~ is set in the EESE.
2\. Whenever the timer runs out, the EESE sets a flag invalidating the keys.
3\. Upon next contact from the UE, the EESE replies with an error message
indicating the reason (key has expired). This step is skipped whenever the
EESE triggers new contact.
4\. The EESE generates a fresh RAND (or triggers the EMKS that a new RAND is
needed), derives the new e2eKEYSET and forwards the RAND to the UE, which
derives the new e2eKEYSET.
5\. The UE or EESE transmit the message.
#### 6.5.2.4 Setting the timer
The value of the time t~e2e~ may be specified by the enterprise. The EESE may
also support a local command for the enterprise to expire e2eKEYSET
immediately -- this is outside the scope of the standard.
#### 6.5.2.5 Interfaces of the EESE
The EESE may have a number of interfaces:
\- An interface between the EESE and the EMKS for the exchange of the
e2e_int_key.
\- An interface to receive a RAND from e.g. the EMKS.
\- An interface that allows the CIoT operator platform to let the enterprise
expire the keys immediately, which is out of scope of the standard.
### 6.5.3 Solution Evaluation
This solution fulfils the requirement of an end-to-end security mechanism
between the Enterprise and the UE, thereby fulfilling the requirement 5.4. And
because it builds upon solutions #3, it also fulfils the requirement #1 by
deriving a key that can be used for encrypting data between the UE and the
EESE and it can fulfils requirement #2 by picking the right KDF.
## 6.6 Solution #6: Bearer protection
### 6.6.1 Introduction
The present solution builds on the previous AKA key derivation solutions, such
as solution #1 and #2, clauses 6.1 and 6.2 respectively. It is presented as a
delta, i.e. the description of the present solution contains only elements in
addition to those solutions. The solution proposes IPsec ESP for user plane
protection utilizing the AKA key derivation solutions documented in those
clauses.
### 6.6.2 Solution description
In order to protect the user plane data between the UE and the HSE it is
required to implement IPsec ESP according to RFC 4303 [36] as profiled by TS
33.210 [37], with confidentiality, integrity and replay protection. The e2m
key pairs shared between the UE and the HSE are derived as described in
solutions #1 and #2 of the document. The keys are used for encryption and
integrity protection by the e2m IPsec ESP Security Association (SA). There are
two options for lifecycle management of the SA, such as parameter negotiations
and rekeying. One option is to preconfigure necessary parameters and handle SA
lifecycle via CIoT specific methods. Another option is to use IKEv2[refr x].
See discussions on these two options below.
NOTE 1: The choice of crypto suites is not restricted further from the ones in
TS 33.210[37], but due to computational efficiency, the use of AEAD algorithms
combining authentication and encryption is preferred.
NOTE 2: The solution does not mandate the use of tunnel versus transport-mode
ESP.
NOTE 3: While header compression is expected to further improve efficiency of
the solution, this contribution neither mandates it nor puts forward the use
of specific compression algorithms.
Pre-configured ESP SA parameters and SA management
ESP SA parameters may be pre-configured and derived for simple IPsec tunnels
without run-time overhead. The e2m key pairs derived by the UE and HSS are
directly used for the crypto processing of the SA. There are obvious drawbacks
to pre-configured SAs, such as: there is no way to negotiate integrity
checking and encryption algorithms, Traffic Selectors, NAT-T and to
communicate the SPI. These parameters have to be either pre-configured or
derived. Furthermore, there is no possibility of anti-replay protection, Dead
Peer Detection (DPD), DiffServ Code Point (DSCP) mapping, re-keying, and
Perfect Forwarding Secrecy (PFS).
NOTE 4: The method of deriving per-SA parameters that cannot be preconfigured
for each SA will be need to be described in the TS.
NOTE 5: ESP SA rekey may be triggered via the signaling message mechanism
described in 6.5.2.3.
IKEv2 negotiated ESP SA parameters and SA management
Using the rich feature set of IKEv2 to negotiate the SA parameters fixes the
above shortcomings. All the SA parameters can be discovered and negotiated in
two message exchanges. IKEv2 may be also utilized for SA rekey and teardown.
Supporting IKEv2 with PSK is already required by TS 33.210 [37]. The e2m key
pairs derived by the UE and HSS are used as input to the standard SA key
generation process of IKEv2 [44].
### 6.6.3 Solution evaluation
The current solution satisfies key issue #1 and its requirements, by providing
IPsec-based integrity and confidentiality protection against tampering and
eavesdropping.
By pointing to the standard list of crypto suites in TS 33.210[37], the
solution allows for the use of crypto algorithms that conform with regional
and visited network requirements, thus satisfies the requirement of key issue
3.
## 6.7 Solution #X: \"End-to-end\" for solutions 1 and 2
### 6.7.1 Introduction
Each of the solutions #1 and #2 can be used for end-to-end encryption by
placing the HSE or EMSE in the CIoT application domain (as is mentioned as
well in solution #2). Even though such a solution may satisfy some clients
needs, none of the solutions will satisfy key issue #4. This clause, is a
solution that works on top of solution #1 and #2.
### 6.7.2 Solution #1 and #2 in End-to-End case
The solution #1 and #2 can be adapted to do both end-to-end and fulfil key
issue #4 by deriving another key from e2mKEYSET (sol. #1) and e2m_key (sol.
#2), namely the e2eKEYSET according to clause 6.5.2.2. In this case, the HSE
(sol. #1) or EMSE (sol. #2) can be the source of the RAND and transport the
RAND to the UE, but the HSE/EMSE can also obtain the RAND from an external or
trusted source such as the EMKS or HSS.
The UE could know that it should derive an additional e2eKEYSET by receiving a
signalling message that is replay, confidentiality and integrity protected
form the HSE/EMSE that it requires e2e instead of e2m that includes a RAND.
The HSE knows that it should apply e2e from a configuration setting that tells
it to derive e2e keys.
Additionally, keys can be refreshed independently by using the mechanism
described in clause 6.5.2.3. For this purpose the same signalling message that
instructs the UE to derive a new key can be reused.
In order to satisfy key issue #4, the HSE/EMSE may be equipped with an
interface that the CIoT application provider can use to initiate a key
derivation. However, such an interface may be out of scope of the
standardisation.
### 6.7.3 Solution Evaluation
This solution shows how using solutions #1 and #2 it is possible to also
fulfil requirement #4. Compared to solution #5, this solution is slightly less
flexible since the end-to-end keys are always refreshed whenever a new AKA run
is necessary.
## 6.8 Solution #8: Complete end to middle solution
### 6.8.1 Introduction
This solution is a complete end to middle solution that includes the following
features that minimise the security overhead whilst delivering all of the key
objectives and addressing all of the key issues:
**\- Optimisation of the transmitted data to reduce battery drain** \-- The
signalling and user plane headers between the UE and the eNodeB have been
optimised so as to significantly reduce both the amount of header data added
to every message and to reduce the processing required to generate a new
message.
**\- Optimisation of the key agreement** \- The number of authentication
messages to setup and synchronise keys has been reduced significantly compared
to a standard E2E security solution. The ability for keys to survive power
cycles and location / network changes, acts to reduce the security overhead
per message and therefore the battery drain. The ability to reuse the 3G
authentication mechanisms significantly reduces the signalling required for
key agreement.
**\- Re-use of existing signalling** \-- The use of the protocol configuration
options element that it is passed transparently from the UE to the HSE via the
existing LTE architecture for the initial signalling setup allows the overhead
for this signalling to be minimised and allows the protocols specified here to
be transparent to the visited network that does not know about the BEST
service. For a network that is aware of the BEST service, this also allows the
visited network to send BEST service restriction requests to the home network
to meet LI requirements.
**\- Use of tunnelled bearer to reduce message overheads** \-- This solution
uses newly specified SGi PtP tunnelling based on UDP/IP bearer to reduce the
transmitted data size. With the SGi PtP tunnelling based on UDP/IP bearer the
IP/UDP headers are created in the PGW and not by the UE saving a significant
number of transmitted bytes.
The solution specifically addresses:
Service discovery.
Enabling and disabling the service.
Negotiation of parameters.
Key agreement and re-keying.
Starting a session.
Suspending and resuming a session.
Ending a session.
Consequences of network changes and errors.
The solution proposed includes the setup of the E2M solution at the request of
the UE and at the request of the external data network.
### 6.8.2 Solution description
#### 6.8.2.1 Proposed Architecture
{width="6.513888888888889in" height="2.7020833333333334in"}
Figure 6.5.2.5.1 Proposed Architecture for Solution #8
The two new network elements proposed are:
\- Home Security Environment (HSE) -- this is the endpoint for the secure
communications in the home network. It is expected that both the user plane
data and the signalling data relevant to the BEST service will terminate here.
In line with the LTE architecture, the HSE may be split into a signalling part
and a user data part. The HSE has interfaces to the PDN gateway (UDP/IP and
Diameter over SGi), the enterprise server (out of scope for 3GPP) and either
the HSS (S6x) or the EMKS (new 2).
\- End to Middle Key Server (EMKS) -- This is an optional key server element
that manages the key communication with the HSS (for quintets) and stores keys
to reduce loading on the HSE and HSS. Note: This is the same element described
in solution #2. The EMKS has interfaces to the HSS (S6y) and the HSE (new 2).
The four new network interfaces proposed are:
\- S6x -- An interface between the HSE and the HSS to allow the HSE to obtain
subscription data and authentication vectors.
\- New 1 -- An interface between the HSE and the Enterprise Server that allows
the Enterprise Server to manage aspects of the BEST service and allows the
transportation of user data to and from the Enterprise Server.
\- New 2 -- An interface between the HSE and the EMSK that allows the HSE to
retrieve authentication vectors for a user\'s subscription.
\- S6y -- An interface between the EMSK and the HSS that allows the EMSK to
retrieve a block of authentication vectors for later use by the HSE.
The SGi interface between the PDN Gateway and the HSE has 2 connections per
subscriber. A Diameter connection for \"service discovery and negotiation\"
and a UDP/IP connection for the session signalling and user plane data.
#### 6.8.2.2 Service Discovery and Negotiation
This clause defines the BEST service discovery and initial BEST service
definition. This is run when the UE wants to use the BEST service and there is
no BEST session active or as part of the power-on sequence.
In this solution, the BEST service only needs to be supported by the UE, the
MME and the HSE in the home network to operate. The visited network may have a
requirement to influence the use of the BEST service to comply with local laws
such as Lawful Interception.
Figure 6.8.2.2.1 shows the message flow for service discovery for LTE
Note: non relevant messages have been omitted for clarity.
The message flow for GSM and 3G is similar.
Figure 6.8.2.2.1: Flow diagram showing the BEST service discovery message flow
for LTE
The ability of the UE to support the BEST service shall be indicated in a BEST
container within the protocol configuration options of a
PDN_CONNECTIVITY_REQUEST.
The following BEST service aspects shall be indicated in the protocol
configuration options as detailed in figure 8.6.2.2.2 (based on the protocol
block format for the protocol configuration options IE in 3GPP TS 24.008
[12]):
* * *
Bit 8 Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Upper byte of PCO protocol ID
= UE BEST  
Lower byte of PCO protocol ID = UE BEST  
Length of Best protocol ID contents  
BEST release supported by the UE BEST counter schemes supported by the UE -
BEST optimised counter scheme Reserved for future use (set to 000)  
BEST protocols supported - type 01 signalling plane EMSDP message Reserved for
future use (set to 000) BEST protocols supported - type 01 user plane EMSDP
message Reserved for future use (set to 000)  
Support for user data push to UE BEST encryption algorithm GEA4 supported BEST
encryption algorithm GEA5 supported BEST encryption algorithm UEA1 supported
BEST encryption algorithm UEA2 supported BEST encryption algorithm EEA0
supported BEST encryption algorithm 128-EEA1 supported BEST encryption
algorithm 128-EEA2 supported BEST encryption algorithm 128-EEA3 supported BEST
integrity algorithm GIA4 supported BEST integrity algorithm GIA5 supported
BEST integrity algorithm UIA1 supported BEST integrity algorithm UIA2
supported BEST integrity algorithm 128-EIA1 supported BEST integrity algorithm
128-EIA2 supported BEST integrity algorithm 128-EIA3 supported
* * *
Figure 6.8.2.2.2: Definition of the UE BEST protocol ID element
\- BEST release supported by the UE -- an indicator the release of the BEST
solution that the UE has been designed to. If no release is indicated this
means that the BEST service is not supported. This shall be a 4 bit field
where \"0000\" = Rel.14 and \"0001\" to \"1111\" are RFU,
\- BEST protocols supported -- 1 octet where each bit is used to indicate a
BEST signalling protocol that is supported from the following list: type 01
signalling plane EMSDP message and type 01 user plane EMSDP message. All other
values are reserved for future use.
\- BEST encryption algorithms supported by the UE -- a flag for each supported
algorithm. A further optimisation for this would be to assume that all
algorithms indicated in the UE network capability information element are
supported for the BEST service (currently GEA4, GEA5, UEA1, UEA2, EEA0,
128-EEA1, 128-EEA2 and 128-EEA3).
\- BEST integrity algorithms supported by the UE -- a flag for each supported
algorithm. A further optimisation for this would be to assume that all
algorithms indicated in the UE network capability information element are
supported for the BEST service (currently GIA4, GIA5, UIA1, UIA2, 128-EIA1,
128-EIA2 and 128-EIA3).
\- BEST counter schemes supported by the UE -- a flag for each supported
scheme. Currently only one scheme is being proposed, the optimised counter
scheme, but other optimisations may be proposed in the future.
\- Support for user data push to UE -- a flag to indicate whether the UE
supports user data pushed to the UE without a request for user data from the
UE.
\- Power capabilities of the UE. This allows the home network and visited
network to optimise their key agreement and signalling layers to take into
account the power available.
In order to support regulatory requirements in certain countries (e.g. LI or
where encryption is prohibited) then an MME that supports the BEST service may
inspect the PCO provided by the UE in the PDN_CONNECTIVITY_REQUEST. The MME
may add a VISITED NETWORK BEST INDICATION container to the PCO with the
following information:
\- BEST encryption Restricted -- A flag that indicates that encryption is not
allowed through this visited network.
The HSE defines how the BEST service shall be setup in a BEST container within
the protocol configuration options of a ACTIVATE DEDICATED EPS BEARER CONTEXT
REQUEST.
The following BEST service aspects shall be indicated in the protocol
configuration options as detailed in figure 8.6.2.2.3 (based on the protocol
block format for the protocol configuration options IE in 3GPP TS 24.008
[12]):
* * *
8 7 6 5 4 3 2 1 Upper byte of PCO protocol ID = HSE BEST  
Lower byte of PCO protocol ID = HSE BEST  
Length of Best protocol ID contents  
BEST Service Activated BEST encryption algorithm GEA4 to be used BEST
encryption algorithm GEA5 to be used BEST encryption algorithm UEA1 to be used
BEST encryption algorithm UEA2 to be used BEST encryption algorithm EEA0 to be
used BEST encryption algorithm 128-EEA1 to be used BEST encryption algorithm
128-EEA2 to be used BEST signalling plane protocol identifier  
BEST user plane protocol identifier  
BEST encryption algorithm 128-EEA3 to be used BEST integrity algorithm GIA4 to
be used BEST integrity algorithm GIA5 to be used BEST integrity algorithm UIA1
to be used BEST integrity algorithm UIA2 to be used BEST integrity algorithm
128-EIA1 to be used BEST integrity algorithm 128-EIA2 to be used BEST
integrity algorithm 128-EIA3 to be used Reserved for future use (set to 000)
Local BEST configuration management allowed EMSDP session ID length  
Reserved for future use (set to 00) New session required EMSDP MAC length Size
of EMSDP Data Length
* * *
Figure 6.8.2.2.3: Definition of the HSE BEST protocol ID element
\- BEST Service Activated -- a bit flag that when set instructs the UE to use
the BEST service and when clear instructs the UE not to use the BEST service,
\- BEST signalling plane protocol identifier -- 1 octet that is used to
determine the BEST signalling protocol to be used from the following list
(only one shall be indicated): 01 = type 01 signalling plane EMSDP message.
All other values are reserved for future use.
\- BEST user plane protocol identifier -- 1 octet that is used to determine
the BEST signalling protocol to be used from the following list (only one
shall be indicated): 01 = type 01 user plane EMSDP message. All other values
are reserved for future use.
\- BEST encryption algorithm to be used -- 1 octet that is used to define
which of the following algorithms to use for encryption: GEA0, GEA4, GEA5,
UEA0, UEA1, UEA2, EEA0, 128-EEA1, 128-EEA2 and 128-EEA3. Only one algorithm
from this list shall be indicated. If the Visited network indicated that BEST
encryption is restricted, then the HSE shall indicate EEA0.
\- BEST integrity algorithm to be used -- 1 octet that is used to define which
one of the following algorithms to use for integrity:GIA4, GIA5, UIA1, UIA2,
128-EIA1, 128-EIA2 and 128-EIA3). Only one algorithm from this list shall be
indicated.
\- BEST counter scheme to be used -- a flag for each supported scheme. 4 bits
that are used to define which one of the following counter schemes to use:
\"0001\" = the optimised EMSDP counter scheme. All other values are reserved
for future use. Only one counter scheme from this list is allowed to be
indicated.
\- Local BEST configuration management allowed -- a flag to indicate that the
software connected to the UE is allowed to manage the BEST service.
\- EMSDP session ID length -- 4 bits that indicates how many octets in the
EMSDP data packet the EMSDP session ID will be on.
\- New Session Required -- 1 bit that indicates if a new session is required.
If this bit is set to 0 then the details agreed for the last session can be
used and a new session is not required to be setup.
\- EMSDP MAC length -- 2 bits that indicates how many octets in the EMSDP data
packet the integrity checksum (MAC) will be on, as follows: \"00\"=4 octets,
\"01\"=8 octets, \"10\"=12 octets and \"11\"= 16 octets. This value shall not
be set to a size that is greater than MAC size produced by the chosen
algorithm.
\- Size of EMSDP Data Length -- 4 bits that indicate how many octets are used
for the EMSDP Data Length. \"0000\" is reserved for future use.
Any remaining bits are reserved for future use and are set to \"0..0\".
In order to ensure that the visited networks encryption restriction is
honoured by the HSE, an MME that has indicated BEST encryption is restricted,
should inspect the BEST information element in the PCO within the start
session response from the PGW and if it indicates an encryption algorithm that
is not EEA0, the MME should reject the start session response. It is the
HSE\'s responsibility to send a corrected start session response.
#### 6.8.2.3 Ability to enable and disable the BEST service
The HSE may allow the enterprise to manage the BEST service. The service shall
allow enable / disable of the BEST service down to an individual UE level. It
is anticipated that the interface for the management of the BEST service
between the enterprise and the HSE will be out of scope for 3GPP. However it
is expected that such an interface would have the following abilities:
\- a mechanism that allows the service to be removed for a specific subscriber
at the network end (probably re-using a service provisioning service).
\- the ability for the enterprise to enable / disable the E2M security service
for one or many of their endpoints through communication with the operators
CIoT interface. (This may be because other security mechanisms are being
used).
\- The ability for the home network to disable the BEST service due to non-
payment or security concerns.
If the BEST service parameters in the HSE change as a result of the management
of the BEST service for a specific UE and the BEST service is not currently
active with that UE then the changes shall take effect the next BEST session.
If the BEST service parameters in the HSE change as a result of the management
of the BEST service for a specific UE and the BEST service is currently active
with that UE then the HSE shall end the current BEST session and where
appropriate start a new BEST session using the new BEST service parameters.
The UE may allow the application connected to it to manage the BEST service if
the Local BEST configuration management flag within the protocol configuration
options of a ACTIVATE DEDICATED EPS BEARER CONTEXT REQUEST indicates this is
allowed.
If the BEST service parameters in the UE change as a result of the management
of the BEST service and the BEST service is not currently active then the
changes shall take effect the next BEST session.
If the BEST service parameters in the UE change as a result of the management
of the BEST service and the BEST service is currently active in that UE then
the UE shall end the current BEST session and where appropriate start a new
BEST session using the new BEST service parameters.
The UE may choose not to accept data that does not meet the defined security
requirements.
When the BEST service is disabled it is anticipated that the HSE and UE shall
act as though the BEST service is not supported.
#### 6.8.2.4 End to Middle Security User Plane and Signalling Plane
##### 6.8.2.4.1 Data transport
This solution uses the SGi PtP tunnelling based on UDP/IP bearer specified in
3GPP TS 23.401[16] to transport both user plane and signalling plane data
between the UE and the HSE. This bearer has been chosen as it significantly
reduces the size of the data header used over the air interface (and hence
reduces power consumption) whilst still allowing IP/UDP to be used between the
PGW and the HSE.
##### 6.8.2.4.2 End to Middle Secured Data Protocol (EMSDP)
A new data protocol between the UE and the HSE is detailed in this solution,
called \"End to Middle Secured Data Protocol\" (EMSDP), which has been
optimised for efficient, secure transfer of both user plane and signalling
plane data.
Figure 6.8.2.4.2.1 shows the data stack for the EMSDP transfers (based on 3GPP
TS 23.401 [16]).
Figure 6.8.2.4.2.1: data stack for the EMSDP transfers
The UE selects the non-IP PDN data type as defined in clause 4.3.17.8 of 3GPP
TS 23.401[16]. The PDN GW adds the IP and UDP layers for the communication
with the HSE.
So that an MME that does not support the BEST service can restrict the use of
the BEST service, as part of the normative work, a fixed APN structure will be
investigated that allows filtering of the BEST service based on the APN
requested by the UE.
##### 6.8.2.4.3 EMSDP general structure
This clause details a type 01 signalling plane EMSDP message and a type 01
user plane EMSDP message.
Figure 6.8.2.4.3.1 shows the general structure of the EMSDP type 01 message:
+---------+--------+---------+---------+---------+---------+--------+ | Sig | | | | | | | | nalling | | | | | | | | Plane | | | | | | | | type 01 | | | | | | | | m | | | | | | | | essage: | | | | | | | +---------+--------+---------+---------+---------+---------+--------+ | UP / SP | Key ID | SP | Session | EMSDP | Cmd | MAC | | Flag | | COUNTER | ID | Command | Options | | +---------+--------+---------+---------+---------+---------+--------+ | 1 bit | 4 bits | Note 4 | Note 1 | Note 1 | Note 2 | Note 1 | | | | | | | | | | | | | Note 2 | Note 2 | Note 3 | Note 3 | | | | | | | | | | | | | | Note 3 | | | +---------+--------+---------+---------+---------+---------+--------+ | User | | | | | | | | Plane | | | | | | | | type 01 | | | | | | | | m | | | | | | | | essage: | | | | | | | +---------+--------+---------+---------+---------+---------+--------+ | UP / SP | Key ID | UP | Session | Data | Data | MAC | | Flag | | COUNTER | ID | Length | | | +---------+--------+---------+---------+---------+---------+--------+ | 1 bit | 4 bits | Note 4 | _Note | Note 1 | Note 2 | Note 1 | | | | | 1_ | | | | | | | | | Note 2 | Note 3 | Note 3 | | | | | _Note | | | | | | | | 2_ | Note 3 | | | +---------+--------+---------+---------+---------+---------+--------+
Note 1: The length of these fields is indicated in the BEST service discovery
from the HSE.
Note 2: These fields are included in the integrity protection calculation.
Note 3: These fields are encrypted when encryption is used. When encrypted
these fields are replaced by the encrypted output.
Note 4: The length of this field is as defined in the BEST Counter Scheme
being used.
Figure 6.8.2.4.3.1: data stack for the EMSDP transfers
**UP / SP Flag:** This is a 1 bit field that when set means that the data
packet is a User Plane message and when clear means that the message is a
signalling plane message.
**Key ID:** This is a 4 bit field that indicates the key being used for
encryption and Integrity protection.
**SP COUNTER:** This is a counter used for signalling plain data packets that
is incremented every data packet. It is used to protect data packets against
replay and its length is set based on the counter scheme indicated in the BEST
service discovery (minimum length is 3 bits). There are separate counter
values for UE to HSE and HSE to UE.
**UP COUNTER:** This is a counter used for user plain data packets that is
incremented every data packet. It is used to protect data packets against
replay and its length is set based on the counter scheme indicated in the BEST
service discovery (minimum length is 3 bits). There are separate counter
values for UE to HSE and HSE to UE.
**Session ID:** This indicates the identifier for the current session. The
value is assigned by the HSE. For signalling messages sent outside of a
session, the Session ID shall be all 0\'s. Its length is the value set in the
BEST service discovery.
**EMSDP Command** : This is a 1 byte field that contains the signalling
command. The defined commands are detailed below.
**Cmd Options** : This is a TLV container that contains TLV elements that
detail the options for the EMSDP command. The defined options TLVs are
detailed below.
**MAC** : This contains the truncated integrity result for this data packet
calculated using the agreed integrity algorithm. Its length is set in the BEST
service discovery.
**Data length** : This holds the length of the following data in this data
packet. Its length is set in the BEST service discovery.
**Data** : This is the data being transferred.
##### 6.8.2.4.3 EMSDP Counter Schemes
##### 6.8.2.4.3.1 Optimised EMSDP counter scheme {#optimised-emsdp-counter-
scheme .H6}
The optimised EMSDP counter scheme has a 3 bit counter length followed by the
counter value. This allows the counter length to be changed on a per message
basis. The 3 bits are used to indicate the number of octets the counter is on,
the value \"000\" is reserved for future use. So for instance:
> Counter value \"1\" is represented as \"001 00000001\"
>
> Counter value \"257\" is represented as \"010 00000001 00000001\"
The optimised EMSDP counter scheme is defined as scheme 01.
##### 6.8.2.4.4 EMSDP Integrity protection
The integrity protection algorithm to be used and the length of the MAC is
indicated in the BEST service discovery.
Integrity protection is mandatory for all signalling plane and user plan data
packets except for the following signalling plane commands when no valid
keyset is agreed between the UE and HSE:
\- a Start EMSDP session request originating from the UE or the HSE
\- a Start EMSDP session response originating from the HSE
For these commands the MAC shall be set to \"0...0\".
For all other signalling plane and user plane data packets the MAC shall be
computed as follows:
First the following fields are calculated (where needed for the chosen
algorithm):
\- INPUT-I set to the Data Packet Counter Value expanded and right padded with
0\'s to a fixed size of 4 bytes.
\- COUNT-C set to the Data Packet Counter Value expanded and right padded with
0\'s to a fixed size of 4 bytes
\- M (GSM) set to the length of Message in bytes. It is coded on 2 bytes.
\- LENGTH set to the length of Message in bytes. It is coded on 2 bytes.
\- MESSAGE the fields marked for integrity protection in figure 6.8.2.4.3.1:
\"data stack for the EMSDP transfers\" concatenated in the order they appear
in the data packet.
\- M (LTE) the fields marked for integrity protection in figure 6.8.2.4.3.1:
\"data stack for the EMSDP transfers\" concatenated in the order they appear
in the data packet.
\- DIRECTION The DIRECTION bit shall be \"0\" for UE to HSE data packets and
set to \"1\" for HSE to UE data packets.
\- BEARER For signalling data packets this shall be set to \"00000\" and for
user plane data packets this shall be set to \"10101\"
\- FRAMETYPE For signalling data packets this shall be set to \"00\" and for
user plane data packets this shall be set to \"AA\".
\- KI128 This is the agreed integrity key value truncated to the lowest 128
bits.
\- IK This is the agreed integrity key value truncated to the lowest 128 bits.
If GIA4 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 55.241 [38] shall be used to generate the MAC value. If
the MAC length indicated in the BEST service discovery is less than the length
of the MAC produced by the GIA4 function, then the MAC shall be truncated to
the correct size from the right.
If GIA5 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 55.251 [39] shall be used to generate the MAC value. If
the MAC length indicated in the BEST service discovery is less than the length
of the MAC produced by the GIA5 function, then the MAC shall be truncated to
the correct size from the right.
If UIA1 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 35.205 [40] shall be used to generate the MAC-I value.
The MAC shall be set to the MAC-I truncated to the correct size from the
right.
If UIA2 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 35.215 [41] shall be used to generate the MAC-I value.
The MAC shall be set to the MAC-I truncated to the correct size from the
right.
If 128-EIA1 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.401 [42] shall be used to generate the MAC-I
value. The MAC shall be set to the MAC-I truncated to the correct size from
the right.
If 128-EIA2 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.401 [42] shall be used to generate the MAC-I
value. The MAC shall be set to the MAC-I truncated to the correct size from
the right.
If 128-EIA3 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.221 [43] shall be used to generate the MAC-I
value. The MAC shall be set to the calculated MAC-I value truncated to the
correct size from the right.
##### 6.8.2.4.5 EMSDP Encryption
The encryption protection algorithm to be used is indicated in the BEST
service discovery. If EEA0 is indicated then the data packet shall not be
encrypted.
Encryption is mandatory for all signalling plane and user plan data packets
when an encryption algorithm is indicated in the BEST service discovery,
except for the following signalling plane commands when no valid keyset is
agreed between the UE and HSE:
> \- a Start EMSDP session request originating from the UE or the HSE
>
> \- a Start EMSDP session response originating from the HSE
For all other data packets the following encryption shall be applied the
fields indicated in figure 6.8.2.4.3.1: \"data stack for the EMSDP transfers\"
to be encrypted.
First the following are computed (where relevant for the algorithm being
used):
\- INPUT-I set to the Data Packet Counter Value expanded and right padded with
0\'s to a fixed size of 4 bytes.
\- COUNT-C set to the Data Packet Counter Value expanded and right padded with
0\'s to a fixed size of 4 bytes
\- M (GSM) set to the length of Message in bytes. It is coded on 2 bytes.
\- LENGTH set to the length of Message in bytes. It is coded on 2 bytes.
\- MESSAGE the fields marked for encryption protection in figure 6.8.2.4.3.1:
\"data stack for the EMSDP transfers\" concatenated in the order they appear
in the data packet.
\- M (LTE) the fields marked for encryption protection in figure 6.8.2.4.3.1:
\"data stack for the EMSDP transfers\" concatenated in the order they appear
in the data packet.
\- DIRECTION The DIRECTION bit shall be \"0\" for UE to HSE data packets and
set to \"1\" for HSE to UE data packets.
\- BEARER For signalling data packets this shall be set to \"00000\" and for
user plane data packets this shall be set to \"10101\"
\- FRAMETYPE For signalling data packets this shall be set to \"00\" and for
user plane data packets this shall be set to \"AA\".
\- KI128 This is the agreed encryption key value truncated to the lowest 128
bits.
\- CK This is the agreed encryption key value truncated to the lowest 128
bits.
If GEA4 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 55.241 [38] shall be used to generate the OUTPUT value.
The OUTPUT value replaces the fields that are encrypted in the data packet.
If GEA5 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 55.251 [39] shall be used to generate the OUTPUT value.
The OUTPUT value replaces the fields that are encrypted in the data packet.
If UEA1 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 35.205 [40] shall be used to generate the OBS value. The
OBS value replaces the fields that are encrypted in the data packet.
If UEA2 is indicated in the HSE BEST protocol ID element, then the algorithm
specified in 3GPP TS 35.215 [41] shall be used to generate the OBS value. The
OBS value replaces the fields that are encrypted in the data packet.
If 128-EEA1 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.401 [42] shall be used to generate the OBS
value. The OBS value replaces the fields that are encrypted in the data
packet.
If 128-EEA2 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.401 [42] shall be used to generate the OBS
value. The OBS value replaces the fields that are encrypted in the data
packet.
If 128-EEA3 is indicated in the HSE BEST protocol ID element, then the
algorithm specified in 3GPP TS 35.221 [43] shall be used to generate the OBS
value. The OBS value replaces the fields that are encrypted in the data
packet.
##### 6.8.2.4.6 EMSDP Commands
##### 6.8.2.4.6.0 Overview {#overview .H6}
The following EMSDP commands are proposed Table 6.8.2.4.6.1.1:
Table 6.8.2.4.6.1.1: EMSDP commands
* * *
Code (Hex) Command 10 Start EMSDP session request 11 Start new EMSDP session
30 Terminate EMSDP session request 31 Terminate EMSDP session response 40
Manage EMSDP Keys request 41 Manage EMSDP Keys response
* * *
##### 6.8.2.4.6.1 Start EMSDP session request {#start-emsdp-session-request
.H6}
The Start EMSDP session request command is used by the UE to trigger a new
BEST session from the HSE.
The cmd options for the Start EMSDP session request command are as follows:
Enterprise Setup Information Element TLV: This is a TLV element that contains
information from the UE that is used by the HSE to setup the HSE to enterprise
connection.
##### 6.8.2.4.6.2 Start new EMSDP session {#start-new-emsdp-session .H6}
The Start new EMSDP session response command is used by the HSE to setup a new
BEST session. This message can be sent in response to a start EMSDP session
request command from the UE or as an initial message from the HSE.
The Start new EMSDP session response command has the following cmd options:
HSE Identity TLV: this contains a 4 octet numeric identifier for the HSE. This
should be unique to the HSE being used within the home network.
Key agreement TLV: this contains the RAND IE and AUTN IE specified in 3GPP TS
24.008 [12] as detailed in table 6.8.2.4.6.2.1:
Table 6.8.2.4.6.2.1: Key Agreement TLV
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M 0 or
35 RAND IE 17 bytes C See 10.5.3.1 in 3GPP TS 24.008 [12] AUTN IE 18 bytes C
See 10.5.3.1.1 in 3GPP TS 24.008 [12]
* * *
If the Length of the Key agreement is set to 0 then this means use current
keyset.
##### 6.8.2.4.6.3 Terminate EMSDP session request {#terminate-emsdp-session-
request .H6}
The Terminate EMSDP session request EMSDP command is used by either the UE or
the HSE to terminate an existing EMSDP session.
This command has no cmd options.
##### 6.8.2.4.6.4 Manage EMSDP Keys request {#manage-emsdp-keys-request .H6}
The Manage EMSDP Keys request EMSDP command is used by the HSE to negotiate
new key material.
This command has no cmd options.
##### 6.8.2.4.6.5 Manage new EMSDP Keys {#manage-new-emsdp-keys .H6}
The Manage EMSDP Keys response command is used by the HSE to agree new keys.
The Manage EMSDP Keys response command has the following cmd options:
Key agreement TLV: this contains the RAND IE and AUTN IE specified in 3GPP TS
24.008 [12] as detailed in table 6.8.2.4.6.5.1:
Table 6.8.2.4.6.5.1: Key Agreement TLV
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M 35
RAND IE 17 bytes C See 10.5.3.1 in 3GPP TS 24.008 [12] AUTN IE 18 bytes C See
10.5.3.1.1 in 3GPP TS 24.008 [12]
* * *
#### 6.8.2.7 Key Agreement and Refreshing
##### 6.8.2.7.1 Overview
There are several key agreement solutions presented in this document that
would be capable of agreeing keys between the UE and the HSE. For this
solution it is proposed to use the key agreement similar to the mechanism
proposed in solution #3 as it enables complete confidentially between the home
network and the UE and it remains unaffected by visited network changes (such
as location area changes).
##### 6.8.2.7.2 Key setup messaging between HSE and UE
New keys are agreed either at the start of a BEST session or as required due
to key aging or counter thresholds being met. Key agreement is based on the
3GPP AKA mechanism detailed in TS33.102 [27] and the AKA challenge is
transported between the HSE and the UE in any of the following EMSDP commands:
\- Start new EMSDP session EMSDP command from the HSE as part of a new session
being setup by the HSE.
\- Manage new EMSDP Keys EMSDP command from the HSE as a result of key aging
or counter thresholds being met.
Once in a session, a UE can request new keys by sending a Manage EMSDP Keys
request command to the HSE.
Figure 6.8.2.7.2.1 shows the key agreement process
Figure 6.8.2.7.2.1 BEST key agreement process
The Key agreement steps are:
**1\. Start EMSDP session request command or Manage EMSDP Keys request command
over the Air interface / core network interfaces.** \-- If the UE wants to
initialise the BEST session, it sends a \"Start EMSDP session request
command\" through the SGI PtP tunnel (This is described in detail in clause
6.8.2.8). If the UE is already in a session and wants to renegotiate the keys
it sends a or Manage EMSDP Keys request command secured with the current keys
to the PDN gateway through the SGI PtP tunnel.
**2\. Start EMSDP session request command or Manage EMSDP Keys request command
over the SGi interface.** \--The \"Start EMSDP session request command\" or
Manage EMSDP Keys request command is forwarded to the HSE using the SGi
interface.
**3\. Keys required?** \- the HSE checks to see if there are valid keys with
valid counter values available in the HSE for that UE then the following is
checked:
\- If the \"Start EMSDP session request command\" has the correct counter
value, is correctly encrypted and is correctly integrity protected then the
HSE sends a \"Start new EMSDP session command\" -- use current keyset, to the
UE correctly encrypted, integrity protected and with a correct counter to the
UE (step 6).
\- If the \"Start EMSDP session request command\" is not integrity protected
or has any of the security parameters wrong (against the information the HSE
has) and there are new authentication vectors available in the HSE for that
UE, then the HSE goes to step 6 and uses one of the available unused
authentication vectors.
\- If the \"Start EMSDP session request command\" is not integrity protected
or has any of the security parameters wrong (against the information the HSE
has) and there are no authentication vectors available in the HSE for that UE
and the HSE has a direct connection to the HSS, then the HSE goes to step 4.
\- If the \"Start EMSDP session request command\" is not integrity protected
or has any of the security parameters wrong (against the information the HSE
has) and there are no authentication vectors available in the HSE for that UE
and the HSE has an indirect connection to the HSS via a EMKS, then the HSE
goes to step a.
**4\. Authentication-Information-Request over S6x interface** \-- The HSE uses
the S6x interface to the HSS to request one or more authentication vectors
using the UE IMSI. These vectors will be specific to the BEST service. The
IMSI of the UE is the IMSI passed in the accounting request (Start) for that
UE when the SGi interface was setup.
**5\. Authentication-Information-Answer over S6x interface** \-- The HSS uses
the S6x interface to the HSE to return the requested authentication vectors.
These vectors are specific to the BEST service.
**a. Authentication-Information-Request over the new2 interface** \-- Where an
EMKS is used, the HSE uses the new2 interface to the EMKS to request an
authentication vector using the UE IMSI. These vectors will be specific to the
BEST service. The IMSI of the UE is the IMSI passed in the accounting request
(Start) for that UE when the SGi interface was setup.
**b. Authentication-Information-Request over the S6y interface** \-- The EMKS
uses the S6y interface to the HSS to request one or more authentication
vectors using the UE IMSI. These vectors will be specific to the BEST service.
**c. Authentication-Information-Answer over the S6y interface** \-- The HSS
uses the S6y interface to the EMKS to return the requested authentication
vectors. These vectors may be stored on the EMKS for later use.
**d. Authentication-Information-Answer over the new2 interface** \-- The EMKS
uses the new2 interface to the HSE to return the requested authentication
vector.
**6\. Start new EMSDP session command over the SGi interface** \- The HSE
sends a \"Start new EMSDP session\" command to the PDN Gateway using the SGi
interface as follows:
> \- If the new keys need to be agreed for the BEST service, then the HSE
> includes the Key Agreement TLV in the \"Start new EMSDP session\" command.
> The Key Agreement TLV has the RAND and AUTN of the authentication vector
> used in the RAND IE and AUTN IE.
**7\. Start new EMSDP session command over the Air interface / core network
interface** \- The PDN Gateway sends a \"Start new EMSDP session\" command to
the UE using the core network and air interfaces.
**8\. Calculate UE Keys** \- On successful reception of the \"Start new EMSDP
session\" command, the UE checks the AKA challenge as detailed in 3GPP TS
33.xxx [x] and if it is valid, calculates the AKA response CK and IK. Unlike
the normal AKA challenge/response, the AKA response in not sent to the HSE as
the HSE can determine that this was successful from the MAC value presented in
any following message. The UE calculates the K~E2Menc~ key using the BEST key
derivation mechanism, CK, IK, a HSE id and the key id with the Algorithm id
set to \"BEST encryption Key\". The UE calculates the K~E2Mint~ key using the
BEST key derivation mechanism, CK, IK, a HSE id and the key id with the
Algorithm id set to \"BEST integrity Key\". The UE may choose to calculate one
or a set of K~E2Menc~ and K~E2Mint~ key values depending on its optimal power
strategy. Each key id refers to a pair of K~E2Menc~ and K~E2Mint~ key values.
**9\. Calculate HSE Keys** \- The HSE calculates the K~E2Menc~ key using the
BEST key derivation mechanism, CK, IK, a HSE id and the key id with the
Algorithm id set to \"BEST encryption Key\". The HSE calculates the K~E2Mint~
key using the BEST key derivation mechanism, CK, IK, a HSE id and the key id
with the Algorithm id set to \"BEST integrity Key\".
The pair of K~E2Menc~ and K~E2Mint~ key values for the indicated key id are
then used for all further EMSDP messages until either a new key ID is
indicated or until the keys are re-negotiated.
##### 6.8.2.7.3 BEST key derivation mechanism
All key derivations (including input parameter encoding) for BEST shall be
performed using the key derivation function (KDF) specified in TS 33.220 [20].
This clause specifies how to construct the input string, S, to the KDF (which
is input together with the relevant key).
When deriving a K~E2Menc~ or K~E2Mint~ from CK, IK, a HSE id, key id and
algorithm id, the following parameters shall be used to form the input S to
the KDF.
\- FC = [TBD],
\- P0 = HSE id,
\- L0 = length of HSE id (i.e. 0x00 0x03),
\- P1 = SQN ⊕ AK
\- L1 = length of SQN ⊕ AK (i.e. 0x00 0x06)
\- P2 = algorithm id
\- L2 = length of algorithm id (i.e. 0x00 0x01)
_The exclusive or of the Sequence Number (SQN) and the Anonymity Key (AK) is
sent to the UE as a part of the Authentication Token (AUTN), see TS 33.102. If
AK is not used, AK shall be treated in accordance with TS 33.102 [27], i.e. as
000...0._
The algorithm id shall be \"BEST encryption key\" for BEST encryption
algorithms and \"BEST integrity Key\" for BEST integrity protection
algorithms. The values 0x03 to 0xf0 are reserved for future use, and the
values 0xf1 to 0xff are reserved for private use.
Table 6.8.2.7.3.1: Algorithm type distinguishers
* * *
Algorithm distinguisher Value BEST encryption key (K~E2Menc~) 0x01 BEST
integrity Key (K~E2Mint~) 0x02
* * *
The input key shall be equal to the concatenation CK \|\| IK of CK and IK.
#### 6.8.2.8 Starting a BEST service session
##### 6.8.2.8.1 UE initiated BEST session
Figure 6.8.2.8.2.1 UE initiated BEST session startup flow diagram
Once the data session is live (following the BEST service discovery
procedure), if there is no current session running and typically when the UE
has some data to transfer, the UE checks the key status and the BEST container
received from the BEST service discovery procedure and does the following:
\- If the BEST service is not activated in the BEST container then the session
shall not be started.
\- If the UE determines that the key needs to be re-agreed then the UE sends a
\"Start EMSDP session request\" command through the SGI PtP tunnel (This is
described in detail in clause 6.8.2.8) with the key id set to \"00\", Session
id set to \"00..00\", no encryption and the MAC set to \"00..00\".
\- If the UE determines that the key does not need to be re-agreed then the UE
sends a \"Start EMSDP session request\" command with the indicated key and
algorithms. The HSE may trigger a key re-agreement if it chooses to do so.
On reception of the \"Start EMSDP session request\" command from the UE via
the PDN gateway, the HSE checks the security of the message, the UE\'s
subscription, the BEST service status for the location of the UE and the
validity of the BEST service keys and carries out one of the following:
\- If the HSE determines that the key does not need to be re-agreed then the
HSE sends a \"Start new EMSDP session\" command with the indicated key,
encrypted and integrity protected as indicated in the service discovery. This
message has one HSE Identity TLV containing the identity of the HSE and a Key
agreement TLV with its length set to 00 and no AUTN IE or RAND IE.
\- If the new keys need to be agreed for the BEST service, then the HSE
includes one HSE Identity TLV containing the identity of the HSE and the Key
Agreement TLV in the \"Start new EMSDP session\" command. The Key Agreement
TLV has the RAND and AUTN of the authentication vector to be used, in the RAND
IE and AUTN IE.
On reception of the \"Start new EMSDP session\" command in the UE, the BEST
session is considered setup and user plane messages are allowed to be sent.
##### 6.8.2.8.2 HSE initiated BEST session
Once the data session is live (following the BEST service discovery
procedure), if there is no current session running and typically when the HSE
has some data to transfer, the HSE checks the UE\'s subscription, the BEST
service status for the location of the UE and the validity of the BEST service
keys and carries out one of the following:
\- If the HSE determines that the key does not need to be re-agreed then the
HSE sends a \"Start new EMSDP session\" command with the indicated key,
encrypted and integrity protected as indicated in the service discovery. This
message has one HSE Identity TLV containing the identity of the HSE and a Key
agreement TLV with its length set to 00 and no AUTN IE or RAND IE.
\- If the new keys need to be agreed for the BEST service, then the HSE
includes one HSE Identity TLV containing the identity of the HSE and the Key
Agreement TLV in the \"Start new EMSDP session\" command. The Key Agreement
TLV has the RAND and AUTN of the authentication vector to be used, in the RAND
IE and AUTN IE.
On reception of the \"Start new EMSDP session\" command in the UE, the BEST
session is considered setup and user plane messages are allowed to be sent.
#### 6.8.2.9 Resuming a BEST session following a power cycle at the UE or a
re-attach
If the new session required is not set and the other BEST parameters in the
HSE BEST IE are identical to the previous agreed HSE BEST IE, the UE may
continue a previously started session by using the security details of the
last agreed session.
#### 6.8.2.10 BEST service session operation
Once a BEST session is setup, boith signalling messages and user plan messages
can be sent and received between the UE and the HSE secured by the agreed
security mechanisms via the PDN gateway.
#### 6.8.2.11 Ending a BEST service session
The HSE or the UE can end a BEST session by sending a Terminate EMSDP request
command. This may be due to a request to do so by the enterprise or the user
or due to an error condition.
### 6.8.3 Solution Evaluation
This solution completely describes a BEST service.
Key issue #1 is fully addressed by the described solution as it describes a
secure message service the between the UE and an element in the home network
called the HSE. The keys are agreed securely by re-using the strong LTE
authentication mechanism. The user data is protected by an integrity mechanism
and optionally protected by encryption. The user data messages are protected
with a counter to prevent reply attacks.
Key issue #2 is fully met by this solution.
Key Issue #3 is fully met by the solution by the ability for the visited
network to indicate restrictions to the HSE which in turn takes this
information into account.
Key Issue #4 is fully met as this solution specifies integrity protection of
all user data and allows the enterprise to control the security used either at
the UE or at the HSE.
## 6.9 Solution #9: Complete end to end solution
### 6.9.1 Introduction
This solution is a complete end to end solution that includes the following
features that minimise the security overhead whilst delivering all of the key
objectives and addressing all of the key issues:
**\- Optimisation of the transmitted data to reduce battery drain** \-- The
signalling and user plane headers between the UE and the eNodeB have been
optimised so as to significantly reduce both the amount of header data added
to every message and to reduce the processing required to generate a new
message.
**\- Optimisation of the key agreement** \- The number of authentication
messages to setup and synchronise keys has been reduced significantly compared
to an over the top E2E security solution. The ability for keys to survive
power cycles and location / network changes, acts to reduce the security
overhead per message and therefore the battery drain. The ability to reuse the
3G authentication mechanisms significantly reduces the signalling required for
key agreement.
**\- Re-use of existing signalling** \-- The use of the protocol configuration
options element that it is passed transparently from the UE to the EnSE via
the existing LTE architecture for the initial signalling setup allows the
overhead for this signalling to be minimised and allows the protocols
specified here to be transparent to the visited network that does not know
about the BEST service. For a network that is aware of the BEST service, this
also allows the visited network to send BEST service restriction requests to
the home network to meet LI requirements.
**\- Use of tunnelled bearer to reduce message overheads** \-- This solution
uses newly specified SGi PtP tunnelling based on UDP/IP bearer to reduce the
transmitted data size. With the SGi PtP tunnelling based on UDP/IP bearer the
IP/UDP headers are created in the PGW and not by the UE saving a significant
number of transmitted bytes.
**\- Encryption of data from the UE all the way to the Enterprise** \-- This
solution describes the derivation of end-to-end keys between the UE and the
Enterprise allowing for end-to-end encryption and integrity protection from
the UE to the Enterprise while allowing the operator to assert control over
the application of this encryption.
The solution specifically addresses:
\- Service discovery.
\- Enabling and disabling the service.
\- Negotiation of parameters.
\- Key agreement and re-keying.
\- Starting a session.
\- Suspending and resuming a session.
\- Ending a session.
\- Consequences of network changes and errors.
The solution proposed includes the setup of the E2E solution at the request of
the UE and at the request of the external data network. The solution builds on
the solution #8, the complete end to middle solution.
In comparison to solution #8, this solution adds:
\- An additional key derivation to derive a key shared between the Enterprise
and the UE is proposed. This key derivation has two steps, namely, first
derive an intermediate key at the HSE that is shared with the Enterprise and
then in the EnSE deriving an E2E keyset using the intermediate key and an
newly introduced Enterprise key.
\- An Enterprise key shared between the UE and the Enterprise and used in the
derivation of the E2E keyset.
\- An Enterprise container that is signalled between the Enterprise and the UE
to contain relevant information for the key derivation.
\- An endpoint, called the Enterprise Security Endpoint inside the Enterprises
premises where the E2E session terminates.
\- Full control over the E2E session by running it through the HSE in the home
network and keeping a session open between the HSE and the UE for full
control.
\- Signalling messages between the HSE and the UE to control the E2E session
between the UE and the EnSE.
### 6.9.2 Solution description
#### 6.9.2.1 Proposed Architecture
{width="6.513888888888889in" height="2.7020833333333334in"}
Figure 6.9.2.1.1 Proposed Architecture for Solution #9
The two new network elements proposed are:
\- Home Security Environment (HSE) -- this is the endpoint for the secure
communications in the home network. It is expected that some user plane data
and most of the signalling data relevant to the BEST service will terminate
here. In line with the LTE architecture, the HSE may be split into a
signalling part and a user data part. The HSE has interfaces to the PDN
gateway (UDP/IP and Diameter over SGi), the enterprise server (out of scope
for 3GPP), the EnSE (new 3) and either the HSS (S6x) or the EMKS (new 2).
\- Enterprese Security Endpoint (EnSE) - This is the endpoint for the secure
communications in the domain of the enterprise. The user plane relevant for
the BEST service will terminate here and some signalling traffic will
terminate here. The EnSE has a new interface (new 3) that is used to pass key
material from the HSE to the EnSE, to forward user plane data from the UE and
to exchange relevant signalling between the HSE and the EnSE, such as the
applicability of encryption or integrity algorithms. The EnSE maybe integrated
with the Enterprise Server.
\- End to Middle Key Server (EMKS) -- This is an optional key server element
that manages the key communication with the HSS (for quintets) and stores keys
to reduce loading on the HSE and HSS. Note: This is the same element described
in solution #2. The EMKS has interfaces to the HSS (S6y) and the HSE (new 2).
The four new network interfaces proposed are:
\- S6x -- An interface between the HSE and the HSS to allow the HSE to obtain
subscription data and authentication vectors.
\- New 2 -- An interface between the HSE and the EMSK that allows the HSE to
retrieve authentication vectors for a user\'s subscription.
\- New 3 -- An interface between the HSE and the EnSE that is used for
carrying user plane traffic between the EnSE and the HSE and for signalling
between the HSE and the EnSE.
\- New 4 -- An interface between the EnSE and the Enterprise Server that
allows the Enterprise Server to manage aspects of the BEST service and allows
the transportation of user data to and from the Enterprise Server.
\- S6y -- An interface between the EMSK and the HSS that allows the EMSK to
retrieve a block of authentication vectors for later use by the HSE.
The SGi interface between the PDN Gateway and the HSE has 2 connections per
subscriber. A Diameter connection for \"service discovery and negotiation\"
and a UDP/IP connection for the session signalling and user plane data.
Compared to solution #8, the complete End to Middle solution, the EnSE and the
new-4 interface are added.
#### 6.9.2.2 Service Discovery and Negotiation
Clause 6.8.2.2 describes how this works for this solution.
#### 6.9.2.3 Ability to Enable and Disable the BEST service
Like solution #8, the HSE allows the enterprise to manage the BEST service.
However, the interface may be provided through the EnSE and tunnelled to the
HSE. In addition to solution #8, the EnSE allows the enterprise to turn E2E
off without turning BEST off entirely, falling back to end-to-middle instead.
#### 6.9.2.4 End to Middle Security User Plane and Signalling Plane
##### 6.9.2.4.1 Data transport
Just like solution #8, this solution uses the SGi PtP tunnelling based on
UDP/IP bearer specified in 3GPP TS 23.401[x] to transport both user plane and
signalling plane data between the UE and the HSE. This bearer has been chosen
as it significantly reduces the size of the data header used over the air
interface (and hence reduces power consumption) whilst still allowing IP/UDP
to be used between the PGW and the HSE.
##### 6.9.2.4.2 End to Middle Secured Data Protocol (EMSDP)
This solution uses the same EMSDP protocol as solution #8. A new data protocol
between the UE and the HSE is detailed in this solution, called \"End to
Middle Secured Data Protocol\" (EMSDP), which has been optimised for
efficient, secure transfer of both user plane and signalling plane data.
Figure 6.9.2.4.2.1 shows the data stack for the EMSDP transfers (based on 3GPP
TS 23.401 [16]) for data transfer between the HSE and the UE.
Figure 6.9.2.4.2.1: data stack for the EMSDP transfers
The UE selects the non-IP PDN data type as defined in clause 4.3.17.8 of 3GPP
TS 23.401[16]. The PDN GW adds the IP and UDP layers for the communication
with the HSE. The HSE routes traffic between the UE and the EnSE based on the
session ID in the EMDSP headers over the New-4 interface.
So that an MME that does not support the BEST service can restrict the use of
the BEST service, as part of the normative work, a fixed APN structure will be
investigated that allows filtering of the BEST service based on the APN
requested by the UE.
The dashed box in HSE indicates that the control session between the UE and
HSE terminates in the HSE and that the E2E session between the UE and the EnSE
is forwarded by the HSE. Forwarding is left unspecified at this point in time
and may include encapsulation in another protocol, such as XML over TCP/IP.
##### 6.9.2.4.3 EMSDP general structure
This solution uses the EMSDP general structure specified in 6.8.2.4.3 without
modifications.
NOTE: With respect to the session ID, it is noted that in the end to end case,
there is one session the HSE and the UE and one for data transfer between the
EnSE and UE. The session between the HSE and the UE is the session that the
HSE uses to control the session between the EnSE and the UE.
##### 6.9.2.4.3A EMSDP Counter Schemes
There are no changes to the EMSDP Counter Schemes as specified in 6.8.2.4.3 .
##### 6.9.2.4.4 EMSDP Integrity protection
There are no changes to the EMSDP Integrity protection as specified in
6.8.2.4.4
##### 6.9.2.4.5 EMSDP Encryption
There are no changes to the EMSDP Encryption as specified in 6.8.2.4.5
##### 6.9.2.4.6 EMSDP Commands
##### 6.9.2.4.6.0 Overview {#overview-2 .H6}
There are no changes to the commands specified in 6.8.2.4.6.1
The following EMSDP commands for controlling the E2E session are proposed
Table 6.9.2.4.6.1.1. These commands are exchanged between the UE and the HSE
on the session, if it exists.
Table 6.9.2.4.6.1.1: EMSDP commands
* * *
Code (Hex) Command 12 Start EMSDP session request with E2E keys 13 Start EMSDP
session response with E2E keys 12 Start EMSDP session request for E2E only 13
Start EMSDP session response for E2E only 32 Terminate EMSDP session request
for E2E 33 Terminate EMSDP session response for E2E 42 Manage EMSDP Keys
request for E2E keys 43 Manage EMSDP Keys request for E2E keys 44 Manage EMSDP
Keys request for E2E keys only
* * *
##### 6.9.2.4.6.1 Start EMSDP session request with E2E keys {#start-emsdp-
session-request-with-e2e-keys .H6}
The Start EMSDP session request command is used by the UE to trigger a new
BEST session from the HSE and at the same time start a session between the UE
and the EnSE
The cmd options for the Start EMSDP session request command are as follows:
Enterprise Setup Information Element TLV: This is a TLV element that contains
information from the UE that is used by the HSE to setup the HSE to enterprise
connection.
Use E2E keys: Indicates the ability of the UE to setup a session with E2E
encryption.
##### 6.9.2.4.6.2 Start new EMSDP session response with E2E keys {#start-new-
emsdp-session-response-with-e2e-keys .H6}
The Start new EMSDP session response command is used by the HSE to setup a new
BEST session. This message can be sent in response to a start EMSDP session
request command from the UE or as an initial message from the HSE.
The Start new EMSDP session response command has the following cmd options:
HSE Identity TLV: this contains a 4 octet numeric identifier for the HSE. This
should be unique to the HSE being used within the home network.
Key agreement TLV: this contains the RAND IE and AUTN IE specified in 3GPP TS
24.008 [12] as detailed in table 6.9.2.4.6.2.1:
Table 6.9.2.4.6.2.1: Key Agreement TLV
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M 0 or
35 RAND IE 17 bytes C See 10.5.3.1 in 3GPP TS 24.008 [12] AUTN IE 18 bytes C
See 10.5.3.1.1 in 3GPP TS 24.008 [12]
* * *
If the Length of the Key agreement is set to 0 then this means use current
keyset.
E2E options: Indicates whether E2E is allowed
E2E session ID: Indicates the session ID to be used for the session between
the UE and the EnSE
E2E derivation information: a container that contains the provided information
for the key E2E derivation for the UE as provided by EnSE. The container may
contain an identifier for the a private key to be used and optionally other
values for key derivation.
Table 6.9.2.4.6.2.2: Key Agreement TLV for E2E
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M
Maximum length TBD Container contents Length C Provided by the EnSE
* * *
##### 6.9.2.4.6.3 Start EMSDP session request with E2E only {#start-emsdp-
session-request-with-e2e-only .H6}
The Start EMSDP session request command is used by the UE to trigger a new
BEST E2E session from the HSE to the same endpoint as the standing session.
So, it serves as a request to turn the existing session between an HSE and the
UE into a control session and obtain a new session for data transfer to the
endpoint.
There are no cmd options for this command.
##### 6.9.2.4.6.4 Start new EMSDP session response E2E only {#start-new-emsdp-
session-response-e2e-only .H6}
The Start new EMSDP session response command is used by the HSE to add a new
BEST E2E session to the existing session between the HSE and UE. This message
can be sent in response to a start EMSDP session request for E2E only command
from the UE or as an initial message from the HSE.
The Start new EMSDP session response for E2E only command has the following
cmd options:
E2E options: Indicates whether E2E is allowed
E2E session ID: Indicates the new session ID to be used for the session
between the UE and the EnSE
E2E derivation information: a container that contains the provided information
for the key E2E derivation for the UE as provided by EnSE. The container may
contain an identifier for the a private key to be used and optionally other
values for key derivation.
Table 6.9.2.4.6.2.2: Key Agreement TLV for E2E
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M
Maximum length TBD Container contents Length C Provided by the EnSE
* * *
##### 6.9.2.4.6.5 Terminate EMSDP session request for E2E {#terminate-emsdp-
session-request-for-e2e .H6}
The Terminate EMSDP session request for E2E EMSDP command is used by either
the UE or the HSE to terminate an existing EMSDP session with E2E keys. This
message is exchanged between the UE and the HSE on control session to
terminate the E2E session between the UE and the EnSE. It has the following
options:
Session ID to be terminated: The session ID of the E2E session to be
terminated.
NOTE: This message is omitted whenever the control session between the UE and
the HSE is terminated. Upon termination of the control session, the HSE and UE
shall terminate the E2E session as well.
##### 6.9.2.4.6.6 Manage EMSDP Keys request for E2E Keys {#manage-emsdp-keys-
request-for-e2e-keys .H6}
The Manage EMSDP Keys request for E2E keys EMSDP command is used by the UE to
negotiate new key material.
Command options:
E2E_keys_only: indicates whether the UE wants to refresh all the keys or the
E2E keys only.
##### 6.9.2.4.6.7 Manage new EMSDP Keys for E2E Keys {#manage-new-emsdp-keys-
for-e2e-keys .H6}
The Manage EMSDP Keys response command for E2E keys is used by the HSE to
agree new keys.
The Manage EMSDP Keys response command for E2E keys has the following cmd
options:
Key agreement TLV: this contains the RAND IE and AUTN IE specified in 3GPP TS
24.008 [12] as detailed in table 6.8.2.4.6.5.1:
Table 6.8.2.4.6.5.1: Key Agreement TLV
* * *
Name Size M / C / O Value Key Agreement TLV 1 byte M TBD Length 1 byte M 35
RAND IE 17 bytes C See 10.5.3.1 in 3GPP TS 24.008 [12] AUTN IE 18 bytes C See
10.5.3.1.1 in 3GPP TS 24.008 [12]
* * *
E2E derivation information: a container that contains the provided information
for the key E2E derivation for the UE as provided by EnSE as specified in
Table 6.9.2.4.6.2.2.
##### 6.9.2.4.6.8 Manage new EMSDP Keys for E2E Keys only {#manage-new-emsdp-
keys-for-e2e-keys-only .H6}
The Manage EMSDP Keys response command is used by the HSE to agree new keys
between EnSE and the UE only. The intermediate key material and the E2M keys
remain unchanged. The command options are as follows:
E2E derivation information: a container that contains the provided information
for the key E2E derivation for the UE as provided by EnSE as specified in
Table 6.9.2.4.6.2.2.
#### 6.9.2.7 Key Agreement and Refreshing
##### 6.9.2.7.1 Overview
There are several key agreement solutions presented in this document that
would be capable of agreeing keys between the UE and the enterprise. For this
solution it is proposed to use the key agreement similar to the mechanism
proposed in solution #4 as it enables complete confidentially between the
enterprise and the UE and it remains unaffected by visited network changes
(such as location area changes).
##### 6.9.2.7.2 Key setup messaging between HSE and UE
New keys are agreed either at the start of a BEST session or as required due
to key aging or counter thresholds being met. Key agreement is based on the
3GPP AKA mechanism detailed in TS33.102 [27] and the AKA challenge is
transported between the HSE and the UE in any of the following EMSDP commands:
\- Start new EMSDP session EMSDP command from the HSE as part of a new session
being setup by the HSE.
\- Manage new EMSDP Keys EMSDP command from the HSE as a result of key aging
or counter thresholds being met.
Once in a session, a UE can request new keys by sending a Manage EMSDP Keys
for E2E request or Manage EMSDP Keys for E2E only request command to the HSE.
Figure 6.9.2.7.2.1 shows the key agreement process
Figure 6.9.2.7.2.1 BEST key E2E agreement process
The Key agreement steps are:
**1\. Start EMSDP session request with E2E command or Manage EMSDP Keys
request for E2E (only) command over the Air interface / core network
interfaces.** \-- If the UE wants to initialise the BEST E2E session, it sends
a \"Start EMSDP session request command with E2E\" through the SGI PtP tunnel
(This is described in detail in clause 6.9.2.8). If the UE is already in a
session and wants to renegotiate the keys it sends a or Manage EMSDP Keys
request for E2E command secured with the current keys to the PDN gateway
through the SGI PtP tunnel.
**2\. Start EMSDP session request command with E2E or Manage EMSDP Keys
request for E2E (only) command over the SGi interface.** \--The \"Start EMSDP
session request with E2E command\" or Manage EMSDP Keys for E2E (only) request
command is forwarded to the HSE using the SGi interface.
**3\. Keys required?** \- the HSE checks to see if there are valid keys with
valid counter values available in the HSE for that UE then the following is
checked:
\- If the \"Start EMSDP session request with E2E command\" has the correct
counter value, is correctly encrypted and is correctly integrity protected
then the HSE sends a \"Start new EMSDP session with E2E command\" -- use
current keyset, to the UE correctly encrypted, integrity protected and with a
correct counter to the UE (step 6).
\- If the \"Start EMSDP session request with E2E command\" is not integrity
protected or has any of the security parameters wrong (against the information
the HSE has) and there are new authentication vectors available in the HSE for
that UE, then the HSE goes to step 6 and uses one of the available unused
authentication vectors.
\- If the \"Start EMSDP session request command with E2E\" is not integrity
protected or has any of the security parameters wrong (against the information
the HSE has) and there are no authentication vectors available in the HSE for
that UE and the HSE has a direct connection to the HSS, then the HSE goes to
step 4.
\- If the \"Start EMSDP session request with E2E command\" is not integrity
protected or has any of the security parameters wrong (against the information
the HSE has) and there are no authentication vectors available in the HSE for
that UE and the HSE has an indirect connection to the HSS via a EMKS, then the
HSE goes to step a.
\- If the command is the \'Manage EMSDP Keys request for E2E only', then the
HSE skips steps 4, 5, 6 and directly proceeds to step 7.
**4\. Authentication-Information-Request over S6x interface** \-- The HSE uses
the S6x interface to the HSS to request one or more authentication vectors
using the UE IMSI. These vectors will be specific to the BEST service. The
IMSI of the UE is the IMSI passed in the accounting request (Start) for that
UE when the SGi interface was setup.
**5\. Authentication-Information-Answer over S6x interface** \-- The HSS uses
the S6x interface to the HSE to return the requested authentication vectors.
These vectors are specific to the BEST service.
**a. Authentication-Information-Request over the new2 interface** \-- Where an
EMKS is used, the HSE uses the new2 interface to the EMKS to request an
authentication vector using the UE IMSI. These vectors will be specific to the
BEST service. The IMSI of the UE is the IMSI passed in the accounting request
(Start) for that UE when the SGi interface was setup.
**b. Authentication-Information-Request over the S6y interface** \-- The EMKS
uses the S6y interface to the HSS to request one or more authentication
vectors using the UE IMSI. These vectors will be specific to the BEST service.
**c. Authentication-Information-Answer over the S6y interface** \-- The HSS
uses the S6y interface to the EMKS to return the requested authentication
vectors. These vectors may be stored on the EMKS for later use.
**d. Authentication-Information-Answer over the new2 interface** \-- The EMKS
uses the new2 interface to the HSE to return the requested authentication
vector.
**6\. Calculate HSE Keys** \- The HSE calculates the K~E2Menc~ key using the
BEST key derivation mechanism, CK, IK, a HSE id and the key id with the
Algorithm id set to \"BEST encryption Key\". The HSE calculates the K~E2Mint~
key using the BEST key derivation mechanism, CK, IK, a HSE id and the key id
with the Algorithm id set to \"BEST integrity Key\". The HSE calculates the
(K~Int_E2E~) key using the BEST key derivation mechanism, CK, IK, a HSE id and
the key id with the Algorithm id set to \" BEST end2end Intermediate Key\".
**7\. The HSE sends a 'UE E2E Session Request' to the EnSE over the new 3
interface** \-- The HSE uses the new 3 interface to the EnSE to inform the
EnSE of the new E2E session request and forwards the intermediate E2E key
(K~Int_E2E~) to the EnSE.
**8\. The EnSE sends a 'E2E Session Accept' to the HSE with an Enterprise
service container** \-- The EnSE replies with the Enterprise service container
to be send to the UE.
**9\. Start new EMSDP session command over the SGi interface** \- The HSE
sends a \"Start new EMSDP session with E2E\" command to the PDN Gateway using
the SGi interface as follows:
\- If the new keys need to be agreed for the BEST service, then the HSE
includes the Key Agreement TLV and the provided Enterprise container in the
\"Start new EMSDP session\" command. The Key Agreement TLV has the RAND and
AUTN of the authentication vector used in the RAND IE and AUTN IE. The
Enterprise container is passed on transparently.
\- A different session ID for the E2E session, i.e. for the user data that
should not be decrypted by the HSE but passed on unchanged to the EnSE. This
session ID is to be used between the UE and the EnSE.
**10\. Start new EMSDP session command over the Air interface / core network
interface** \- The PDN Gateway sends a \"Start new EMSDP session with E2E\"
command to the UE using the core network and air interfaces.
**11\. Calculate UE Keys** \- On successful reception of the \"Start new EMSDP
session with E2E\" command, the UE checks the AKA challenge as detailed in
3GPP TS 33.102 [27] and if it is valid, calculates the AKA response CK and IK.
Unlike the normal AKA challenge/response, the AKA response in not sent to the
HSE as the HSE can determine that this was successful from the MAC value
presented in any following message. The UE calculates the End to Middle keys
as follows:
\- K~E2Menc~ key using the BEST key derivation mechanism, CK, IK, a HSE id and
the key id with the Algorithm id set to \"BEST encryption Key\". The UE
calculates the K~E2Mint~ key using the BEST key derivation mechanism, CK, IK,
a HSE id and the key id with the Algorithm id set to \"BEST integrity Key\".
The UE may choose to calculate one or a set of K~E2Menc~ and K~E2Mint~ key
values depending on its optimal power strategy. Each key id refers to a pair
of K~E2Menc~ and K~E2Mint~ key values. The UE calculates the (K~Int_E2E~) key
using the BEST key derivation mechanism, CK, IK, a HSE id and the key id with
the Algorithm id set to \" BEST end2end Intermediate Key\".
The UE calculates the E2E keys as follows:
The UE calculates the K~E2Eenc~ key using the BEST key E2E derivation
mechanism using the Enterprise key, optional additional information from the
Enterprise container, the BEST end-to-end Intermediate Key (K~Int_E2E~) and
the Algorithm ID set to \"BEST e2e encryption key\" and the UE calculates the
K~E2Eenc~ key using the BEST key E2E derivation mechanism using the Enterprise
key, optional additional information from the Enterprise container, the BEST
end2end Intermediate Key (K~Int_E2E~) and the Algorithm ID set to \"BEST e2e
integrity key (K~E2Eenc~)\".
NOTE: Upon successful \" Manage EMSDP Keys request for E2E only\", the UE only
calculates the E2E keys.
**12\. Calculate EnSE Keys** \- The EnSE calculates the K~E2Eenc~ key using
the BEST key E2E derivation mechanism using the Enterpise key and optional
additional information, the BEST end-to-end Intermediate Key (K~Int_E2E~) and
the Algorithm ID set to \"BEST e2e encryption key\". The EnSE calculates the
K~E2Eenc~ key using the BEST key E2E derivation mechanism using the Enterprise
key and optional additional information from the Enterprise container, the
BEST end2end Intermediate Key (K~Int_E2E~) and the Algorithm ID set to \"BEST
e2e integrity key (K~E2Eenc~)\".
The pair of K~E2Menc~ and K~E2Mint~ key values for the indicated key id are
then used for all further EMSDP messages between the HSE and the UE until
either a new key ID is indicated or until the keys are re-negotiated. The pair
of K~E2Eenc~ and K~E2Eint~ key values for the indicated key id are then used
for all further EMSDP messages between the EnSE and the UE until either a new
key ID is indicated or until the keys are re-negotiated.
##### 6.9.2.7.3 BEST key derivation mechanism
##### 6.9.2.7.3.1 BEST End to middle and intermediate key derivation {#best-
end-to-middle-and-intermediate-key-derivation .H6}
All key derivations (including input parameter encoding) for BEST shall be
performed using the key derivation function (KDF) specified in TS 33.220 [20].
This clause specifies how to construct the input string, S, to the KDF (which
is input together with the relevant key).
When deriving a K~E2Menc~ or K~E2Mint~ from CK, IK, a HSE id, key id and
algorithm id, the following parameters shall be used to form the input S to
the KDF.
\- FC = [TBD],
\- P0 = HSE id,
\- L0 = length of HSE id (i.e. 0x00 0x03),
\- P1 = SQN ⊕ AK
\- L1 = length of SQN ⊕ AK (i.e. 0x00 0x06)
\- P2 = algorithm id
\- L2 = length of algorithm id (i.e. 0x00 0x01)
_The exclusive or of the Sequence Number (SQN) and the Anonymity Key (AK) is
sent to the UE as a part of the Authentication Token (AUTN), see TS 33.102. If
AK is not used, AK shall be treated in accordance with TS 33.102 [27], i.e. as
000...0._
The algorithm id shall be \"BEST encryption key\" for BEST encryption
algorithms and \"BEST integrity Key\" for BEST integrity protection
algorithms. The values 0x04 to 0xf0 are reserved for future use, and the
values 0xf1 to 0xff are reserved for private use.
Table 6.9.2.7.3.1: Algorithm type distinguishers
* * *
Algorithm distinguisher Value BEST encryption key (K~E2Menc~) 0x01 BEST
integrity Key (K~E2Mint~) 0x02 BEST end2end Intermediate Key (K~Int_E2E~) 0x03
* * *
The input key shall be equal to the concatenation CK \|\| IK of CK and IK.
##### 6.9.2.7.3.2 BEST End to end key derivation {#best-end-to-end-key-
derivation .H6}
All key derivations (including input parameter encoding) for BEST shall be
performed using the key derivation function (KDF) specified in TS 33.220 [20].
This clause specifies how to construct the input string, S, to the KDF (which
is input together with the relevant key).
When deriving a K~E2Eenc~ or K~E2Eint~ from K~Int_E2E~, the following is the
following parameters shall be used to form the input S to the KDF. The RAND in
this derivation could be provided by inside the Enterprise container.
\- FC = [TBD],
\- P0 = EnSE id,
\- L0 = length of EnSE id (i.e. 0x00 0x03),
\- P1 = algorithm id
\- L1 = length of algorithm id (i.e. 0x00 0x01)
\- P2 = RAND
\- L2 = length of rand (0 if no rand found in the Enterprise container)
The algorithm id shall be \"BEST e2e encryption key\" for BEST encryption
algorithms and \"BEST e2e integrity Key\" for BEST integrity protection
algorithms. The values 0x03 to 0xf0 are reserved for future use, and the
values 0xf1 to 0xff are reserved for private use.
Table 6.9.2.7.3.2: Algorithm type distinguishers
* * *
Algorithm distinguisher Value BEST e2e encryption key (KE2Eenc) 0x01 BEST e2e
integrity Key (KE2Eint) 0x02
* * *
The input key shall be equal to the concatenation K~Int_E2E~ \|\|
Enterprise_Key of K~Int_E2E~ and Enterprise_Key. When the Enterprise container
specifies no Enterprise key, the Enterprse_Key shall be set to zero (0..0).
Note: The Enterprise_Key provisioning is outside the scope of 3GPP.
#### 6.9.2.8 Starting a BEST service session
##### 6.9.2.8.1 UE initiated BEST session
Figure 6.9.2.8.2.1 UE initiated BEST session startup flow diagram
Once the data session is live (following the BEST service discovery
procedure), if there is no current session running and typically when the UE
has some data to transfer, the UE checks the key status and the BEST container
received from the BEST service discovery procedure and does the following:
\- If the BEST service is not activated in the BEST container then the session
shall not be started.
\- If the UE determines that the key needs to be re-agreed then the UE sends a
\"Start EMSDP session request with E2E\" command through the SGI PtP tunnel
(This is described in detail in clause 6.8.2.8) with the key id set to \"00\",
Session id set to \"00..00\", no encryption and the MAC set to \"00..00\".
\- If the UE determines that the key does not need to be re-agreed then the UE
sends a \"Start EMSDP session request with E2E\" command with the indicated
key and algorithms. The HSE may trigger a key re-agreement if it chooses to do
so.
On reception of the \"Start EMSDP session request with E2E\" command from the
UE via the PDN gateway, the HSE checks the security of the message, the UE\'s
subscription, the BEST service status for the location of the UE and the
validity of the BEST service keys and carries out one of the following:
\- If the HSE determines that the key does not need to be re-agreed then the
HSE sends a \"Start new EMSDP session with E2E\" command with the indicated
key, encrypted and integrity protected as indicated in the service discovery.
This message has one HSE Identity TLV containing the identity of the HSE and a
Key agreement TLV with its length set to 00 and no AUTN IE or RAND IE. This
message may contain an empty enterprise container indicating that the stored
E2E keys can be reused.
\- If the new keys need to be agreed for the BEST service, then the HSE
includes one HSE Identity TLV containing the identity of the HSE and the Key
Agreement TLV in the \"Start new EMSDP session with E2E\" command. The Key
Agreement TLV has the RAND and AUTN of the authentication vector to be used,
in the RAND IE and AUTN IE. Also, it includes whether E2E is allowed, includes
the EnSE ID and provides the Enterprise container if E2E is allowed.
On reception of the \"Start new EMSDP session with E2E\" command in the UE,
the BEST session is considered setup and user plane messages are allowed to be
sent.
If no E2E session is allowed, the HSE can decide to reply with a \"Start new
EMDSP session\" in stead telling the UE that it should commence a session
without E2E. In this case, the UE falls back to the End to Middle scenario.
##### 6.9.2.8.2 HSE initiated BEST session
Figure 6.9.2.8.2.1: Flow diagram of HSE initiated BEST session
Once the data session is live (following the BEST service discovery
procedure), if there is no current session running and typically when the HSE
has some data to transfer, the HSE checks the UE\'s subscription, the BEST
service status for the location of the UE and the validity of the BEST service
keys and carries out one of the following:
\- If the HSE determines that the key does not need to be re-agreed then the
HSE sends a \"Start new EMSDP session with E2E\" command with the indicated
key, encrypted and integrity protected as indicated in the service discovery.
This message has one HSE Identity TLV containing the identity of the HSE and a
Key agreement TLV with its length set to 00 and no AUTN IE or RAND IE. This
message may contain an empty enterprise container indicating that the stored
E2E keys can be reused.
\- If the new keys need to be agreed for the BEST service, then the HSE
includes one HSE Identity TLV containing the identity of the HSE and the Key
Agreement TLV in the \"Start new EMSDP session with E2E\" command. The Key
Agreement TLV has the RAND and AUTN of the authentication vector to be used,
in the RAND IE and AUTN IE. Also, it includes whether E2E is allowed, includes
the EnSE ID and provides the Enterprise container if E2E is allowed.
On reception of the \"Start new EMSDP session with E2E\" command in the UE,
the BEST session is considered setup and user plane messages are allowed to be
sent.
If no E2E session is allowed, the HSE can decide to send a \"Start new EMDSP
session\" in stead telling the UE that it should commence a session without
E2E. In this case, the UE falls back to the End to Middle scenario.
#### 6.9.2.9 Resuming a BEST session following a power cycle at the UE or a
re-attach
If the new session required is not set and the other BEST parameters in the
HSE BEST IE are identical to the previous agreed HSE BEST IE, the UE may
continue a previously started session by using the security details of the
last agreed session. If the control session is resumed, it is implicitly
assumed that the E2E associated with that control session is resumed as well.
#### 6.9.2.10 BEST service session operation
Once a BEST session is setup, boith signalling messages and user plan messages
can be sent and received between the UE and the HSE / EnSE secured by the
agreed security mechanisms via the PDN gateway.
#### 6.9.2.11 Ending a BEST service session
The HSE or the UE can end a BEST session by sending a Terminate EMSDP request
command. This may be due to a request to do so by the enterprise or the user
or due to an error condition.
### 6.9.3 Solution Evaluation
This solution completely describes a BEST service.
Key issue #1 is fully addressed by the described solution as it describes a
secure message service the between the UE and an element in the Enteprise's
domain, the EnSE. The keys are agreed securely by re-using the strong LTE
authentication mechanism. The user data is protected by an integrity mechanism
and optionally protected by encryption. The user data messages are protected
with a counter to prevent reply attacks.
Key issue #2 is fully met by this solution.
Key Issue #3 is fully met by the solution by the ability for the visited
network to indicate restrictions to the HSE which in turn takes this
information into account and also controls the E2E session.
Key Issue #4 is fully met as this solution specifies integrity protection of
all user data and allows the enterprise to control the security used either at
the UE or at the HSE through the EnSE.
## 6.10 Solution #10: \"AKA-based session key generation for application
protocols\"
### 6.10.1 Introduction
The main purpose of the present solution is providing AKA-based session key
generation as an independent module usable by any security protocol at the
application layer.
Solution 10 leaves security context negotiation (apart from the keys) and
protection of transferred data to the application layer protocol.
As an example, it is shown how the present solution will work with pre-shared
key DTLS.
The present solution builds on solution #2. The present solution extends
solution #2 by providing an example of a standardized interface between the
EMSE and the EMKS that enables any application, in the home network or in the
trusted third party domain, to obtain e2m keys from the EMKS. Furthermore, the
requirements on the application layer security protocols that need to be
fulfilled so that the present solution can be used are stated. Furthermore,
compared to solution 2, the text expands on the transport of the UE\'s
application layer identities, the usefulness of key identifiers and two
aspects of key refresh.
The present solution can be used for CIoT (which is why it is included in the
present document). It should be noted, though, that there is no technical
reason why the present solution should be restricted to the CIoT use case; it
can provide e2m security whenever AKA is run in a mobile network.
This solution introduces E2M Security Endpoint (EMSE), an entity that is
authorized to obtain e2m keys from the E2M Key Server (EMKS). An EMSE may
reside in an operator\'s home network, but also in a trusted third party
domain (e.g. a CIoT application provider platform). The EMKS always resides in
an operator\'s home network.
There may be multiple instances of an EMSE, with which a UE engages
simultaneously or sequentially. There is typically only one instance of an
EMKS per HSS.
As usual in 3GPP standardisation, EMSE and EMKS denote functional entities
that could be implemented stand-alone or combined with HSS or GGSN or P-GW.
EMSE and EMKS could also be combined. The advantage of introducing the EMKS is
that the HSS could continue to operate in a stateless fashion.
The following solution description first highlights the features of the
present solution, then describes the interface between EMSE and EMKS, and
finally show how the solution can be applied using the example of pre-shared
key DTLS as the application layer security protocol between UE and EMSE.
### 6.10.2 Solution description
#### 6.10.2.1 Features
The present solution follows the same functional architecture as in solution
#2.
**Requirements on the application layer security protocol** :
The present solution can be used as a key establishment mechanim for an
application layer security protocol if the protocol fulfills the following
requirements:
1) The protocol needs to support use with pre-shared keys.
2) The protocol needs to provide a means to transport the user identity
(including a key identifier) to the EMSE.
NOTE: This identity transport mechanism necessarily is specific to the
particular security protocol.
3) The protocol needs to be able to generate fresh session keys for
consecutive instances of the protocol even when the pre-shared key remains the
same (cf. also clause on key refresh below).
NOTE: All three requirements are satisfied for (D)TLS and IKE.
**Considerations on the user identity in the application layer security
protocol** :
The UE could use the IMSI. But the UE's application layer identity used in the
security protocol between UE and EMSE does not have be identical to the IMSI.
This depends on offline agreements between UE, EMSE, and the mobile network
operator.
If the UE's application layer identity is different from the IMSI, then two
alternatives are available:
1) EMSE translates the UE's application layer identity to an IMSI and sends
IMSI to EMKS.
2) EMSE sends the UE's application layer identity to the EMKS, and the EMKS
translates the UE's application identity to an IMSI.
For case 1, there may be privacy implications if MNO does not want to share
the IMSI with the third party.
For case 2, it may be possible that the third party does not want to share the
UE's application layer identity with the MNO. However, case 2 seems less
critical as, for any solution for BEST, the third party depends on the MNO for
deriving pre-shared key for its communicaton protocol between the UE and EMSE,
which means that the third party has to put a substantial amount of trust in
the MNO anyhow. Case 2 therefore is the preferred solution.
**Key synchronization between the UE and the EMSE:**
**Key synchronization issues could occur due to race condition or
authentication failures. For example,**
a) When HSS pushes key to EMKS the HSS does not know whether network access
authentication will be successful. If not successful, the UE does not have the
latest key pushed to the EMKS. This could happen repeatedly. So, when a UE
establishes an application layer connection with the EMSE the UE could have a
key that is older than the latest one available at the EMKS.
b) Assume an MME requests re-authentication (which is possible even while the
UE is in connected state). The HSS then sends authentication vectors back to
the MME and, at the same time, pushes e2m_int_key to the EMKS. At (roughly)
the same time the UE establishes an application layer connection with the
EMSE, but has not seen the latest Authentication challenge from the MME yet
(race condition). Again, the UE could have a key that is older than the latest
one available at the EMKS.
The present solution avoids key synchronization problem through the following
set of features:
a) It is proposed that the EMKS does not immediately delete a e2m_int_key in
storage when it receives a new e2m_int_key from the HSS for a given UE. The
EMKS keeps a fixed (small) number of instances of e2m_int_key from the past.
This is up to the policy of the EMKS.
b) Identify each instance of e2m_int_key with a unique key identifier. HSS
pushes both the key and its identifier to EMKS during network access
authentication. UE is independently able to generate the key identifier.
Considerations on key identifier is discussed next.
c) UE provides the latest version of the key identifier to EMSE when it
initiates setup of the application layer security prototocol. This is used by
EMSE to query EMKS for the appropriate e2m_int_key.
d) The EMKS obtains the associated e2m_int_key from its store and responds to
EMKS with the generated e2m_key.
Therefore, even if UE had an older version of e2m_int_key, by storing multiple
instances of e2m_int_key in its store, EMKS can obtain the correct e2m_int_key
and continue with the derivation of e2m_key.
**Considerations on the key identifier** :
The present solution proposes the use of a key identifier for the e2m_key.
This key identifier is assumed to be sent along with the UE's application
layer identity from the UE to the EMSE, when application layer security is
established, and further from the EMSE to the EMKS when the EMSE fetches a key
from the EMKS.
The key identifier is useful to synchronize the use of e2m_key at UE and EMSE.
In order to support key synchronization, it is proposed that the EMKS does not
immediately delete a e2m_int_key in storage when it receives a new e2m_int_key
from the HSS for a given UE, but keeps a fixed (small) number of instances of
e2m_int_key from the past. This is up to the policy of the EMKS.
The present solution envisages two alternatives for defining a key identifier:
1) Use a portion of RAND as contained in the authentication vector, e.g. the
32 least significant bits of RAND. With this approach, the HSS would have to
push the relevant portion of RAND from the HSS to the EMKS, together with the
e2m_int_key.
2) Use a short hash of the e2m_int_key. The hash would not serve any
cryptographic purposes. It should just be long enough to achieve an acceptably
small rate of accidental collisions. With this approach, the EMKS would have
to compute hashes on all the e2m_int_key values it has stored for a particular
UE when the EMKS receives a request from the EMSE to fetch a key.
Alternative 1 is the preferred approach.
**Considerations on unique key per EMSE**
The UE could connect to multiple application layer endpoints in the enterprise
network at any given time. To achieve key separation of UE's traffic between
these endpoints, the present solution proposes to generate unique e2m_key for
each endpoint by including an identifier for the endpoint in the key
derivation.
In the present solution, each instance of EMSE is identified by a unique
**endpoint_id or EMSE_Id** that is known to both the UE and EMSE.
When the UE initiates set up of a secure application layer connection with an
instance of the EMSE, the EMSE requests a e2m_key from the EMKS. The EMKS
includes EMSE_Id in the key deriviation to generate unique e2m_key for the
connection. The EMSE could include EMSE_Id in every request for e2m_key or
provide it to EMKS one-time during the initial registration.
The UE would correspondingly generate EMSE specific e2m_key by including
EMSE_Id in its key derivation procedure.
Key derivation rules are discussed in a later clause.
**Transparency for core network nodes:**
The present solution will work transparently to core network. In other words,
the present solution does not require any change to SGSNs, GGSNs, MMEs, S-GWs
and P-GWs.
**Transparency for the USIM:**
As for solution#2, the present solution can re-use existing USIMs, with all
CIoT-specific operations to be done in the ME.
**Key derivation rules:**
This solution reuses key derivation rules from solution #2. They are repeated
here for the sake of readability of the present solution
As for solution#1, the present solution uses a new key pair CK´, IK´for UMTS
PS or GPRS access security between UE and SGSN. This new key pair CK´, IK´ is
generated in the HSS and included in the UMTS AKA authentication vector sent
to the SGSN. The SGSN will not notice the difference to legacy authentication
vectors. For EPS, K~ASME~ can be re-used as defined today.
In the present solution, the key used between UE and EMSE is called
\"e2m_key\".
The e2m key is derived in two steps:
(1) Whenever an Authentication Information Request from the SGSN or the MME
arrives at the HSS, the HSS checks the subscription profile for the need to
derive an e2m_int_key. The HSS then generates authentication vectors and sends
them back to the SGSN or MME. If there is a need to derive an e2m_int_key a
new key pair CK´, IK´is included in the authentication vector for UMTS PS or
GPRS. Furthermore, the HSS derives e2m_int_key from CK, IK and a string
pointing to the purpose of the key use, namely e2m security for CIoT, where
the derivation of e2m_int_key has the form
e2m_int_key = KDF (CK\|\|IK, string)
and the string could be set to e.g. \"e2m_ CIoT\". The HSS the pushes the
e2m_int_key to the EMKS.
NOTE: It is expected that the interface between HSS and EMKS will be based on
DIAMETER, details will be defined in stage 3.
(2) The EMKS derives e2m_key from e2m_int_key upon request from an EMSE. As
there may be multiple instances of EMSE it becomes necessary to include an
identifier of the EMSE in the key derivation in order to achieve key
separation between EMSEs. The following is the key derivation rule:
e2m_key = KDF (e2m_int_key, EMSE_Id, string)
> Editor\'s Note: it is ffs whether the additional input \'string\' is needed
> in the derivation of e2m_key. It may be appropriate to allocate FC values
> for the purpose of the two key derivations in steps 1) and 2) according to
> TS 33.220 [20], B.2.2.
**Key refresh** :
There are two aspects to consider:
1) The application layer security protocol requires a fresh session key.
This is the case e.g. when the application layer session is torn down and re-
established some time later. It could be that the e2m_key, which is used as
pre-shared key, has not changed in the meantime. The present solution does not
envisage a means for the application layer to trigger the generation of a new
e2m_key. Therefore, it is stated further above as a requirement that
application layer security protocol needs to be able to generate fresh session
keys for consecutive instances of the protocol even when the pre-shared key
remains the same.
2) A new e2m_int_key becomes available due to a re-authentication at the
network access layer.
In general, it is not the case that an application layer security protocol can
change the pre-shared key during an ongoing session. This means that a new
pre-shared key derived from the new e2m_int_key can only be established when
the session has been terminated, for reasons determined within the
application, and a new session is set up. Then the EMSE will again contact the
EMKS and obtain, in this way, a new e2m_key.
#### 6.10.2.2 Interface between EMKS and EMSE
##### 6.10.2.2.1 Introduction
> Editor\'s Note: The material in this clause describes a candidate interface
> bewteen EMKS and EMSE. Other examples for this interface should be studied
> in a normative phase, e.g. the Tsp interface could be an object of study.
The interface between EMKS and EMSE is used by the EMSE for fetching UE-
related key to be used in the application layer security protocol between UE
and EMSE.
The interface should be standardized to achieve maximum interoperability.
In the following, we describe the example of a RESTful HTTP interface between
EMKS and EMSE.
It is described as follows:
\- TCP provides communication service at the transport layer
\- TLS provides security to the communication
\- HTTP based transport of XML data
\- XML documents used to embed specific datastructures, such as keys etc.
> Figure 6.10.2.2.1-1 illustrates the protocol stack of this reference point.
{width="5.272222222222222in" height="2.4923611111111112in"}
Figure: 6.10.2.2.1-1 RESTful HTTPS between EMKS and EMSE
EMKS and EMSE act as both HTTP client and server. Thus, there is a TCP
connection for each direction. This permits bidirectional communication
between EMKS and EMSE.
RESTful HTTP is used at the application delivery layer. The content type of
the RESTful HTTP is XML.
The unsecured HTTP protocol shall be combined with TLS, as HTTPS, to provide
confidentiality and integrity protection. Mutual authentication shall be
enabled in TLS for authenticating and allowing only an authorized third party
EMSE to access the EMKS. The profile for TLS implementation and usage shall
follow the provisions given in 3GPP TS 33.310 [45], Annex E.
##### 6.10.2.2.2 Procedures over the RESTful HTTP reference point
Following procedures are supported over the RESTful HTTP reference point:
\- Initial registration by EMSE
\- Obtaining UE specific e2m_key from EMKS
\- Deregistration by EMSE
\- Subscription to Notification by EMKS
\- Notification by EMSE
> Editor's Note: Subscription by EMSE to a particular event, and Notification
> by EMKS is ffs
##### 6.10.2.2.2.1 Initial registration by EMSE {#initial-registration-by-emse
.H6}
The EMSE registers with EMKS by sending an HTTP POST message to the EMKS
including its identifier (EMSE_Id). The EMKS establishes a session context for
this EMSE and returns session id in HTTP 201 CREATED.
##### 6.10.2.2.2.2 Obtaining UE specific e2m key from the EMKS {#obtaining-ue-
specific-e2m-key-from-the-emks .H6}
The EMSE obtains UE specific e2m key from the EMKS by sending an HTTP GET
message including an identity of the UE and a key identifier received from the
UE. This message is embedded in the following example information flow using
DTLS-PSK.
##### 6.10.2.2.2.3 Deregistration by EMSE {#deregistration-by-emse .H6}
When the session needs to be terminated, EMSE may send an HTTP DELETE message
including the session ID as the URL address to the EMKS.
#### 6.10.2.3 Example use of solution 10: information flow using pre-shared
key DTLS
In this subclause we show how the present solution can be applied using the
example of pre-shared key DTLS as the application layer security protocol
between UE and EMSE.
Other candidate application layer security protocols include IKEv2 (with pre-
shared keys) combined with ESP.
Prerequisite:
a) HSS has processed the Authentication Information Request from the SGSN or
MME, and pushed the intermediate key, e2m_int_key and the associated key
identifier to the EMKS.\ Network access AKA run is completed and UE is in
possession of the necessary inputs for deriving the e2m_int_key, together with
the related key identifier.
b) UE is ready to initiate setup of the chosen application layer security
protocol with a particular EMSE. UE derives e2m_key using the EMSE_Id.
c) EMSE has registered and established a session with the EMKS. The interface
between EMSE and EMKS is integrity- and confidentiality-protected by TLS as
shown in the protocol stack in Figure 6.10.2.2.1-1.
Figure: 6.10.2.3 DTLS-PSK session between UE and EMSE based on e2m_key
In the following sequence (D)TLS-PSK is used as an example:
1) UE initiates establishment of a DTLS session by sending TLS message
\"ClientHello\". This may, for example, contain COAP defined mandatory-to-
implement cipher suite TLS_PSK_WITH_AES_128_CCM_8.
2) EMSE responds to the UE with the \"ServerHello\" and \"ServerHelloDone\"
messages.
3) Using e2m_key (from prerequisite step b above) as the psk, UE generates TLS
session keys.
4) UE sends \"ClientKeyExchange\", \"ChangeCipherSpec\" and \"Finished\". UE's
application layer identity and key identifier are sent in the psk_identity
value in the \"ClientKeyExchange\" message.
5) EMSE initiates HTTP GET to obtain the latest UE specific e2m_key from EMKS.
EMSE sends UE's identity value and key identifier in this request message to
EMKS.
6) The EMKS selects the right e2m_int_key with the help of the key identifier
and computes e2m_key using the EMSE_Id as input.
7) The EMKS then returns e2m_key in the HTTP 201 response to EMSE.
8) EMSE uses the received e2m_key as pre-shared secret as specified for DTLS.
9-11) EMSE continues with rest of the DTLS session setup flow.
> As a result, a DTLS security session is setup between the UE and EMSE.
### 6.10.3 Solution evaluation
Solution #10 builds upon Solution #2. Therefore all aspects of solution #2, as
indicated in clause 6.2.3, apply to solution #10 as well. In particular,
solution#10 is transparent to core network nodes, apart from the HSS; and does
not require any changes to SGSN, GGSN, S-GW, or P-GW. In addition, solution
#10 provides a standardized interface for the application layer security
protocol in 3^rd^ party networks, to fetch keys and use it as pre-shared
secret. This enables any application layer protocol to use MNO generated AKA
key to generate protocol-specific session keys between the UE and the
application layer node (EMSE). Solution #10 provides an essential module in a
modular approach to BEST.
## 6.11 Solution #11: A method for IoT service layer security bootstrapping
solution
### 6.11.1 Introduction
This solution provides a mechanism for deriving session keys between the IoT
device and the application server with the following advantages.
Note: This solution is not compatible with GPRS.
1) Key Issue No. 1: It provides integrity protection and confidentiality keys
to all communications between the IoT device and the application server which
can be used by a transport protocol to secure communications. Confidentiality
is invoked as per the legal regulatory of the serving network.
2) Key Issue No. 2: Addresses the efficient user data protection challenges by
allowing keys of at least 128 bits.
Address main performance objective of the study:
3) Optimization of transmitted flows to reduce battery consumption by
eliminating the need for another AKA procedure, i.e., GBA-AKA, and thus saves
at least four message flows of the procedure, then reduces the power
consumption at the IoT device.
4) Use existing 3GPP architecture and network entities/nodes with minimum
changes to existing interfaces to accomplish the objectives of this study.
### 6.11.2 Solution description
#### 6.11.2.1 Proposed architecture
{width="5.135416666666667in" height="1.8541666666666667in"}
Figure 6.11.2.1.1 Proposed Architecture for Solution #11
The key network element is:
\- Service Capability Exposure Function (SCEF): This is the key entity within
the 3GPP architecture for service capability exposure that provides a means to
securely expose the services and capabilities provided by 3GPP network
interfaces. It is expected that signalling data relevant to the IoT
application boostrapping service will terminate at this node. As defined in
TS23.682, SCEF has interfaces to the MME/SGSN(T6a/T6b), the HSS(S6t), the
application server. The HSE functionality could reside as needed with SCEF.
> The functionality of relevant interfaces used by this solution are:
\- T6a: An interface between the SCEF and the MME to allow the SCEF to obtain
the UE application layer session key (Ks) based on the UE session Identifier
(GUTI).
Editor's Note: Whether using GUTI which doesn't have one-to-one correspondence
with K~ASME~ introduces any security threat is for FFS.
\- S6a: Utilize this existing interface between the HSS and MME to allow HSS
to provide a per-UE application layer session key to MME (Ks); In case of HSS
providing multiple AVs, HSS provide one session key per AV.
\- Ua: An interface between the UE and the application server that transfers
user plane data
#### 6.11.2.2 Security boostrapping and key refreshing
##### 6.11.2.2.1 Overview
This clause describes how to derive session keys between the UE and the
application server utilizing existing 3GPP interfaces and the fundamental 3GPP
SCEF functionality which is designed to expose 3GPP services capabilities to
trusted third parties, e.g., the application servers. This solution provides
an option which allows SCEF to pull UE application layer session keys from the
MME serving the specific UE and then deliver the session key as requested to
the application server.In this option, HSS derives a per-UE per-AV application
layer master session key (Ks) and deliver the session key to the MME over
interface S6a in User Authentication Info Respone message. This is a minimum
impact on the HSS.
##### 6.11.2.2.2 Key agreement and boostrapping with HSS deriving master
session key
New IoT application level master session key is agreed upon when the UE
perform 3GPP-AKA procedure while accessing the network, i.e. at the phase when
the UE and the network mutually authenticate each other. This proposal
requires changes, as described in this document, at UE, MME and HSS while
using 3GPP-AKA mechanism as detailed in 3GPP TS 33.102 [27]and 3GPP TS 33.401
[28].
Figure 6.11.2.2.2.1 shows the key agreement and boostrapping process.
{width="6.689583333333333in" height="6.977083333333334in"}
Figure 6.11.2.2.2.1: 3GPP-AKA Key Agreement and IoT Application Security
Bootstrapping Process
The key steps are as follows:
1) MME starts access authentication request and requires the identity of the
UE.
2) The UE responses MME with IMSI to identify himself.
3) The MME sends authentication data request to HSS to ask for materials to
authenticate the UE mutually.
4) HSS receives the request and searches the root key shared with UE using
IMSI. HSS generates one or more AV, RAND, XRES, AUTH, CK, IK, K~ASME~ as in
TS33.401. In addition, HSS will generate Ks based on CK, IK for the
application service. The key Ks is generated as Ks=KDF(CK\|\|IK, \"End-to-
End_IOT\").
5) HSS responds to MME with the Authentication Vector. Authentication Vector
(AV) consists of AV=(RAND, AUTH, XRES, K~ASME~) as defined in TS33.401. HSS
adds the Application layer master session key (Ks) to map to one-to-ome with
the AV.
6) Note: If HSS sends multiple AVs to MME at a time, then HSS includes
multiple Ks.
7) Note: It is recommended to distribute only one AV at a time as the
frequency of AKA runs is very low in the IOT scenario.
8) MME sends user authentication request to UE, this request consists of RAND
and AUTH as defined in 3GPP TS 33.102 [27] / 3GPP TS 33.401 [28].
9) UE generates keys and check AUTH to authenticate the network, and computes
response message RES. All the procedures are defined as in 3GPP TS 33.102 [27]
/ 3GPP TS 33.401 [28].
10) UE sends the authentication response message RES to MME as defined in 3GPP
TS 33.102 [27] / 3GPP TS 33.401 [28].
11) MME checks RES by comparing RES and XRES as defined in 3GPP TS 33.102 [27]
/ 3GPP TS 33.401 [28].
12) MME sends Authentication Successful to the UE together with GUTI generated
by MME. MME updates the UE context with the respective used AV and Ks.
13) UE generates the master key Ks and then generates key Ks_AS for
application service. Ks_AS is generated in the form Ks_AS = KDF(Ks, AS_ID),
where AS_ID is the identity of the application server.
14) UE sends Application Request to the application server over the Ua
interface. This message contains the GUTI received from MME in step 10, and
msg. The content of msg depends on specific protocol.
15) Once receiving the Application Request, the application server sends Key
Requset to SCEF with GUTI, AS_ID.
16) SCEF receives GUTI, SCEF uses the GUTI and other 3GPP operator services,
e.g., network DNS, to identify the serving MME.
17) SCEF send a Mobile Data Request to the MME with the GUTI included.
Note: In case SCEF is not equipped to derive KS-AS, SCEF include the AS_ID in
the Mobile Data Request to allow the MME to derive the Ks_AS.
18) The MME search its database for the UE context of the received GUTI. MME
responds to SCEF with Mobile Data Answer with the GUTI and the Ks included.
Note: If the MME receives the GUTI and the AS_ID, MME derives the KS-AS key as
KDF (Ks, AS-ID) and return to SCEF in the Mobile Data Answer.
19) The SCEF responds to the application server with the application key
Ks_AS.
20) The application server returns to the UE with Application Response.
##### 6.11.2.2.2.1 Key Generation in Application Layer. {#key-generation-in-
application-layer. .H6}
This proposal presents two possible solutions for the UE and Application to
generate session keys. All the session key is based on Ks_AS. In order to
ensure the freshness of the session key, the UE will generate a random number
as the input material of the session key.
**Session Key Generation without Certificate** : The UE generates a random
number RAND_AS. In addition, the UE computes encryption key Ks_AS_enc and
integrity key Ks_AS_int, respectively. The two keys are generated in the way
Ks_AS_enc = KDF(Ks_AS, \"enc\") and Ks_AS_int = KDF(Ks_AS, \"int\"). The UE
computes the session key as K_app = KDF(Ks_AS_enc, RAND_AS), then to protect
the integrity of GUTI and RAND_AS, UE generates the message authentication
code t = MAC~K_AS_int~(GUTI, RAND_AS). The UE puts RAND_AS and t into msg in
the Application Request. Once received Ks_AS, the application server generates
Ks_AS_enc and Ks_AS_int and then verify the message authentication code t. If
it is correct, then the application server computes the session key K_app.
**Session Key Generation with Certificate** : In this solution, the UE is
configured with the certificate of the application server. This certificate
contains the public key PK_AS of the application server. The UE generates a
random number RAND_AS. In addition, the UE computes encryption key Ks_AS_enc
and integrity key Ks_AS_int as the above solution. The session key K_app is
also generated in the UE as K_app = KDF(Ks_AS_enc, RAND_AS). To protect GUTI
and RAND_AS, the public key PK_AS is used to encrypt RAND_AS as C =
Enc~PK_AS~(RAND_AS) and the integrity is protected as t = MAC~Ks_AS_int~(GUTI,
C). The UE puts C and t into msg in the Application Request (RAND_AS is not
included in cleartext). Once received Ks_AS, the application server generates
Ks_AS_enc and Ks_AS_int and then verify the message authentication code t. If
it is correct, the application server uses the private key to decrypt C and
get RAND_AS, then computes the session key K_app.
These two solutions ensure the freshness of the session key, this enables that
two different sessions between the same UE and application server not to be
the same. In addition, the certificate solution provides end-to-end security
between the UE and the application server where the wireless operator has no
access to the encrypted traffic.
##### 6.11.2.2.3 Key refreshing
In this proposal, the key refreshing could be triggle by both the UE and
application server.
**Initiated by UE** : The procedure is described in Figure 6.11.2.2.3.1
{width="5.135416666666667in" height="2.2604166666666665in"}
Figure 6.11.2.2.3.1: Key Refreshing Initiated by the UE
The steps are as follows:
1) UE initiates key refreshing by sending a Refresh Request to the application
server. This message will contain the GUTI.
2) The application server forwards the Refresh Request to the SCEF.
3) A Bootstrapping Renegotiation Request is sent to MME by SCEF.
4) MME then will re-authenticate the UE by initiating a 3GPP-AKA procedure.
**Initiated by application server** : The procedure is decribed in Figure
6.11.2.2.3.2
{width="5.135416666666667in" height="2.2604166666666665in"}
Figure 6.11.2.2.3.2: Key Refreshing Initiated by the Application Server
The steps are similar to the case that the UE intiating procedure except that
the application server start the Refresh Request.
### 6.11.3 Solution evaluation
This solution creates an end-to-end key shared between UE, IoT Device, and the
application server utilizing existing 3GPP architecture and interfaces, that
can be used to provide confidentiality and integrity. This solution eliminates
the need for GBA-AKA and optimizes the power usage at the IoT device. The
solution addresses key agreement between UE and the Application Server.
## 6.12 Solution #12: A method for IoT service layer security bootstrapping
solution
### 6.12.1 Introduction
This document proposes an IoT service layer security bootstrapping solution as
described below. This solution provides a mechanism for deriving session keys
between the IoT device and the application server with the following
advantages.
Address all Key Issues:
1) Key Issue No. 1: It provides integrity protection and confidentiality to
the IoT device and the application server which can be used by a transport
protocol to secure communications.. Confidentiality is invoked as per the
legal regulatory of the serving network.
2) Key Issue No. 2: Address the efficient user data protection challenges by
allowing keys of at least 128 bits.
Address main performance objective of the study:
3) Optimization of transmitted flows to reduce battery consumption by
eliminating the need for another AKA procedure of GBA (see 3GPP TS
33.220[20]), i.e., GBA-AKA, and thus saves at least four message flows of the
procedure, then reduces the power consumption at the IoT device.
4) Use existing 3GPP architecture and network entities/nodes with minimum
changes to existing interfaces to accomplish the objectives of this technical
report.
### 6.12.2 Solution description
#### 6.12.2.1 Proposed architecture
{width="5.135416666666667in" height="1.8541666666666667in"}
Figure 6.12.2.1.1 Proposed Architecture for Solution #10
The key network element is:
\- Service Capability Exposure Function (SCEF): This is the key entity within
the 3GPP architecture for service capability exposure that provides a means to
securely expose the services and capabilities provided by 3GPP network
interfaces. It expected that the some signalling data relevant to the
boostrapping service will terminate at this node. As defined in 3GPP TS
23.682[46], SCEF has interfaces to the MME/SGSN(T6a/T6b), the HSS(S6t), the
application server. The HSE functionality could reside as needed with SCEF.
The functionality of relevant interfaces used in this solution are:
\- T6a: An interface between the SCEF and the MME to allow the SCEF obtain the
authentication result of the UE and return feedbacks to the MME.
\- S6t: An interface between the SCEF and the HSS that allows the SCEF to
obtain the session key for application and subscription and UE related
information.
\- S6a: Utilize this existing interface between the HSS and MME to allow HSS
to provide an indication to MME that this UE supports current IoT security
bootstapping and MME needs to push the network authentication result together
with other subscriber information to SCEF.
\- Ua: An interface between the UE and the application server that transfers
user plane data.
#### 6.12.2.2 Security boostrapping and key refreshing
##### 6.12.2.2.1 Overview
This clause describes how to derive session keys between the UE and the
application server utilizing existing 3GPP interfaces and the fundamental 3GPP
SCEF functionality which is designed to expose 3GPP services capabilities to
trusted third parties, e.g., the application servers. This solution provides
an option which allows HSS pushes the application layer key to SCEF serving
the specific UE over the S6t interface.
##### 6.12.2.2.2 Key agreement and boostrapping
New IoT application level master session key is agreed upon when the UE
perform 3GPP-AKA procedure while accessing the network, i.e. at the phase when
the UE and the network mutually authenticate each other. This proposal
requires changes, as described in this document, at UE, MME and HSS while
using 3GPP-AKA mechanism as detailed in 3GPP TS 33.102 [27] and 3GPP TS 33.401
[28].
Figure 6.12.2.2.2.1 shows the key agreement and boostrapping process:
{width="6.689583333333333in" height="6.977083333333334in"}
Figure 6.12.2.2.2.1: Key Agreement and Bootstrapping Process
The key steps are as follows:
1) MME starts access authentication request and requires the identity of the
UE.
2) The UE responses MME with IMSI to identify himself.
3) The MME sends authentication data request to HSS to ask for materials to
authenticate the UE mutually.
4) HSS receives the request and searches the root key shared with UE using
IMSI. HSS generates one or more AV, RAND, XRES, AUTH, CK, IK, K~ASME~ as in
TS33.401. In addition, HSS will generate Ks based on CK, IK for the
application service. The key Ks is generated as Ks=KDF(CK\|\|IK, \"End-to-
End_IOT\").
5) HSS responds to MME with the Authentication Vector. Authentication Vector
(AV) consists of AV=(RAND, AUTH, XRES, KASME) as defined in 3GPP TS 33.401
[28]. HSS adds an indication to MME to indicate that MME needs to push the
network authentication result and other subscribe information to SCEF.
5.1) HSS pushes to SCEF the KeySet which is later used to be delivered to the
application server. The KeySet contains the RAND from AV, IMSI and the key Ks.
This message is over S6t interface.
Note1 : If HSS sends multiple AVs to MME at a time, then HSS will pushes
multiple RAND, Ks to SCEF (still with the same IMSI). SCEF will store all
these information.
Note2: It is recommended to distribute only one AV at a time as the frequency
of AKA runs is very low in the IOT scenario.
6) MME sends user authentication request to UE, this request consists of RAND
and AUTH as defined in 3GPP TS 33.102 [27] and 3GPP TS 33.401 [28].
7) UE generates keys and check AUTH to authenticate the network, and computes
response message RES. All the procedures are defined as in 3GPP TS 33.102 [27]
and 3GPP TS 33.401 [28].
8) UE sends the authentication response message RES to MME as defined in 3GPP
TS 33.102 [27] and 3GPP TS 33.401 [28].
9) MME checks RES by comparing RES and XRES as defined in 3GPP TS 33.102 [27]
and 3GPP TS 33.401 [28].
10) MME sends Authentication Successful to the UE together with GUTI generated
by MME.
Editor's Note: Whether using GUTI which doesn't have one-to-one correspondence
with K~ASME~ introduces any security threat is for FFS.
10.1 MME pushes the Notification message over the T6a interface to SCEF. The
Notification message contains Authentication Result, RAND (from AV), IMSI and
GUTI.
11) UE generates the master key Ks and then generates key Ks_AS for
application service. Ks_AS is generated in the form Ks_AS = KDF(Ks, AS_ID),
where AS_ID is the identity of the application server.
12) UE sends Application Request to the application server over the Ua
interface. This message contains the GUTI received from MME in step 10, and
msg. The content of msg depends on specific protocol.
13) Once receiving the Application Request, the application server sends Key
Requset to SCEF with GUTI, AS_ID.
14) SCEF receives GUTI, searches the database and finds out the state of the
Authentication Result according to this GUTI, If the state is Successful, then
SCEF will find the application key Ks with RAND and IMSI. Then, SCEF generate
application key Ks_AS based on Ks and AS_ID.
15) The SCEF responds to the application server with the application key
Ks_AS.
16) The application server returns to the UE with Application Response.
##### 6.12.2.2.2.1 Key generation in application layer. {#key-generation-in-
application-layer.-1 .H6}
This proposal presents two options for the UE and Application to generate
session keys depending on whether certificate is used or not. All the session
keys is based on Ks_AS. In order to ensure the freshness of the session key,
the UE will generate a random number as the input material of the session key.
**Session Key Generation without Certificate** : The UE generates a random
number RAND_AS. In addition, the UE computes encryption key Ks_AS_enc and
integrity key Ks_AS_int, respectively. The two keys are generated in the way
Ks_AS_enc = KDF(Ks_AS, \"enc\") and Ks_AS_int = KDF(Ks_AS, \"int\"). The UE
computes the session key as K_app = KDF(Ks_AS_enc, RAND_AS), then to protect
the integrity of GUTI and RAND_AS, UE generates the message authentication
code t = MAC~Ks_AS_int~(GUTI, RAND_AS). The UE puts RAND_AS and t into msg in
the Application Request. Once received Ks_AS, the application server generates
Ks_AS_enc and Ks_AS_int and then verify the message authentication code t. If
it is correct, then the application server computes the session key K_app.
**Session Key Generation with Certificate** : In this solution, the UE is
configured with the certificate of the application server. This certificate
contains the public key PK_AS of the application server. The UE generates a
random number RAND_AS. In addition, the UE computes encryption key Ks_AS_enc
and integrity key Ks_AS_int as the above solution. The session key K_app is
also generated in the UE as K_app = KDF(Ks_AS_enc, RAND_AS). To protect GUTI
and RAND_AS, the public key PK_AS is used to encrypt RAND_AS as C =
Enc~PK_AS~(RAND_AS) and the integrity is protected as t = MAC~Ks_AS_int~(GUTI,
C). The UE puts C and t into msg in the Application Request (RAND_AS is not
included in cleartext). Once received Ks_AS, the application server generates
Ks_AS_enc and Ks_AS_int and then verify the message authentication code t. If
it is correct, the application server uses the private key to decrypt C and
get RAND_AS, then computes the session key K_app.
These two options ensure the freshness of the session key, this enables that
two different sessions between the same UE and application server not to be
the same. In addition, the certificate solution provides end-to-end security
between the UE and the application server where the wireless operator has no
access to the encrypted traffic.
##### 6.12.2.2.3 Key refreshing
In this proposal, the key refreshing could be triggle by both the UE and
application server.
**Initiated by UE** : The procedure is described in Figure 6.12.2.2.3.1
{width="5.135416666666667in" height="2.2604166666666665in"}
Figure 6.12.2.2.3.1: Key Refreshing Initiated by the UE
The steps are as follows:
1) UE initiates key refreshing by sending a Refresh Request to the application
server. This message will contain the GUTI.
2) The application server forwards the Refresh Request to the SCEF.
3) A Bootstrapping Renegotiation Request is sent to MME by SCEF.
4) MME then will re-authenticate the UE by initiating a 3GPP-AKA procedure.
**Initiated by application server** : The procedure is decribed in Figure
6.12.2.2.3.2
{width="5.135416666666667in" height="2.2604166666666665in"}
Figure 6.12.2.2.3.2: Key Refreshing Initiated by the Application Server
The steps are similar to the case that the UE intiating procedure except that
the application server start the Refresh Request.
### 6.12.3 Solution evaluation
This solution creates an end-to-end key shared between UE, IoT Device, and the
application server utilizing existing 3GPP architecture and interfaces, that
can be used to provide confidentiality and integrity. This solution eliminates
the need for GBA-AKA and optimizes the power usage at the IoT device. The
solution addresses key agreement between UE and the Application Server.
# 7 Conclusions
## 7.1 Issues identified
The present document identifies that:
\- Using current traditional end to end security methods such as IPsec and
DLTS may have significant power and network traffic capacity overheads when
used by battery efficient devices to transfer small data packets over a 3GPP
system.
\- For low power MTC devices, end to middle security that reuses 3GPP security
procedures and keys is likely to be significantly more efficient than end to
end security. The current 3GPP system can only secure information between the
UE and the SGSN of the visited network and does not extend to the home GGSN.
\- Any security mechanism specified by 3GPP for end to middle security needs
to take into account local and home regulations on encryption of data and
lawful intercept.
The report identifies the following key issues relating to battery efficient
machine type communication:
\- N-PDU data tampering and eavesdropping -- It recommends that an integrity
mechanism be provided to prevent tampering of N-PDU data and a confidentiality
mechanism (where allowed) to prevent eavesdropping on the data content.
\- Efficient user data protection -- It recommends that the minimum key size
for confidentiality should be 128 bits and where a HMAC is used this should
not be less than 64bits.
\- Visited PLMN specific needs -- It recommends that any proposed solution
should have mechanisms to disable confidentiality protection where local laws
in the visited country require this. Also mechanisms need to exist for Lawful
intercept of data where applicable.
\- End to End security -- The enterprise should have control over the
frequency of derivation of the key material, the key material exchanges should
be minimised and that higher level key material should not leave the 3GPP or
operator domain.
## 7.2 Solution evaluation summary
The report proposes the following solutions:
\- Solution #1 \"UE to HPLMN security based on UMTS/EPS AKA enhancements\".
This solution uses enhancements to the 3GPP AKA to generate key material used
by the end to end or end to middle security mechanisms. The solution is
intended for use over the cellular IoT RAT where the middle endpoint is a HSE.
The solution proposes a mechanism that protects the key materials from being
exposed to the visited network but does not cover the mechanisms that use
these keys to deliver integrity protection and confidentiality protection.
Variants of this solution are proposed that differ in how and when the key
material is delivered to the non-UE end of the communication as follows:
\- \"Variant A\" where the HSS/HLR pushes key materials to the relevant HSE
when an AKA generation occurs that includes end to middle key generation. In
this solution the HSE needs to store the generated keys until they are used.
\- \"Variant B\" where the HSS/HLR pushes key materials to the relevant HSE
when a PDP context activation occurs following a successful AKA exchange with
the UE that includes end to middle key generation. In this solution the
HSS/HLR needs to store the generated keys until they are used.
\- \"Variant C\" where the HSE pulls the key materials from the HSS/HLR when
an PDP context activation occurs following a successful AKA exchange with the
UE that includes end to middle key generation. In this solution the HSS/HLR
needs to store the generated keys until they are used.
\- \"Variant D\" where the HSS/HLR pushes key materials to a new standardised
key store entity called an End to Middle Key Server (EMKS) when an AKA
generation occurs that includes end to middle key generation. The HSE pulls
the key materials from the EMKS when a PDP context activation occurs following
a successful AKA exchange with the UE that includes end to middle key
generation. In this solution the EMKS needs to store the generated keys until
they are used.
\- \"Variant E\" is a modification of variants a, b, c and d where the USIM
only performs an unmodified AKA procedure and the creation of the local end to
middle key values is calculated on the ME.
\- Solution #2 \"End to middle security based on AKA with an EMSE\". This
solution defines a new middle endpoint called an E2M Security Endpoint (EMSE).
This solution uses the EMKS defined in solution #1d to store the end to middle
keysets and the processes in solution #1e where the UE end to middle keys are
generated in the ME so that no modifications to the current USIM is required.
The solution proposes a mechanism that protects the key materials from being
exposed to the visited network but does not cover the mechanisms that use
these keys to deliver integrity protection and confidentiality protection.
\- Solution #3 \"Independent VPLMN and e2m security associations\". This
solution proposes a separate specific AKA run to generate the end to middle
key material when they are needed so that there is no inter-relationship or
related synchronisation issues with the AKA run for network access. The
solution does not require modification of the HSS/HLR or the USIM but does not
cover the mechanisms that use these keys to deliver integrity protection and
confidentiality protection and uses more power/network resources to deliver as
it requires 2 AKA runs. Although this solution requires two AKA procedures
initially (Solution 1 and 2 only require one AKA procedure), further AKA runs
only depend on the use and timing of the user plane data and not on any aspect
of a 3GPP RAT.
\- Solution #4 \"Security Policies\". This solution describes the sharing of
security policies between the HPLMN and Visited PLMN that relate to the
frequency and type of security features supported so that the visited network
can identify CIoT devices and adjust their security model appropriately. This
solution does not address the agreement on key materials or the mechanisms
that use these keys to deliver integrity protection and confidentiality
protection.
\- Solution #5 \"End to End security solution\". This solution introduces a
new element, the End to End Security Endpoint (EESE) that allows an authorised
third party to fetch end to end keysets that have been agreed using one of the
methods detailed in solutions 1, 2 or 3. It also presents a key aging and re-
agreement mechanism using a timer. It does not however detail the security
mechanisms that these keys are used with.
\- Solution #6 \"Bearer protection\". This solution introduces IPsec ESP for
authentication, integrity and confidentiality protection of the user-plane
between the UE and the HSE using the keys derived by the UE and HSS and
distributed to the HSE according to solutions #1 or #2. For crypto algorithms
the solution points the 33.210. The solution does not stipulate on tunnel vs.
transport mode ESP and on compression methods. Furthermore the solution does
not define the derivation or negotiation of the IPsec ESP Security Association
parameters.
\- Solution #7 \"End to End\". The solution extends solutions 1 and 2 to End
to End security. However this solution does not currently deal with mechanisms
for LI and optional data cyphering.
\- Solution #8 \"Complete end to middle solution\". This solution describes a
full BEST service including service discovery, session management, secure
operation and error management. All of the key issues are addressed fully in
this solution.- Solution #9 \"Complete end to emd solution\". This solution
describes a full BEST service including service discovery, session management,
secure operation and error management. All of the key issues are addressed
fully in this solution.
\- Solution #9 \" Complete end to emd solution\". This solution describes a
full BEST service including service discovery, session management, secure
operation and error management. All of the key issues are addressed fully in
this solution.
\- Solution #10 \"AKA-based session key generation for application
protocols\": This solution provides a mechanism to use AKA-based session key
generation as an independent module usable by any security protocol at the
application layer. It leaves security context negotiation (apart from the
keys) and protection of transferred data to the application layer protocol.
The solution proposes a mechanism that protects the key materials from being
exposed to the visited network but does not cover the mechanisms that use
these keys to deliver integrity protection and confidentiality protection.
.- Solution #11 \"Service Layer Bootstrapping Solution\". This solution
describes an IoT service layer security bootstrapping that allows key network
element SCEF to pull application session keys from MME for the application
layer. The solution addresses key agreement between UE and the Application
Server.
.- Solution #12 \"Service Layer Bootstrapping Solution\". This solution
describes an IoT service layer security bootstrapping that allows HSS to push
application key to SCEF for the application layer. The solution addresses key
agreement between UE and the Application Server.
The solutions are further summarised as follows:
Table 7.2-1: Summary overview of the proposed solutions
+---------+---------+---------+---------+---------+---------+---------+ | **Sol |** Endp | **Ta |** Ef | ** | **C |** Nodes | | ution**| oints** | mpering | ficient | Visited | onfiden | pote | | | | and | device | PLMN | tiality | ntially | | | | eavesd | power | needs | and | eff | | | | ropping | and | addr | in | ected**| | | | prote | network | essed** | tegrity | | | | | ction**| use** | | me | | | | | | | | chanism | | | | | | | | spec | | | | | | | | ified** | | +---------+---------+---------+---------+---------+---------+---------+ | 1A | E2M | Yes | ef | Yes | No | H | | | | | ficient | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 1B | E2M | Yes | ef | Yes | No | H | | | | | ficient | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 1C | E2M | Yes | ef | Yes | No | H | | | | | ficient | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 1D | E2M | Yes | ef | Yes | No | EMKS, | | | | | ficient | | | H | | | | | | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 1E | E2M | Yes | ef | Yes | No | EMKS, | | | | | ficient | | | H | | | | | | | | SS/HLR, | | | | | | | | and ME | +---------+---------+---------+---------+---------+---------+---------+ | 2 | E2M | Yes | ef | Yes | No | EMKS, | | | | | ficient | | | H | | | | | | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 3 | E2M | Yes | less | Yes | No | EMKS | | | | | ef | | | and ME | | | | | ficient | | | | +---------+---------+---------+---------+---------+---------+---------+ | 4 | - | Yes | ef | Yes | No | UE | | | | | ficient | | | | +---------+---------+---------+---------+---------+---------+---------+ | 5 | E2E | Yes | ef | No | No | EMKS, | | | | | ficient | | | EESE | | | | | | | | and UE | +---------+---------+---------+---------+---------+---------+---------+ | 6 | E2M | Yes | ef | No | No | H | | | | | ficient | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 7 | E2E | Yes | ef | No | No | H | | | | | ficient | | | SS/HLR, | | | | | | | | USIM, | | | | | | | | ME, | | | | | | | | SGSN, | | | | | | | | GGSN, | | | | | | | | MME, | | | | | | | | S-GW | | | | | | | | and | | | | | | | | P-GW | +---------+---------+---------+---------+---------+---------+---------+ | 8 | E2M | Yes | ef | Yes | Yes | UE, | | | | | ficient | | | USIM, | | | | | | | | MME, | | | | | | | | HSS and | | | | | | | | HSE | +---------+---------+---------+---------+---------+---------+---------+ | 9 | E2E | Yes | Ef | Yes | Yes | UE, | | | | | ficient | | | USIM, | | | | | | | | MME, | | | | | | | | HSS, | | | | | | | | HSE and | | | | | | | | EnSE | +---------+---------+---------+---------+---------+---------+---------+ | 10 | E2E | Depends | Depends | No | No | USIM, | | | | on the | on the | | | H | | | | appl | appl | | (Set up | SS/HLR, | | | | ication | ication | | by the | ME, | | | | layer | layer | | appl | EMKS | | | | s | s | | ication | | | | | ecurity | ecurity | | layer | | | | | p | p | | pr | | | | | rotocol | rotocol | | otocol) | | +---------+---------+---------+---------+---------+---------+---------+ | 11 | E2E | Depends | Depends | No | No | UE, | | | | on the | on the | | | MME, | | | | appl | appl | | | HSS | | | | ication | ication | | | | | | | layer | layer | | | | | | | s | s | | | | | | | ecurity | ecurity | | | | | | | p | p | | | | | | | rotocol | rotocol | | | | +---------+---------+---------+---------+---------+---------+---------+ | 12 | E2E | Depends | Depends | No | No | UE, | | | | on the | on the | | | MME, | | | | appl | appl | | | HSS | | | | ication | ication | | | | | | | layer | layer | | | | | | | s | s | | | | | | | ecurity | ecurity | | | | | | | p | p | | | | | | | rotocol | rotocol | | | | +---------+---------+---------+---------+---------+---------+---------+
## 7.3 Recommendation for normative work
This document recommends that solutions 8 (end to middle security) and 9 (end
to end security) are the basis for normative specifications. This should be
carried out in a modular fashion to allow as much re-use of functionality as
possible and so that the solution can be easily extended to new algorithms,
new security transport protocols and new bearers. Specifically, a module for
the establishment of pre-shared keys based on AKA needs to be defined in the
normative work that could be used by a pre-shared key protocol (e.g., pskDTLS,
IKE). Furthermore, the normative solution should aim not to require changes of
following core network nodes MME, P-GW, S-GW, SGSN, and GGSN, except when
required to meet LI requirements (e.g. in MME). It needs to be determined as
part of the normative work as to whether this can be achieved by solution 8
and 9 or whether additional solutions need to be considered (e.g. solution
#10). As this technical report is focussed on Machine Type Communications, the
normative specifications should be defined for both EPS and eGPRS. These
solutions could be specified for UMTS, but it is not currently a focus for
Machine Type Communications.
###### ### Annex A: AKA procedures assessment in very low data throughput
environment
# A.1 Introduction
In order to assess whether a security protocol is suitable for use in a
situation wherein the battery capacity is limited and wherein the data rate is
very low, it is necessary to provide measurable information to evaluate the
potential impacts on the MTC device\'s battery life and the quality of
service.
The following presents the description of UMTS AKA, DTLS or GBA procedures
that are likely to be used in M2M or in a Cellular IoT context (as in defined
by GERAN in 3GPP TR 45.820 [25]).
According to 3GPP TR 45.820 [25], the minimum data throughput over one channel
is 160 bps for both uplink and downlink. This throughput will be taken as the
base to calculate the time to transmit.
A.2 is the breakout example of the UMTS AKA procedure.
A.3 is the breakout example of DTLS 1.2 handshake procedure with ECDHE-ECDSA
ciphersuite.
A.4 is the overhead description of a DTLS record header for ciphered data
A.5 is the breakout example of a TLS handshake session resumption procedure.
A.6 is the breakout of GBA with the shared-based mutual authentication
procedure between UE and NAF.
# A.2 UMTS AKA
The following tables describe the messages during a successful UMTS AKA
procedure which are exchanged between a UE and a SGSN. The authentication
message request sent from the SGSN to the UE is defined in 3GPP TS 24.008 [12]
and can be described as below:
Table A.2-1: Authentication and Ciphering Request
* * *
Payload Name **M/O/C** **Parameter name** **min size (byte)** **max size
(byte)** **min size (bits)** **max size (bits)** **Case (bits)** **Transmit
time (s)** **Comments** **Authentication and Ciphering Request**  
M protocol discriminator 4 4 4  
M Skip indicator 4 4 4  
M message type 1 1 8 8 8  
M Ciphering algorithm 4 4 4  
M IMEISV request 4 4 4  
M Force to standby 4 4 4  
M A&C reference number 4 4 4  
O Authentication parameter RAND 17 17 136 136 136  
C Cipher key sequence number 1 1 8 8 8 only included if RAND is present O
Authentication parameter AUTN 18 18 144 144 144  
Final total 320 320 320 2  
Ciphering Key Sequence Number IE  
IEI 4  
spare 1  
key sequence 3  
Total 8  
Authentication Parameter IE  
RAND IEI 1 8  
RAND value 16 128  
Total 136  
Authentication Parameter AUTN IE  
AUTN IEI 1 8  
Length of AUTN 1 8  
AUTN 16 128  
Total 144  
AUTN  
SQN xor AK 48  
AMF 16  
MAC 64  
Total 128
* * *
The authentication message response sent from the UE to the SGSN is defined in
3GPP TS 24.008 [12] and can be described as below:
Table A.2-2: Authentication and Ciphering Response
* * *
Payload Name M/O/C Parameter name min size (byte) max size (byte) min size
(bits) max size (bits) Case (bits) Transmit time (s) Comments **Authentication
and Ciphering Response**  
M protocol discriminator 4 4 4  
M Skip indicator 4 4 4  
M message type 1 1 8 8 8  
M A&C reference number 4 4 4  
M spare 4 4 4  
O Authentication Response parameter 5 5 40 40 40  
O IMEISV 11 11 88 88 0  
O Authentication Response parameter (extension) 3 14 24 112 0  
Final total 176 264 64 0.4  
Authentication Response parameter IE  
IEI 1 8 8  
RES (most significant bits) 4 32 32  
Total 40 40  
Authentication Response parameter (extension) IE  
IEI 1 8  
Length 1 8  
RES (all but 4 most significant octets) 0 12 96  
Total 112
* * *
# A.3 DTLS handshake for ECDHE-ECDSA configuration
## A.3.1 DTLS handshake procedure measurement
The following describes the DTLS Record and Handshake messages exchanged for
the ECDHE-ECDSA configuration sent between the UE and a Server is defined in
IETF RFC 6347 [33] and IETF RFC 4492 [34].
Table A.3.1-1: High level DTLS Handshake procedure measurement
* * *
DTLS handshake for ECDHE-ECDSA  
Direction Step Message Name Size (bits) transmit time (s) C -> S 1 ClientHello
608  
subtotal 608  
subtotal with compressed IP/UDP headers 704 4.4  
subtotal with IP/UDP headers 928 5.8  
S -> C 2 ServerHello 728
S -> C 2 Server Certificate 800
S -> C 2 ServerKeyExchange 1128
S -> C 2 ServerHelloDone 72  
subtotal 2728  
subtotal with compressed IP/UDP headers 2824 17.65  
subtotal with IP/UDP headers 3048 19.05  
C -> S 3 ClientKeyExchange 592
C -> S 3 ChangeCipherSpec 48
C -> S 3 Finished 168  
subtotal 808  
subtotal with compressed IP/UDP headers 904 5.65  
subtotal with IP/UDP headers 1,128 7.05  
S -> C 4 ChangeCipherSpec 48
S -> C 4 Finished 168  
subtotal 216  
subtotal with compressed IP/UDP headers 312 1.95  
subtotal with IP/UDP headers 536 3.35  
TOTAL with compressed IP/UDP headers 4,744 29.65  
TOTAL with IP/UDP headers 5,640 35.25
* * *
## A.3.2 TLS Record and Handshake message measurement
The TLS Record message is defined as follow:
Table A.3.2-1: Record message header measurement
* * *
Payload Name M/O/C Parameter name min size (byte) max size (byte) min size
(bits) max size (bits) ECDHE ECDSA Case (bits) Comments RECORD MESSAGE  
Content Type 1 1 8 8 8  
Protocol Version 2 2 16 16 16  
Length 2 2 16 16 16  
Fragment 0 16384 0 131072 message dependent The Handshake messages will be
contained within a Record Message header total 40  
final total 5 16389 40 131112 message dependent
* * *
The TLS record encapsulates Handshake messages (as well as Change Cipher Spec
messages) which are defined as follows:
Table A.3.2-2: Handshake message header measurement
* * *
Payload Name M/O/C Parameter name min size (byte) max size (byte) min size
(bits) max size (bits) ECDHE ECDSA Case (bits) Comments HANDSHAKE MESSAGE  
Handshake type 1 1 8 8 8  
Length 3 3 24 24 24  
body 0 4095 message dependent The message content itself e.g. the ClientHello
header total 32  
final total message dependent
* * *
The TLS Handshake messages are further described as follows:
Table A.3.2-3: ClientHello message measurement
* * *
Payload Name **Parameter name** **Size (bits)** **Comments** ClientHello ECDHE
ECDSA case (Direction: Client -> Server)  
Protocol Version 16  
Random 256  
Session ID 8 first time (only length byte) Cipher Suites 48 One cipher suite
e.g. TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8, 2 length bytes, renegotiation
ciphersuite Compression methods 16 Length byte + NULL extensions 192 2 byte
total ext length field + 2 byte Sig Alg ext ID + 2 byte ext len + 2 byte list
len + Sig Alg (2) + 2 byte Curve ext ID + 2 byte ext len + 2 byte list len + 2
byte curve ID + 2 byte Point Format ext ID + 2 byte ext len + 1 byte list len
+ 1 byte format. final total 536  
final total with record and handshake headers 608
* * *
Table A.3.2-4: ServerHello message measurement
* * *
Payload Name Parameter name Size (bits) Comments ServerHello ECDHE ECDSA case
(Direction: Server -> Client)  
Protocol Version 16  
Random 256 Independently generated from the ClientHello.Random Session ID 256
The assigned Session ID Cipher Suite 16 One cipher suite e.g.
TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 Compression methods 8 null extensions 104
e.g. brainpoolP256r1(26); 2 byte total ext length field + 2 byte Renego ext ID
+ 2 byte ext len + 1 byte + 2 byte Point Format ext ID + 2 byte ext len + 1
byte list len + 1 byte format final total 656  
final total with record and handshake headers 728
* * *
Table A.3.2-5: Certificate message measurement
* * *
**Payload Name** **Parameter name** **Size (bits)** **Comments** Certificate
ECDHE ECDSA case (Direction: Server -> Client)  
final total ASN.1Cert certificate list 728 example Raw Public Certificate
ECDSA P-256: 91 bytes final total with record and handshake headers 800
* * *
Table A.3.2-6: ServerKeyExchange message measurement
* * *
Payload Name Parameter name Size (bits) Comments ServerKeyExchange ECDHE ECDSA
case (Direction: Server -> Client)  
ServerECDHParams 544  
Signature 512  
final total 1056  
final total with record and handshake headers 1128
* * *
Table A.3.2-7: ServerKeyExchange message measurement
* * *
Payload Name Parameter name Size (bits) Comments ServerHelloDone ECDHE ECDSA
case (Direction: Server -> Client)  
total 0  
final total with record and handshake headers 72
* * *
Table A.3.2-8: ClientKeyExchange message measurement
* * *
Payload Name Parameter name Size (bits) Comments ClientKeyExchange ECDHE ECDSA
case (Direction: Client -> Server)  
exchange keys 520 The client selects an ephemeral ECDH public key
corresponding to the parameters it received from the server according to the
ECKAS-DH1 scheme from IEEE 1363 final total 520  
final total with record and handshake headers 592
* * *
Table A.3.2-9: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec ECDHE ECDSA
case (Direction: Client -> Server)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
NOTE: ChangeCipherSpec messages aren\'t handshake messages and are directly
encapsulated in a record message.
Table A.3.2-10: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished ECDHE ECDSA case
(Direction: Client -> Server)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
Table A.3.2-11: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec ECDHE ECDSA
case (Direction: Server -> Client)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
> Note: ChangeCipherSpec messages aren\'t handshake messages and are directly
> encapsulated in a record message.
Table A.3.2-12: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished ECDHE ECDSA case
(Direction: Server -> Client)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
# A.4 DTLS record header overhead description for ciphered data
## A.4.1 DTLS record header measurement
The following describes the overhead of DTLS record header per ciphered data:
Table A.4.1-1: DTLS Record Layer per-packet overhead measurement
* * *
Parameter name min size (bits) max size (bits) ECDHE ECDSA Case (bits)
Comments
DTLS Record Layer Per-Packet Overhead (see also Appendix B of IETF dice
profile 10)
DTLS record layer header 104 104 104
nonce 64 64 64 RFC 6655 [RFC6655] allows the nonce_explicit to be a sequence
number or something else. This document makes this use more restrictive for
use with DTLS: the 64-bit none_explicit needs to be the 16-bit epoch
concatenated with the 48-bit seq_num. The sequence number component of the
nonce_explicit field at the AES-CCM layer is an exact copy of the sequence
number in the record layer header field. This leads to a duplication of
8-bytes per record.\ \ To avoid this 8-byte duplication RFC 7400 [RFC7400]
provides help with the use of the generic header compression technique for
IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs). Note that this
header compression technique is not available when DTLS is exchanged over
transports that do not use IPv6 or 6LoWPAN, such as the SMS transport
described in Appendix A.
ICV 64 64 64
total 232
DTLS record layer header
content type 8 8
version 16 16
epoch 16 16
sequence number 48 48
length 16 16
* * *
# A.5 TLS handshake session resumption
## A.5.1 TLS handshake session resumption procedure measurement
The following describes the TLS Record and Handshake messages exchanged for
the ECDHE-ECDSA configuration for session resumption between the UE and a
Server.
Table A.5.1-1: High level DTLS Handshake session resumption procedure
measurement
* * *
DTLS handshake for ECDHE-ECDSA  
Direction Step Message Name Size (bits) transmit time (s) C -> S 1 ClientHello
864  
subtotal 864  
subtotal with compressed IP/UDP headers 960 6 subtotal with IP/UDP headers
1184 7.4 S -> C 2 ServerHello 736  
subtotal 736  
subtotal with compressed IP/UDP headers 832 5.2 subtotal with IP/UDP headers
1056 6.6 C -> S 3 ChangeCipherSpec 48  
C -> S 3 Finished 168  
subtotal 216  
subtotal with compressed IP/UDP headers 312 1.95 subtotal with IP/UDP headers
536 3.35 S -> C 4 ChangeCipherSpec 48  
S -> C 4 Finished 168  
subtotal 216  
subtotal with compressed IP/UDP headers 312 1.95 subtotal with IP/UDP headers
536 3.35 TOTAL with compressed IP/UDP headers 2,416 15.1 TOTAL with IP/UDP
headers 3,312 20.7
* * *
## A.5.2 TLS Record and Handshake message measurement
The TLS Record message is defined as follow:
Table A.5.2-1: Record message header measurement
* * *
Payload Name M/O/C Parameter name min size (byte) max size (byte) min size
(bits) max size (bits) ECDHE ECDSA Case (bits) Comments RECORD MESSAGE  
Content Type 1 1 8 8 8  
Protocol Version 2 2 16 16 16  
Length 2 2 16 16 16  
Fragment 0 16384 0 131072 message dependent The Handshake messages will be
contained within a Record Message header total 40  
final total 5 16389 40 131112 message dependent
* * *
The TLS record encapsulates Handshake messages (as well as Change Cipher Spec
messages) which are defined as follows:
Table A.5.2-2: Handshake message header measurement
* * *
Payload Name M/O/C Parameter name min size (byte) max size (byte) min size
(bits) max size (bits) ECDHE ECDSA Case (bits) Comments HANDSHAKE MESSAGE  
Handshake type 1 1 8 8 8  
Length 3 3 24 24 24  
body 0 4095 message dependent The message content itself e.g. the ClientHello
header total 32  
final total message dependent
* * *
The TLS Handshake messages are further described below:
Table A.5.2-3: ClientHello message measurement
* * *
Payload Name **Parameter name** **Size (bits)** **Comments** ClientHello ECDHE
ECDSA case (Direction: Client -> Server)  
Protocol Version 16  
Random 256  
Session ID 264 32 byte session + 1 length byte Cipher Suites 48 One cipher
suite e.g. TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8, 2 length bytes, renegotiation
ciphersuite Compression methods 16 Length byte + NULL extensions 192 2 byte
total ext length field + 2 byte Sig Alg ext ID + 2 byte ext len + 2 byte list
len + Sig Alg (2) + 2 byte Curve ext ID + 2 byte ext len + 2 byte list len + 2
byte curve ID + 2 byte Point Format ext ID + 2 byte ext len + 1 byte list len
+ 1 byte format. final total 792  
final total with record and handshake headers 864
* * *
Table A.5.2-4: ServerHello message measurement
* * *
Payload Name Parameter name Size (bits) Comments ServerHello ECDHE ECDSA case
(Direction: Server -> Client)  
Protocol Version 16  
Random 256 Independently generated from the ClientHello.Random Session ID 264
The assigned Session ID + length byte Cipher Suite 16 One cipher suite e.g.
TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 Compression methods 8 null extensions 104 2
byte total ext length field + 2 byte Renego ext ID + 2 byte ext len + 1 byte +
2 byte Point Format ext ID + 2 byte ext len + 1 byte list len + 1 byte format
final total 664  
final total with record and handshake headers 736
* * *
Table A.5.2-5: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec ECDHE ECDSA
case (Direction: Client -> Server)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
Note: ChangeCipherSpec messages aren\'t handshake message and are directly
encapsulated in a record message.
Table A.5.2-6: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished ECDHE ECDSA case
(Direction: Client -> Server)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
Table A.5.2-7: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec ECDHE ECDSA
case (Direction: Server -> Client)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
Note: ChangeCipherSpec messages aren\'t handshake message and are directly
encapsulated in a record message.
Table A.5.2-8: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished ECDHE ECDSA case
(Direction: Server -> Client)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
# A.6 GBA bootstrapping procedure
## A.6.1 Bootstrapping procedure description measurement
The following is an example signalling flow demonstrating a successful
bootstrapping procedure found in 3GPP TS 24.109 [34].
**Table A.6.1-1: Successful** Bootstrapping Procedure Description
+------------------------+------------------------+------------------+ | Step | Example message | Character count | +------------------------+------------------------+------------------+ | Initial GET request | GET / HTTP/1.1 | 302 UTF-8 Chars | | (UE to BSF) | | | | | Host: bsf.home1.net:80 | 302 bytes | | | | | | | User-Agent: | | | | Bootstrapping Client | | | | Agent; Release-6; | | | | 3gpp-gba-tmpi | | | | | | | | Date: Thu, 08 Jan 2004 | | | | 10:13:17 GMT | | | | | | | | Accept: */* | | | | | | | | Authorization: Digest | | | | | | | | username=\"user1\ | | | | _private\@home1.net\", | | | | | | | | re | | | | alm=\"bsf.home1.net\", | | | | | | | | nonce=\"\", | | | | | | | | uri=\"/\", | | | | | | | | response=\"\" | | +------------------------+------------------------+------------------+ | Unauthorized response | HTTP/1.1 401 | 299 UTF-8 Chars | | (BSF to UE) | Unauthorized | | | | | 299 bytes | | | Server: Bootstrapping | | | | Server; Release-6 | | | | | | | | Date: Thu, 08 Jan 2004 | | | | 10:13:17 GMT | | | | | | | | WWW-Authenticate: | | | | Digest | | | | | | | | re | | | | alm=\"bsf.home1.net\", | | | | | | | | nonce= | | | | base64(A3 | | | | 4Cm+Fva37UYWpGNB34JP), | | | | | | | | algorithm=AKAv1-MD5, | | | | | | | | qop=\"auth-int\", | | | | opaque=\"5ccc069c403e | | | | baf9f0171e9517f30e41\" | | +------------------------+------------------------+------------------+ | GET request (UE to | GET / HTTP/1.1 | 530 UTF-8 Chars | | BSF) | | | | | Host: bsf.home1.net:80 | 530 bytes | | | | | | | User-Agent: | | | | Bootstrapping Client | | | | Agent; Release-6; | | | | 3gpp-gba-tmpi | | | | | | | | Date: Thu, 08 Jan 2004 | | | | 10:13:18 GMT | | | | | | | | Accept: */* | | | | | | | | Authorization: Digest | | | | | | | | username=\"user1\ | | | | _private\@home1.net\", | | | | | | | | re | | | | alm=\"bsf.home1.net\", | | | | | | | | nonce=\"base64(A34C | | | | m+Fva37UYWpGNB34JP)\", | | | | | | | | uri=\"/\", | | | | qop=auth-int, | | | | | | | | nc=00000001, | | | | | | | | cnonce=\"6629fae49393a | | | | 05397450978507c4ef1\", | | | | | | | | re | | | | sponse=\"6629fae49393a | | | | 05397450978507c4ef1\", | | | | | | | | opaque=\"5ccc069c403eb | | | | af9f0171e9517f30e41\", | | | | | | | | algorithm=AKAv1-MD5 | | +------------------------+------------------------+------------------+ | 200 OK response (BSF | HTTP/1.1 200 OK | 705 UTF-8 Chars | | to UE) | | | | | Server: Bootstrapping | 705 bytes | | | Server; Release-6; | | | | 3gpp-gba-tmpi | | | | | | | | Authentication-Info: | | | | qop=auth-int, | | | | | | | | r | | | | spauth=\"6629fae49394a | | | | 05397450978507c4ef1\", | | | | | | | | cnonce=\"6629fae49393a | | | | 05397450978507c4ef1\", | | | | | | | | nc=00000001, | | | | | | | | opaque=\"5ccc069c403eb | | | | af9f0171e9517f30e41\", | | | | | | | | nextnonce=\"base64(A34 | | | | Cm+Fva37UYWpGNB34JP)\" | | | | | | | | Date: | | | | | | | | Expires: Thu, 08 Jan | | | | 2004 10:23:17 GMT | | | | | | | | Content-Type: | | | | applic | | | | ation/vnd.3gpp.bsf+xml | | | | | | | | Content-Length: 255 | | | | | | | | \ | | | | | | | | \ | | | | | | | | \user\@bsf | | | | .operator.com\ | | | | | | | | \ | | | | 2004-05-28T | | | | 13:20:00Z\ | | | | | | | | \ | | | | | | | | \2004-05-27T13: | | | | 20:00Z\ | | | | | | | | \ | | | | | | | | \ | | +------------------------+------------------------+------------------+ | total | | 1836 UTF-8 Chars | | | | | | | | 1836 bytes | | | | | | | | 14688 bits | +------------------------+------------------------+------------------+
The compressed IP and TCP header overhead per message is 24 bytes, therefore
the total amount of data that is transmitted over the air is 15456 bits.
## A.6.2 PSK-TLS procedure measurement in GBA case.
The following describes the PSK-TLS procedures compliant with the shared key-
based mutual authentication between UE and NAF procedure defined in clause 5.4
of 3GPP TS 33.222 [35].
Table A.6.2-1: Shared key-based mutual authentication between UE and NAF
* * *
TLS handshake PSK-TLS for GBA  
Direction Step Message Name Size (bits) transmit time (s) C -> S 1 ClientHello
520  
subtotal 520  
subtotal with compressed IP/TCP headers 712 4.45 S -> C 2 ServerHello 640  
S -> C 2 ServerKeyExchange 216  
S -> C 2 ServerHelloDone 72  
subtotal 928  
subtotal with compressed IP/TCP headers 1120 7 C -> S 3 ClientKeyExchange 392  
C -> S 3 ChangeCipherSpec 48  
C -> S 3 Finished 168  
subtotal 608  
subtotal with compressed IP/TCP headers 800 5 S -> C 4 ChangeCipherSpec 48  
S -> C 4 Finished 168  
subtotal 216  
subtotal with compressed IP/TCP headers 408 2.55 TOTAL with compressed IP/TCP
headers 3,040 19
* * *
The TLS Handshake messages are further described as follows:
Table A.6.2-2: ClientHello message measurement
+----------------+----------------+----------------+----------------+ | Payload Name | **Parameter |** Size | **Comments** | | | name**| (bits)** | | +----------------+----------------+----------------+----------------+ | ClientHello | | | | | PSK-TLS case | | | | | (Direction: | | | | | Client -> | | | | | Server) | | | | +----------------+----------------+----------------+----------------+ | | Protocol | 16 | | | | Version | | | +----------------+----------------+----------------+----------------+ | | Random | 256 | | +----------------+----------------+----------------+----------------+ | | Session ID | 0 | First time | +----------------+----------------+----------------+----------------+ | | Cipher Suites | 32 | Two cipher | | | | | suite e.g. | | | | | | | | | | TLS_PSK_ | | | | | WITH_AES_128 | | | | | _CBC_SHA256, | | | | | one PSK-based | | | | | cipher suite. | +----------------+----------------+----------------+----------------+ | | Compression | 8 | NULL | | | methods | | | +----------------+----------------+----------------+----------------+ | | extensions | 136 | | +----------------+----------------+----------------+----------------+ | final total | | 448 | | +----------------+----------------+----------------+----------------+ | final total | 520 | | | | with record | | | | | and handshake | | | | | headers | | | | +----------------+----------------+----------------+----------------+
Table A.6.2-3: ServerHello message measurement
+-----------------+-----------------+-------------+-----------------+ | Payload Name | Parameter name | Size (bits) | Comments | +-----------------+-----------------+-------------+-----------------+ | ServerHello | | | | | PSK-TLS case | | | | | (Direction: | | | | | Server -> | | | | | Client) | | | | +-----------------+-----------------+-------------+-----------------+ | | Protocol | 16 | | | | Version | | | +-----------------+-----------------+-------------+-----------------+ | | Random | 256 | Independently | | | | | generated from | | | | | the | | | | | Cli | | | | | entHello.Random | +-----------------+-----------------+-------------+-----------------+ | | Session ID | 256 | The assigned | | | | | Session ID | +-----------------+-----------------+-------------+-----------------+ | | Cipher Suite | 32 | Two cipher | | | | | suite e.g. | | | | | | | | | | TLS_PSK | | | | | _WITH_AES_12 | | | | | 8_CBC_SHA256, | | | | | one PSK-based | | | | | cipher suite. | +-----------------+-----------------+-------------+-----------------+ | | Compression | 8 | null | | | methods | | | +-----------------+-----------------+-------------+-----------------+ | | extensions | 0 | | +-----------------+-----------------+-------------+-----------------+ | final total | 568 | | | +-----------------+-----------------+-------------+-----------------+ | final total | 640 | | | | with record and | | | | | handshake | | | | | headers | | | | +-----------------+-----------------+-------------+-----------------+
Table A.6.2-4: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec PSK-TLS case
(Direction: Server -> Client)  
psk identity hint 144 3GPP-bootstrapping final total 144  
final total with record header and handshake headers 216
* * *
Table A.6.2-5: ServerHelloDone message measurement
* * *
Payload Name Parameter name Size (bits) Comments ServerHelloDone PSK-TLS case
(Direction: Server -> Client)  
total 0  
final total with record and handshake headers 72
* * *
Table A.6.2-6: ClientKeyExchange message measurement
* * *
Payload Name Parameter name Size (bits) Comments ClientKeyExchange PSK-TLS
case (Direction: Client -> Server)  
psk identity 320 3GPP-bootstrapping;user\@bsf.operator.com final total 320  
final total with record header and handshake headers 392
* * *
Table A.6.2-7: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec PSK-TLS case
(Direction: Client -> Server)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
Table A.6.2-8: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished PSK-TLS case
(Direction: Client -> Server)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
Table A.6.2-9: ChangeCipherSpec message measurement
* * *
Payload Name Parameter name Size (bits) Comments ChangeCipherSpec PSK-TLS case
(Direction: Server -> Client)  
Change cipher spec 8 To help avoid pipeline stalls, ChangeCipherSpec is an
independent TLS protocol content type, and is not actually a TLS handshake
message. final total 8  
final total with record header 48
* * *
Table A.6.2-10: Finished message measurement
* * *
Payload Name Parameter name Size (bits) Comments Finished PSK-TLS case
(Direction: Server -> Client)  
verify data 96  
final total 96  
final total with record and handshake headers 168
* * *
###### ### Annex B: Review of security standardization efforts in other SDOs
# B.0 Introduction
This annex collects information on security standardization efforts in other
standards organizations (SDOs) that are relevant for this study. This body of
work includes security procedures that are optimized for constrained
environments.
# B.1 (D)TLS optimization efforts in IETF
## B.1.1 Background
Editor\'s note: This clause presents the current status of evolving work, and
would need to be updated after substantial progress in IETF.
CoAP is the most promising IoT protocol that also GERAN is expected to be used
with Cellular IoT. CoAP was developed for constrained environments, and for
this reason, it may seem strange that IETF choose DTLS as the primary security
mechanism for CoAP. It is widely known that TLS is heavy in terms of
negotiation roundtrips and amount of data sent during the negotiation.
However, it seems that IETF wanted to re-use security mechanism that has
already been proven, and widely deployed. By making this decision, IETF seemed
to make also a commitment to solve the efficiency problems of DTLS to better
fit the needs of CoAP. IETF community has been very active on finding
solutions to the latency and overhead issues of DTLS. The commitment of
solving the problems can be seen e.g. in the TLS working group charter that
describes some of the main design goals for (D)TLS v1.3:
_\"Develop modes to reduce handshake latency, which primarily support HTTP-
based applications, aiming for one roundtrip for a full handshake and one or
zero roundtrip for repeated handshakes.\" [4]_
The CoAP security story is based heavily on the use of DTLS with raw public
keys. One deployment scenario assumes that IoT UEs would have a pre-installed
asymmetric public key, and that a (truncated) hash of the public key would be
used as the IoT UE identifier. The identifiers could be collected by using a
barcode on the outside of the device, and stored in the server side. The
identifiers would then be used to create access control lists about the IoT
UEs that may use DTLS. Using strong cryptography for DTLS connection
negotiation makes it possible to elongate the lifetime of the connection.
The other important assumption is that the IoT UE may not need to create DTLS
sessions with several entities but only few, ideally only one. From this point
of view, the situation is very different from a more typical TLS deployment
scenario where TLS is supposed to be used with any server. This makes some of
the DTLS protocol features look a little odd, e.g. why send the certificates
(or even the information about the supported security algorithms) in every
DTLS handshake if the end-points remains the same. There is obviously room for
optimization in order to make the DTLS more suitable for CoAP.
## B.1.2 Existing and evolving TLS optimizations
The main technique for making DTLS more suitable for CoAP is to leave the DTLS
session open for much longer period of time than it is left open in other
application contexts. This mode of operation is described in CoAP protocol,
and the basic idea seems to be that if the DTLS handshake is done using strong
credentials, it needs not to be closed that soon. This saves energy and
resources from IoT UE.
_\"DTLS connections in RawPublicKey and Certificate mode are set up using
mutual authentication so they can remain up and be reused for future message
exchanges in either direction. Devices can close a DTLS connection when they
need to recover resources, but in general they should keep the connection up
for as long as possible. Closing the DTLS connection after every CoAP message
exchange is very inefficient.\" [5]_
DTLS connection created using shared secrets is not mentioned, however, this
does not mean that DTLS handshake created using 3GPP credentials stored in
UICC would not meet the security requirements for leaving the DTLS connection
open for a longer period of time.
Other reasons why DTLS connection can be left open more easily is that the
proxy/server connected to UE is dedicated to server a restricted set of UEs.
The amount of state maintained in proxy/server can be pre-calculated, and the
risk of DoS attacks is not that severe. From the UE point of view, the amount
of data that is sent over the DTLS connection at a time is very small. This
means that there is less data available for a potential attacker to figure out
the keys.
The dice WG (DTLS In Constrained Environments) is currently discussing about
more optimized DTLS handshake procedures, and DTLS profiles for CoAP. For
example, the draft-ietf-dice-profile [10] gives recommendations for chip
manufacturers and software vendors on how to implement (D)TLS in CoAP devices.
draft-ietf-dice-profile is a very useful document because it collects
references to various RFCs and I-Ds together, and does not introduce any
changes to (D)TLS but rather guides for better interoperability. It is based
on (D)TLS 1.2, and strongly recommends resuming a (D)TLS sessions instead of
running full handshake. However, draft-ietf-dice-profile is not a piece of
work describing any real TLS optimizations as such. draft-ietf-dice-profile is
currently in IESG review for publication.
## B.1.3 Making the full handshake lighter
There are at least two strategies for making the TLS handshake lighter. First
one is trying to reduce the size of the certificates sent during the
handshake, and the second one modifying the handshake itself in order to make
it more compact.
On the certificate side, the raw public key certificates specified in RFC 7250
use ASN.1Cert format that is lighter than the full X.509 certificates. For the
constrained environments, even more lightweight certificate format has been
proposed [6]. There is also work going on where the certificates are cached in
the TLS client removing the need of sending it every time a new TLS connection
is negotiated [7]. This would be a useful feature in CoAP where the
communication end-point seldom changes.
TLS 1.3 that is currently under development in IETF is trying to reduce the
number of messages sent in the full TLS handshake [8]. The current version
includes a 1,5 roundtrips handshake (instead of 2 roundtrips of TLS 1.2). The
1,5 roundtrips mode was only possible when resuming existing TLS 1.2 sessions.
This more optimized TLS handshake is very likely to be included in the next
TLS standard (Figure B.1.3-1).
ClientHello
ClientKeyShare -------->
ServerHello
ServerKeyShare
\
Figure B.1.3-1: Full TLS 1.3 handshake (optional/situational messages omitted)
## B.1.4 Resuming existing connection
A full TLS 1.2 handshake requires 2-roundtrips (four messages) before the
handshake is completed, and the application can start sending application data
[9]. This means not only an increase in latency but also more security related
data to be sent. It is also possible to resume earlier TLS sessions but also
in this case the handshake requires 1,5-roundtrips (three messages). The
amount of bits is reduced radically if compared to full handshake. It is
estimated that the saving would be roughly 60%.
The TLS working group is currently discussing on more radical modes of
resuming the connections in TLS 1.3 namely the \"1-roundtrip\" and
\"0-roundtrip\" modes. There seems to be a strong commitment within the
working group to include the 0-roundtrip handshake for TLS session resumption
partly because DTLS is an integral part of security of constrained
environments. Interestingly, it is estimated that the 1-roundtrip mode would
not save the number of bits if compared to TLS 1.2 resumption. It would still
be roughly 60% less bits if compared to full handshake. But the 1-roundtrip
mode is still interesting because it reduces the latency. Note that the
0-roundtrip may not mean that all of the TLS handshake messages would be
omitted. It means that the client can start sending application data directly,
and the server may still reply with some TLS resume messages (Figure B.1.4-1).
Client Server
ClientHello
ClientKeyShare
{Certificate*}
{CertificateVerify*}
{Finished}
[Application Data] -------->
ServerHello
ServerKeyShare
\ [Application Data]
Figure B.1.4-1: Overview of 0-RTT Flow
The 0-roundtrip functionality may be limited to certain use cases only, and
could be used only if both the client and the server agree to use it. There is
going to be new key derivation procedure for the TLS master shared secret when
the session is resumed. One of the current problems is related to the TLS
anti-replay feature that is based on the idea that each side provides a random
value that is mixed into the keying material. The anti-reply can be achieved
for the 0-roundtrip client but not to the server. It is currently discussed
how this can be solved, e.g. if the server should simply drop the 0-roundtrip
data when the server thinks the 0-roundtrip is not possible. The server needs
to tell the client that this was done for the client application to
retransmit. However, the 0-roundtrip is seen as a feature for limited cases
where the application domains can safely keep state, and can profile the use
of TLS.
###### ### Annex C: Proposed normative changes
# C.1 Introduction
For the normative work, the key best functions need to be designed in a
modular fashion so that they can be re-used for each solution and for other
solutions in the future.
As cellular internet of things can be delivered over GPRS or LTE, it is
expected that the normative specifications shall be available both in GPRS and
LTE. These specifications may be available in UMTS.
The normative work could be specified either as Change requests to existing
specifications or as a new technical specification. This technical report
recommends that the BEST feature be delivered as changes to existing technical
specifications.
The following specifications could be modified to include the BEST
specifications:
\- 3GPP TS 33.401 [28]: This covers LTE use.
\- 3GPP TS 43.020 [47]: This covers use in GPRS.
This TR recommends that the changes be put into 3GPP TS 33.401[28] and
references to the changes in 3GPP TS 33.401 [28] be put into 3GPP TS 43.020
[47]. This means only one version of the BEST normative specifications exists
which is easier to maintain.
# C.2 Proposed changes to 3GPP TS 33.401 [28]
## C.2.1 Overview of changes
The BEST changes can be achieved through the following changes:
\- Clause 3: Definitions and abbreviations
\- New clause 17 \"Security Procedures for Extended User Plane protection (or
simply \"BEST\")\" with all of BEST. This should consist of both the modular
building blocks and the way of using these blocks to deliver end to middle
security and end to end security.
\- New Annex A.19: Key derivations for BEST
# C.3 Proposed changes to 3GPP TS 43.020 [47]
The BEST changes can be achieved through the following changes:
\- Clause 3: Definitions and abbreviations
\- New Annex \"Security Procedures for Extended User Plane protection (or
simply \"BEST\")\" with references to all of BEST in TS 33.401 [28].
#
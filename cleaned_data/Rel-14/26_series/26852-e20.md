# Foreword
This Technical Report has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
The present document has been created as part of the MEPRO work item to
identify relevant profiles for the MBMS user services, study the feasibility
of MBMS as a transport enabler, and identify relevant APIs that can offered to
applications to enable usage of MBMS user services.
# 1 Scope
The present document identifies a set of profiles for based on the most
relevant use cases for the usage of MBMS. It also studies the feasibility of
using MBMS as a regular transport enabler through the definition of an MBMS
URL scheme and the procedures to resolve such URL schemes. In addition, it
identifies a set of APIs for controlling MBMS user service reception and
retrieving resources that are delivered over MBMS. Finally, the present
document also addresses the issue of defining QoE reporting for DASH over
MBMS.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or nonâ€‘specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TR 41.001: \"GSM Release specifications\".
[3] 3GPP TR 21 912 (V3.1.0): \"Example 2, using fixed text\".
[4] 3GPP TS 26.346: \" Multimedia Broadcast/Multicast Service (MBMS);
Protocols and codecs\".
[5] IETF RFC 5052: \"Forward Error Correction (FEC) Building Block\".
[6] IETF RFC 5053: \"Raptor Forward Error Correction Scheme for Object
Delivery\".
[7] IETF RFC 3695: \"Compact Forward Error Correction (FEC) Schemes\".
[8] IETF RFC 5053: \"Raptor Forward Error Correction Scheme for Object
Delivery\".
[9] 3GPP TS 26.247: \"Transparent end-to-end Packet-switched Streaming Service
(PSS); Progressive Download and Dynamic Adaptive Streaming over HTTP (3GP-
DASH)\".
[10] IETF RFC 2616: \" Hypertext Transfer Protocol -- HTTP/1.1\".
[11] 3GPP TS 26.946: \"Multimedia Broadcast/Multicast Service (MBMS) user
service guidelines\"
[12] ISO/IEC 23009-1:2014: \"Information technology -- Dynamic adaptive
streaming over HTTP (DASH) -- Part 1: Media presentation description and
segment formats\".
[13] 3GPP TS 29.303, \"Domain Name System Procedures, Stage 3\"
[14] IETF RFC 2782, \"A DNS RR for specifying the location of services (DNS
SRV)\"
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
**Multimedia Broadcast/Multicast Service (MBMS):** See 3GPP TS 26.346 [4].
**MBMS user services:** See 3GPP TS 26.346 [4].
**MBMS user service discovery/announcement:** user service discovery refers to
methods for the UE to obtain the list of available MBMS user services along
with information on the user service\ The user service announcement refers to
methods for the MBMS service provider to make the list of available MBMS user
services along with information on the user service available to the UE.
**MBMS delivery method:** mechanism used by a MBMS user service to deliver
content\ There are three MBMS delivery method instances: group communication,
download and streaming.
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply.\ An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
ADPD Associated Delivery Procedure Description
BM-SC Broadcast-Multicast - Service Centre
DANE DASH Aware Network Element
DASH Dynamic Adaptive Streaming over HTTP
ERT Expected Residual Time
FDT File Delivery Table
FLUTE File deLivery over Unidirectional Transport
LCT Layered Coding Transport
MIME Multipurpose Internet Mail Extensions
PSS Packet Switch Streaming
SAND Server and Network Assisted DASH
SCT Sender Current Time
TMGI Temporary Mobile Group Identity
TOI Transport Object Identifier
TSI Transport Session Identifier
# 4 Use Cases
## 4.1 Introduction
This clause identifies the most relevant use cases for the usage of MBMS user
services that server as the reference for identifying the key functions to be
considered in profile definition.
## 4.2 Service Announcement for Services in-venue and outside
### 4.2.1 Description
An operator wants to offer a set of MBMS user services depending on the
interest in areas. Typically, the interest is high inside of venues. Live
coverage of the event is also of interest outside of the venue.
The operator may want to offer some Live Video services during events inside
of the venue and also outside of the venue. An example for a Live Video
Service is a camera feed from the match.
In-Venue events are typically advertised in advance so that the audience has a
chance to buy tickets. Services and offerings are also planned and scheduled
in advance. Devices are desired to have all relevant service access
information locally available as required via broadcast, in order to limit /
avoid dependency on the unicast.
### 4.2.2 Characteristics
\- Several MBMS User Services are offered inside of a venue (together with
other venue specific services) and out side
\- Devices receive service announcement information prior to an event and keep
the information until end of validity
\- All UEs are informed of all services all the time and devices filter the
list. The list of services advertised in a given area could be limited
(location-based) or nationwide if the number of services is not large.
\- The operator may activate reception reporting (for QoE reporting) for the
Live DASH service. An appropriate Associated Delivery Procedure Description
(ADPD) Fragment is provided to that effect.
## 4.3 Service Announcement updates for live streaming
### 4.3.1 Description
Sub Case 1: An operator wants to update already announced MBMS user services.
For instance, the football match final was planned to include penalty
shooting, but one team was a clear winner after the regular match duration.
The operator wants to update the service announcement and provide the correct
service end-time. A more precisely defined schedule information and **MPD**
\@mediaPresentationDuration allows for a more graceful shut down of the
presentation playback.
Sub Case 2: Another example, which requires service announcement updates for
live streaming services is ad-insertion: The operator may insert an
advertisement into the DASH stream and therefore needs to update the MPD
containing an new period.
### 4.3.2 Characteristics
\- The operator needs to send service announcement updates to all devices,
which are currently not consuming the content. The devices should have the
correct access information when activating the reception.
\- Devices need to frequently check for all service announcement updates, even
if only consuming content for one of the services. This reduces the latency in
acquiring a new service since the relevant MBMS metadata fragments are locally
cached.
\- The operator needs to send updated service announcement information quickly
to those devices that are currently consuming the service.
\- Devices are not required to monitor the SDCH while receiving content on
another bearer. However, user experience may improve, when the UE supports
reception of multiple MBMS bearers simultaneously.
\- Updating all devices with the latest service announcement information
depends on the device SDCH checking frequency.
## 4.4 Service Announcement updates for Non-Real Time services
### 4.4.1 Description
Sub Case 1: The operator has scheduled a file delivery service such as an
Digital Signage Service. The operator realizes prior to the event but after
first service announcement, that the delivered NRT content is larger than
initially planned. The broadcast session duration should be updated and the
operator provides new schedule information.
Sub Case 2: The operator has initially scheduled the file delivery service for
a certain time slot. Due to another, higher priority service, the operator
needs to change the schedule for the NRT file delivery service by updating the
schedule.
### 4.4.2 Characteristics
The operator needs to send service announcement updates to all devices, which
are currently not consuming the content. The devices should have the correct
access information when activating the reception.
## 4.5 Application Update Use Case
### 4.5.1 Use Case
The user is interested in software updates for his smartphone or some of the
applications in his smartphone. Because those applications are very popular,
the operator wants to avoid that a significant amount of downloads of the same
resource occur at the same time over the unicast channel. Updates to
applications are usually made available within an app store by application
providers. Firmware updates are usually notified to a UE user via a dedicated
tool. As such multiple management authorities may be managing a subset of the
device. In the case that (one or all the) Management Authorities are
interested in leveraging a 3^rd^ party MBMS platforms from an operator or
service provider, the updated resources can be delivered over MBMS for more
economical resource usage. The UEs are informed about file updates of interest
to them. The UEs then join the dedicated MBMS service to receive these
updates.
### 4.5.2 Implication on Profile
The profile on file download should contain the following tools for the
support of the app update use case:
\- Pre-configured USD for keep-updated service
\- Registration/de-registration for keep updated service
\- Notification using OMA PUSH about upcoming file distribution
\- OMA DM Client Authority Delegation to authorize retrieval and access to the
app and firmware updates
In addition, it is recommended that API functionality should be studied to
support the use case. The usage of OMA DM Client API Framework 1.0 should also
be considered to allow applications and services to use management objects
installed on the device.
## 4.6 Delivery of Live DASH Service over eMBMS
### 4.6.0 General
A mobile network operator, as the eMBMS service provider, offers a variety of
live sports events delivered as DASH-over-eMBMS services that can potentially
be accessed by a large end-user population. For a given Live DASH service, the
availability times of Segments depend on the position of the Segment in the
Media Presentation timeline.
### 4.6.1 Download Delivery Characteristics of Live DASH services:
Key characteristics, pertaining to download delivery, of implementations of
Live DASH services delivered over eMBMS include the following:
\- A single MBMS Download Delivery Session (aka FLUTE session) is used to
carry all media components of the DASH Media Presentation, which comprises
either as a single, multiplexed Representation, or separate Representations,
each carrying a different media type.
\- Although the segment URLs may be known from a segment template in the MPD,
these files cannot be fully described in an FDT Instances until they are
available for broadcast transport on the BM-SC.
\- File repair is not supported for Live DASH services due to stringent
playout delay requirements, and as such, minimizes the amount of time that
incomplete files have to be retained in the device.
\- Service announcement metadata fragments which may be dynamically updated
are delivered inband with the Media Segments on the same MBMS download
delivery session, and potentially broadcast throughout the service session.
\- The session schedule of the Schedule Description fragment is used to signal
the nominal broadcast delivery window of the live event.
### 4.6.2 Relevant/Necessary Tools
The following MBMS and 3GP-DASH mechanisms as specified in TS 26.346 and TS
26.247 are necessary to support the required capabilities for the above use
case. These represent key aspects of the download delivery profile to be
defined and aspects of use that needs profiling.
\- MBMS download delivery method to carry the Media Segments of the Live DASH
service, in either multiplexed or non-multiplexed form as defined in TS
26.247.
\- Use of the Schedule Description metadata fragment to convey the planned
broadcast delivery window of the associated service event.
\- Use of new FDT Instances describing new Segments as the Segment become
available.
\- Use of the FDT Instance\'s _Expires_ attribute to indicate when individual
Segment transmission is expected to end.
\- Use of interleaved vs. sequential transmission of separate Media Segments
(e.g., audio and video).
\- Use of inband metadata fragments (Schedule Description, MPD, and ADPD
fragments) transmitted in interleaved fashion with Media Segments.
\- Use of new FDT instances to describe new in-band metadata fragment updates.
\- Use of the FDT\'s _Expires_ attribute to indicate that inband fragments are
transmitted through end of the session.
## 4.7 Scores and Statistics Service
### 4.7.0 General
eMBMS service provider \'Hoopster.com\' offers NBA basketball scores and
statistics information as an eMBMS download delivery service. During the
regular NBA season, and across evening hours and weekend afternoons, files
containing live scores and other statistical information on players and teams
are broadcast on this service. The size of a given file ranges from 10 kB to
25 kB, with average size of 20 kB.
Based on contractual agreement between Hoopster.com and the NBA (the content
owner) to support fast and up-to-date service acquisition, regardless of when
the subscriber chooses to monitor the service, the latest version of service
files is transmitted repeatedly, back-to-back, on the allocated MBMS bearer.
Files are nominally updated every 120 seconds, although dynamic changes may
occur at any time, for example to provide real-time announcement of final
scores of games and leading scorer information as these transpire. The nominal
update interval of the content delivered by the service is delivered to the
UE. The MBMS client monitors the delivered content at that nominal update
interval.
### 4.7.1 Download Delivery Characteristics of the \"Scores & Statistics\"
Service
Key characteristics of eMBMS download delivery of the \"Scores & Statistics\"
(S&S) Service include the following:
\- The Sports Scores and Statistics service is an example of the back-to-back
(carousel) Datacasting service. Its contents are associated with a nominal
update period but for which dynamic changes may occur at any time and are
delivered immediately on the dedicated FLUTE session.
\- This service may be always-on, meaning that content is
continuously/repeatedly delivered on the assigned MBMS Download Delivery
session of the service, or it may be active during certain times of the day or
week, i.e. represented by one or more delivery sessions each of which is
associated with a transmission window. In the latter case, the duration of
each active delivery session is defined by the difference between the _start_
and _stop_ elements of the _sessionSchedule_ of the Schedule Description
fragment.
\- The Schedule Description fragment for the service describes when the
service is active, and the frequency of file updates.
### 4.7.2 Relevant/Necessary Tools
The following MBMS mechanisms as specified in TS 26.346 are necessary to
support the required capabilities for the above use case. These represent key
aspects of the download delivery profile to be defined and aspects of use that
needs profiling.
\- MBMS download delivery method to carry the content components of the S&S
service.
\- Use of different FDT Instances to describe file changes by using the same
file name for different content vs. the use of different file names for the
different content.
\- Use of different FDT Instances to describe the different file versions for
the same file URL (i.e. _Content-Location_), with respect to the FDT
Instances\' _Expires_ attribute for each instance.
\- Capability of the Schedule Description fragment to define nominal
periodicity of updates on the S&S service to enable more battery power
efficient means of consuming this service.
## 4.8 Digital Signage Service
### 4.8.0 General
eMBMS service provider \'DigSign\' deploys digital displays of advertisements
and other types of information throughout the city. These are targeted to
fixed-location digital display signs which contain LTE Broadcast receivers
with limited memory. Files contain a sequence of images that make up an ad.
Each file can be up to 1 MB in size. DigSign updates two times a day a set of
10 ad files being displayed and uses the mobile operator \"BigFriendly
Wireless\" eMBMS service to deliver these updates.
### 4.8.1 Download Delivery Characteristics of the Digital Signage Service
Key characteristics of eMBMS download delivery of the Digital Signage service
include the following:
\- The Digital Signage service (\"DigiSign\") is an example of a \"sent-once\"
delivery, where a sequence of files is sent during a delivery session. Each
file is broadcast exactly once during a delivery session. In this use case,
there are two delivery sessions per day.
\- The Schedule Description fragment for the service describes when the
service is active, and the frequency of file updates.
\- MBMS receivers determine from the Schedule Description fragment the precise
start and stop times of each delivery session from the _sessionSchedule_
element.
\- MBMS receivers determine the delivery interval of upcoming files and
whether a certain file should be picked up or not based on the _fileSchedule_
element, whose _deliveryInfo_ child element defines the reception window.
### 4.8.2 Relevant/Necessary Tools:
The following MBMS mechanisms as specified in TS 26.346 are necessary to
support the required capabilities for the above use case.
\- MBMS download delivery method to carry the content components of the
DigSign service.
\- Use of different FDT Instances to describe file updates by using the same
file name for different content vs. the use of different file names for the
different content.
\- Use of different FDT Instances to describe the different file versions for
the same file URL (i.e. _Content-Location_), with respect to the FDT
Instances\' _Expires_ attribute for each instance.
\- Capability of the Schedule Description fragment to define delivery session
duration. This enables the MBMS receiver to power-off between delivery
sessions for battery savings.
\- Capability of the Schedule Description fragment to provide file URLs and
define a file schedule for each file. That enables a device to efficiently
filter content based on the file URL (e.g. the file URL may contain some
application defined semantics like http://example.com/service-1/image.png) and
file schedule.
# 5 Profile Definition
## 5.1 Introduction
The following criteria are considered when defining a profile:
\- A profile should be backed by one or more use cases
\- A profile should refer only to features and behaviours that are already
defined in TS 26.346 [4].
## 5.2 Delivery Profile
### 5.2.1 FDT Attributes and Elements
#### 5.2.1.1 Introduction
Characterization of the relevant FDT attributes and elements of the Download
Delivery Profile is described in this clause. FDT attributes and elements are
categorized at the FDT-Instance level (i.e. the _FDT-Instance_ element of the
FDT) and at the File level (i.e. the _File_ element of the FDT).
#### 5.2.1.2 Common FDT-Instance and File Attributes
The following FDT attributes, defined at both the FDT-Instance and File
levels, should be carried in the FDT sent by the FLUTE sender, under either
the _File-Instance_ or _File_ element, and should be supported by the FLUTE
receiver:
\- Content-Type
\- FEC-OTI-FEC-Encoding-ID
\- FEC-OTI-Maximum-Source-Block-Length
\- FEC-OTI-Encoding-Symbol-Length
\- FEC-OTI-Scheme-Specific-Info
The following FDT parameters, defined at both the FDT-Instance and File
levels, should not be carried in the FDT sent by the FLUTE sender, in either
the _File-Instance_ or _File_ element, and are optional to support by the
FLUTE receiver:
\- Content-Encoding attribute
\- FEC-OTI-FEC-Instance-ID attribute (not applicable to Rel-9 FEC schemes)
\- FEC-OTI-Max-Number-of-Encoding-Symbols attribute (not applicable to Rel-9
FEC schemes)
\- Group element
#### 5.2.1.3 FDT-Instance specific Attributes and Elements
The following parameters, defined at the FDT-Instance level, should not be
carried in the FDT sent by the FLUTE sender, and are optional to support by
the FLUTE receiver:
\- Complete attribute
\- mbms2008:FullFDT attribute
\- mbms2012:Base-URL-1 element
\- mbms2012:Base-URL-2 element
\- MBMS-Session-Identity-Expiry element
#### 5.2.1.4 FDT File specific Attributes and Elements
The following attributes, defined at the File level, should be carried in the
FDT sent by the FLUTE sender, and should be supported by the FLUTE receiver,
subject to the qualifications indicated below:
\- Content-Location
\- The value of this attribute should not contain \"//\", except when used as
part of the URL format (i.e. following \"scheme\" concatenated with \":\"
(e.g. http://). In addition, FLUTE sender apply URL safe encoding by proper
escaping/encoding of reserved characters to generate a well-formed URL.
\- TOI
\- Content-Length
\- Content-MD5
\- Should not be included for DASH-formatted services.
The following element may be carried in the FDT sent by the FLUTE sender, and
should be supported by the FLUTE receiver:
\- mbms2007:Cache-Control
The following attributes may be carried in the FDT sent by the FLUTE sender,
and should be supported by the FLUTE receiver. These attributes should only be
present for the purpose of replacing/overriding corresponding attributes at
the FDT-Instance level.
\- Content-Type
\- FEC-OTI-FEC-Encoding-ID
\- FEC-OTI-Maximum-Source-Block-Length
\- FEC-OTI-Encoding-Symbol-Length
\- FEC-OTI-Scheme-Specific-Info
The following attributes should not be carried in the FDT sent by the FLUTE
sender, and are optional to support by the FLUTE receiver:
Transfer-Length
\- mbms2009:Decryption-KEY-URI
\- mbms2012:FEC-Redundancy-Level
\- mbms2012:Alternate-Content-Location-1
\- mbms2012:Alternate-Content-Location-2
\- MBMS-Session-Identity
Figure 1 illustrates the 3GPP FLUTE FDT Schema for which the specified usage
for the Download Delivery Profile is described in this clause.
Figure 1: 3GPP FLUTE FDT Schema
### 5.2.2 Version and Delimiter Schema
The present document defines two XML Schema elements necessary for the UE and
the network side to maintain forward and backward compatibility:
_schemaVersion_ and _delimiter_. These elements are used by the following
schemas: USBD, Schedule Description, Filter Description and FDT. This Download
Delivery Profile supports _schemaVersion_ = \"1\" for the FDT. The supported
_delimiter_ element has value = \"0\" as set by the network, and the element
content should be ignored by the UE.
### 5.2.3 RTSP Control of FLUTE Sessions
\"FLUTE session setup and control with RTSP\" as specified in clause 7.5 of
the present document is optional to support by the UE.
### 5.2.4 Other Aspects of FLUTE Delivery
Regarding Application Layer FEC support, the two FEC schemes referenced in the
present document, the Compact No-Code FEC scheme as specified in RFC 5052 [5],
and the Raptor FEC scheme as specified in RFC 5053 [6] are optional to
implement by the BM-SC and mandatory to support by the UE. File fragmentation
into blocks is supported. In the case of the Compact No-Code FEC scheme, the
blocking algorithm as defined in RFC 3695 [7] should be used. For the Raptor
FEC scheme, specification of the blocking algorithm should comply with the
recommendations on the derivation of the relevant parameters as defined in RFC
5053 [8].
As indicated in clause 7.2.4 of the present document, congestion control is
not used for FLUTE delivery in MBMS, and therefore, FLUTE channelization
should be provided by a single FLUTE channel with single rate transport.
Regarding FLUTE session description, an instance of Session Description
fragment, comprising an SDP file, will contain all parameters as defined in
clause 7.3 of the present document.
The LCT Header Extension \"EXT_FTI\" as defined by ALC in [10], for the
purpose of communicating FEC Object Transmission Information, should be used
in FLUTE packets that carry symbols of FDT Instance(s). FEC Object
Transmission Information in FLUTE packets which carry symbols of content files
should be conveyed by the FEC-OTI parameters in the FDT, and for which the
expectations on network usage and UE support are specified in clauses 5.2.1.1
and 5.2.1.2.
The means to signal the end of the FLUTE session or the end of individual file
transmissions is provided by the Schedule Description fragment, via the
session schedule and file schedule elements. The LCT header\'s \'Close
Session\' flag (A) and \'Close Object\' flag (B) should be set by the network
to \"0\", and the UE should ignore these flags.
Timing related fields in LCT corresponding to Sender Current Time (SCT) and
Expected Residual Time (ERT), either in the form of the T and R flags in the
LCT header, or carried in the LCT Extension Header \'EXT_TIME\', are not used
in the Download Delivery Profile. The network should set these flags/fields to
zero, and the UE should ignore them.
# 6 MBMS as a Transport Protocol
## 6.1 URL Handling Interface
The URL handling interface is described graphically by the diagram in Figure
2. All the boxes except for the yellow, bold, box are pre-existing and no
change is needed. An application might, for example, be written to use MBMS
services using the MBMS API (left side of the diagram). Or, it may be written
to support URLs that address \'file\' resources, and use a generic operating
system URL resolution library (\'URL Dispatch\' in the diagram) to return the
identified resource when it encounters one. The \"file\" resource may be an
entry point to a service and it may be the case that there is a default file
defined for a service (just as done today if you use http to access a web
site). That library, in turn, identifies the specific protocol handler from
the URL scheme name (e.g. \"http:\", \"mbms:\"), and invokes the appropriate
protocol-specific handler. The interface to that handler is determined by the
operating system also; internally, the MBMS handler picks apart the URL form,
and, possibly using the existing MBMS APIs, initiates the acquisition of the
MBMS service that permits access to the identified resource, and acquisition
of the indicated \'file\' resource from that session, and returns that
resource. Note that the MBMS function may also act as an MBMS URL handler.
{width="4.014583333333333in" height="4.097222222222222in"}
Figure 2: MBMS URL Handler
## 6.2 URL Scheme Variants
### 6.2.1 Self-contained URL (No resolution/USD)
(Note that the use of \"&\" here is **_not_** part of a query or fragment, as
there is no preceding \"?\" or \"#\". \"&\" is in the main body of URLs where
it is a legal character.)
The mid-part has three elements, each optional.
1) The start-time of the viability of the URL, indicated by the string
\"&start=\" and a decimal value.
2) The end-time of the viability of the URL, indicated by the string \"&end=\"
and a decimal value.
3) Possibly only in the case of the first variant, zero or more indicators of
the networks on which the resource is available, indicated by the string
\"&plmn=\" followed by the PLMN-Id of a network expressed as 6 hexadecimal
characters.
The start and end times are each optional and if present are expressed exactly
as in SDP (see the \"t=\" value), i.e. as the decimal representation of
Network Time Protocol (NTP) time values in seconds since 1900.
The suffix consists of the string \"&label=\" followed by the content-label of
a resource, expressed as its URI, without any escaping.
If the suffix is absent, then the MPD included in the USD is returned. [[Ed:
We do not have to do this defaulting, and it would have been cleaner if the
USD had identified the root or default resource in general, rather than having
special handling for DASH MPDs; then, for example, a web session could have
identified the root HTML file as the default.]]
Note that the suffix may include a fragment or query identifier (preceded by
\"#\" or \"?\" respectively), although query identifiers are not really
relevant to the service.
Note that the \"//\" means that the MBMS scheme is hierarchical and that
relative URLs are permitted, and that they would be effectively composed
against the label part. This means that, for example, an explicit or implied
base URL in an MPD may be an MBMS URL, and that relative URLs in the MPD can
be composed against that base.
[[Ed: the \'defaulting\' to the included MPD, above, means that relative URLs
may get messed up; needs study.]]
### 6.2.2 URL Scheme with ServiceID
#### 6.2.2.1 Overall Form
The form described here uses a URN in the prefix part; if only this form is
adopted, parsers check for the existence of \"urn:\" and cease parsing if it
is absent. [[Ed: it might need an explicit indication of this variant, e.g. by
saying \"serviceID=\" after the \"//\" and before the URN]]. This URN form
relies on the terminal reception of USD files over the MBMS signaling channel.
The prefix consists of the scheme name \"mbms\", followed by a colon character
and two slashes, and a URN. The prefix terminates either at the end of the
URL, or at the first character not permitted in a URN (an \'excluded
character\' from the URN RFC, such as \"&\").
The URN is formatted the same as the value of the serviceID attribute in a
USD, and will be matched to a serviceID. (Note that TS 26.346 explicitly
describes this as a URN, not a URI, so a URL is not permitted.)
example:
mbms://urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66
#### 6.2.2.2 Example
mbms://urn:uuid:6e8bc430-9c3a-11d9-9669-0800200c9a66&plmn=3a06de&label=http://www.example.com/content.mpd
#### 6.2.2.3 Operation of the URL Handler
When the terminal initializes, or at some time preceding the first request to
the MBMS URL Handler, the terminal\'s MBMS function opens the SACH signalling
channel and receives, and caches, the USDs that are sent on that channel. In
those USDs it finds the unique serviceID attribute value, defined to be a URN
by TS 26.346, and indexes the received USDs by this serviceID URN value. (This
channel is REQUIRED for variant 1, but not for variant two.)
Each URL is passed to the MBMS URL handler for resolution.
First:
\- the handler checks the start and end times, if present, as above;
\- if the URL has one or more PLMN mid-part values, and the PLMN-ID of the
current network is operating matches none of them, it returns with error (400,
Bad Request?). If there are no PLMN-Ids in the URL, then the URL handler
should continue and assume the resource/session are generally available, or
that other means have been used to assure that the URL is only passed to
terminals able to use it.
If these checks pass, the MBMS URL handler then checks to see if the serviceID
of the URL matches one of the services it is already receiving (it has already
initiated reception e.g. through the API). If it is already being received, it
moves ahead to return the resource at the time when the resource is available.
Otherwise, since the MBMS service described by the USD is not currently open,
it causes the USD with the matching ServiceID to be opened (again, possibly
using the API; if a match cannot be found, it returns with error (404? Service
Unavailable?).
Note, this assumes that all USDs have arrived before any URL request is made
for them.
If it can be found, it causes the session to be opened. The terminal therefore
starts to receive the contents of that session, particularly the FDT and the
files described by it, and the terminal caches the included files as they
arrive (see below for more discussion of caching).
### 6.2.3 Non-restricted MBMS URL Scheme
#### 6.2.3.1 MBMS URL Scheme Syntax and Semantics
An MBMS URL cannot put any restrictions on the authority, path, or query parts
of the URL according to the IETF guidelines. This will avoid collisions,
dilution, and rigidity of the URL and thus increase its utility drastically.
In order to support unicast fallback, The MBMS URL includes an indication of
the URL of the resource that is accessible over unicast. This is done by
mapping the unicast URL scheme to the MBMS URL scheme and keeping the rest of
the URL intact.
Finally, this MBMS URL scheme supports MooD by enabling redirection to the
unicast location of the requested resource.
The MBMS URL has the following ABNF syntax:
_scheme = mbms-scheme \"://\" host [\":\" port] \"/\" path\ mbms-scheme =
\"mbms-http\" \| \"mbms-https\" \| \"mbms-rtsp\"_
_The scheme part of the URL contains the unicast protocol scheme that should
replace the MBMS URL scheme when unicast fetching is required._
The authority part of the URL is exactly the same as that of original unicast
URL. The authority part of the URL including \ and \ is specified
in RFC3986.
For example, a resource that has the following URL over unicast:
https://www.example.com/resource.mpd would have the following MBMS URL:
mbms-https://www.example.com/resource.mpd
#### 6.2.3.2 Address Resolution
Upon receiving a request for an MBMS URI, the MBMS scheme handler first
resolve the address to locate it.
The address resolution procedure consists of the following steps:
\- Operating system/browser launches the MBMS protocol handler with the
requested MBMS URL
\- MBMS protocol handler checks local cache for already received resource with
MBMS URL or the corresponding unicast URL and if found returns the resource to
the receiver
\- If the resource is not located in the local cache, the MBMS protocol
handler checks its cached USDs and Schedule Description Metadata fragments for
the occurrence of the URL as part of a fileSchedule or an appService. If
found, the MBMS protocol handler will check for the scheduled time of delivery
of the resource/stream and if suitable/acceptable for the application, it will
schedule reception of the resource/stream over broadcast.
\- If the resource is not found, the MBMS URL scheme handler will revert to
MooD for receiving the resource/stream. It sends the request using the unicast
URL to the MooD proxy server, which will either retrieve the resource over
unicast or redirect the receiver to MBMS reception.
Note: An appropriate API for passing the requested resources and error
handling is considered as part of the API work.
### 6.2.4 Parameter-less URL structure and definition
#### 6.2.4.1 Introduction
This MBMS URL design and its handling aim to satisfy the following
requirements:
1) The URL scheme complies with the guidelines specified by the IETF in RFC
2782
2) The URL scheme supports both resources delivered over HTTP as well as
RTSP/RTP streaming sessions
3) The MBMS URL handling supports fallback to unicast delivery if the
requested resource is not available over MBMS
4) The MBMS URL handling supports MooD by resolving automatically to either a
unicast or broadcast location
This MBMS URL does not put any restrictions on the authority, path, or query
parts of the URL according to the IETF guidelines. This will avoid collisions,
dilution, and rigidity of the URL and thus increase its utility drastically.
In order to support unicast fallback, The MBMS URL includes an indication of
the URL of the resource that is accessible over unicast. This is done by
mapping the unicast URL scheme to the MBMS URL scheme and keeping the rest of
the URL intact.
Finally, the MBMS URL supports MooD by enabling redirection to the unicast
location of the requested resource.
The MBMS URL has the following ABNF syntax:
_MBMS-URL = mbms-scheme "://" host [":" port] "/" path\ mbms-scheme = "mbms"_
The authority part of the URL is exactly the same as that of the original
unicast URL. The authority part of the URL including \ and \ is
specified in RFC3986.
As an example, a device manufacturer wishes to distribute a major firmware
update to its devices. The firmware update is accessible under the following
URL:
> https://www.manufacturer.com/firmware/version10.bin
The device manufacturer wishes to use MooD on certain operators to efficiently
distribute the update. For these operators, it provides the following URL:
> mbms://www.manufacturer.com/firmware/version10.bin
If a large number of requests is measured, the operator will change the DNS
records to point to MBMS distribution. All following requests will then be
served over broadcast.
## 6.3 DNS Resolution of MBMS URLs
### 6.3.1 URL structure and definition
#### 6.3.1.1 Structure
The URL is composed of a prefix, mid-part, and suffix.
#### 6.3.1.2 Prefix
The prefix consists of the string mbms:// followed by a hostname, or an
explicit IP4 or IPv6 address, followed by a ":" and a portnumber. The use of
explicit IP addresses enables a DNS step to be avoided; however, the use of
DNS enables the same URL to serve on many networks, resolving on each to the
correct TMGI, so the explicit address form is less flexible. The default port
number may be defined in TS 26.346; no default is currently defined and it
needs to be supplied explicitly.
Explicit IP addresses may be used only if it can be assured that the URLs will
only be served to terminals that can use them. Both the IPv4 forms (e.g.
mbms://225.34.12.9.77:56852/) and the IPv6 form using "[" and "]" may be used
(e.g. mbms:://[2001:db8::7]:65432/).
#### 6.3.1.3 Mid-part
The mid-part has three elements, each optional.
1) The start-time of the viability of the URL, indicated by the string
"&start=" and a decimal value.
2) The end-time of the viability of the URL, indicated by the string "&end="
and a decimal value.
3) Zero or more indicators of the networks on which the resource is available,
indicated by the string "&plmn=" followed by one or more PLMN-Ids of a network
each expressed as 6 hexadecimal characters and separated by \"+\".
The start and end times are each optional and if present are expressed exactly
as in SDP (see the "t=" value in [[ref needed: **SDP: Session Description
Protocol, RFC 4566]]**), i.e. as the decimal representation of Network Time
Protocol (NTP) time values in seconds since 1900. The default start time is
the indefinite past; the default end time is the indefinite future.
(Note that the use of "&" here is **_not_** part of a query or fragment, as
there is no preceding "?" or "#". "&" is in the main body of URLs where it is
a legal character.)
#### 6.3.1.4 Suffix
The suffix consists of the string "&label=" followed by the content-label of a
resource, expressed as its URI, without any escaping.
If the suffix is absent, then implied label is the filename identified as the
default by the USD.
The suffix is terminated by a fragment or query identifier (preceded by "#" or
"?" respectively), if present, or by the end of the URL if they are absent.
#### 6.3.1.5 Query and fragment parts
A query may be present, after the suffix, identified by its initial \"?\".
However, there is no processing defined for queries.
Similarly, a fragment may be present, identified by its initial \"#\".
Fragments are processed according to the definitions for the provided
resource.
#### 6.3.1.6 Relative URIs
Note that the "//" means that the MBMS scheme is hierarchical and that
relative URLs are permitted, and that they are effectively composed against
the label part. This means that, for example, an explicit or implied base URL
in an MPD may be an MBMS URL, and that relative URLs in the MPD can be
composed against that base.
### 6.3.2 URL Processing
#### 6.3.2.1 Pre-flighting
The MBMS URL handler, on receipt of a request for a resource identified by a
URL, performs the following pre-flight checks:
a) if the URL has a start mid-part value, and the value is in the future, it
returns an error (503, service unavailable)
b) if the URL has an end mid-part value, and the value is in the past, it
returns with error (503, service unavailable)
c) if the URL has a plmn mid-part value, and the terminal is operating on a
network that is not in the list of PLMN-Ids, it returns an error (400, bad
request)
#### 6.3.2.2 Initializing the service
##### 6.3.2.2.1 Introduction
Initialization of the service involves locating and processing the USD. This
may be done in one of two ways. If the service has already been initialized
(see below under Caching and Keep-alive) then this step is skipped.
The service filename is indicated by the prefix part of the URL, without any
port-number.
The USD would need to be available on either or both (a) the signalling
channel or (b) in-band in the channel it describes. The USD would preferably
always be made available in-band.
##### 6.3.2.2.2 Signalling Channel Initialization
If the terminal has been configured to use the SACH (signalling channel), then
the USD is first sought by matching the prefix part of the URL (the initial
part preceding the first \"&\", with any explicit port number removed) with
the filenames received on the signalling channel. If a match is found, that
USD is retrieved and the session initialized from it.
If no matching filename is found, the handler may wait for it to arrive, or
may proceed to use in-band initialization.
##### 6.3.2.2.3 In-band initialization
If the terminal does not use signaling channel initialization, or the USD is
not found there or not found in time, then in-band initialization would
preferably be attempted.
If an explicit address is not used (IPv4 or IPv6), then the hostname is
resolved to a multicast IP address using standards DNS lookup. The domain name
server used to resolve the name to an address has to be 'sensitive' to the
network on which the terminal resides, i.e. return a result that is valid for
that network. If the MBMS session is not available on the network, the DNS
query has to either fail or return all zeroes in the lower part of the
returned IP address.
In the case of IPv4, the address is of the form 0xE1xxxxxx where xxxxxx is the
24 bits MBMS Service ID. Since the name resolution detected and used the
information as to what network the terminal is on, this is an MBMS Service ID
valid for the PLMN-ID (MNC/MCC) of that network; the TMGI is therefore the
terminal's known PLMN-ID and this MBMS Service ID.
Similarly in the case of IPv6 the MBMS Service ID is embedded in the lowest 24
bits of the IPv6 multicast address; the entire address, including the other
104 bits need to be a valid IPv6 multicast address.
The channel identified by the composed TMGI is opened and FLUTE reception
initiated. The FDT is scanned for a resource whose filename is identified by
the URL prefix (just as for the signaling channel). If no such file is found,
the handler returns a suitable error (404, not found). Otherwise, the USD that
has a filename equal to the prefix part of the URL is retrieved and the
session initialized.
If no FDT can be found on either the signaling channel or in-band, within a
timeout period, then an error is returned (408, timeout).
#### 6.3.2.3 Retrieving and returning the resource
The label part of the URL identifies the desired resource.
If it is missing the default label is the file identified by the USD. This
label is returned by the MBMS handler in the same manner as an HTTP redirect
would be returned from an HTTP handler. The application would normally then
request this resource, and also use this URL as the basis for relative URL
resolution.
If the label does not match any content-location entry in the FDT, the
resource is not available on that session and the handler returns an error
(404, not found).
Otherwise, the handler waits until the MBMS handler has received the file with
the given content-location (it may be already cached, whereupon no wait is
required), and returns it with the content-type, content-encoding, etc. as
indicated in the FDT.
If the API request for the MBMS URL indicated a time-out, and the requested
resource has not arrived in the time-out period, then an error is returned
(408, timeout).
#### 6.3.2.4 Caching and keep-alive
The MBMS URL handler maintains the session open for a keep-alive time after
each request determined by the implementation, expecting further requests for
other files from the same session.
The files identified in the FDT are cached. Each such file is described by a
content-location, which is a URI. If that content-location URI form uses the
scheme-name of another protocol (e.g. "http:") then the resource is ideally
cached in a cache shared between the MBMS URL handler and that other protocol.
In this way, after the session is initiated, it is possible that, for example,
a request to the HTTP URL handler for a resource can be satisfied by a file
that has arrived and been cached by the MBMS URL handler.
When operating in an environment that permits arrival notifications (e.g. web
push or other events), as each file arrives a notification may be sent.
### 6.3.3 Example
_Example:_ \
mbms://soapopera.example.com:8054/episode1.usd&start=X&label=http://example.com/tv/episode3.mpd
DNS on soapopera.example.com yields a multicast address 0xE1xxxxxx where
xxxxxx is the TMGI, and is combined by the terminal with the currently PLMN-ID
(MCC/MNC) to form the MBMS Service ID. The port number is supplied explicitly
here (8054).
The label of the USD is mbms://soapopera.example.com: 8054/episode1.usd
The label of the desired resource is http://example.com/tv/episode3.mpd
### 6.3.4 DNS Resolution Using SRV Records
#### 6.3.4.1 Introduction
While the most widely used DNS resource record request is the A request, which
just provides the IPv4 address for a certain domain name, it is certainly not
the only use of DNS.
3GPP specifies the usage of DNS SRV and TXT records for several of their
functions, including selection of S-GWs and P-GWs. The 3GPP DNS procedures are
defined in TS 29.303 [14].
In particular, DNS SRV RRs [15] are widely used for providing services with
load balancing and service discovery.
#### 6.3.4.2 DNS Resolution of Parameter-less MBMS URLs
Currently, MBMS supports 3 different delivery methods: streaming, download,
and group communication. Depending on the delivery method, the following
resource types need to be addressed:
  * A media streaming session that uses the streaming delivery method
  * A single file that uses the download delivery method
  * A set of related files (object flows) that are delivered using a download delivery method (e.g. DASH over MBMS)
  * A group communication session that delivers multicast UDP datagrams
Based on the resource type and delivery method, a set of information is needed
in order to locate the resources and be able to access them. This information
is currently scattered in multiple locations:
  * User Service Description
  * Schedule fragment
  * SDP of the delivery method
The User Service Description provides information about the service
identifier, the delivery methods, the FEC configuration for bundled
protection, access randomization parameters, and radio access information.
The Schedule fragment provides information about transmission time windows and
repetition frequencies for each resource as well as resource URL and version.
The SDP provides information about the protocol, source IP addresses,
destination multicast IP address and port number, media format, TMGI, protocol
dependent information such as TSI.
In order to enable DNS resolution of the URLs of resources that are
potentially delivered over MBMS, a set of DNS Resource Records need to be
used.
The DNS SRV Resource Record (RR) is used to provide the following information:
  * Multicast IP Address
  * Port Number
The MBMS SRV RR follows the format specified in [2] as follows:
> __mbms._UDP.Request_FQDN TTL IN SRV Priority Weight Port
> service_id.BMSC_DN._
The Port field corresponds to the destination port number of the service
announcement channel (SACH). The target also contains the the service
identifier of the MBMS User Service that carries the resource as part of the
domain name of the BM-SC that is serving the content over MBMS.
The following is an example of an SRV RR for the MBMS service:
_mbms._udp.example.com. 14400 IN SRV 1 100 23412 938471323.mbms.operator.com.
The response also contains an A or AAAA record for the target and it
corresponds to the multicast IP address of the SACH.
The A RR is specified to follow the following format:
owner-name ttl class rr ipv4
The following is an example of a corresponding A RR:
938471323.mbms 14400 IN A 224.100.32.1
If no resources for the specified domain are being served over multicast, then
the response only contains an A RR that points to the unicast address that
resolves for the FQDN of the corresponding unicast URL.
Additionally, in case of broadcast delivery, a TXT resource records is
returned to the user, containing additional parameters. The following
parameters are defined:
ServiceId: the MBMS service id that needs to be used to locate the USD for the
MBMS user
service that carries the required resource.
An example of such a TXT RR is given as follows:
938471323.mbms 14400 IN TXT \"service-id=938471323\"
#### 6.3.4.3 Resource Retrieval
Upon receiving the response to the DNS query on the MBMS URL FQDN, the MBMS
scheme handler will perform the following steps:
  * If the DNS query response contains an A record that points to a unicast address, then the MBMS scheme handler assumes that the resource is currently not served by MBMS and the requested resource is retrieved using HTTP/HTTPS and the resolved unicast address (the decidion whether to using HTTP or HTTP over TLS depends on the rest of the HTTP requested to avoid any CORS or mixing of request types issues).
  * If the DNS query response contains an SRV RR and a TXT RR that provide a service-id NVP, then the MBMS scheme handler performs the following:
```{=html}
``` \- MBMS protocol handler checks local cache for already received resources
with the MBMS URL or the corresponding unicast URL and if found returns the
resource to the application.
  * If the resource is not located in the local cache, the MBMS protocol handler checks its cached USDs and Schedule Description Metadata fragments for the occurrence of the URL as part of a fileSchedule or an appService. If found, the MBMS protocol handler checks for the scheduled time of delivery of the resource/stream and if suitable/acceptable for the application, it schedules reception of the resource/stream over broadcast.
  * If the requested resource is described in one of the existing USDs but the distribution time does not fulfill the requirements of the application, then unicast retrieval (potentially through a MooD proxy) is attempted.
  * If the resource is not found, the MBMS URL scheme handler reverts to unicast retrieval (potentially using MooD for receiving the resource/stream).
Appropriate API support for the communication between protocol handler and
application will be considered as part of this work.
# 7 Application Programming Interface (API) Aspects
## 7.1 Architectures
### 7.1.1 Service Layer Architecture and Scope
Figure 3 shows a service architecture for DASH-based streaming services over
MBMS. This use case is explained exemplary, but considered also as the most
relevant one. On the network side, a content provider uses DASH formats and
provides these formats to a BM-SC. The BM-SC is controlled by an eMBMS
provisioning system. The lower layers support the physical delivery of the
data through regular LTE unicast as well as MBMS broadcast bearers. The MBMS
client receivers the data and provides the data to the DASH client, but also
communicates with an application in the device. The application may for
example be a dedicated app or a common browser and the application is
controlled by JavaScript. The MBMS client provides the information to the DASH
client.
Today TS 26.346 defines the interface between the BMSC and the MBMS client for
both unicast and broadcast related services and functions. The interface
between the MBMS client and the application are not specified. The focus of
TRAPO and API are the interfaces between the application and the MBMS client
as well as the mapping of the methods and API calls to the transport protocol
between the MBMS client and the BMSC.
The DASH client may be viewed as part of the application, or it may be
considered as a separate entity. As 3GPP defines interfaces into a DASH client
in TS 26.247 [9] it is proposed to separate the DASH client function in the
architecture.
Figure 3: Service Architecture for DASH-over-MBMS
### 7.1.2 Client Architecture
A more refined client architecture is provided below in Figure 4 and two
functions are provided, the streaming application and the file download
application.
Different high-level functions are defined:
\- An application function that includes a streaming and/or file download
application.
\- The multimedia subsystem that includes a DASH client (as well as codecs and
other associated functions).
\- The DRM agent for providing secure processing of content.
\- Underlying eMBMS transport function.
\- The MBMS client that includes different functions according to TS 26.346.
{width="6.5in" height="3.0104166666666665in"}
Figure 4: MBMS Client Architecture
The specific interfaces MBMS-API and HTTP may be considered in scope of TRAPO
and API, but HTTP is mostly defined by TS 26.247 and possibly new work in the
SAND work in MPEG.
Therefore, the most relevant interfaces for the MEPRO work is MBMS-API in
order to get access to the MBMS service layer functions in a simple manner.
### 7.1.3 Deployment Scenarios
Different use cases and deployment scenarios may be considered:
1) The application and DASH client are on the same device as the MBMS client
and the LTE modem.
2) The application and DASH client are on a different device than as the MBMS
client and the LTE modem. The latter scenario is shown in Figure 5. In this
case MBMS-API and HTTP will be supported as network protocols. Whereas for
HTTP this already exists, for MBMS-API this is an open questions.
Figure 5: MBMS Client and Application in separate devices
## 7.2 Use Cases and Scenarios
### 7.2.1 Overview
In the following some use cases and scenarios that are considered relevant are
provided. In particular, the focus of the presentation is on the interaction
between application and MBMS client. Three different relevant use cases and
scenarios are addressed, i.e.:
\- Service Discovery and Bootstrapping
\- DASH-based streaming content and service change
\- File download
### 7.2.2 Service Discovery and Bootstrapping
In the following service discovery and bootstrapping is discussed. The call
flow in Figure 6 provides a call flow that includes the Application, the MBMS
client, the lower layer eMBMS service and the BMSC. Assume an application is
aware of an MBMS-based application and it registers with the MBMS client. The
MBMS client will then activate and download all User Service Description
information and informs the MBMS client about the available services. The
service information is as follows:
\- Service Id (unique identifier assigned by BM-SC)
\- Service class
\- Service language
\- Service Availability
\- List of service names (language and name)
\- MPD URI (for DASH streaming services)
{width="6.031944444444444in" height="4.052083333333333in"}
Figure 6: Service Discovery and Bootstrapping
The relevant APIs for service announcement are the Application Registration
and the available service list as indicated in bold and red.
### 7.2.3 DASH-based streaming content and service change
For the DASH-based streaming content a call flow is provided in Figure 6\. It
is assumed that the application has access to the service information
including the service ID and the MPD URL.
The following steps are carried out according to Figure 7.
\- Start Streaming service based on the serviceID:
\- This triggers actions in the MBMS client and eMBMS service to open a FLUTE
session.
\- Once completed, the application obtains a service start notification.
\- The application starts the service calling the DASH client with the
appropriate MPD URL as known from the service announcement.
\- The MBMS client and DASH client act by providing and consuming MPDs and
Segments for the DASH client.
\- The application may provide a stop message for the streaming service using
the ID:
\- The MBMS client will process accordingly and terminate the session.
> In summary the following notifications from the MBMS client to the
> Application may be provided:
\- Service started
\- Service stopped
\- Service error
\- Service stalled
{width="6.031944444444444in" height="4.052083333333333in"}
Figure 7: DASH Streaming Service with relevant APIs
### 7.2.4 File Download Service
For a file download service, a call flow is provided in Figure 8. It is
assumed that the application has access to the service information according
to the previous clause including the service ID and some file identifiers
(URLs, directories, etc.).
The following steps are carried out according to Figure 8:
\- After service discovery, the Application would request the MBMS client to
receive files. Examples include that the application is interested to receive
files to show program guide or the application is interested to download a
weekly/daily magazine:
\- The MBMS client initiates all the communication and setup and downloads the
file, including ADPs.
\- The MBMS client provides a file download notification to the application.
{width="6.495833333333334in" height="3.995833333333333in"}
Figure 8: File Download Service
### 7.2.5 Other services and Scenarios
Other services and scenarios may be considered on application level. This
includes:
\- service updates (MBMS client sends a service update notification to the
application)
\- information on broadcast coverage
\- Broadcast unicast handoffs
\- MooD redirections
### 7.2.6 Supported Use cases
In summary, the following use cases are considered in the above scenarios:
\- Play streaming service
\- Switching streaming service
\- Starting file download service
\- Receiving MPD updated notification
\- Receiving file available notification
\- Receiving service update notification
\- Receiving broadcast coverage notification
\- Receiving stalled notification
\- Configured service class
Two different approaches for the user plane APIs are documented in the present
document. These APIs have a significant amount of synergies and are expected
to be merged on a function basis to create the skeleton for the MBMS APIs.
### 7.2.7 Approach 1
#### 7.2.7.1 Introduction
The API provides model and controller implementation for a typical
application, for example a Java application on an Androidâ„¢ platform. The
envisaged architecture facilitates quick development of client Applications.
The API lets application developers concentrate on creating great apps instead
of worrying about the underlying Androidâ„¢ Services and management of
communication with those services.
Example services that may make use of service APIs are the following:
\- Firmware Over The Air (FOTA)
\- Weekly Magazine
\- Examples of streaming services
\- Live sports games
\- Live TV channels
The content associated with services is delivered in broadcast networks via IP
packets and logical access network channels. The broadcast network also
provides a service announcement function to describe the services available in
the network. Apps do not have to be aware of how services are delivered in the
network, but use the I-1 interface:
\- To discover available services
\- To request that the MBMS client to activate reception of data for the
available services.
The MBMS client identifies each service by a Service ID. The app has to use
the right service ID in any serviceÂ­specific request.
To use the API, the App should have the following information:.
\- App id -- The unique ID of the app.
\- Service Class info -- A set of services may be grouped together according
to a common classification. This group is called a service class. For example,
there could be a service class named \"sports\" which refers to all sports-
related services.
The list of service classes that the app is interested in has to be given to
the MBMS client while using the API. The MBMS client is able to give the data
only for those services that belong to this set of service classes.
#### 7.2.7.2 Network Architecture
From an overall network perspective, Figure 9 is an overview of network
elements typically associated with sending data to an app.
Figure 9: Overview of elements involved in sending data to the app running on
UE
#### 7.2.7.3 Modules
The following modules are:
\- Management Module
\- Streaming Module
\- File Delivery Module
\- Network Module
Depending on the use case, one or several of the above modules are involved.
#### 7.2.7.4 Use Cases and Message Flows
##### 7.2.7.4.1 Streaming application
A typical streaming app streams live videos to the user. The user typically
sees a list of available streaming services, and based on the user selection,
the app streams the video to the user.
The following use case call flow assumes that the user:
1) Opens the app.
2) Selects a streaming service from a list of services.
3) Switches to another streaming service.
4) Exits the app.
Figure 10 is the overview of the call flow for a typical streaming service
app.
Figure 10a: Streaming -- Typical call flow for a streaming service app (1 of
3)
Figure 10b: Streaming - Typical call flow for a streaming service app (2 of 3)
Figure 10c: Streaming -- Typical call flow for a streaming service app (3 of
3)
The call flow in Figure 10 is supported by the following actions that map to
communication of the MBMS client with the network. Those actions that map
against protocol information are highlighted.
initializeMBMSClient()
_The MBMS client acquires the MBMS service information from its bootstrap
information, namely by accessing the USD Bundle_
The MBMS client responds and acknowledge initialization
getStreamingController()
builds a framework
is internal to MBMS client and application
may be removed from the call flow
addStreamingEventListener()
provides communication channel for events
more an issue of implementation
may be removed from the call flow
initializeStreamingService(ServiceClass)
_mapping against the USD attribute r7:serviceClass_
{width="4.416666666666667in" height="3.21875in"}
Figure 11: USD Fragment
\- getStreamingServiceList()
\- filter the USD for streaming services (including an MPD URL) and associated
to service class
\- a list of service IDs is returned
\- startStreamingService(service ID)
\- _access and start downloading the segments into local cache_
\- _streamingServiceStarted informs app about the start of the service, i.e.
when the MPD is available_
\- getPlaybackURL (serviceID)
\- _returns MPD URL pointing to the local host_
\- application can now start the DASH client
\- switchStreamingService(service S1, service S2)
\- _starts and stops TMGI/FLUTE reception for S2 and S1_
\- _notifies app about the availability of the MPD for S2_
\- stopStreamingService (serviceID)
\- _stops TMGI/FLUTE reception for S2_
\- removeStreamingEventListener()
\- stops the event listener
\- more an issue of implementation
\- may be removed from the call flow
\- terminateStreamingService()
\- internal
\- implementation issue
\- may be removed from the call flow
##### 7.2.7.4.2 File Delivery application
Figure 12 is the typical overall call flow sequence of an app support file
delivery service. Subsequent clauses include the call flow sequences for
individual functions and other scenarios.
Figure 12a: FD -- Typical call flow for a file delivery service app (1 of 2)
Figure 12b: FD -- Typical call flow for a file delivery service app (2 of 2)
The call flow in Figure 7 is supported by the following actions that map to
communication of the MBMS client with the network. Those actions that map
against protocol information are highlighted.
\- First steps see above (all in 6-1)
\- getFileDeliveryServiceList()
\- _returns list to file delivery services that match service class_
\- _if there is a file schedule, then the list of file URLs will be added as
well_
\- startFileCapture(serviceID, file URI)
\- MBMS client hands file to application
\- The MBMS client will not store the file
##### 7.2.7.4.3 App -- Top 10 videos
In this clause, we look at a typical kind of app which downloads the top 10
videos of the day for the user. The following use case call flow assumes that
the user:
1) Opens the app.
2) Sees the top 10 videos of the day (may play a few videos).
3) Exits the app.
In this scenario, we look at how the app can avoid downloading videos over
subsequent days if they have already been downloaded the previous day as part
of that day\'s top 10 list. The unwanted older video files are also deleted
from the device.
The scenario also assumes that the Top 10 video files are always broadcasted.
The key issue is that in this use case, the context of the file bundle is part
of the application, only the application is aware that the set of files
constitute the Top 10 files.
There may be other cases for which the \"bundle\" is in the MBMS delivery, but
this is not the case in the below. Generally, such \"bundling\" of files
should be carefully checked and avoided as it overloads the MBMS client with
ESG-kind of data.
Figure 13a: Top 10 videos application (1 of 4)
Figure 13b: Top 10 videos application (2 of 4)
Figure 13c: Top 10 videos application (3 of 4)
Figure 13d: Top 10 videos application (4 of 4)
The call flow in Figure 13 is supported by the following actions that map to
communication of the MBMS client with the network. Those actions that map
against protocol information are highlighted.
### 7.2.8 Approach2
#### 7.2.8.1 Basic Principle
The APIs are separate in 3 main areas:
The mbms protocol allows the management of MBMS services. The following
function may be defined:
\- get the list of a service,
\- start to download files of a service,
\- get the list of files,
\- get the manifest file of an eMBMS service.
The HTTP protocol can be used by an application to acquire the files
downloaded in the cache. For instance a DASH client will acquire the AV
segments downloaded by the Middleware.
The socket API can be used for RTP stream consumption.
HTTP protocol and Socket API are used in order to work with traditional
players such as RTP player or DASH player.
#### 7.2.8.2 MBMS Protocol
##### 7.2.8.2.1 Introduction
This protocol allows the management of services (get the list of available
services). Moreover, this protocol allows to open, close a service and
download files carried in a service. A non-exhaustive list of possible APIs
are proposed in this clause.
##### 7.2.8.2.2 General APIs
Get the list of services (mbms://).
> It returns the list of mbms services\' URLs described in the Service
> Announcement.
Get the list of services (serviceClass).
> It returns the list of mbms services\' URLs described in the Service
> Announcement, filtered out by service class, i.e. the list of services whose
> _serviceClass_ attribute, within the USD, is equals to the given parameter.
##### 7.2.8.2.3 DASH service APIs
Open DASH service (mbmsServiceURL)
> It starts the download of the segments
Close DASH service (mbmsServiceURL )
> It stops the download of the segments and clears the cached segments
Get manifest (mbmsServiceURL )
It returns the local HTTP URL of the MPD.
In order to acquire files (mpd file, init segment and AV segment), the
application should be able to use an HTTP server.
##### 7.2.8.2.4 Download service APIs
Open service (mbmsServiceURL )
It starts the download of all available files. An event is sent to the
eventListener when a file is cached.
Close service (mbmsServiceURL )
It stops the download of all available file and deletes the cached files
Get manifest (mbmsServiceURL )
It returns a list of available files\' URLs for the given service.
Get file (fileURL)
If the file has already been cached, it delivers the file.\ If the file can be
downloaded/cached, it starts or schedules its acquisition. An event is sent to
the eventListener when the file is cached.\ If the file can\'t be downloaded,
it returns HTTP 404 error.
##### 7.2.8.2.5 Event listener APIs
Set Event Listener (eventListener)
Indicates to the middleware where its events to be thrown.
##### 7.2.8.2.6 Event List
File cached : file successfully downloaded and available from the cache
File download failure: the file could not be downloaded. Body of the event
provides details: service or file removed from the announcement, out of eMBMS
service coverage...
## 7.3 User Plane APIs
### 7.3.1 Introduction
The following functionalities are considered relevant on the interface:
\- Regular object delivery
\- Unicast broadcast handoff
\- Adjustment of availability times
\- Partial file handling
\- Cache status
\- Others
As part of the study of the user plane API interface, the present document
will:
\- address the relevant functionalities between the MBMS client and a generic
user agent when HTTP is used as the API
consider reuse of existing functionalities as much as possible with the
following preference:
\- Defined in 3GPP
\- Defined in IETF
\- Defined in MPEG SAND
### 7.3.2 Regular object delivery and Partial File Handling
For regular object delivery and partial file handling, TS 26.247 [4], clause
5.3.2 and 7.3.8 provide a possible solution.
Byte range requests and error handling are for further study.
### 7.3.3 Cache Status
#### 7.3.3.1 Revision of the Key Use Case
The main use case of interest in in SAND is to create an interface that can
handle DASH over MBMS including unicast. The DASH client needs to be steered
from the broadcast information to the unicast information and vice versa. In
an initial design this was accomplished by defining two BaseURLs in the MPD
and the DASH client is basically told which BaseURLs are available and which
ones not.
The assumed operational context is as follows:
\- A DASH-over-MBMS service with unicast fallback is provisioned;
\- The DASH client has obtained an MPD, from the MBMS client (received over
FLUTE as a Media Presentation Description fragment), which declares the
entirety of available Representations of the Media Presentations of the DASH-
over-MBMS service, and whereby one or more Representations are delivered over
the MBMS bearer(s) and one or more Representations are delivered over the
unicast bearer; Note that the MBMS receiver may act as a DANE, i.e. a network
entity that provides regular DASH content, but also does provide dynamic
operational hints, assistance or enforcement for the DASH client.
\- In the MPD unicast and broadcast Representations are only differentiated by
different URL patterns, most suitable by the use of different base URLs. In
the simplest way, the different base URLs may be expressed by different
**BaseURL** elements.
\- The USD (i.e. eMBMS service discovery framework) contains information that
enables the MBMS client to determine the transport mode (broadcast and/or
unicast) of any given Segment request from the DASH client, and the presence
of identical or alternative version(s) of the requested content by transport
mode.
In addition, it is assumed that the UE implements the HTTP/1.1 interface
between the DASH client and the MBMS client, the latter entity containing a
HTTP proxy/cache function. Such UE architecture is shown below in Figure 14,
which is a duplicate of Figure 4.2.1-1 in TR 26.848.
Figure 14: UE architecture employing HTTP/1.1 interface between MBMS client
and DASH client
#### 7.3.3.2 Potential Solutions
A potential solution is expected to be provided by MPEG Server and Network
Assisted DASH (SAND) using the **DaneResourceStatus** messages delivered from
the DASH Aware Network Element (DANE) to the application. In this case, the
MBMS client would act as a DANE.
### 7.3.4 Unicast Broadcast Handoff
Potential Solutions are:
\- The solution in clause 2.2 on **DaneResourceStatus**.
\- The usage of the **ResourceStatus** as documented in TR 26.946 [11] and
also available in MPEG SAND.
\- The usage of identical and alternative content as available in TS 26.346
[9].
### 7.3.5 Adjustment of AvailabilityStartTime
A potential solution is expected to be provided by MPEG Server and Network
Assisted DASH (SAND) using the **ResourceStatus** messages delivered from the
DASH Aware Network Element (DANE) to the application. In this case, the MBMS
client would act as a DANE.
### 7.3.6 Other Functionalities
Other functionalities of potential relevance for User Plane APIs:
\- Metric reporting: Potential solutions are provided by the framework in
clause 9 of the present document or by MPEG SAND on the Metric reporting.
\- Handling of conditional HTTP requests, or example cookies, query parameters
or header extensions. A potential solution is expected to be provided by the
third amendment of ISO/IEC 23009-1:2014.
# 8 MBMS Reception Reporting of DASH QoE Metrics
## 8.1 Current QoE Reporting Behaviour
The MBMS reception reporting (\'RR\') and DASH QoE (\'DQ\') metrics reporting
procedures are currently separately defined in TS 26.346 and TS 26.247,
respectively. These are depicted in Figure 1 from a high-level, architectural
perspective.
Figure 8: Architecture and Interaction Model of MBMS Reception Reporting and
DASH QoE Metrics Reporting Procedures
As shown in the diagram, the two processes are independent from one another,
and feature different client functions responsible for collecting and sending
different types of measurements to different network servers. The MBMS client
collects reception statistics according to metrics specified in the Session
Description fragment, in accordance to the types applicable to the download
delivery method as specified in clause 8.4 of TS 26.346, and performs
reception reporting according to the directives in the Associated Delivery
Procedure Description (ADPD) fragment of the user service announcement. It
provides the corresponding report to the Reception Reporting server as
designated in the ADPD. In DQ metrics reporting, the DASH MPD, or Media
Presentation Description metadata fragment in the case of DASH-over-MBMS,
specifies the parameters to be collected by the DASH client and uploaded to
the DASH server.
## 8.2 Desired QoE Reporting Optimization
The objective is to link these two mechanisms by integrating the DQ procedure
with the RR procedure. The MBMS client should collect the DQ metrics and
submit those to the same network server to which reception reports are sent,
possibly combined with the reception report as an aggregated document. The
construction of the MPD\'s **Metrics.Reporting** \@reportingServer attribute
passed to the DASH client should point to the appropriate report server. The
appropriate reporting server URL could be specified in different ways. For
example, the content provider or the MBMS operator which produces the MPD may
set that URL. Alternatively, the MBMS client, upon receiving the Media
Presentation Description metadata fragment, could modify the reception server
URL to point to the local HTTP server in the UE. It may also be possible to
consider the use of MPEG SAND messages to identify the proper reporting server
location to which the DQ metrics report should be sent, which could be the
local HTTP server in the UE, or the reception report server in the BM-SC. In
the case of using SAND messages, security issues such as encryption,
authentication and assumed trust relationships will be addressed.
When DQ metrics reports are sent to the local HTTP server in the MBMS client,
the MBMS client should:
\- Accept POST commands related to DQ metrics submitted by the DASH client.
\- Embed the DQ metrics file in a corresponding reception report message.
As said, the desired functionality is for the MBMS client to receive DQ
metrics reports from the DASH client to be combined with nominal reception
reports to be sent to the RR server. Modification of the decoupled RR and DQ
metrics reporting architectures previously shown in Figure 8 is illustrated in
Figure 9.
Figure 9: DASH QoE Metrics Reporting via MBMS Reception Reporting
Besides the required MPD change, the ADPD will need to be modified, for
example, by adding under the _postReceptionReport_ element, a flag to indicate
whether DASH QoE metrics should be collected by the MBMS client. Additional
attributes may be added under _postReceptionReport_ to signal, for example,
which DQ metrics to be collected and reported. Alternatively, the list of
desired QoE attributes could be specified in the Session Description, similar
to the existing use of the SDP to define MBMS-specific QoE measurements as
described in TS 26.346.
The content provider and/or the DASH-over-MBMS service provider may also
require that DQ metrics reports are to be sent to a nominal DQ metrics report
server, which could be accomplished in different ways:
The DASH client may post the report directly to the local HTTP server
associated with the MBMS client (to a _localhost_ based location) and the MBMS
client may duplicate the report to the external DQ metrics report server. This
is shown as the duplicated method in arrow B of Figure 2.
The MBMS client may intercept the DQ measurement report and forward it to the
external server. This is shown as the proxied method in arrow B of Figure 2.
The DASH client may issue multiple reports: one to the MBMS client and another
to an external DQ metrics report server. The reports may pertain to the same
or different metrics, and based on either the same or different collection and
upload directives. This is shown as arrow A in Figure 2.
## 8.3 Current QoE Metrics and Reporting Formats
### 8.3.1 DASH QoE Metrics in the MPD
The MPD may contain, at the root level, the element **Metrics** which
specifies information on QoE metrics to be reported by the DASH client. The
high level MPD Schema is shown in Figure 10.
{width="6.5in" height="4.000694444444444in"}
Figure 10: High Level MPD Schema Containing Metrics Element
The data structure of **Metrics** is shown in Figure 11.
{width="6.5in" height="5.2965277777777775in"}
Figure 11: XML Data Structure of MPD.Metrics Element
The metrics attribute contains a set of quality metric keys for metrics to be
collected and reported by the DASH client. As indicated in TS 26.247, these
metrics may include:
> \- List of HTTP Request/Response Transactions,
\- List of Representation Switch Events,
\- Average Throughput,
\- Initial Playout Delay,
\- Buffer Level,
\- Play List, and
> \- MPD Information.
The quality reporting scheme is signalled using the **Reporting** element in
the **Metrics** element. The URN defined for the **Reporting** \@schemeIdUri
is \"urn:3GPP:ns:PSS:DASH:QM10\". The scheme information for the 3GP-DASH
quality reporting scheme is represented by a data structure comprising
extension attributes in a separate namespace
(\"urn:3GPP:ns:PSS:AdaptiveHTTPStreaming:2009:qm\"), whose XML syntax is shown
in Figure 12 below.
The **Range** element indicates the time period during which quality metric
collection is requested. When not present, quality metric collection is
requested for the entire duration of the content. For a Live service, the
wall-clock time value for the start of quality metric collection is given by
\@startTime + **MPD** \@availabilityStartTime.
{width="2.7715277777777776in" height="3.046527777777778in"}
Figure 12: Syntax of Quality Reporting Scheme Information
The DASH client decides whether QoE metrics reporting should be performed in
accordance to the value of \@samplePercentage. The attribute \@reportingServer
identifies the server to which the reports should be sent, and
\@reportingInterval indicates the time(s) that reports should be sent.
### 8.3.2 DASH QoE Report Format and Protocol
The QoE report is formatted as an XML document whose schema is shown in Figure
13.
{width="6.406944444444444in" height="8.104166666666666in"}
Figure 13: XML Schema of Quality Report Message
The DASH client will send QoE reports to the report server as indicated in the
**ThreeGPQualityReporting** element using the HTTP (RFC 2616 [10]) [2] POST
request, the message body of which contains an XML-formatted Quality Report
document according to the schema shown in Figure 4.
### 8.3.3 Similarities and Differences between DASH QoE and MBMS Reception
Reporting
Similarities in QoE metrics and reporting scheme between DASH QoE and MBMS
Reception Reporting should be considered in devising the means to integrate
the two mechanisms. Similar characteristics to both schemes include the target
percentage of clients that should perform QoE reporting, the location of the
network server to which the reports should be sent, and temporal parameters
pertaining to when reporting should be sent to the report server. With respect
to the QoE metrics to be reported as defined in TS 26.346, it can be seen that
the MBMS QoE metrics pertain to the transport level, whereas the DASH QoE
metrics apply at the level of the media/content carried in the DASH format.
Also common between the two reporting mechanisms is the use of HTTP POST as
the means to convey the contents of the XML-formatted QoE report document to
the corresponding report server.
## 8.4 Potential Solutions
### 8.4.1 Modifications to the ADPD
#### 8.4.1.1 Method 1 -- New Attributes Under postReceptionReport Element
The _postReceptionReport_ element in the ADPD indicates the parameters
associated with reception reporting by the MBMS client. This element should be
extended to carry the parameters associated with DASH QoE metrics reporting,
including the full or subset of DASH QoE metrics as defined in TS 26.247. An
example schema of the modified _postReceptionReporting_ element is shown in
Figure 14.
{width="6.691666666666666in" height="3.484722222222222in"}
Figure 14: Modification to postReceptionReport element to include DASH QoE
Reporting
As shown in the figure, a new flag (@_DASHQoEReporting_) is added to indicate
whether DASH QoE metrics should be collected by the MBMS client for reception
reporting. If the flag is set to \"true\", then other conditionally mandatory
attributes will further indicate:
\- whether the report should be compressed (@_DASHQoECompression_);
\- the set of DASH QoE metrics to be collected and reported
(@_DASHQoEMetrics_);
\- whether DASH QoE reporting should be synchronized, i.e. provided during the
nominal time of MBMS reception reporting;
\- optionally, target probability that the QoE report should be transmitted
(@_DASHQoESamplePercentage_).
The set of DASH QoE metrics to be sent, represented by (@_DASHQoEMetrics_)
should correspond to the same or subset of DASH QoE parameters as defined in
TS 26.247. The optional presence of @_DASHQoESamplePercentage_ could be used
to represent conditional probability of DASH QoE report transmission relative
to the (probabilistic) occurrence of reception reporting.
#### 8.4.1.2 Method 2 -- New Element Under _postReceptionReport_ Element
An alternative change to the ADPD is shown in Figure 15.
{width="6.545138888888889in" height="4.43125in"}
Figure 15: Alternative Modification to postReceptionReport element to include
DASH QoE Reporting
In this method, a new _DASHQoEProcedure_ element is added as child of
_postReceptionReport_. Added under _DASHQoEProcedure_ element are child
elements pertaining to DASH QoE metrics processing and reporting. If
_DASHQoEProcedure_ is present, then DASH QoE collection and reporting may be
required in accordance to the value of the child elements of
_DASHQoEProcedure_.
### 8.4.2 Synchronization of DASH QoE Reporting with Reception Reporting
The _DASHQoESync_ flag in either method 1 or 2 above is used to define whether
and how the DASH QoE metrics reporting should be synchronized with the MBMS
Reception Reporting. The following outcomes are possible, depending on the
synchronization flag value:
Scenario 1: The _DASHQoESync_ sync flag is set to \"true\", and
_DASHQoESamplePercentage_ is absent. Assuming that the MBMS Reception Report
procedure is active, then a DASH QoE metrics report should be attached to each
reception report transmission.
Scenario 2: the sync flag is set to \"true\", and sample percentage for DASH
QoE reporting, P~DQ~, is present. Assuming that the MBMS Reception Report
procedure is active and associated with sample percentage P~RR~, the
likelihood of DASH QoE reporting should be determined by the conditional
probability, i.e. [P~DQ~ \| P~RR~] = P~DQ~ x P~RR~, assuming the independence
of random number generation in producing the two reporting probability values
in the UE. For example, if reception reporting sample percentage = 50 and DASH
QoE reporting sample percentage = 50, the probability of DASH QoE metric
report would be 0.5 x 0.5 = 0.25 or 25%.
Scenario 3: the sync flag is set to \"false\", and sample percentage for DASH
QoE reporting, P~DQ~, is present. In this case, independently of reception
reporting activity, the probability for DASH QoE reporting is given by its
sample percentage value.
### 8.4.3 Aggregation of DASH QoE Reports with Reception Reports
MBMS reception reports and DASH QoE measurement reports may be combined into a
single aggregate document using the existing procedure allowed for reception
reporting defined in TS 26.346, by making use of the MIME multipart/mixed file
format [2]. Two options are possible:
1) Option 1: The Internet Media Type (content type) is used to differentiate
between the two types of reports, e.g. text/xml for nominal reception report
files, and text/xml-DQ for DASH QoE metrics report files
2) Option 2: The same text/xml media type may be used for both. The server can
differentiate the report types by the XML header portion of the report.
An example of Option 1 is shown below. Here, the MIME multipart message which
contains as separate body parts the Reception Report and the DASH QoE Report
delineates the two parts by a boundary, named \"separator\" in the \"Content-
Type: \" header. This boundary is placed between the parts at the beginning
and end of the body of the message, as follows:
POST http://www.exampleserver.com/rr HTTP/1.1
Host: 192.68.1.1
User-Agent: Mozillaâ„¢/5.0(Linux; U; Androidâ„¢ 4.0.3 ....)
Content-Length: 12345
Content-Type: multipart/mixed; boundary=separator
Connection: Keep-Alive
_\ _
\--separator
Content-Type: text/xml
**\ **
\--separator
Content-Type: text/xml-DQ
**\ **
\--separator--
### 8.4.4 Modification to MPD
The MPD\'s **Metrics.Reporting** \@reportingServer may need to be constructed
to point to the MBMS client to allow posting of DASH QoE metrics reports to
the local HTTP server in the UE. For example, the MBMS client may overwrite
the BaseURL in the Media Presentation Description fragment to \"localhost/\",
before forwarding the MPD to the DASH client. Alternatively, the HTTP URL of
the report server in the MPD, nominally pointing to an external network
server, can be unchanged should the MBMS client act as a proxy for all HTTP
requests of the DASH client. In this case, the DASH QoE report could be
terminated at the MBMS client.
## 8.5 Client Identifier Access via MBMS API
### 8.5.1 Introduction
**It may be important for MBMS operators to obtain appropriate subscriber
identification, generically referred to as \'clientID\', in the reporting of
transport level statistics and/or service/content usage details produced by
MBMS UEs, . Transport level statistics are delivered in nominal MBMS reception
reports, whereas service/content usage details would be carried in DASH QoE
metrics reports. Each operator may have its own policy on the type/format of
_clientID_ to be reported by the UE, which may be enabled by defining
extensions to the Associated Delivery Procedure Description (ADPD). Different
methods may be available to the MBMS client to obtain the _clientID_ from the
UE platform, such as via calls to the operating system, or through the MBMS
API set.**
### 8.5.2 Methods and Considerations for Accessing clientID Information
**For the purpose of the analysis of user service consumption details in
reception/QoE reports, availability of _clientID_ in the reports is important.
For the purpose of precision marketing, which may include targeted advertising
according to specific user\'s viewing behaviour, individual user data needs to
be known rather than mass statistics. Therefore, the identifier of the
reporting UE needs to be collected. As specified in TS 26.346, the _clientId_
attribute is unique identifier for the receiver and** identifies the reporting
UE**, e.g. an MSISDN of the UE.**
At the implementation level, there could be different ways for MBMS client to
obtain this parameter, for example:
a) The MBMS client may utilize the API offered by the operating system such as
\"getLine1Number\" in Androidâ„¢. This API will respond with the subscriber
identification information read from the (U)SIM card. In the event that no
such data has been written in the card, the API will return null information.
b) The application usually requires the user to register for the first time
and log in with the username and password afterwards. Registration information
may include the _clientID_ which can enable the MBMS client to get the
_clientID_ from the application.
Different operators may have different policies. Some operators will allow the
MSISDN data to be written in the (U)SIM card, and some will not. In the latter
situation, no MSISDN data but IMSI is written in the (U)SIM card. However, the
IMSI may not provide uniqueness in user identification, since the same
subscriber may change his/her (U)SIM card over time, each change resulting in
a different IMSI. Therefore, the first method mentioned in the above may not
always be the best solution.
On the other hand, since SMS validation is a frequently used method for user
verification among application providers, by which the MSISDN is the most
common choice as the username for logging in to the application. Under such
situation, _clientID_ access from the application using the MBMS API will be
straightforward.
### 8.5.3 clientID Access via MBMS API
An example call flow showing _clientID_ collection by the MBMS client via the
MBMS API is shown in Figure 16, and comprises two basic steps as described
below:
A) Client ID Retrieval
1) Operator-defined policy on _clientID_ access is specified in the ADPD
fragment of the USD. Here, it is assumed that such operator policy may contain
several information components. The first defines the preferred and
alternative access methods for use by the MBMS client to obtain _clientID_ ,
such as querying the MBMS application via the MBMS API, and if unavailable,
calling a suitable API exposed by the operating system. The second policy
component specifies the type of _clientID_ to be reported by the MBMS client,
such as MSISDN, email address etc. The third policy component indicates
whether the _clientID_ will be included in the QoE report.
2) MBMS client uses the MBMS API to request and obtain _clientID_ from the
application.
3) If (2) is unsuccessful, MBMS client calls the appropriate operating system
API to retrieve the _clientID._
Note: Steps 2) and 3) are under the consumption of the policy that querying
MBMS API is the preferred way to obtain clientID.
4) MBMS client determines whether the retrieved _clientID_ fulfils the
required format as indicated in the ADPD.
1) DASH QoE Reporting:
5) MBMS client receives, via HTTP POST, DASH QoE (DQ) metrics submitted by the
DASH client;
6) MBMS client collects MBMS reception statistics and previously received DASH
QoE measurements.
7) MBMS client combines the DASH QoE metrics with the MBMS reception/QoE
measurement into a reception report message and sends it to the report server.
Figure 16: Reception Report containing clientID using policy-based access
### 8.5.4 Considerations on clientID Access via the MBMS API
The following caveats or qualifications should be considered in the use of the
MBMS API method for the MBMS client to obtain the _clientID_ from the MBMS
application, as described below.
\- There is potential for MBMS applications in the UE to be associated with
different forms of _clientID_ \'s, and it may be necessary for the MBMS
operator to ensure that all those applications are provisioned with the same
_clientID_ value for proper subscriber identification in reception reporting;
\- The MBMS client and the MBMS application may reside in separate physical
devices. An example is the use of an integrated MBMS receiver/WiFi router that
serves multiple end-user devices, e.g. in the home or business premises
network. In this implementation scenario, and assuming that some of those end-
user devices are UEs, there will exist multiple _clientID_ \'s. Under this
circumstance, and when performing nominal reception reports which do not
contain DASH QoE measurements, only a single _clientID_ should be included,
such that the MBMS client will most likely report the _clientID_ of the UE in
which it is hosted. On the other hand, in the reporting of DASH QoE metrics,
it would be desirable for the MBMS client to identify the different UEs it
serves and separately report each of their respective service/content usage
measurements with the corresponding user/client identification. Acquisition of
_clientID_ from the MBMS API may represent an attractive solution.
# 9 Conclusions and Recommendations
In the present document, a set of relevant use cases for the usage of MBMS
user services has been identified. The necessary functionality for enabling
these use cases have been extracted and build the core for the definition of
profiles for service announcement and for download services.
The possibility of defining an MBMS URL form to simplify access to resources
delivered over MBMS by providing a URL as an entry point to resources and
services has been studied. Different variants of the MBMS URL scheme have been
identified, ranging from packing all information into the URL, relying on the
MBMS service id, or just changing the protocol scheme. Usage of DNS for
resolving the location of resources to MBMS has also been studied.
The definition of APIs for applications to communicate with the MBMS client
has also been studied in the present document. The APIs cover aspects of
service discovery, resource fetching, error handling, and hints on resource
status.
Finally, enhancements to QoE reporting have also been investigated and new
means to trigger QoE reporting at MBMS have been suggested.
Based on the analysis of the present document, the following recommendations
are made:
1) define the profiles for the service announcement over broadcast
2) define the profiles for download services
3) define the enhancements to enable DASH-specific QoE reporting to the BM-SC
4) continue evaluation of the MBMS URL schemes and their resolution and define
one or several MBMS URL schemes
5) define skeleton APIs for service discovery, transport, and error handling
and communicate with groups that could potentially define these APIs
#
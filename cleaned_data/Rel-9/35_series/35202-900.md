# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The 3GPP Confidentiality and Integrity Algorithms f8 & f9 have been developed
through the collaborative efforts of the European Telecommunications Standards
Institute (ETSI), the Association of Radio Industries and Businesses (ARIB),
the Telecommunications Technology Association (TTA), the T1 Committee.
The f8 & f9 Algorithms Specifications may be used only for the development and
operation of 3G Mobile Communications and services. Every Beneficiary must
sign a Restricted Usage Undertaking with the Custodian and demonstrate that he
fulfills the approval criteria specified in the Restricted Usage Undertaking.
Furthermore, Mitsubishi Electric Corporation holds essential patents on the
Algorithms. The Beneficiary must get a separate IPR License Agreement from
Mitsubishi Electronic Corporation Japan.
For details of licensing procedures, contact ETSI, ARIB, TTA or T1.
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
This specification has been prepared by the 3GPP Task Force, and gives a
detailed specification of the 3GPP Algorithm KASUMI. KASUMI is a block cipher
that forms the heart of the 3GPP confidentiality algorithm **_f8_** , and the
3GPP integrity algorithm **_f9_**.
This document is the second of four, which between them form the entire
specification of the 3GPP Confidentiality and Integrity Algorithms:
\- 3GPP TS 35.201: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 1: _f8_ and _f9_
Specification\".
**\- 3GPP TS 35.202: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 2: KASUMI
Specification\".**
\- 3GPP TS 35.203: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 3: Implementors'
Test Data\".
\- 3GPP TS 35.204: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 4: Design
Conformance Test Data\".
The normative part of the specification of **KASUMI** is in the main body of
this document. The annexes to this document are purely informative. Annex 1
contains illustrations of functional elements of the algorithm, while Annex 2
contains an implementation program listing of the cryptographic algorithm
specified in the main body of this document, written in the programming
language C.
Similarly the normative part of the specification of the **_f8_**
(confidentiality) and the **_f9_** (integrity) algorithms is in the main body
of Document 1. The annexes of those documents, and Documents 3 and 4 above,
are purely informative.
# 0 Scope
This specification gives a detailed specification of the 3GPP Algorithm
KASUMI. KASUMI is a block cipher that forms the heart of the 3GPP
confidentiality algorithm **_f8_** , and the 3GPP integrity algorithm
**_f9_**.
# NORMATIVE SECTION
This part of the document contains the normative specification of the KASUMI
algorithm.
# 1 Outline of the normative part
Section 2 introduces the algorithm and describes the notation used in the
subsequent sections.
Section 3 defines the algorithm structure and its operation.
Section 4 defines the basic components of the algorithm.
## 1.1 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or non‑specific.
  * For a specific reference, subsequent revisions do not apply.
  * For a non-specific reference, the latest version applies. In the > case of a reference to a 3GPP document (including a GSM document), > a non-specific reference implicitly refers to the latest version > of that document _in the same Release as the present document_.
[1] 3GPP TS 33.102 version 3.2.0: \"3rd Generation Partnership Project;
Technical Specification Group Services and System Aspects; 3G Security;
Security Architecture\".
[2] 3GPP TS 33.105 version 3.1.0: \"3rd Generation Partnership Project;
Technical Specification Group Services and System Aspects; 3G Security;
Cryptographic Algorithm Requirements\".
[3] 3GPP TS 35.201: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 1: f8 and f9
Specification\".
[4] 3GPP TS 35.202: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 2: KASUMI
Specification\".
[5] 3GPP TS 35.203: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 3: Implementors'
Test Data\".
[6] 3GPP TS 35.204: \"3rd Generation Partnership Project; Technical
Specification Group Services and System Aspects; 3G Security; Specification of
the 3GPP Confidentiality and Integrity Algorithms; Document 4: Design
Conformance Test Data\".
[7] ISO/IEC 9797-1:1999: \"Information technology -- Security techniques --
Message Authentication Codes (MACs)\".
# 2 Introductory information
## 2.1 Introduction
Within the security architecture of the 3GPP system there are two standardised
algorithms: A confidentiality algorithm **_f8_** , and an integrity algorithm
**_f9_**. These algorithms are fully specified in a companion document[3].
Each of these algorithms is based on the **KASUMI** algorithm that is
specified here.
**KASUMI** is a block cipher that produces a 64-bit output from a 64-bit input
under the control of a 128-bit key.
## 2.2 Notation
### 2.2.1 Radix
We use the prefix **0x** to indicate **hexadecimal** numbers.
### 2.2.2 Bit/Byte ordering
All data variables in this specification are presented with the most
significant bit (or byte) on the left hand side and the least significant bit
(or byte) on the right hand side. Where a variable is broken down into a
number of sub-strings, the left most (most significant) sub-string consists of
the most significant part of the original string and so on through to the
least significant.
For example if a 64-bit value **_X_** is subdivided into four 16-bit
substrings **_P, Q, R, S_** we have:
**_X_** = 0x0123456789ABCDEF
we have:
**_P_** = 0x0123, **_Q_** = 0x4567, **_R_** = 0x89AB, **_S_** = 0xCDEF.
In binary this would be:
**_X_** = 0000000100100011010001010110011110001001101010111100110111101111
with **_P_** = 0000000100100011\ **_Q_ =** 0100010101100111\ **_R_ =**
1000100110101011\ **_S_** = 1100110111101111
### 2.2.3 Conventions
We use the assignment operator '=', as used in several programming languages.
When we write
\ = \
we mean that \ assumes the value that \ had before
the assignment took place. For instance,
_x_ = _x_ \+ _y_ \+ 3
means
(new value of _x_) becomes (old value of _x_) + (old value of _y_) + 3.
### 2.2.4 Subfunctions
KASUMI decomposes into a number of subfunctions (**_FL, FO, FI_**) which are
used in conjunction with associated sub-keys (**_KL, KO, KI_**) in a Feistel
structure comprising a number of rounds (and rounds within rounds for some
subfunctions). Specific instances of the function and/or keys are represented
by **_XX~i,j~_** where **_i_** is the outer round number of KASUMI and **_j_**
is the inner round number.
For example the function **_FO_** comprises three rounds of the function
**_FI_** , so we designate the third round of **_FI_** in the fifth round of
KASUMI as **_FI~5,3~_**.
### 2.2.5 List of Symbols
= The assignment operator.
⊕ The bitwise exclusive-OR operation.
\|\| The concatenation of the two operands.
\ y0 = 0⊕0⊕0⊕1⊕1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0 = 0\ y1 = 0⊕0⊕0⊕1⊕1⊕0⊕0⊕0⊕0⊕0⊕1 = 1\ y2 =
> 0⊕0⊕0⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕0⊕1 = 0\ y3 = 1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0 = 1\ y4 =
> 0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1 = 1\ y5 = 1⊕0⊕0⊕0⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕0⊕0⊕1 = 1\ y6 =
> 1⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕0⊕0 = 0
Thus y = 0111010~2~ = 58
### 4.5.2 S9
**Gate Logic :**
y0 = x0x2⊕x3⊕x2x5⊕x5x6⊕x0x7⊕x1x7⊕x2x7⊕x4x8⊕x5x8⊕x7x8⊕1
y1 = x1⊕x0x1⊕x2x3⊕x0x4⊕x1x4⊕x0x5⊕x3x5⊕x6⊕x1x7⊕x2x7⊕x5x8⊕1
y2 = x1⊕x0x3⊕x3x4⊕x0x5⊕x2x6⊕x3x6⊕x5x6⊕x4x7⊕x5x7⊕x6x7⊕x8⊕x0x8⊕1
y3 = x0⊕x1x2⊕x0x3⊕x2x4⊕x5⊕x0x6⊕x1x6⊕x4x7⊕x0x8⊕x1x8⊕x7x8
y4 = x0x1⊕x1x3⊕x4⊕x0x5⊕x3x6⊕x0x7⊕x6x7⊕x1x8⊕x2x8⊕x3x8
y5 = x2⊕x1x4⊕x4x5⊕x0x6⊕x1x6⊕x3x7⊕x4x7⊕x6x7⊕x5x8⊕x6x8⊕x7x8⊕1
y6 = x0⊕x2x3⊕x1x5⊕x2x5⊕x4x5⊕x3x6⊕x4x6⊕x5x6⊕x7⊕x1x8⊕x3x8⊕x5x8⊕x7x8
y7 = x0x1⊕x0x2⊕x1x2⊕x3⊕x0x3⊕x2x3⊕x4x5⊕x2x6⊕x3x6⊕x2x7⊕x5x7⊕x8⊕1
y8 = x0x1⊕x2⊕x1x2⊕x3x4⊕x1x5⊕x2x5⊕x1x6⊕x4x6⊕x7⊕x2x8⊕x3x8
**Decimal Table :**
167,239,161,379,391,334, 9,338, 38,226, 48,358,452,385, 90,397,
183,253,147,331,415,340, 51,362,306,500,262, 82,216,159,356,177,
175,241,489, 37,206, 17, 0,333, 44,254,378, 58,143,220, 81,400,
95, 3,315,245, 54,235,218,405,472,264,172,494,371,290,399, 76,
165,197,395,121,257,480,423,212,240, 28,462,176,406,507,288,223,
501,407,249,265, 89,186,221,428,164, 74,440,196,458,421,350,163,
232,158,134,354, 13,250,491,142,191, 69,193,425,152,227,366,135,
344,300,276,242,437,320,113,278, 11,243, 87,317, 36, 93,496, 27,
487,446,482, 41, 68,156,457,131,326,403,339, 20, 39,115,442,124,
475,384,508, 53,112,170,479,151,126,169, 73,268,279,321,168,364,
363,292, 46,499,393,327,324, 24,456,267,157,460,488,426,309,229,
439,506,208,271,349,401,434,236, 16,209,359, 52, 56,120,199,277,
465,416,252,287,246, 6, 83,305,420,345,153,502, 65, 61,244,282,
173,222,418, 67,386,368,261,101,476,291,195,430, 49, 79,166,330,
280,383,373,128,382,408,155,495,367,388,274,107,459,417, 62,454,
132,225,203,316,234, 14,301, 91,503,286,424,211,347,307,140,374,
35,103,125,427, 19,214,453,146,498,314,444,230,256,329,198,285,
50,116, 78,410, 10,205,510,171,231, 45,139,467, 29, 86,505, 32,
72, 26,342,150,313,490,431,238,411,325,149,473, 40,119,174,355,
185,233,389, 71,448,273,372, 55,110,178,322, 12,469,392,369,190,
1,109,375,137,181, 88, 75,308,260,484, 98,272,370,275,412,111,
336,318, 4,504,492,259,304, 77,337,435, 21,357,303,332,483, 18,
47, 85, 25,497,474,289,100,269,296,478,270,106, 31,104,433, 84,
414,486,394, 96, 99,154,511,148,413,361,409,255,162,215,302,201,
266,351,343,144,441,365,108,298,251, 34,182,509,138,210,335,133,
311,352,328,141,396,346,123,319,450,281,429,228,443,481, 92,404,
485,422,248,297, 23,213,130,466, 22,217,283, 70,294,360,419,127,
312,377, 7,468,194, 2,117,295,463,258,224,447,247,187, 80,398,
284,353,105,390,299,471,470,184, 57,200,348, 63,204,188, 33,451,
97, 30,310,219, 94,160,129,493, 64,179,263,102,189,207,114,402,
438,477,387,122,192, 42,381, 5,145,118,180,449,293,323,136,380,
43, 66, 60,455,341,445,202,432, 8,237, 15,376,436,464, 59,461
**Example:**
If we have an input value = 138, then using the decimal table S9[138] = 339.
For the combinational logic we have:
138 = 010001010~2~ ⇒ x8 = 0, x7 = 1, x6 = 0, x5=0, x4=0, x3=1, x2=0, x1=1,
x0=0
which gives us:
> y0 = 0⊕1⊕0⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕1 = 1
>
> y1 = 1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1⊕0⊕0⊕1 = 1
>
> y2 = 1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1 = 0
>
> y3 = 0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0 = 0
>
> y4 = 0⊕1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0 = 1
>
> y5 = 0⊕0⊕0⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕0⊕1 = 0
>
> y6 = 0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1⊕0⊕0⊕0⊕0 = 1
>
> y7 = 0⊕0⊕0⊕1⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1 = 0
>
> y8 = 0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕1⊕0⊕0 = 1
Thus y = 101010011~2~ = 339
## 4.6 Key Schedule
KASUMI has a 128-bit key **_K_**. Each round of KASUMI uses 128 bits of key
that are derived from **_K_**. Before the round keys can be calculated two
16-bit arrays **_Kj_** and **_Kj′_** (**_j_** =1 to 8) are derived in the
following manner:
The 128-bit key **_K_** is subdivided into eight 16-bit values **_K1...K8_**
where
**K = K1 \|\| K2 \|\| K3 \|\|...\|\| K8.**
A second array of subkeys, **_Kj′_** is derived from **_Kj_** by applying:
For each integer **_j_** with 1 ≤ **_j_** ≤ 8
**Kj′ = Kj ⊕ Cj**
Where **_Cj_** is the constant value defined in table 2.
The round subkeys are then derived from **_Kj_** and **_Kj′_** in the manner
defined in table 1.
Table 1: Round subkeys
* * *
            1            2            3            4            5            6            7            8
KL~i,1~ K1\>(16-b)))
/*------- unions: used to remove \"endian\" issues \------------------------*/
typedef union {
u32 b32;
u16 b16[2];
u8 b8[4];
} DWORD;
typedef union {
u16 b16;
u8 b8[2];
} WORD;
/*-------- globals: The subkey arrays \-----------------------------------*/
static u16 KLi1[8], KLi2[8];
static u16 KOi1[8], KOi2[8], KOi3[8];
static u16 KIi1[8], KIi2[8], KIi3[8];
/*---------------------------------------------------------------------
* FI()
* The FI function (fig 3). It includes the S7 and S9 tables.
* Transforms a 16-bit value.
*---------------------------------------------------------------------*/
static u16 FI( u16 in, u16 subkey )
{
u16 nine, seven;
static u16 S7[] = {
54, 50, 62, 56, 22, 34, 94, 96, 38, 6, 63, 93, 2, 18,123, 33,
55,113, 39,114, 21, 67, 65, 12, 47, 73, 46, 27, 25,111,124, 81,
53, 9,121, 79, 52, 60, 58, 48,101,127, 40,120,104, 70, 71, 43,
20,122, 72, 61, 23,109, 13,100, 77, 1, 16, 7, 82, 10,105, 98,
117,116, 76, 11, 89,106, 0,125,118, 99, 86, 69, 30, 57,126, 87,
112, 51, 17, 5, 95, 14, 90, 84, 91, 8, 35,103, 32, 97, 28, 66,
102, 31, 26, 45, 75, 4, 85, 92, 37, 74, 80, 49, 68, 29,115, 44,
64,107,108, 24,110, 83, 36, 78, 42, 19, 15, 41, 88,119, 59, 3};
static u16 S9[] = {
167,239,161,379,391,334, 9,338, 38,226, 48,358,452,385, 90,397,
183,253,147,331,415,340, 51,362,306,500,262, 82,216,159,356,177,
175,241,489, 37,206, 17, 0,333, 44,254,378, 58,143,220, 81,400,
95, 3,315,245, 54,235,218,405,472,264,172,494,371,290,399, 76,
165,197,395,121,257,480,423,212,240, 28,462,176,406,507,288,223,
501,407,249,265, 89,186,221,428,164, 74,440,196,458,421,350,163,
232,158,134,354, 13,250,491,142,191, 69,193,425,152,227,366,135,
344,300,276,242,437,320,113,278, 11,243, 87,317, 36, 93,496, 27,
487,446,482, 41, 68,156,457,131,326,403,339, 20, 39,115,442,124,
475,384,508, 53,112,170,479,151,126,169, 73,268,279,321,168,364,
363,292, 46,499,393,327,324, 24,456,267,157,460,488,426,309,229,
439,506,208,271,349,401,434,236, 16,209,359, 52, 56,120,199,277,
465,416,252,287,246, 6, 83,305,420,345,153,502, 65, 61,244,282,
173,222,418, 67,386,368,261,101,476,291,195,430, 49, 79,166,330,
280,383,373,128,382,408,155,495,367,388,274,107,459,417, 62,454,
132,225,203,316,234, 14,301, 91,503,286,424,211,347,307,140,374,
35,103,125,427, 19,214,453,146,498,314,444,230,256,329,198,285,
50,116, 78,410, 10,205,510,171,231, 45,139,467, 29, 86,505, 32,
72, 26,342,150,313,490,431,238,411,325,149,473, 40,119,174,355,
185,233,389, 71,448,273,372, 55,110,178,322, 12,469,392,369,190,
1,109,375,137,181, 88, 75,308,260,484, 98,272,370,275,412,111,
336,318, 4,504,492,259,304, 77,337,435, 21,357,303,332,483, 18,
47, 85, 25,497,474,289,100,269,296,478,270,106, 31,104,433, 84,
414,486,394, 96, 99,154,511,148,413,361,409,255,162,215,302,201,
266,351,343,144,441,365,108,298,251, 34,182,509,138,210,335,133,
311,352,328,141,396,346,123,319,450,281,429,228,443,481, 92,404,
485,422,248,297, 23,213,130,466, 22,217,283, 70,294,360,419,127,
312,377, 7,468,194, 2,117,295,463,258,224,447,247,187, 80,398,
284,353,105,390,299,471,470,184, 57,200,348, 63,204,188, 33,451,
97, 30,310,219, 94,160,129,493, 64,179,263,102,189,207,114,402,
438,477,387,122,192, 42,381, 5,145,118,180,449,293,323,136,380,
43, 66, 60,455,341,445,202,432, 8,237, 15,376,436,464, 59,461};
/* The sixteen bit input is split into two unequal halves, *
* nine bits and seven bits - as is the subkey */
nine = (u16)(in>>7);
seven = (u16)(in&0x7F);
/* Now run the various operations */
nine = (u16)(S9[nine] \^ seven);
seven = (u16)(S7[seven] \^ (nine & 0x7F));
seven \^= (subkey>>9);
nine \^= (subkey&0x1FF);
nine = (u16)(S9[nine] \^ seven);
seven = (u16)(S7[seven] \^ (nine & 0x7F));
in = (u16)((seven\ to identify the
* appropriate subkeys to use.
*---------------------------------------------------------------------*/
static u32 FO( u32 in, int index )
{
u16 left, right;
/* Split the input into two 16-bit words */
left = (u16)(in>>16);
right = (u16) in;
/* Now apply the same basic transformation three times */
left \^= KOi1[index];
left = FI( left, KIi1[index] );
left \^= right;
right \^= KOi2[index];
right = FI( right, KIi2[index] );
right \^= left;
left \^= KOi3[index];
left = FI( left, KIi3[index] );
left \^= right;
in = (((u32)right)\ to identify the
* appropriate subkeys to use.
*---------------------------------------------------------------------*/
static u32 FL( u32 in, int index )
{
u16 l, r, a, b;
/* split out the left and right halves */
l = (u16)(in>>16);
r = (u16)(in);
/* do the FL() operations */
a = (u16) (l & KLi1[index]);
r \^= ROL16(a,1);
b = (u16)(r \| KLi2[index]);
l \^= ROL16(b,1);
/* put the two halves back together */
in = (((u32)l)\>24); d[1].b8[0] = (u8)(right>>24);
d[0].b8[1] = (u8)(left>>16); d[1].b8[1] = (u8)(right>>16);
d[0].b8[2] = (u8)(left>>8); d[1].b8[2] = (u8)(right>>8);
d[0].b8[3] = (u8)(left); d[1].b8[3] = (u8)(right);
}
/*---------------------------------------------------------------------
* KeySchedule()
* Build the key schedule. Most \"key\" operations use 16-bit
* subkeys so we build u16-sized arrays that are \"endian\" correct.
*---------------------------------------------------------------------*/
void KeySchedule( u8 *k )
{
static u16 C[] = {
0x0123,0x4567,0x89AB,0xCDEF, 0xFEDC,0xBA98,0x7654,0x3210 };
u16 key[8], Kprime[8];
WORD *k16;
int n;
/* Start by ensuring the subkeys are endian correct on a 16-bit basis */
k16 = (WORD *)k;
for( n=0; n\<8; ++n )
key[n] = (u16)((k16[n].b8[0]\<\<8) + (k16[n].b8[1]));
/* Now build the K\'[] keys */
for( n=0; n\<8; ++n )
Kprime[n] = (u16)(key[n] \^ C[n]);
/* Finally construct the various sub keys */
for( n=0; n\<8; ++n )
{
KLi1[n] = ROL16(key[n],1);
KLi2[n] = Kprime[(n+2)&0x7];
KOi1[n] = ROL16(key[(n+1)&0x7],5);
KOi2[n] = ROL16(key[(n+5)&0x7],8);
KOi3[n] = ROL16(key[(n+6)&0x7],13);
KIi1[n] = Kprime[(n+4)&0x7];
KIi2[n] = Kprime[(n+3)&0x7];
KIi3[n] = Kprime[(n+7)&0x7];
}
}
/*---------------------------------------------------------------------
* e n d o f k a s u m i . c
*---------------------------------------------------------------------*/
#
# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
The present document describes the detailed mapping from input blocks of 160
speech samples in 13‑bit uniform PCM format to encoded blocks of 95, 103, 118,
134, 148, 159, 204, and 244 bits and from encoded blocks of 95, 103, 118, 134,
148, 159, 204, and 244 bits to output blocks of 160 reconstructed speech
samples. The sampling rate is 8 000 samples/s leading to a bit rate for the
encoded bit stream of 4.75, 5.15, 5.90, 6.70, 7.40, 7.95, 10.2 or 12.2 kbit/s.
The coding scheme for the multi-rate coding modes is the so‑called Algebraic
Code Excited Linear Prediction Coder, hereafter referred to as ACELP. The
multi-rate ACELP coder is referred to as MR-ACELP.
In the case of discrepancy between the requirements described in the present
document and the fixed point computational description (ANSI‑C code) of these
requirements contained in [4], the description in [4] will prevail. The ANSI‑C
code is not described in the present document, see [4] for a description of
the ANSI‑C code.
The transcoding procedure specified in the present document is mandatory for
systems using the AMR speech codec.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or non‑specific.
  * For a specific reference, subsequent revisions do not apply.
  * For a non-specific reference, the latest version applies. In the > case of a reference to a 3GPP document (including a GSM document), > a non-specific reference implicitly refers to the latest version > of that document _in the same Release as the present document_.
[1] GSM 03.50: \" Digital cellular telecommunications system (Phase 2+);
Transmission planning aspects of the speech service in the GSM Public Land
Mobile Network (PLMN) system\".
[2] 3GPP TS 26.101 : \"Frame Structure\".
[3] 3GPP TS 26.094: \"AMR Speech Codec; Voice Activity Detector\".
[4] 3GPP TS 26.073: \"Adaptive Multi-Rate (AMR); ANSI C source code\".
[5] 3GPP TS 26.074: \"Adaptive Multi-Rate (AMR); Test sequences\".
[6] ITU‑T Recommendation G.711 (1988): \"Pulse code modulation (PCM) of voice
frequencies\".
[7] ITU‑T Recommendation G.726: \"40, 32, 24, 16 kbit/s Adaptive Differential
Pulse Code Modulation (ADPCM)\".
[8] ITU-T Recommendation G.712
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of the present document, the following terms and definitions
apply:
**adaptive codebook:** contains excitation vectors that are adapted for every
subframe. The adaptive codebook is derived from the long-term filter state.
The lag value can be viewed as an index into the adaptive codebook
**adaptive postfilter: t** his filter is applied to the output of the short-
term synthesis filter to enhance the perceptual quality of the reconstructed
speech. In the adaptive multi-rate codec, the adaptive postfilter is a cascade
of two filters: a formant postfilter and a tilt compensation filter
**algebraic codebook:** fixed codebook where algebraic code is used to
populate the excitation vectors (innovation vectors). The excitation contains
a small number of nonzero pulses with predefined interlaced sets of positions
**anti-sparseness processing:** adaptive post-processing procedure applied to
the fixed codebook vector in order to reduce perceptual artefacts from a
sparse fixed codebook vector
**closed‑loop pitch analysis:** adaptive codebook search, i.e., a process of
estimating the pitch (lag) value from the weighted input speech and the long
term filter state. In the closed‑loop search, the lag is searched using error
minimization loop (analysis‑by‑synthesis). In the adaptive multi-rate codec,
closed‑loop pitch search is performed for every subframe
**direct form coefficients:** One of the formats for storing the short term
filter parameters. In the adaptive multi-rate codec, all filters which are
used to modify speech samples use direct form coefficients.
**fixed codebook:** The fixed codebook contains excitation vectors for speech
synthesis filters. The contents of the codebook are non‑adaptive (i.e.,
fixed). In the adaptive multi-rate codec, the fixed codebook is implemented
using an algebraic codebook.
**fractional lags:** A set of lag values having sub‑sample resolution. In the
adaptive multi-rate codec a sub‑sample resolution of 1/6^th^ or 1/3^rd^ of a
sample is used.
**frame:** time interval equal to 20 ms (160 samples at an 8 kHz sampling
rate)
**integer lags:** set of lag values having whole sample resolution
**interpolating filter:** FIR filter used to produce an estimate of subsample
resolution samples, given an input sampled with integer sample resolution
**inverse filter: t** his filter removes the short term correlation from the
speech signal. The filter models an inverse frequency response of the vocal
tract
**lag:** long term filter delay. This is typically the true pitch period, or
its multiple or sub‑multiple
**Line Spectral Frequencies:** (see Line Spectral Pair)
**Line Spectral Pair:** transformation of LPC parameters. Line Spectral Pairs
are obtained by decomposing the inverse filter transfer function A(z) to a set
of two transfer functions, one having even symmetry and the other having odd
symmetry. The Line Spectral Pairs (also called as Line Spectral Frequencies)
are the roots of these polynomials on the z-unit circle
**LP analysis window: f** or each frame, the short term filter coefficients
are computed using the high pass filtered speech samples within the analysis
window. In the adaptive multi-rate codec, the length of the analysis window is
always 240 samples. For each frame, two asymmetric windows are used to
generate two sets of LP coefficient in the 12.2 kbit/s mode. For the other
modes, only a single asymmetric window is used to generate a single set of LP
coefficients. In the 12.2 kbit/s mode, no samples of the future frames are
used (no lookahead). The other modes use a 5 ms lookahead
**LP coefficients: l** inear Prediction (LP) coefficients (also referred as
Linear Predictive Coding (LPC) coefficients) is a generic descriptive term for
the short term filter coefficients
**mode: w** hen used alone, refers to the source codec mode, i.e., to one of
the source codecs employed in the AMR codec
**open‑loop pitch search:** process of estimating the near optimal lag
directly from the weighted speech input. This is done to simplify the pitch
analysis and confine the closed‑loop pitch search to a small number of lags
around the open‑loop estimated lags. In the adaptive multi-rate codec, an
open‑loop pitch search is performed in every other subframe
**residual: t** he output signal resulting from an inverse filtering operation
**short term synthesis filter:** this filter introduces, into the excitation
signal, short term correlation which models the impulse response of the vocal
tract
**perceptual weighting filter: this** filter is employed in the
analysis‑by‑synthesis search of the codebooks. The filter exploits the noise
masking properties of the formants (vocal tract resonances) by weighting the
error less in regions near the formant frequencies and more in regions away
from them
**subframe:** time interval equal to 5 ms (40 samples at 8 kHz sampling rate)
**vector quantization:** method of grouping several parameters into a vector
and quantizing them simultaneously
**zero input response:** output of a filter due to past inputs, i.e. due to
the present state of the filter, given that an input of zeros is applied
**zero state response:** output of a filter due to the present input, given
that no past inputs have been applied, i.e., given that the state information
in the filter is all zeroes
## 3.2 Symbols
For the purposes of the present document, the following symbols apply:
{width="0.3611111111111111in" height="0.25in"} The inverse filter with
unquantized coefficients
{width="0.34652777777777777in" height="0.2777777777777778in"} The inverse
filter with quantized coefficients
{width="0.875in" height="0.4583333333333333in"} The speech synthesis filter
with quantized coefficients
{width="0.18055555555555555in" height="0.2222222222222222in"} The unquantized
linear prediction parameters (direct form coefficients)
{width="0.18055555555555555in" height="0.2222222222222222in"} The quantified
linear prediction parameters
{width="0.18055555555555555in" height="0.1527777777777778in"} The order of the
LP model
{width="0.375in" height="0.44375in"} The long‑term synthesis filter
{width="0.3611111111111111in" height="0.25in"} The perceptual weighting filter
(unquantized coefficients)
{width="0.4027777777777778in" height="0.2222222222222222in"} The perceptual
weighting factors
{width="0.4166666666666667in" height="0.2222222222222222in"} Adaptive
pre‑filter
{width="0.1527777777777778in" height="0.18055555555555555in"} The integer
pitch lag nearest to the closed‑loop fractional pitch lag of the subframe
{width="0.1388888888888889in" height="0.2222222222222222in"} The adaptive
pre‑filter coefficient (the quantified pitch gain)
{width="1.2777777777777777in" height="0.5277777777777778in"} The formant
postfilter
{width="0.2222222222222222in" height="0.2361111111111111in"} Control
coefficient for the amount of the formant post‑filtering
{width="0.2222222222222222in" height="0.2222222222222222in"} Control
coefficient for the amount of the formant post‑filtering
{width="0.44375in" height="0.2361111111111111in"} Tilt compensation filter
{width="0.18055555555555555in" height="0.2361111111111111in"} Control
coefficient for the amount of the tilt compensation filtering
{width="0.6666666666666666in" height="0.2361111111111111in"} A tilt factor,
with {width="0.2222222222222222in" height="0.2222222222222222in"}being the
first reflection coefficient
{width="0.44375in" height="0.2638888888888889in"} The truncated impulse
response of the formant postfilter
{width="0.2222222222222222in" height="0.2361111111111111in"} The length of
{width="0.44375in" height="0.2638888888888889in"}
{width="0.34652777777777777in" height="0.2361111111111111in"} The
auto‑correlations of {width="0.44375in" height="0.2638888888888889in"}
{width="0.5965277777777778in" height="0.2916666666666667in"} The inverse
filter (numerator) part of the formant postfilter
{width="0.7361111111111112in" height="0.2916666666666667in"} The synthesis
filter (denominator) part of the formant postfilter
{width="0.3194444444444444in" height="0.2222222222222222in"} The residual
signal of the inverse filter {width="0.5965277777777778in"
height="0.2916666666666667in"}
{width="0.3888888888888889in" height="0.2361111111111111in"} Impulse response
of the tilt compensation filter
{width="0.4861111111111111in" height="0.2361111111111111in"} The
AGC‑controlled gain scaling factor of the adaptive postfilter
{width="0.1527777777777778in" height="0.1527777777777778in"} The AGC factor of
the adaptive postfilter
{width="0.5in" height="0.2361111111111111in"} Pre‑processing high‑pass filter
{width="0.44375in" height="0.2222222222222222in"},
{width="0.4861111111111111in" height="0.2222222222222222in"} LP analysis
windows
{width="0.34652777777777777in" height="0.25in"} Length of the first part of
the LP analysis window {width="0.44375in" height="0.2222222222222222in"}
{width="0.375in" height="0.25in"} Length of the second part of the LP analysis
window {width="0.44375in" height="0.2222222222222222in"}
{width="0.3888888888888889in" height="0.25in"} Length of the first part of the
LP analysis window {width="0.4861111111111111in"
height="0.2222222222222222in"}
{width="0.4166666666666667in" height="0.25in"} Length of the second part of
the LP analysis window {width="0.4861111111111111in"
height="0.2222222222222222in"}
{width="0.44375in" height="0.2361111111111111in"} The auto‑correlations of the
windowed speech {width="0.3611111111111111in" height="0.20833333333333334in"}
{width="0.5138888888888888in" height="0.2638888888888889in"} Lag window for
the auto‑correlations (60 Hz bandwidth expansion)
{width="0.19375in" height="0.2361111111111111in"} The bandwidth expansion in
Hz
{width="0.19375in" height="0.2222222222222222in"} The sampling frequency in Hz
{width="0.5277777777777778in" height="0.2361111111111111in"} The modified
(bandwidth expanded) auto‑correlations
{width="0.5in" height="0.2361111111111111in"} The prediction error in the _i_
th iteration of the Levinson algorithm
{width="0.16666666666666666in" height="0.2361111111111111in"} The _i_ th
reflection coefficient
{width="0.2777777777777778in" height="0.3055555555555556in"} The _j_ th direct
form coefficient in the _i_ th iteration of the Levinson algorithm
{width="0.4027777777777778in" height="0.2361111111111111in"} Symmetric LSF
polynomial
{width="0.4166666666666667in" height="0.2361111111111111in"} Antisymmetric LSF
polynomial
{width="0.4027777777777778in" height="0.2361111111111111in"} Polynomial
{width="0.4027777777777778in" height="0.2361111111111111in"} with root
{width="0.4722222222222222in" height="0.18055555555555555in"} eliminated
{width="0.4166666666666667in" height="0.2361111111111111in"} Polynomial
{width="0.4166666666666667in" height="0.2361111111111111in"} with root
{width="0.3611111111111111in" height="0.16666666666666666in"} eliminated
{width="0.18055555555555555in" height="0.2361111111111111in"} The line
spectral pairs (LSPs) in the cosine domain
{width="0.1388888888888889in" height="0.18055555555555555in"} An LSP vector in
the cosine domain
{width="0.3055555555555556in" height="0.2777777777777778in"} The quantified
LSP vector at the _i_ th subframe of the frame _n_
{width="0.20833333333333334in" height="0.2361111111111111in"} The line
spectral frequencies (LSFs)
{width="0.4166666666666667in" height="0.2222222222222222in"} A
{width="0.16666666666666666in" height="0.1388888888888889in"}th order
Chebyshev polynomial
{width="0.7361111111111112in" height="0.2222222222222222in"} The coefficients
of the polynomials {width="0.3888888888888889in"
height="0.2222222222222222in"}and {width="0.4027777777777778in"
height="0.2222222222222222in"}
{width="0.8055555555555556in" height="0.2638888888888889in"} The coefficients
of the polynomials {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"}
{width="0.3333333333333333in" height="0.2222222222222222in"} The coefficients
of either {width="0.4027777777777778in" height="0.2361111111111111in"} or
{width="0.4166666666666667in" height="0.2361111111111111in"}
{width="0.3611111111111111in" height="0.2222222222222222in"} Sum polynomial of
the Chebyshev polynomials
{width="0.1388888888888889in" height="0.1527777777777778in"} Cosine of angular
frequency {width="0.16666666666666666in" height="0.1527777777777778in"}
{width="0.2222222222222222in" height="0.2361111111111111in"} Recursion
coefficients for the Chebyshev polynomial evaluation
{width="0.2222222222222222in" height="0.2361111111111111in"} The line spectral
frequencies (LSFs) in Hz
{width="1.1527777777777777in" height="0.2916666666666667in"} The vector
representation of the LSFs in Hz
{width="0.4861111111111111in" height="0.2638888888888889in"},
{width="0.5138888888888888in" height="0.2638888888888889in"} The mean‑removed
LSF vectors at frame _n_
{width="0.5in" height="0.2638888888888889in"}, {width="0.5138888888888888in"
height="0.2638888888888889in"} The LSF prediction residual vectors at frame
_n_
{width="0.3333333333333333in" height="0.20833333333333334in"} The predicted
LSF vector at frame _n_
{width="0.7361111111111112in" height="0.2638888888888889in"} The quantified
second residual vector at the past frame
{width="0.20833333333333334in" height="0.2361111111111111in"} The quantified
LSF vector at quantization index _k_
{width="0.375in" height="0.2361111111111111in"} The LSP quantization error
{width="0.9583333333333334in" height="0.2222222222222222in"} LSP‑quantization
weighting factors
{width="0.2222222222222222in" height="0.2361111111111111in"} The distance
between the line spectral frequencies {width="0.3055555555555556in"
height="0.2361111111111111in"} and {width="0.3055555555555556in"
height="0.2361111111111111in"}
{width="0.3333333333333333in" height="0.2222222222222222in"} The impulse
response of the weighted synthesis filter
{width="0.2777777777777778in" height="0.2361111111111111in"} The correlation
maximum of open‑loop pitch analysis at delay _k_
{width="0.875in" height="0.2638888888888889in"} The correlation maxima at
delays {width="0.8333333333333334in" height="0.2361111111111111in"}
{width="1.1805555555555556in" height="0.2777777777777778in"} The normalized
correlation maxima {width="0.2361111111111111in"
height="0.2361111111111111in"} and the corresponding delays
{width="0.8333333333333334in" height="0.2361111111111111in"}
{width="1.7916666666666667in" height="0.4722222222222222in"} The weighted
synthesis filter
{width="0.5694444444444444in" height="0.2916666666666667in"} The numerator of
the perceptual weighting filter
{width="0.7222222222222222in" height="0.2916666666666667in"} The denominator
of the perceptual weighting filter
{width="0.16666666666666666in" height="0.2222222222222222in"} The integer
nearest to the fractional pitch lag of the previous (1^st^ or 3^rd^) subframe
{width="0.3611111111111111in" height="0.20833333333333334in"} The windowed
speech signal
{width="0.4166666666666667in" height="0.2361111111111111in"} The weighted
speech signal
{width="0.3194444444444444in" height="0.2222222222222222in"} Reconstructed
speech signal
{width="0.375in" height="0.2222222222222222in"} The gain‑scaled post‑filtered
signal
{width="0.4305555555555556in" height="0.2638888888888889in"} Post‑filtered
speech signal (before scaling)
{width="0.3333333333333333in" height="0.2222222222222222in"} The target signal
for adaptive codebook search
{width="0.4166666666666667in" height="0.2361111111111111in"},
{width="0.20833333333333334in" height="0.2777777777777778in"} The target
signal for algebraic codebook search
{width="0.625in" height="0.2222222222222222in"} The LP residual signal
{width="0.3194444444444444in" height="0.2222222222222222in"} The fixed
codebook vector
{width="0.3194444444444444in" height="0.2222222222222222in"} The adaptive
codebook vector
{width="1.2361111111111112in" height="0.2222222222222222in"} The filtered
adaptive codebook vector
{width="0.4305555555555556in" height="0.2361111111111111in"} The past filtered
excitation
{width="0.3333333333333333in" height="0.2222222222222222in"} The excitation
signal
{width="0.3333333333333333in" height="0.2361111111111111in"} The emphasized
adaptive codebook vector
{width="0.375in" height="0.2222222222222222in"} The gain‑scaled emphasized
excitation signal
{width="0.2638888888888889in" height="0.2638888888888889in"} The best
open‑loop lag
{width="0.3194444444444444in" height="0.2222222222222222in"} Minimum lag
search value
{width="0.34652777777777777in" height="0.2222222222222222in"} Maximum lag
search value
{width="0.3888888888888889in" height="0.25in"} Correlation term to be
maximized in the adaptive codebook search
{width="0.25in" height="0.2222222222222222in"} The FIR filter for
interpolating the normalized correlation term {width="0.3888888888888889in"
height="0.25in"}
{width="0.4583333333333333in" height="0.2638888888888889in"} The interpolated
value of {width="0.3888888888888889in" height="0.25in"} for the integer delay
_k_ and fraction _t_
{width="0.2638888888888889in" height="0.2361111111111111in"} The FIR filter
for interpolating the past excitation signal {width="0.3333333333333333in"
height="0.2222222222222222in"} to yield the adaptive codebook vector
{width="0.3194444444444444in" height="0.2222222222222222in"}
{width="0.2638888888888889in" height="0.2361111111111111in"} Correlation term
to be maximized in the algebraic codebook search at index _k_
{width="0.2222222222222222in" height="0.2361111111111111in"} The correlation
in the numerator of {width="0.2638888888888889in"
height="0.2361111111111111in"} at index _k_
{width="0.3333333333333333in" height="0.25in"} The energy in the denominator
of {width="0.2638888888888889in" height="0.2361111111111111in"} at index _k_
{width="0.6666666666666666in" height="0.2777777777777778in"} The correlation
between the target signal {width="0.4166666666666667in"
height="0.2361111111111111in"} and the impulse response
{width="0.3333333333333333in" height="0.25in"}, i.e., backward filtered target
{width="0.19375in" height="0.18055555555555555in"} The lower triangular
Toepliz convolution matrix with diagonal {width="0.3333333333333333in"
height="0.25in"} and lower diagonals {width="0.9305555555555556in"
height="0.25in"}
{width="0.7083333333333334in" height="0.2777777777777778in"} The matrix of
correlations of {width="0.3333333333333333in" height="0.25in"}
{width="0.34652777777777777in" height="0.2222222222222222in"} The elements of
the vector **d**
{width="0.44375in" height="0.2222222222222222in"} The elements of the
symmetric matrix {width="0.18055555555555555in"
height="0.18055555555555555in"}
{width="0.20833333333333334in" height="0.2222222222222222in"} The innovation
vector
{width="0.19375in" height="0.2222222222222222in"} The correlation in the
numerator of {width="0.2638888888888889in" height="0.2361111111111111in"}
{width="0.20833333333333334in" height="0.2361111111111111in"} The position of
the _i_ th pulse
{width="0.20833333333333334in" height="0.2361111111111111in"} The amplitude of
the _i_ th pulse
{width="0.2777777777777778in" height="0.25in"} The number of pulses in the
fixed codebook excitation
{width="0.3055555555555556in" height="0.2222222222222222in"} The energy in the
denominator of {width="0.2638888888888889in" height="0.2361111111111111in"}
{width="0.69375in" height="0.2361111111111111in"} The normalized long‑term
prediction residual
{width="0.3194444444444444in" height="0.2222222222222222in"} The signal used
for presetting the signs in algebraic codebook search
{width="0.4027777777777778in" height="0.2361111111111111in"} The sign signal
for the algebraic codebook search
{width="0.4027777777777778in" height="0.2222222222222222in"} Sign extended
backward filtered target
{width="0.5in" height="0.2638888888888889in"} The modified elements of the
matrix {width="0.18055555555555555in" height="0.18055555555555555in"},
including sign information
{width="0.18055555555555555in" height="0.2222222222222222in"},
{width="0.3611111111111111in" height="0.2361111111111111in"} The fixed
codebook vector convolved with {width="0.3333333333333333in"
height="0.2222222222222222in"}
{width="0.375in" height="0.2222222222222222in"} The mean‑removed innovation
energy (in dB)
{width="0.18055555555555555in" height="0.20833333333333334in"} The mean of the
innovation energy
{width="0.375in" height="0.2361111111111111in"} The predicted energy
{width="0.8611111111111112in" height="0.2638888888888889in"} The MA prediction
coefficients
{width="0.3611111111111111in" height="0.2361111111111111in"} The quantified
prediction error at subframe _k_
{width="0.2638888888888889in" height="0.2222222222222222in"} The mean
innovation energy
{width="0.3888888888888889in" height="0.2222222222222222in"} The prediction
error of the fixed‑codebook gain quantization
{width="0.2916666666666667in" height="0.25in"} The quantization error of the
fixed‑codebook gain quantization
{width="0.3194444444444444in" height="0.2222222222222222in"} The states of the
synthesis filter {width="0.4861111111111111in" height="0.2638888888888889in"}
{width="0.4305555555555556in" height="0.2361111111111111in"} The perceptually
weighted error of the analysis‑by‑synthesis search
{width="0.1527777777777778in" height="0.19375in"} The gain scaling factor for
the emphasized excitation
{width="0.20833333333333334in" height="0.2222222222222222in"} The
fixed‑codebook gain
{width="0.20833333333333334in" height="0.2222222222222222in"} The predicted
fixed‑codebook gain
{width="0.20833333333333334in" height="0.2222222222222222in"} The quantified
fixed codebook gain
{width="0.2361111111111111in" height="0.19722222222222222in"} The adaptive
codebook gain
{width="0.2361111111111111in" height="0.19722222222222222in"} The quantified
adaptive codebook gain
{width="0.9027777777777778in" height="0.25in"} A correction factor between the
gain {width="0.20833333333333334in" height="0.2222222222222222in"} and the
estimated one {width="0.20833333333333334in" height="0.2222222222222222in"}
{width="0.3333333333333333in" height="0.2638888888888889in"} The optimum value
for {width="0.2777777777777778in" height="0.25in"}
{width="0.2638888888888889in" height="0.2361111111111111in"} Gain scaling
factor
## 3.3 Abbreviations
For the purposes of the present document, the following abbreviations apply.
ACELP Algebraic Code Excited Linear Prediction
AGC Adaptive Gain Control
AMR Adaptive Multi-Rate
CELP Code Excited Linear Prediction
EFR Enhanced Full Rate
FIR Finite Impulse Response
ISPP Interleaved Single‑Pulse Permutation
LP Linear Prediction
LPC Linear Predictive Coding
LSF Line Spectral Frequency
LSP Line Spectral Pair
LTP Long Term Predictor (or Long Term Prediction)
MA Moving Average
# 4 Outline description
The present document is structured as follows:
Clause 4.1 contains a functional description of the audio parts including the
A/D and D/A functions. Clause 4.2 describes the conversion between 13‑bit
uniform and 8‑bit A‑law or {width="0.16666666666666666in"
height="0.18055555555555555in"}-law samples. Clauses 4.3 and 4.4 present a
simplified description of the principles of the AMR codec encoding and
decoding process respectively. In clause 4.5, the sequence and subjective
importance of encoded parameters are given.
Clause 5 presents the functional description of the AMR codec encoding,
whereas clause 6 describes the decoding procedures. In clause 7, the detailed
bit allocation of the AMR codec is tabulated.
## 4.1 Functional description of audio parts
The analogue‑to‑digital and digital‑to‑analogue conversion will in principle
comprise the following elements:
1) Analogue to uniform digital PCM
\- microphone;
\- input level adjustment device;
\- input anti‑aliasing filter;
\- sample‑hold device sampling at 8 kHz;
\- analogue‑to‑uniform digital conversion to 13‑bit representation.
The uniform format shall be represented in two\'s complement.
2) Uniform digital PCM to analogue
\- conversion from 13‑bit/8 kHz uniform PCM to analogue;
\- a hold device;
\- reconstruction filter including x/sin( x ) correction;
\- output level adjustment device;
\- earphone or loudspeaker.
In the terminal equipment, the A/D function may be achieved either:
\- by direct conversion to 13‑bit uniform PCM format;
\- or by conversion to 8‑bit A‑law or {width="0.16666666666666666in"
height="0.18055555555555555in"}-law compounded format, based on a standard
A‑law or {width="0.16666666666666666in" height="0.18055555555555555in"}-law
codec/filter according to ITU‑T Recommendations G.711 [6] and G.714, followed
by the 8‑bit to 13‑bit conversion as specified in clause 4.2.1.
For the D/A operation, the inverse operations take place.
In the latter case it should be noted that the specifications in ITU‑T G.714
(superseded by G.712) are concerned with PCM equipment located in the central
parts of the network. When used in the terminal equipment, the present
document does not on its own ensure sufficient out‑of‑band attenuation. The
specification of out‑of‑band signals is defined in [1] in clause 2.
## 4.2 Preparation of speech samples
The encoder is fed with data comprising of samples with a resolution of 13
bits left justified in a 16‑bit word. The three least significant bits are set
to \'0\'. The decoder outputs data in the same format. Outside the speech
codec further processing must be applied if the traffic data occurs in a
different representation.
### 4.2.1 PCM format conversion
The conversion between 8‑bit A‑Law or {width="0.16666666666666666in"
height="0.18055555555555555in"}-law compressed data and linear data with
13‑bit resolution at the speech encoder input shall be as defined in ITU‑T
Rec. G.711 [6].
ITU‑T Rec. G.711 [6] specifies the A‑Law or {width="0.16666666666666666in"
height="0.18055555555555555in"}-law to linear conversion and vice versa by
providing table entries. Examples on how to perform the conversion by
fixed‑point arithmetic can be found in ITU‑T Rec. G.726 [7]. Clause 4.2.1 of
G.726 [7] describes A‑Law or {width="0.16666666666666666in"
height="0.18055555555555555in"}-law to linear expansion and clause 4.2.8 of
G.726 [7] provides a solution for linear to A‑Law or
{width="0.16666666666666666in" height="0.18055555555555555in"}-law
compression.
## 4.3 Principles of the adaptive multi-rate speech encoder
The AMR codec consists of eight source codecs with bit-rates of 12.2, 10.2,
7.95, 7.40, 6.70, 5.90, 5.15 and 4.75 kbit/s.
The codec is based on the code‑excited linear predictive (CELP) coding model.
A 10^th^ order linear prediction (LP), or short‑term, synthesis filter is used
which is given by:
{width="2.0277777777777777in" height="0.5555555555555556in"}, (1)
where {width="0.9305555555555556in" height="0.2222222222222222in"} are the
(quantified) linear prediction (LP) parameters, and {width="0.5in"
height="0.18055555555555555in"} is the predictor order. The long‑term, or
pitch, synthesis filter is given by:
{width="1.25in" height="0.5138888888888888in"}, (2)
where is the pitch delay and {width="0.2222222222222222in" height="0.25in"} is
the pitch gain. The pitch synthesis filter is implemented using the so‑called
adaptive codebook approach.
The CELP speech synthesis model is shown in figure 2. In this model, the
excitation signal at the input of the short‑term LP synthesis filter is
constructed by adding two excitation vectors from adaptive and fixed
(innovative) codebooks. The speech is synthesized by feeding the two properly
chosen vectors from these codebooks through the short‑term synthesis filter.
The optimum excitation sequence in a codebook is chosen using an
analysis‑by‑synthesis search procedure in which the error between the original
and synthesized speech is minimized according to a perceptually weighted
distortion measure.
The perceptual weighting filter used in the analysis‑by‑synthesis search
technique is given by:
{width="1.125in" height="0.5694444444444444in"}, (3)
where {width="0.3611111111111111in" height="0.25in"} is the unquantized LP
filter and {width="1.0555555555555556in" height="0.2222222222222222in"} are
the perceptual weighting factors. The values (for the 12.2 and 10.2 kbit/s
mode) or {width="0.6666666666666666in" height="0.2361111111111111in"} (for all
other modes) and {width="0.5833333333333334in" height="0.2222222222222222in"}
are used. The weighting filter uses the unquantized LP parameters.
The coder operates on speech frames of 20 ms corresponding to 160 samples at
the sampling frequency of 8 000 sample/s. At each 160 speech samples, the
speech signal is analysed to extract the parameters of the CELP model (LP
filter coefficients, adaptive and fixed codebooks\' indices and gains). These
parameters are encoded and transmitted. At the decoder, these parameters are
decoded and speech is synthesized by filtering the reconstructed excitation
signal through the LP synthesis filter.
The signal flow at the encoder is shown in figure 3. LP analysis is performed
twice per frame for the 12.2 kbit/s mode and once for the other modes. For the
12.2 kbit/s mode, the two sets of LP parameters are converted to line spectrum
pairs (LSP) and jointly quantized using split matrix quantization (SMQ) with
38 bits. For the other modes, the single set of LP parameters is converted to
line spectrum pairs (LSP) and vector quantized using split vector quantization
(SVQ). The speech frame is divided into 4 subframes of 5 ms each (40 samples).
The adaptive and fixed codebook parameters are transmitted every subframe. The
quantized and unquantized LP parameters or their interpolated versions are
used depending on the subframe. An open‑loop pitch lag is estimated in every
other subframe (except for the 5.15 and 4.75 kbit/s modes for which it is done
once per frame) based on the perceptually weighted speech signal.
Then the following operations are repeated for each subframe:
The target signal {width="0.3333333333333333in" height="0.2222222222222222in"}
is computed by filtering the LP residual through the weighted synthesis filter
{width="0.69375in" height="0.2222222222222222in"} with the initial states of
the filters having been updated by filtering the error between LP residual and
excitation (this is equivalent to the common approach of subtracting the zero
input response of the weighted synthesis filter from the weighted speech
signal).
The impulse response, {width="0.3333333333333333in"
height="0.2222222222222222in"} of the weighted synthesis filter is computed.
Closed‑loop pitch analysis is then performed (to find the pitch lag and gain),
using the target {width="0.3333333333333333in" height="0.2222222222222222in"}
and impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"}, by searching around the open‑loop pitch lag.
Fractional pitch with 1/6^th^ or 1/3^rd^ of a sample resolution (depending on
the mode) is used.
The target signal {width="0.3333333333333333in" height="0.2222222222222222in"}
is updated by removing the adaptive codebook contribution (filtered adaptive
codevector), and this new target, {width="0.4166666666666667in"
height="0.2361111111111111in"}, is used in the fixed algebraic codebook search
(to find the optimum innovation).
The gains of the adaptive and fixed codebook are scalar quantified with 4 and
5 bits respectively or vector quantified with 6-7 bits (with moving average
(MA) prediction applied to the fixed codebook gain).
Finally, the filter memories are updated (using the determined excitation
signal) for finding the target signal in the next subframe.
The bit allocation of the AMR codec modes is shown in table 1. In each 20 ms
speech frame, 95, 103, 118, 134, 148, 159, 204 or 244 bits are produced,
corresponding to a bit-rate of 4.75, 5.15, 5.90, 6.70, 7.40, 7.95, 10.2 or
12.2 kbit/s. More detailed bit allocation among the codec parameters is given
in tables 9a-9h. Note that the most significant bits (MSB) are always sent
first.
Table 1: Bit allocation of the AMR coding algorithm for 20 ms frame
* * *
Mode Parameter 1^st^ subframe 2^nd^ subframe 3^rd^ subframe 4^th^ subframe
total per frame 2 LSP sets 38 **12.2 kbit/s** Pitch delay 9 6 9 6 30 **(GSM
EFR)** Pitch gain 4 4 4 4 16 Algebraic code 35 35 35 35 140 Codebook gain 5 5
5 5 20 **Total** 244 LSP set 26 **10.2 kbit/s** Pitch delay 8 5 8 5 26
Algebraic code 31 31 31 31 124 Gains 7 7 7 7 28 Total 204 LSP sets 27 **7.95
kbit/s** Pitch delay 8 6 8 6 28 Pitch gain 4 4 4 4 16 Algebraic code 17 17 17
17 68 Codebook gain 5 5 5 5 20 Total 159 LSP set 26 **7.40 kbit/s** Pitch
delay 8 5 8 5 26 **(TDMA EFR)** Algebraic code 17 17 17 17 68 Gains 7 7 7 7 28
Total 148 LSP set 26 **6.70 kbit/s** Pitch delay 8 4 8 4 24 **(PDC EFR)**
Algebraic code 14 14 14 14 56 Gains 7 7 7 7 28 Total 134 LSP set 26 **5.90
kbit/s** Pitch delay 8 4 8 4 24 Algebraic code 11 11 11 11 44 Gains 6 6 6 6 24
Total 118 LSP set 23 **5.15 kbit/s** Pitch delay 8 4 4 4 20 Algebraic code 9 9
9 9 36 Gains 6 6 6 6 24 Total 103 LSP set 23 **4.75 kbit/s** Pitch delay 8 4 4
4 20 Algebraic code 9 9 9 9 36 Gains 8 8 16  
Total 95
* * *
## 4.4 Principles of the adaptive multi-rate speech decoder
The signal flow at the decoder is shown in figure 4. At the decoder, based on
the chosen mode, the transmitted indices are extracted from the received
bitstream. The indices are decoded to obtain the coder parameters at each
transmission frame. These parameters are the LSP vectors, the fractional pitch
lags, the innovative codevectors, and the pitch and innovative gains. The LSP
vectors are converted to the LP filter coefficients and interpolated to obtain
LP filters at each subframe. Then, at each 40-sample subframe:
‑ the excitation is constructed by adding the adaptive and innovative
codevectors scaled by their respective gains;
‑ the speech is reconstructed by filtering the excitation through the LP
synthesis filter.
Finally, the reconstructed speech signal is passed through an adaptive
postfilter.
## 4.5 Sequence and subjective importance of encoded parameters
The encoder will produce the output information in a unique sequence and
format, and the decoder must receive the same information in the same way. In
table 9a-9h, the sequence of output bits and the bit allocation for each
parameter is shown.
The different parameters of the encoded speech and their individual bits have
unequal importance with respect to subjective quality. The output and input
frame formats for the AMR speech codec are given in [2], where a reordering of
bits take place.
# 5 Functional description of the encoder
In this clause, the different functions of the encoder represented in figure 3
are described.
## 5.1 Pre**‑** processing (all modes)
Two pre‑processing functions are applied prior to the encoding process:
high‑pass filtering and signal down‑scaling.
Down‑scaling consists of dividing the input by a factor of 2 to reduce the
possibility of overflows in the fixed‑point implementation.
The high‑pass filter serves as a precaution against undesired low frequency
components. A filter with a cut off frequency of 80 Hz is used, and it is
given by:
{width="3.875in" height="0.4583333333333333in"}. (4)
Down‑scaling and high‑pass filtering are combined by dividing the coefficients
at the numerator of {width="0.5in" height="0.2361111111111111in"} by 2.
## 5.2 Linear prediction analysis and quantization
**12.2 kbit/s mode**
Short‑term prediction, or linear prediction (LP), analysis is performed twice
per speech frame using the auto‑correlation approach with 30 ms asymmetric
windows. No lookahead is used in the auto‑correlation computation.
The auto‑correlations of windowed speech are converted to the LP coefficients
using the Levinson‑Durbin algorithm. Then the LP coefficients are transformed
to the Line Spectral Pair (LSP) domain for quantization and interpolation
purposes. The interpolated quantified and unquantized filter coefficients are
converted back to the LP filter coefficients (to construct the synthesis and
weighting filters at each subframe).
**10.2, 7.95, 7.40, 6.70, 5.90, 5.15, 4.75 kbit/s modes**
Short‑term prediction, or linear prediction (LP), analysis is performed once
per speech frame using the auto‑correlation approach with 30 ms asymmetric
windows. A lookahead of 40 samples (5 ms) is used in the auto‑correlation
computation.
The auto‑correlations of windowed speech are converted to the LP coefficients
using the Levinson‑Durbin algorithm. Then the LP coefficients are transformed
to the Line Spectral Pair (LSP) domain for quantization and interpolation
purposes. The interpolated quantified and unquantized filter coefficients are
converted back to the LP filter coefficients (to construct the synthesis and
weighting filters at each subframe).
### 5.2.1 Windowing and auto**‑** correlation computation
**12.2 kbit/s mode**
LP analysis is performed twice per frame using two different asymmetric
windows. The first window has its weight concentrated at the second subframe
and it consists of two halves of Hamming windows with different sizes. The
window is given by:
{width="4.958333333333333in" height="1.0277777777777777in"} (5)
The values {width="0.7916666666666666in" height="0.25in"} and $L_{2^{(I)}} =
\text{80}$ are used. The second window has its weight concentrated at the
fourth subframe and it consists of two parts: the first part is half a Hamming
window and the second part is a quarter of a cosine function cycle. The window
is given by:
{width="4.986111111111111in" height="1.0277777777777777in"} (6)
where the values {width="0.8465277777777778in" height="0.25in"} and
{width="0.6805555555555556in" height="0.25in"} are used.
Note that both LP analyses are performed on the same set of speech samples.
The windows are applied to 80 samples from past speech frame in addition to
the 160 samples of the present speech frame. No samples from future frames are
used (no lookahead). A diagram of the two LP analysis windows is depicted
below.
{width="6.571527777777778in" height="2.9833333333333334in"}
Figure 1: LP analysis windows
The auto‑correlations of the windowed speech {width="1.25in"
height="0.2361111111111111in"}, are computed by:
{width="2.8465277777777778in" height="0.4722222222222222in"} (7)
and a 60 Hz bandwidth expansion is used by lag windowing the auto‑correlations
using the window:
{width="2.8055555555555554in" height="0.6111111111111112in"}, (8)
where {width="0.5555555555555556in" height="0.2222222222222222in"} Hz is the
bandwidth expansion and {width="0.7083333333333334in"
height="0.2222222222222222in"} Hz is the sampling frequency. Further,
{width="0.4166666666666667in" height="0.2361111111111111in"} is multiplied by
the white noise correction factor 1.0001 which is equivalent to adding a noise
floor at ‑40 dB.
**10.2, 7.95, 7.40, 6.70, 5.90, 5.15, 4.75 kbit/s modes**
LP analysis is performed once per frame using an asymmetric window. The window
has its weight concentrated at the fourth subframe and it consists of two
parts: the first part is half a Hamming window and the second part is a
quarter of a cosine function cycle. The window is given by equation (6) where
the values {width="0.625in" height="0.2361111111111111in"} and
{width="0.5694444444444444in" height="0.2361111111111111in"} are used.
The auto‑correlations of the windowed speech {width="1.25in"
height="0.2361111111111111in"}, are computed by equation (7) and a 60 Hz
bandwidth expansion is used by lag windowing the auto‑correlations using the
window of equation (8). Further, {width="0.4166666666666667in"
height="0.2361111111111111in"} is multiplied by the white noise correction
factor 1.0001 which is equivalent to adding a noise floor at ‑40 dB.
### 5.2.2 Levinson**‑** Durbin algorithm (all modes)
The modified auto‑correlations {width="1.4861111111111112in"
height="0.2361111111111111in"} and {width="2.2777777777777777in"
height="0.25in"} are used to obtain the direct form LP filter coefficients
{width="1.0in" height="0.2222222222222222in"} by solving the set of equations.
{width="2.8194444444444446in" height="0.4722222222222222in"} (9)
The set of equations in (9) is solved using the Levinson‑Durbin algorithm.
This algorithm uses the following recursion:
{width="3.0555555555555554in" height="2.2777777777777777in"}
The final solution is given as {width="1.4305555555555556in"
height="0.2777777777777778in"}.
The LP filter coefficients are converted to the line spectral pair (LSP)
representation for quantization and interpolation purposes. The conversions to
the LSP domain and back to the LP filter coefficient domain are described in
the next clause.
### 5.2.3 LP to LSP conversion (all modes)
The LP filter coefficients {width="0.9722222222222222in"
height="0.2222222222222222in"}, are converted to the line spectral pair (LSP)
representation for quantization and interpolation purposes. For a 10^th^ order
LP filter, the LSPs are defined as the roots of the sum and difference
polynomials:
{width="1.7916666666666667in" height="0.3194444444444444in"} (10)
and
{width="1.8055555555555556in" height="0.3194444444444444in"}, (11)
respectively. The polynomial {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"} are symmetric and anti‑symmetric, respectively.
It can be proven that all roots of these polynomials are on the unit circle
and they alternate each other. {width="0.4027777777777778in"
height="0.2361111111111111in"} has a root {width="0.4722222222222222in"
height="0.16666666666666666in"} ({width="0.4583333333333333in"
height="0.1527777777777778in"}) and {width="0.4166666666666667in"
height="0.2361111111111111in"} has a root {width="0.3611111111111111in"
height="0.16666666666666666in"} ({width="0.4305555555555556in"
height="0.18055555555555555in"}). To eliminate these two roots, we define the
new polynomials:
{width="1.5833333333333333in" height="0.3194444444444444in"} (12)
and
{width="1.625in" height="0.3194444444444444in"} (13)
Each polynomial has 5 conjugate roots on the unit circle
{width="0.4722222222222222in" height="0.3055555555555556in"}, therefore, the
polynomials can be written as
{width="2.125in" height="0.44375in"} (14)
and
{width="2.19375in" height="0.4583333333333333in"}, (15)
where {width="0.8611111111111112in" height="0.2638888888888889in"} with
{width="0.16666666666666666in" height="0.18055555555555555in"} being the line
spectral frequencies (LSF) and they satisfy the ordering property
{width="1.7361111111111112in" height="0.2222222222222222in"}. We refer to
{width="0.18055555555555555in" height="0.2222222222222222in"} as the LSPs in
the cosine domain.
Since both polynomials {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"} are symmetric only the first 5 coefficients of
each polynomial need to be computed. The coefficients of these polynomials are
found by the recursive relations (for {width="0.3611111111111111in"
height="0.18055555555555555in"} to 4):
{width="2.0277777777777777in" height="0.5in"} (16)
where {width="0.5in" height="0.18055555555555555in"} is the predictor order.
The LSPs are found by evaluating the polynomials {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"} at 60 points equally spaced between 0 and
{width="0.125in" height="0.1111111111111111in"} and checking for sign changes.
A sign change signifies the existence of a root and the sign change interval
is then divided 4 times to better track the root. The Chebyshev polynomials
are used to evaluate {width="0.4027777777777778in"
height="0.2361111111111111in"} and {width="0.4166666666666667in"
height="0.2361111111111111in"}. In this method the roots are found directly in
the cosine domain {width="0.3194444444444444in"
height="0.2638888888888889in"}. The polynomials {width="0.4027777777777778in"
height="0.2361111111111111in"} or {width="0.4166666666666667in"
height="0.2361111111111111in"} evaluated at {width="0.5416666666666666in"
height="0.2361111111111111in"} can be written as:
{width="1.375in" height="0.2638888888888889in"},
with:
{width="4.819444444444445in" height="0.2361111111111111in"}, (17)
where {width="1.19375in" height="0.2361111111111111in"} is the
{width="0.16666666666666666in" height="0.1388888888888889in"}th order
Chebyshev polynomial, and {width="1.0277777777777777in"
height="0.2361111111111111in"} are the coefficients of either
{width="0.4027777777777778in" height="0.2361111111111111in"} or
{width="0.4166666666666667in" height="0.2361111111111111in"}, computed using
the equations in (16). The polynomial {width="0.3611111111111111in"
height="0.2222222222222222in"} is evaluated at a certain value of
{width="0.7638888888888888in" height="0.2222222222222222in"} using the
recursive relation:
{width="2.25in" height="0.8055555555555556in"}
with initial values {width="0.4583333333333333in"
height="0.2361111111111111in"} and {width="0.5277777777777778in"
height="0.2361111111111111in"} The details of the Chebyshev polynomial
evaluation method are found in P. Kabal and R.P. Ramachandran [4].
### 5.2.4 LSP to LP conversion (all modes)
Once the LSPs are quantified and interpolated, they are converted back to the
LP coefficient domain {width="0.34652777777777777in"
height="0.2638888888888889in"}. The conversion to the LP domain is done as
follows. The coefficients of {width="0.4027777777777778in"
height="0.2361111111111111in"} or {width="0.4166666666666667in"
height="0.2361111111111111in"} are found by expanding equations (14) and (15)
knowing the quantified and interpolated LSPs {width="1.0277777777777777in"
height="0.2222222222222222in"}. The following recursive relation is used to
compute {width="0.375in" height="0.2361111111111111in"}:
{width="3.1527777777777777in" height="1.4861111111111112in"}
with initial values {width="0.5833333333333334in" height="0.25in"} and
{width="0.69375in" height="0.25in"}. The coefficients
{width="0.3888888888888889in" height="0.25in"} are computed similarly by
replacing {width="0.375in" height="0.2222222222222222in"} by {width="0.25in"
height="0.2222222222222222in"}.
Once the coefficients {width="0.375in" height="0.2361111111111111in"} and
{width="0.3888888888888889in" height="0.2361111111111111in"} are found,
{width="0.4027777777777778in" height="0.2361111111111111in"} and
{width="0.4166666666666667in" height="0.2361111111111111in"} are multiplied by
{width="0.44375in" height="0.20833333333333334in"} and {width="0.44375in"
height="0.20833333333333334in"}, respectively, to obtain
{width="0.4027777777777778in" height="0.2361111111111111in"} and
{width="0.4166666666666667in" height="0.2361111111111111in"}; that is:
{width="2.4305555555555554in" height="0.5in"}. (18)
Finally the LP coefficients are found by:
{width="3.1527777777777777in" height="0.5277777777777778in"}. (19)
This is directly derived from the relation {width="1.69375in"
height="0.2916666666666667in"}, and considering the fact that
{width="0.4027777777777778in" height="0.2361111111111111in"} and
{width="0.4166666666666667in" height="0.2361111111111111in"} are symmetric and
anti‑symmetric polynomials, respectively.
### 5.2.5 Quantization of the LSP coefficients
**12.2 kbit/s mode**
The two sets of LP filter coefficients per frame are quantified using the LSP
representation in the frequency domain; that is:
{width="2.263888888888889in" height="0.4305555555555556in"} (20)
where {width="0.18055555555555555in" height="0.2222222222222222in"} are the
line spectral frequencies (LSF) in Hz [0,4 000] and
{width="0.6666666666666666in" height="0.2222222222222222in"} is the sampling
frequency. The LSF vector is given by {width="1.1527777777777777in"
height="0.2916666666666667in"}, with _t_ denoting transpose.
A 1^st^ order MA prediction is applied, and the two residual LSF vectors are
jointly quantified using split matrix quantization (SMQ). The prediction and
quantization are performed as follows. Let {width="0.5in"
height="0.2638888888888889in"} and {width="0.5in"
height="0.2638888888888889in"} denote the mean‑removed LSF vectors at frame
{width="0.1388888888888889in" height="0.1388888888888889in"}. The prediction
residual vectors {width="0.5in" height="0.2638888888888889in"} and
{width="0.5in" height="0.2638888888888889in"} are given by:
{width="2.0416666666666665in" height="0.5277777777777778in"} (21)
where {width="0.34652777777777777in" height="0.2222222222222222in"} is the
predicted LSF vector at frame {width="0.1388888888888889in"
height="0.1388888888888889in"}. First order moving‑average (MA) prediction is
used where:
{width="1.4722222222222223in" height="0.2777777777777778in"}, (22)
where {width="0.7361111111111112in" height="0.2638888888888889in"} is the
quantified second residual vector at the past frame.
The two LSF residual vectors {width="0.2916666666666667in"
height="0.2361111111111111in"} and {width="0.2916666666666667in"
height="0.2361111111111111in"} are jointly quantified using split matrix
quantization (SMQ). The matrix {width="0.7222222222222222in"
height="0.3194444444444444in"} is split into 5 submatrices of dimension 2 x 2
(two elements from each vector). For example, the first submatrix consists of
the elements {width="0.2777777777777778in" height="0.2916666666666667in"},
{width="0.2777777777777778in" height="0.2916666666666667in"},
{width="0.2916666666666667in" height="0.2916666666666667in"}, and
{width="0.2916666666666667in" height="0.2916666666666667in"}. The 5
submatrices are quantified with 7, 8, 8+1, 8, and 6 bits, respectively. The
third submatrix uses a 256‑entry signed codebook (8‑bit index plus 1‑bit
sign).
A weighted LSP distortion measure is used in the quantization process. In
general, for an input LSP vector {width="0.125in"
height="0.18055555555555555in"} and a quantified vector at index
{width="0.1388888888888889in" height="0.18055555555555555in"},
{width="0.20833333333333334in" height="0.2361111111111111in"}, the
quantization is performed by finding the index {width="0.1388888888888889in"
height="0.18055555555555555in"} which minimizes:
{width="1.69375in" height="0.5277777777777778in"} (23)
The weighting factors {width="0.9027777777777778in"
height="0.2222222222222222in"}, are given by
{width="2.611111111111111in" height="0.8333333333333334in"} (24)
where {width="0.9861111111111112in" height="0.2222222222222222in"} with
{width="0.4305555555555556in" height="0.2222222222222222in"} and
{width="0.7361111111111112in" height="0.2222222222222222in"}. Here, two sets
of weighting coefficients are computed for the two LSF vectors. In the
quantization of each submatrix, two weighting coefficients from each set are
used with their corresponding LSFs.
**10.2, 7.95, 7.40, 6.70, 5.90, 5.15, 4.75 kbit/s modes**
The set of LP filter coefficients per frame is quantified using the LSP
representation in the frequency domain using equation (20).
A 1^st^ order MA prediction is applied, and the residual LSF vector is
quantified using split vector quantization. The prediction and quantization
are performed as follows. Let {width="0.3333333333333333in"
height="0.2222222222222222in"} denote the mean‑removed LSF vectors at frame
$n$. The prediction residual vectors {width="0.3333333333333333in"
height="0.2222222222222222in"} is given by:
{width="1.0965277777777778in" height="0.2222222222222222in"} (25)
where {width="0.34652777777777777in" height="0.2222222222222222in"} is the
predicted LSF vector at frame {width="0.1388888888888889in"
height="0.1388888888888889in"}. First order moving‑average (MA) prediction is
used where:
{width="2.111111111111111in" height="0.2638888888888889in"}, (26)
where {width="0.4722222222222222in" height="0.2361111111111111in"} is the
quantified residual vector at the past frame and
{width="0.18055555555555555in" height="0.20833333333333334in"} is the
prediction factor for the _j_ th LSF.
The LSF residual vectors {width="0.125in" height="0.1388888888888889in"} is
quantified using split vector quantization. The vector {width="0.125in"
height="0.1388888888888889in"} is split into 3 subvectors of dimension 3, 3,
and 4. The 3 subvectors are quantified with 7-9 bits according to table 2.
Table 2. Bit allocation split vector quantization of LSF residual vector.
* * *
Mode Subvector 1 Subvector 2 Subvector 3 **10.2 kbit/s** 8 9 9 **7.95 kbit/s**
9 9 9 **7.40 kbit/s** 8 9 9 **6.70 kbit/s** 8 9 9 **5.90 kbit/s** 8 9 9 **5.15
kbit/s** 8 8 7 **4.75 kbit/s** 8 8 7
* * *
The weighted LSP distortion measure of equation (23) with the weighting of
equation (24) is used in the quantization process.
### 5.2.6 Interpolation of the LSPs
**12.2 kbit/s mode**
The two sets of quantified (and unquantized) LP parameters are used for the
second and fourth subframes whereas the first and third subframes use a linear
interpolation of the parameters in the adjacent subframes. The interpolation
is performed on the LSPs in the {width="0.1388888888888889in"
height="0.18055555555555555in"} domain. Let {width="0.3055555555555556in"
height="0.2916666666666667in"} be the LSP vector at the 4^th^ subframe of the
present frame {width="0.1388888888888889in" height="0.1388888888888889in"},
{width="0.3055555555555556in" height="0.2916666666666667in"} be the LSP vector
at the 2^nd^ subframe of the present frame {width="0.1388888888888889in"
height="0.1388888888888889in"}, and {width="0.4305555555555556in"
height="0.2916666666666667in"} the LSP vector at the 4^th^ subframe of the
past frame {width="0.2916666666666667in" height="0.2222222222222222in"}. The
interpolated LSP vectors at the 1^st^ and 3^rd^ subframes are given by:
{width="1.75in" height="0.5416666666666666in"} (27)
The interpolated LSP vectors are used to compute a different LP filter at each
subframe (both quantified and unquantized coefficients) using the LSP to LP
conversion method described in clause 5.2.4.
**10.2, 7.95, 7.40, 6.70, 5.90, 5.15, 4.75 kbit/s modes**
The set of quantified (and unquantized) LP parameters is used for the fourth
subframe whereas the first, second, and third subframes use a linear
interpolation of the parameters in the adjacent subframes. The interpolation
is performed on the LSPs in the {width="0.1388888888888889in"
height="0.18055555555555555in"} domain. The interpolated LSP vectors at the
1^st^, 2^nd^, and 3^rd^ subframes are given by:
{width="1.9305555555555556in" height="0.8055555555555556in"} (28)
The interpolated LSP vectors are used to compute a different LP filter at each
subframe (both quantified and unquantized coefficients) using the LSP to LP
conversion method described in clause 5.2.4.
### 5.2.7 Monitoring resonance in the LPC spectrum (all modes)
Resonances in the LPC filter are monitored to detect possible problem areas
where divergence between the adaptive codebook memories in the encoder and the
decoder could cause unstable filters in areas with highly correlated
continuous signals. Typically, this divergence is due to channel errors.
The monitoring of resonance signals is performed using unquantized LSPs
{width="0.9305555555555556in" height="0.2222222222222222in"}. The LSPs are
available after the LP to LSP conversion in clause 5.2.3. The algorithm
utilises the fact that LSPs are closely located at a peak in the spectrum.
First, two distances, {width="0.34652777777777777in"
height="0.2222222222222222in"} and {width="0.3611111111111111in"
height="0.2222222222222222in"}, are calculated in two different regions,
defined as {width="2.0694444444444446in" height="0.2361111111111111in"}, and
{width="1.875in" height="0.2361111111111111in"}.
Either of these two minimum distance conditions must be fulfilled to classify
the frame as a resonance frame and increase the resonance counter.
{width="2.5416666666666665in" height="0.9861111111111112in"}
{width="0.8194444444444444in" height="0.2222222222222222in"} is a fixed
threshold while the second one is depending on {width="0.20833333333333334in"
height="0.2222222222222222in"} according to:
{width="2.3194444444444446in" height="0.7916666666666666in"}
12 consecutive resonance frames are needed to indicate possible problem
conditions, otherwise the LSP_flag is cleared.
{width="1.25in" height="1.2222222222222223in"}
## 5.3 Open‑loop pitch analysis
Open‑loop pitch analysis is performed in order to simplify the pitch analysis
and confine the closed‑loop pitch search to a small number of lags around the
open‑loop estimated lags.
Open‑loop pitch estimation is based on the weighted speech signal
{width="0.4166666666666667in" height="0.2361111111111111in"} which is obtained
by filtering the input speech signal through the weighting filter
{width="1.69375in" height="0.2916666666666667in"}. That is, in a subframe of
size {width="0.1527777777777778in" height="0.18055555555555555in"}, the
weighted speech is given by:
{width="4.375in" height="0.5277777777777778in"} (29)
**12.2 kbit/s mode**
Open‑loop pitch analysis is performed twice per frame (each 10 ms) to find two
estimates of the pitch lag in each frame.
Open‑loop pitch analysis is performed as follows. In the first step, 3 maxima
of the correlation:
{width="1.5555555555555556in" height="0.5555555555555556in"} (30)
are found in the three ranges:
{width="0.5416666666666666in"
height="0.7222222222222222in"}{width="0.7361111111111112in"
height="0.7222222222222222in"}
The retained maxima {width="0.875in" height="0.2638888888888889in"}, are
normalized by dividing by {width="1.75in" height="0.34652777777777777in"},
respectively. The normalized maxima and corresponding delays are denoted by
{width="1.1805555555555556in" height="0.2777777777777778in"}. The winner,
{width="0.2638888888888889in" height="0.2638888888888889in"} , among the three
normalized correlations is selected by favouring the delays with the values in
the lower range. This is performed by weighting the normalized correlations
corresponding to the longer delays. The best open‑loop delay
{width="0.2638888888888889in" height="0.2638888888888889in"} is determined as
follows:
{width="1.3333333333333333in" height="2.4166666666666665in"}
This procedure of dividing the delay range into 3 clauses and favouring the
lower clauses is used to avoid choosing pitch multiples.
**10.2 kbit/s mode**
Open-loop pitch analysis is performed twice per frame (every 10 ms) to find
two estimates of the pitch lag in each frame.
The open-loop pitch analysis is performed as follows. First, the correlation
of weighted speech is determined for each pitch lag value _d_ by:
{width="3.2222222222222223in" height="0.5277777777777778in"}, (31)
where {width="0.375in" height="0.2222222222222222in"} is a weighting function.
The estimated pitch-lag is the delay that maximises the weighted correlation
function {width="0.375in" height="0.2222222222222222in"}. The weighting
emphasises lower pitch lag values reducing the likelihood of selecting a
multiple of the correct delay. The weighting function consists of two parts: a
low pitch lag emphasis function, {width="0.44375in"
height="0.2361111111111111in"}, and a previous frame lag neighbouring emphasis
function, {width="0.4583333333333333in" height="0.2361111111111111in"}:
{width="1.3611111111111112in" height="0.2361111111111111in"}. (32)
The low pitch lag emphasis function is a given by:
{width="1.0138888888888888in" height="0.2361111111111111in"} (33)
where {width="0.44375in" height="0.2222222222222222in"} is defined by a table
in the fixed point computational description (ANSI-C code) in [4]. The
previous frame lag neighbouring emphasis function depends on the pitch lag of
previous speech frames:
{width="2.8333333333333335in" height="0.5555555555555556in"} (34)
where {width="0.5965277777777778in" height="0.2222222222222222in"},
$T_{\text{old}}$ is the median filtered pitch lag of 5 previous voiced speech
half-frames, and _v_ is an adaptive parameter. If the frame is classified as
voiced by having the open-loop gain {width="0.5138888888888888in"
height="0.20833333333333334in"}, the _v_ -value is set to 1.0 for the next
frame. Otherwise, the _v_ -value is updated by {width="0.5833333333333334in"
height="0.16666666666666666in"}. The open loop gain is given by:
{width="1.8055555555555556in" height="1.0555555555555556in"} (35)
where {width="0.3611111111111111in" height="0.2222222222222222in"} is the
pitch delay that maximizes {width="0.375in" height="0.2222222222222222in"}.
The median filter is updated only during voiced speech frames. The weighting
depends on the reliability of the old pitch lags. If previous frames have
contained unvoiced speech or silence, the weighting is attenuated through the
parameter _v_.
**7.95, 7.40, 6.70, 5.90 kbit/s modes**
Open‑loop pitch analysis is performed twice per frame (each 10 ms) to find two
estimates of the pitch lag in each frame.
Open‑loop pitch analysis is performed as follows. In the first step, 3 maxima
of the correlation in equation (30) are found in the three ranges:
{width="0.5416666666666666in"
height="0.7222222222222222in"}{width="0.7361111111111112in"
height="0.7361111111111112in"}
The retained maxima {width="0.875in" height="0.2638888888888889in"}, are
normalized by dividing by {width="1.75in" height="0.34652777777777777in"},
respectively. The normalized maxima and corresponding delays are denoted by
{width="1.1805555555555556in" height="0.2777777777777778in"}. The winner,
{width="0.2638888888888889in" height="0.2638888888888889in"} , among the three
normalized correlations is selected by favouring the delays with the values in
the lower range. This is performed by weighting the normalized correlations
corresponding to the longer delays. The best open‑loop delay
{width="0.2638888888888889in" height="0.2638888888888889in"} is determined as
follows:
{width="1.3333333333333333in" height="2.4166666666666665in"}
This procedure of dividing the delay range into 3 clauses and favouring the
lower clauses is used to avoid choosing pitch multiples.
**5.15, 4.75 kbit/s modes**
Open‑loop pitch analysis is performed once per frame (each 20 ms) to find an
estimate of the pitch lag in each frame.
Open‑loop pitch analysis is performed as follows. In the first step, 3 maxima
of the correlation in equation (30) are found in the three ranges:
{width="0.5416666666666666in"
height="0.7222222222222222in"}{width="0.7361111111111112in"
height="0.7361111111111112in"}
The retained maxima {width="0.875in" height="0.2638888888888889in"}, are
normalized by dividing by {width="1.75in" height="0.34652777777777777in"},
respectively. The normalized maxima and corresponding delays are denoted by
{width="1.1805555555555556in" height="0.2777777777777778in"}. The winner,
{width="0.2638888888888889in" height="0.2638888888888889in"} , among the three
normalized correlations is selected by favouring the delays with the values in
the lower range. This is performed by weighting the normalized correlations
corresponding to the longer delays. The best open‑loop delay
{width="0.2638888888888889in" height="0.2638888888888889in"} is determined as
follows:
{width="1.3333333333333333in" height="2.4166666666666665in"}
This procedure of dividing the delay range into 3 clauses and favouring the
lower clauses is used to avoid choosing pitch multiples.
## 5.4 Impulse response computation (all modes)
The impulse response, {width="0.3333333333333333in"
height="0.2222222222222222in"}, of the weighted synthesis filter
{width="2.4166666666666665in" height="0.3194444444444444in"} is computed each
subframe. This impulse response is needed for the search of adaptive and fixed
codebooks. The impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} is computed by filtering the vector of
coefficients of the filter {width="0.5694444444444444in"
height="0.2916666666666667in"} extended by zeros through the two filters
{width="0.4861111111111111in" height="0.2638888888888889in"} and
{width="0.7222222222222222in" height="0.2916666666666667in"}.
## 5.5 Target signal computation (all modes)
The target signal for adaptive codebook search is usually computed by
subtracting the zero input response of the weighted synthesis filter
{width="2.4166666666666665in" height="0.3194444444444444in"} from the weighted
speech signal {width="0.4166666666666667in" height="0.2361111111111111in"}.
This is performed on a subframe basis.
An equivalent procedure for computing the target signal, which is used in the
present document, is the filtering of the LP residual signal {width="0.625in"
height="0.2222222222222222in"} through the combination of synthesis filter
{width="0.4861111111111111in" height="0.2638888888888889in"} and the weighting
filter {width="1.19375in" height="0.2916666666666667in"}. After determining
the excitation for the subframe, the initial states of these filters are
updated by filtering the difference between the LP residual and excitation.
The memory update of these filters is explained in clause 5.9.
The residual signal {width="0.625in" height="0.2222222222222222in"} which is
needed for finding the target vector is also used in the adaptive codebook
search to extend the past excitation buffer. This simplifies the adaptive
codebook search procedure for delays less than the subframe size of 40 as will
be explained in the next clause. The LP residual is given by:
{width="2.013888888888889in" height="0.5555555555555556in"} (36)
## 5.6 Adaptive codebook
### 5.6.1 Adaptive codebook search
Adaptive codebook search is performed on a subframe basis. It consists of
performing closed‑loop pitch search, and then computing the adaptive
codevector by interpolating the past excitation at the selected fractional
pitch lag.
The adaptive codebook parameters (or pitch parameters) are the delay and gain
of the pitch filter. In the adaptive codebook approach for implementing the
pitch filter, the excitation is repeated for delays less than the subframe
length. In the search stage, the excitation is extended by the LP residual to
simplify the closed‑loop search.
**12.2 kbit/s mode**
In the first and third subframes, a fractional pitch delay is used with
resolutions: 1/6 in the range {width="1.0in" height="0.2361111111111111in"}
and integers only in the range [95, 143]. For the second and fourth subframes,
a pitch resolution of 1/6 is always used in the range
{width="1.3194444444444444in" height="0.2361111111111111in"}, where
{width="0.16666666666666666in" height="0.2222222222222222in"} is nearest
integer to the fractional pitch lag of the previous (1^st^ or 3^rd^) subframe,
bounded by 18...143.
Closed‑loop pitch analysis is performed around the open‑loop pitch estimates
on a subframe basis. In the first (and third) subframe the range
{width="0.4861111111111111in" height="0.2638888888888889in"}, bounded by
18...143, is searched. For the other subframes, closed‑loop pitch analysis is
performed around the integer pitch selected in the previous subframe, as
described above. The pitch delay is encoded with 9 bits in the first and third
subframes and the relative delay of the other subframes is encoded with 6
bits.
The closed‑loop pitch search is performed by minimizing the mean‑square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term:
{width="1.8888888888888888in" height="0.7222222222222222in"} (37)
where {width="0.3333333333333333in" height="0.2222222222222222in"} is the
target signal and $y_{k}\left( n \right)$ is the past filtered excitation at
delay {width="0.1388888888888889in" height="0.18055555555555555in"} (past
excitation convolved with {width="0.3333333333333333in"
height="0.2222222222222222in"}). Note that the search range is limited around
the open‑loop pitch as explained earlier.
The convolution {width="0.4305555555555556in" height="0.2361111111111111in"}
is computed for the first delay {width="0.3055555555555556in"
height="0.2222222222222222in"} in the searched range, and for the other delays
in the search range {width="1.375in" height="0.2222222222222222in"}, it is
updated using the recursive relation:
{width="2.19375in" height="0.2361111111111111in"}, $1 \leq n \leq \text{39}$
(38)
and $y_{k}(0) = u( - k)h(0)$, where {width="1.8333333333333333in"
height="0.2361111111111111in"}, is the excitation buffer. Note that in search
stage, the samples{width="1.1805555555555556in"
height="0.2361111111111111in"}, are not known, and they are needed for pitch
delays less than 40. To simplify the search, the LP residual is copied to
{width="0.3333333333333333in" height="0.2222222222222222in"} in order to make
the relation in equation (38) valid for all delays.
Once the optimum integer pitch delay is determined, the fractions from \--3/6
to 3/6 with a step of 1/6 around that integer are tested. The fractional pitch
search is performed by interpolating the normalized correlation in equation
(37) and searching for its maximum. The interpolation is performed using an
FIR filter {width="0.25in" height="0.2222222222222222in"} based on a Hamming
windowed {width="0.6111111111111112in" height="0.2361111111111111in"} function
truncated at ± 23 and padded with zeros at ± 24 ({width="0.8055555555555556in"
height="0.2361111111111111in"}). The filter has its cut‑off frequency (‑3 dB)
at 3 600 Hz in the over‑sampled domain. The interpolated values of
{width="0.3611111111111111in" height="0.25in"} for the fractions --3/6 to 3/6
are obtained using the interpolation formula:
{width="5.069444444444445in" height="0.5277777777777778in"} (39)
where {width="0.69375in" height="0.2222222222222222in"}corresponds to the
fractions 0, 1/6, 2/6, 3/6, -2/6, and --1/6, respectively. Note that it is
necessary to compute the correlation terms in equation (37) using a range
{width="1.1666666666666667in" height="0.2361111111111111in"} to allow for the
proper interpolation.
Once the fractional pitch lag is determined, the adaptive codebook vector
{width="0.3194444444444444in" height="0.2222222222222222in"} is computed by
interpolating the past excitation signal {width="0.3333333333333333in"
height="0.2222222222222222in"} at the given integer delay
{width="0.1388888888888889in" height="0.19375in"} and phase (fraction)
{width="0.13958333333333334in" height="0.16666666666666666in"}:
{width="6.180555555555555in" height="0.5277777777777778in"} (40)
The interpolation filter {width="0.2638888888888889in"
height="0.2361111111111111in"} is based on a Hamming windowed
{width="0.6111111111111112in" height="0.2361111111111111in"} function
truncated at ± 59 and padded with zeros at ± 60 ({width="0.8055555555555556in"
height="0.25in"}). The filter has a cut‑off frequency (‑3 dB) at 3 600 Hz in
the over‑sampled domain.
The adaptive codebook gain is then found by:
{width="3.361111111111111in" height="0.6388888888888888in"} (41)
where {width="1.1666666666666667in" height="0.2361111111111111in"} is the
filtered adaptive codebook vector (zero state response of {width="0.69375in"
height="0.2222222222222222in"} to {width="0.3194444444444444in"
height="0.2222222222222222in"}).
The computed adaptive codebook gain is quantified using 4‑bit non‑uniform
scalar quantization in the range [0.0,1.2].
**7.95 kbit/s mode**
In the first and third subframes, a fractional pitch delay is used with
resolutions: 1/3 in the range {width="0.9722222222222222in"
height="0.2361111111111111in"} and integers only in the range [85, 143]. For
the second and fourth subframes, a pitch resolution of 1/3 is always used in
the range {width="1.5555555555555556in" height="0.2916666666666667in"}, where
{width="0.16666666666666666in" height="0.2222222222222222in"} is nearest
integer to the fractional pitch lag of the previous (1^st^ or 3^rd^) subframe,
bounded by 20...143.
Closed‑loop pitch analysis is performed around the open‑loop pitch estimates
on a subframe basis. In the first (and third) subframe the range
{width="0.4861111111111111in" height="0.25in"}, bounded by 20...143, is
searched. For the other subframes, closed‑loop pitch analysis is performed
around the integer pitch selected in the previous subframe, as described
above. The pitch delay is encoded with 8 bits in the first and third subframes
and the relative delay of the other subframes is encoded with 6 bits.
The closed‑loop pitch search is performed by minimizing the mean‑square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term of equation (37). Note that the search range is limited
around the open‑loop pitch as explained earlier.
The convolution {width="0.4305555555555556in" height="0.2361111111111111in"}
is computed for the first delay {width="0.3055555555555556in"
height="0.2222222222222222in"} in the searched range, and for the other delays
in the search range {width="1.375in" height="0.2222222222222222in"}, it is
updated using the recursive relation of equation (38).
Once the optimum integer pitch delay is determined, the fractions from \--2/3
to 2/3 with a step of 1/3 around that integer are tested. The fractional pitch
search is performed by interpolating the normalized correlation in equation
(37) and searching for its maximum. Once the fractional pitch lag is
determined, the adaptive codebook vector {width="0.3194444444444444in"
height="0.2222222222222222in"} is computed by interpolating the past
excitation signal {width="0.3333333333333333in" height="0.2222222222222222in"}
at the given integer delay and phase (fraction). The interpolation is
performed using two FIR filters (Hamming windowed sinc functions); one for
interpolating the term in equation (37) with the sinc truncated at ± 11 and
the other for interpolating the past excitation with the sinc truncated at ±
29. The filters have their cut‑off frequency (‑3 dB) at 3 600 Hz in the
over‑sampled domain.
The adaptive codebook gain is then found as in equation (41).
The computed adaptive codebook gain is quantified using 4‑bit non‑uniform
scalar quantization as described in clause 5.8.
**10.2, 7.40 kbit/s mode**
In the first and third subframes, a fractional pitch delay is used with
resolutions: 1/3 in the range {width="1.0in" height="0.2916666666666667in"}
and integers only in the range [85, 143]. For the second and fourth subframes,
a pitch resolution of 1/3 is always used in the range
{width="1.4722222222222223in" height="0.2916666666666667in"}, where
{width="0.16666666666666666in" height="0.2222222222222222in"} is nearest
integer to the fractional pitch lag of the previous (1^st^ or 3^rd^) subframe,
bounded by 20...143.
Closed‑loop pitch analysis is performed around the open‑loop pitch estimates
on a subframe basis. In the first (and third) subframe the range
{width="0.4861111111111111in" height="0.25in"}, bounded by 20...143, is
searched. For the other subframes, closed‑loop pitch analysis is performed
around the integer pitch selected in the previous subframe, as described
above. The pitch delay is encoded with 8 bits in the first and third subframes
and the relative delay of the other subframes is encoded with 5 bits.
The closed‑loop pitch search is performed by minimizing the mean‑square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term of equation (37). Note that the search range is limited
around the open‑loop pitch as explained earlier.
The convolution {width="0.4305555555555556in" height="0.2361111111111111in"}
is computed for the first delay {width="0.3055555555555556in"
height="0.2222222222222222in"} in the searched range, and for the other delays
in the search range {width="1.375in" height="0.2222222222222222in"}, it is
updated using the recursive relation of equation (38).
Once the optimum integer pitch delay is determined, the fractions from \--2/3
to 2/3 with a step of 1/3 around that integer are tested. The fractional pitch
search is performed by interpolating the normalized correlation in equation
(37) and searching for its maximum. Once the fractional pitch lag is
determined, the adaptive codebook vector {width="0.3194444444444444in"
height="0.2222222222222222in"} is computed by interpolating the past
excitation signal {width="0.3333333333333333in" height="0.2222222222222222in"}
at the given integer delay and phase (fraction). The interpolation is
performed using two FIR filters (Hamming windowed sinc functions); one for
interpolating the term in equation (37) with the sinc truncated at ± 11 and
the other for interpolating the past excitation with the sinc truncated at ±
29. The filters have their cut‑off frequency (‑3 dB) at 3 600 Hz in the
over‑sampled domain.
The adaptive codebook gain is then found as in equation (41).
The computed adaptive codebook gain (and the fixed codebook gain) is
quantified using 7‑bit non‑uniform vector quantization as described in clause
5.8.
**6.70, 5.90 kbit/s modes**
In the first and third subframes, a fractional pitch delay is used with
resolutions: 1/3 in the range {width="1.0in" height="0.2916666666666667in"}
and integers only in the range [85, 143]. For the second and fourth subframes,
integer pitch resolution is used in the range {width="0.9583333333333334in"
height="0.2916666666666667in"}, where {width="0.16666666666666666in"
height="0.2222222222222222in"} is nearest integer to the fractional pitch lag
of the previous (1^st^ or 3^rd^) subframe, bounded by 20...143. Additionally,
a fractional resolution of 1/3 is used in the range
{width="1.3465277777777778in" height="0.2916666666666667in"}.
Closed‑loop pitch analysis is performed around the open‑loop pitch estimates
on a subframe basis. In the first (and third) subframe the range
{width="0.4861111111111111in" height="0.25in"}, bounded by 20...143, is
searched. For the other subframes, closed‑loop pitch analysis is performed
around the integer pitch selected in the previous subframe, as described
above. The pitch delay is encoded with 8 bits in the first and third subframes
and the relative delay of the other subframes is encoded with 4 bits.
The closed‑loop pitch search is performed by minimizing the mean‑square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term of equation (37). Note that the search range is limited
around the open‑loop pitch as explained earlier.
The convolution {width="0.4305555555555556in" height="0.2361111111111111in"}
is computed for the first delay {width="0.3055555555555556in"
height="0.2222222222222222in"} in the searched range, and for the other delays
in the search range {width="1.375in" height="0.2222222222222222in"}, it is
updated using the recursive relation of equation (38).
Once the optimum integer pitch delay is determined, the fractions from \--2/3
to 2/3 with a step of 1/3 around that integer are tested. The fractional pitch
search is performed by interpolating the normalized correlation in equation
(37) and searching for its maximum. Once the fractional pitch lag is
determined, the adaptive codebook vector {width="0.3194444444444444in"
height="0.2222222222222222in"} is computed by interpolating the past
excitation signal {width="0.3333333333333333in" height="0.2222222222222222in"}
at the given integer delay and phase (fraction). The interpolation is
performed using two FIR filters (Hamming windowed sinc functions); one for
interpolating the term in equation (37) with the sinc truncated at ± 11 and
the other for interpolating the past excitation with the sinc truncated at ±
29. The filters have their cut‑off frequency (‑3 dB) at 3 600 Hz in the
over‑sampled domain.
The adaptive codebook gain is then found as in equation (41).
The computed adaptive codebook gain (and the fixed codebook gain) is
quantified using vector quantization as described in clause 5.8.
**5.15, 4.75 kbit/s modes**
In the first subframe, a fractional pitch delay is used with resolutions: 1/3
in the range {width="1.0in" height="0.2916666666666667in"} and integers only
in the range [85, 143]. For the second, third, and fourth subframes, integer
pitch resolution is used in the range {width="0.9583333333333334in"
height="0.2916666666666667in"}, where {width="0.16666666666666666in"
height="0.2222222222222222in"} is nearest integer to the fractional pitch lag
of the previous subframe, bounded by 20...143. Additionally, a fractional
resolution of 1/3 is used in the range {width="1.3465277777777778in"
height="0.2916666666666667in"}.
Closed‑loop pitch analysis is performed around the open‑loop pitch estimates
on a subframe basis. In the first subframe the range _T~op~_ ± 5, bounded by
20...143, is searched. For the other subframes, closed‑loop pitch analysis is
performed around the integer pitch selected in the previous subframe, as
described above. The pitch delay is encoded with 8 bits in the first subframe
and the relative delay of the other subframes is encoded with 4 bits.
The closed‑loop pitch search is performed by minimizing the mean‑square
weighted error between the original and synthesized speech. This is achieved
by maximizing the term of equation (37). Note that the search range is limited
around the open‑loop pitch as explained earlier.
The convolution {width="0.4305555555555556in" height="0.2361111111111111in"}
is computed for the first delay {width="0.3055555555555556in"
height="0.2222222222222222in"} in the searched range, and for the other delays
in the search range {width="1.375in" height="0.2222222222222222in"}, it is
updated using the recursive relation of equation (38).
Once the optimum integer pitch delay is determined, the fractions from \--2/3
to 2/3 with a step of 1/3 around that integer are tested. The fractional pitch
search is performed by interpolating the normalized correlation in equation
(37) and searching for its maximum. Once the fractional pitch lag is
determined, the adaptive codebook vector {width="0.3194444444444444in"
height="0.2222222222222222in"} is computed by interpolating the past
excitation signal {width="0.3333333333333333in" height="0.2222222222222222in"}
at the given integer delay and phase (fraction). The interpolation is
performed using two FIR filters (Hamming windowed sinc functions); one for
interpolating the term in equation (37) with the sinc truncated at ± 11 and
the other for interpolating the past excitation with the sinc truncated at ±
29. The filters have their cut‑off frequency (‑3 dB) at 3 600 Hz in the
over‑sampled domain.
The adaptive codebook gain is then found as in equation (41).
The computed adaptive codebook gain (and the fixed codebook gain) is
quantified using vector quantization as described in clause 5.8.
### 5.6.2 Adaptive codebook gain control (all modes)
The average adaptive codebook gain is calculated if the _LSP_flag_ is set and
the unquantized adaptive codebook gain exceeds the gain threshold
{width="0.7916666666666666in" height="0.2222222222222222in"}.
The average gain is calculated from the present unquantized gain and the
quantized gains of the seven previous subframes. That is,
{width="3.6666666666666665in" height="0.3333333333333333in"}, where _n_ is the
current subframe. If the average adaptive codebook gain exceeds the
{width="0.3611111111111111in" height="0.2222222222222222in"}, the unquantized
gain is limited to the threshold value and the _GpC_flag_ is set to indicate
the limitation.
{width="1.2777777777777777in" height="1.25in"}
The _GpC_flag_ is used in the gain quantization in clause 5.8.
## 5.7 Algebraic codebook
### 5.7.1 Algebraic codebook structure
The algebraic codebook structure is based on interleaved single‑pulse
permutation (ISPP) design.
**12.2 kbit/s mode**
In this codebook, the innovation vector contains 10 non‑zero pulses. All
pulses can have the amplitudes +1 or ‑1. The 40 positions in a subframe are
divided into 5 tracks, where each track contains two pulses, as shown in table
3.
Table 3: Potential positions of individual pulses in the algebraic codebook,
12.2 kbit/s.
* * *
Track Pulse Positions 1 i0, i5 0, 5, 10, 15, 20, 25, 30, 35 2 i1, i6 1, 6, 11,
16, 21, 26, 31, 36 3 i2, i7 2, 7, 12, 17, 22, 27, 32, 37 4 i3, i8 3, 8, 13,
18, 23, 28, 33, 38 5 i4, i9 4, 9, 14, 19, 24, 29, 34, 39
* * *
Each two pulse positions in one track are encoded with 6 bits (total of 30
bits, 3 bits for the position of every pulse), and the sign of the first pulse
in the track is encoded with 1 bit (total of 5 bits).
For two pulses located in the same track, only one sign bit is needed. This
sign bit indicates the sign of the first pulse. The sign of the second pulse
depends on its position relative to the first pulse. If the position of the
second pulse is smaller, then it has opposite sign, otherwise it has the same
sign than in the first pulse.
All the 3‑bit pulse positions are Gray coded in order to improve robustness
against channel errors. This gives a total of 35 bits for the algebraic code.
**10.2 kbit/s mode**
In this codebook, the innovation vector contains 8 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 40 positions in a subframe are divided
into 4 tracks, where each track contains two pulses, as shown in table 4.
Table 4: Potential positions of individual pulses in the algebraic codebook,
10.2 kbit/s.
* * *
Track Pulse Positions 1 i0, i4 0, 4, 8, 12, 16, 20, 24, 28, 32, 36 2 i1, i5 1,
5, 9, 13, 17, 21, 25, 29, 33, 37 3 i2, i6 2, 6, 10, 14, 18, 22, 26, 30, 34, 38
4 i3, i7 3, 7, 11, 15, 19, 23, 27, 31, 35, 39
* * *
The pulses are grouped into 3, 3, and 2 pulses and their positions are encoded
with 10, 10, and 7 bits, respectively (total of 27 bits). The sign of the
first pulse in each track is encoded with 1 bit (total of 4 bits).
For two pulses located in the same track, only one sign bit is needed. This
sign bit indicates the sign of the first pulse. The sign of the second pulse
depends on its position relative to the first pulse. If the position of the
second pulse is smaller, then it has opposite sign, otherwise it has the same
sign than in the first pulse.
This gives a total of 31 bits for the algebraic code.
**7.95, 7.40 kbit/s modes**
In this codebook, the innovation vector contains 4 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 40 positions in a subframe are divided
into 4 tracks, where each track contains one pulse, as shown in table 5.
Table 5: Potential positions of individual pulses in the algebraic codebook,
7.95, 7.40 kbit/s.
* * *
Track Pulse Positions 1 i0 0, 5, 10, 15, 20, 25, 30, 35 2 i1 1, 6, 11, 16, 21,
26, 31, 36 3 i2 2, 7, 12, 17, 22, 27, 32, 37 4 i3 3, 8, 13, 18, 23, 28, 33,
38, 4, 9, 14, 19, 24, 29, 34, 39
* * *
The pulse positions are encoded with 3, 3, 3, and 4 bits (total of 13 bits),
and the sign of the each pulse is encoded with 1 bit (total of 4 bits). This
gives a total of 17 bits for the algebraic code.
**6.70 kbit/s mode**
In this codebook, the innovation vector contains 3 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 40 positions in a subframe are divided
into 3 tracks, where each track contains one pulse, as shown in table 6.
Table 6: Potential positions of individual pulses in the algebraic codebook,
6.70 kbit/s.
* * *
Track Pulse Positions 1 i0 0, 5, 10, 15, 20, 25, 30, 35 2 i1 1, 6, 11, 16, 21,
26, 31, 36, 3, 8, 13, 18, 23, 28, 33, 38 3 i2 2, 7, 12, 17, 22, 27, 32, 37, 4,
9, 14, 19, 24, 29, 34, 39
* * *
The pulse positions are encoded with 3, 4, and 4 bits (total of 11 bits), and
the sign of the each pulse is encoded with 1 bit (total of 3 bits). This gives
a total of 14 bits for the algebraic code.
**5.90 kbit/s mode**
In this codebook, the innovation vector contains 2 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 40 positions in a subframe are divided
into 2 tracks, where each track contains one pulse, as shown in table 7.
Table 7: Potential positions of individual pulses in the algebraic codebook,
5.90 kbit/s.
* * *
Track Pulse Positions 1 i0 1, 6, 11, 16, 21, 26, 31, 36, 3, 8, 13, 18, 23, 28,
33, 38 2 i1 0, 5, 10, 15, 20, 25, 30, 35, 1, 6, 11, 16, 21, 26, 31, 36, 2, 7,
12, 17, 22, 27, 32, 37, 4, 9, 14, 19, 24, 29, 34, 39
* * *
The pulse positions are encoded with 4 and 5 bits (total of 9 bits), and the
sign of the each pulse is encoded with 1 bit (total of 2 bits). This gives a
total of 11 bits for the algebraic code.
**5.15, 4.75 kbit/s modes**
In this codebook, the innovation vector contains 2 non‑zero pulses. All pulses
can have the amplitudes +1 or ‑1. The 40 positions in a subframe are divided
into 5 tracks. Two subsets of 2 tracks each are used for each subframe with
one pulse in each track. Different subsets of tracks are used for each
subframe. The pulse positions used in each subframe are shown in table 8.
Table 8: Potential positions of individual pulses in the algebraic codebook,
5.15, 4.75 kbit/s.
* * *
Subframe Subset Pulse Positions 1 i0 0, 5, 10, 15, 20, 25, 30, 35 **1** i1 2,
7, 12, 17, 22, 27, 32, 37 2 i0 1, 6, 11, 16, 21, 26, 31, 36 i1 3, 8, 13, 18,
23, 28, 33, 38 1 i0 0, 5, 10, 15, 20, 25, 30, 35 **2** i1 3, 8, 13, 18, 23,
28, 33, 38 2 i0 2, 7, 12, 17, 22, 27, 32, 37 i1 4, 9, 14, 19, 24, 29, 34, 39 1
i0 0, 5, 10, 15, 20, 25, 30, 35 **3** i1 2, 7, 12, 17, 22, 27, 32, 37 2 i0 1,
6, 11, 16, 21, 26, 31, 36 i1 4, 9, 14, 19, 24, 29, 34, 39 1 i0 0, 5, 10, 15,
20, 25, 30, 35 **4** i1 3, 8, 13, 18, 23, 28, 33, 38 2 i0 1, 6, 11, 16, 21,
26, 31, 36 i1 4, 9, 14, 19, 24, 29, 34, 39
* * *
One bit is needed to encoded the subset used. The two pulse positions are
encoded with 3 bits each (total of 6 bits), and the sign of the each pulse is
encoded with 1 bit (total of 2 bits). This gives a total of 9 bits for the
algebraic code.
### 5.7.2 Algebraic codebook search
The algebraic codebook is searched by minimizing the mean square error between
the weighted input speech and the weighted synthesized speech. The target
signal used in the closed‑loop pitch search is updated by subtracting the
adaptive codebook contribution. That is:
{width="2.486111111111111in" height="0.2638888888888889in"} (42)
where {width="1.1666666666666667in" height="0.2361111111111111in"} is the
filtered adaptive codebook vector and {width="0.2361111111111111in"
height="0.2638888888888889in"} is the quantified adaptive codebook gain. If
{width="0.20833333333333334in" height="0.2222222222222222in"} is the algebraic
codevector at index {width="0.1388888888888889in"
height="0.18055555555555555in"}, then the algebraic codebook is searched by
maximizing the term:
{width="1.5in" height="0.6111111111111112in"}, (43)
where {width="0.6666666666666666in" height="0.2777777777777778in"} is the
correlation between the target signal {width="0.4027777777777778in"
height="0.25in"} and the impulse response {width="0.3333333333333333in"
height="0.25in"}, {width="0.19375in" height="0.18055555555555555in"} is a the
lower triangular Toepliz convolution matrix with diagonal
{width="0.3333333333333333in" height="0.25in"} and lower diagonals
{width="0.9305555555555556in" height="0.25in"}, and
{width="0.7083333333333334in" height="0.2777777777777778in"} is the matrix of
correlations of {width="0.3333333333333333in" height="0.25in"}. The vector
{width="0.1388888888888889in" height="0.18055555555555555in"} (backward
filtered target) and the matrix {width="0.18055555555555555in"
height="0.18055555555555555in"} are computed prior to the codebook search. The
elements of the vector {width="0.1388888888888889in"
height="0.18055555555555555in"} are computed by
{width="2.513888888888889in" height="0.5277777777777778in"}, (44)
and the elements of the symmetric matrix {width="0.18055555555555555in"
height="0.18055555555555555in"} are computed by:
{width="2.4583333333333335in" height="0.5555555555555556in"}. (45)
The algebraic structure of the codebooks allows for very fast search
procedures since the innovation vector {width="0.20833333333333334in"
height="0.2222222222222222in"} contains only a few nonzero pulses. The
correlation in the numerator of Equation (43) is given by:
{width="1.1388888888888888in" height="0.5555555555555556in"}, (46)
where {width="0.20833333333333334in" height="0.2222222222222222in"} is the
position of the {width="0.12013888888888889in"
height="0.16666666666666666in"}th pulse, {width="0.20833333333333334in"
height="0.2361111111111111in"} is its amplitude, and
{width="0.2638888888888889in" height="0.2638888888888889in"} is the number of
pulses ({width="0.625in" height="0.25in"})_._ The energy in the denominator of
equation (43) is given by:
{width="3.2777777777777777in" height="0.5833333333333334in"} (47)
To simplify the search procedure, the pulse amplitudes are preset by the mere
quantization of an appropriate signal {width="0.3194444444444444in"
height="0.2222222222222222in"}. This is simply done by setting the amplitude
of a pulse at a certain position equal to the sign of
{width="0.3194444444444444in" height="0.2222222222222222in"} at that position.
The simplification proceeds as follows (prior to the codebook search). First,
the sign signal {width="1.2083333333333333in" height="0.25in"} and the signal
{width="1.19375in" height="0.2777777777777778in"} are computed. Second, the
matrix {width="0.18055555555555555in" height="0.18055555555555555in"} is
modified by including the sign information; that is,
{width="1.6388888888888888in" height="0.2777777777777778in"}. The correlation
in equation (46) is now given by:
{width="1.0416666666666667in" height="0.5694444444444444in"} (48)
and the energy in equation (47) is given by:
{width="2.7083333333333335in" height="0.5138888888888888in"} (49)
**12.2 kbit/s mode**
In this case the signal {width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is a sum
of the normalized {width="0.34652777777777777in"
height="0.2222222222222222in"} vector and normalized long‑term prediction
residual {width="0.69375in" height="0.2361111111111111in"}:
{width="4.513888888888889in" height="0.5965277777777778in"} (50)
is used. Having preset the pulse amplitudes, as explained above, the optimal
pulse positions are determined using an efficient non‑exhaustive
analysis‑by‑synthesis search technique. In this technique, the term in
equation (43) is tested for a small percentage of position combinations.
First, for each of the five tracks the pulse positions with maximum absolute
values of {width="0.3194444444444444in" height="0.2222222222222222in"} are
searched. From these the global maximum value for all the pulse positions is
selected. The first pulse i~0~ is always set into the position corresponding
to the global maximum value.
Next, four iterations are carried out. During each iteration the position of
pulse i~1~ is set to the local maximum of one track. The rest of the pulses
are searched in pairs by sequentially searching each of the pulse pairs
{i~2~,i~3~}, {i~4~,i~5~}, {i~6~,i~7~} and {i~8~,i~9~} in nested loops. Every
pulse has 8 possible positions, i.e., there are four 8x8‑loops, resulting in
256 different combinations of pulse positions for each iteration.
In each iteration all the 9 pulse starting positions are cyclically shifted,
so that the pulse pairs are changed and the pulse i~1~ is placed in a local
maximum of a different track. The rest of the pulses are searched also for the
other positions in the tracks. At least one pulse is located in a position
corresponding to the global maximum and one pulse is located in a position
corresponding to one of the 4 local maxima.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is the quantized
pitch gain of the current subframe bounded by [0.0,1.0]. Note that prior to
the codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to
$h\left( n \right) = \begin{matrix} \left{ h\left( n \right)\text{\ \ \ \ \ \
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }n = 0,\text{.}\text{.}\text{.},T - 1
\middle| \right.\ \ \end{matrix}$ (50a)
The fixed codebook gain is then found by:
{width="0.6388888888888888in" height="0.5416666666666666in"} (51)
where {width="0.20833333333333334in" height="0.2222222222222222in"} is the
target vector for fixed codebook search and {width="0.125in"
height="0.1388888888888889in"} is the fixed codebook vector convolved with
{width="0.3333333333333333in" height="0.2222222222222222in"},
{width="2.4305555555555554in" height="0.5277777777777778in"} (52)
**10.2 kbit/s mode**
In this case the signal {width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is given
by eq. (50). Having preset the pulse amplitudes, as explained above, the
optimal pulse positions are determined using an efficient non‑exhaustive
analysis‑by‑synthesis search technique. In this technique, the term in
equation (43) is tested for a small percentage of position combinations.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is the quantized
pitch gain of the previous subframe bounded by [0.0,0.8]. Note that prior to
the codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to equation
(50a).
The fixed codebook gain is then found by equation (51).
**7.95, 7.40 kbit/s modes**
In this case the signal{width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is equal
to the signal {width="0.34652777777777777in" height="0.2222222222222222in"}.
Having preset the pulse amplitudes, as explained above, the optimal pulse
positions are determined using an efficient non‑exhaustive
analysis‑by‑synthesis search technique. In this technique, the term in
equation (43) is tested for a small percentage of position combinations.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is thequantized
pitch gain of the previous subframe bounded by [0.0,0.8]. Note that prior to
the codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to equation
(50a).
The fixed codebook gain is then found by equation (51).
**6.70 kbit/s mode**
In this case the signal {width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is equal
to the signal {width="0.34652777777777777in" height="0.2222222222222222in"}.
Having preset the pulse amplitudes, as explained above, the optimal pulse
positions are determined using an efficient non‑exhaustive
analysis‑by‑synthesis search technique. In this technique, the term in
equation (43) is tested for a small percentage of position combinations.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is the quantized
pitch gain of the previous subframe bounded by [0.0,0.8]. Note that prior to
the codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to equation
(50a).
The fixed codebook gain is then found by equation (51).
**5.90 kbit/s mode**
In this case the signal {width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is equal
to the signal {width="0.34652777777777777in" height="0.2222222222222222in"}.
Having preset the pulse amplitudes, as explained above, the optimal pulse
positions are determined using an exhaustive analysis‑by‑synthesis search
technique.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is the quantized
pitch gain of the previous subframe bounded by [0.0,0.8]. Note that prior to
the codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to equation
(50a).
The fixed codebook gain is then found by equation (51).
**5.15, 4.75 kbit/s modes**
In this case the signal {width="0.3194444444444444in"
height="0.2222222222222222in"}, used for presetting the amplitudes, is equal
to the signal {width="0.34652777777777777in" height="0.2222222222222222in"}.
Having preset the pulse amplitudes, as explained above, the optimal pulse
positions are determined using an exhaustive analysis‑by‑synthesis search
technique. Note that both subsets are searched.
A special feature incorporated in the codebook is that the selected codevector
is filtered through an adaptive pre‑filter {width="0.4166666666666667in"
height="0.2222222222222222in"} which enhances special spectral components in
order to improve the synthesized speech quality. Here the filter
{width="1.3333333333333333in" height="0.25in"} is used, where
{width="0.1527777777777778in" height="0.18055555555555555in"} is the nearest
integer pitch lag to the closed‑loop fractional pitch lag of the subframe, and
{width="0.1388888888888889in" height="0.2222222222222222in"} is the quantized
pitch gain of the previous subframe for the 5.15 kbit/s mode and the previous
odd subframe for the 4.75 kbit/s bounded by [0.0,0.8]. Note that prior to the
codebook search, the impulse response {width="0.3333333333333333in"
height="0.2222222222222222in"} must include the pre‑filter
{width="0.4166666666666667in" height="0.2222222222222222in"}. That is, for
values of $T$less than 40, the impulse $h(n)$is modified according to equation
(50a).
The fixed codebook gain is then found by equation (51).
## 5.8 Quantization of the adaptive and fixed codebook gains
### 5.8.1 Adaptive codebook gain limitation in quantization
If the _GpC_flag_ is set, the limited adaptive codebook gain is used in the
gain quantization in clause 5.8.2. The quantization codebook search range is
limited to only include adaptive codebook gain values less than
{width="0.3611111111111111in" height="0.2222222222222222in"}. This is
performed in the quantization search for all modes.
### 5.8.2 Quantization of codebook gains
**Prediction of the fixed codebook gain (all modes)**
The fixed codebook gain quantization is performed using MA prediction with
fixed coefficients. The 4^th^ order MA prediction is performed on the
innovation energy as follows. Let {width="0.375in"
height="0.2222222222222222in"} be the mean‑removed innovation energy (in dB)
at subframe {width="0.1388888888888889in" height="0.1388888888888889in"}, and
given by:
$E(n) = \text{10}\text{log}\left( \frac{1}{N}g_{c}^{2}\sum_{i = 0}^{N -
1}{c^{2}(i)} \right) - \overline{E}$, (53)
where {width="0.4861111111111111in" height="0.2222222222222222in"} is the
subframe size, $c\left( i \right)$ is the fixed codebook excitation, and
{width="0.18055555555555555in" height="0.20833333333333334in"} (in dB) is the
mean of the innovation energy. The predicted energy is given by:
{width="1.3888888888888888in" height="0.5277777777777778in"}, (54)
where {width="2.19375in" height="0.2638888888888889in"} are the MA prediction
coefficients, and {width="0.3611111111111111in" height="0.2361111111111111in"}
is the quantified prediction error at subframe {width="0.1388888888888889in"
height="0.18055555555555555in"}. The predicted energy is used to compute a
predicted fixed‑codebook gain {width="0.20833333333333334in"
height="0.2222222222222222in"} as in equation (53) (by substituting
{width="0.375in" height="0.2222222222222222in"} by {width="0.375in"
height="0.2361111111111111in"} and {width="0.20833333333333334in"
height="0.2222222222222222in"} by {width="0.20833333333333334in"
height="0.2222222222222222in"}). This is done as follows. First, the mean
innovation energy is found by:
{width="1.7638888888888888in" height="0.6111111111111112in"} (55)
and then the predicted gain {width="0.20833333333333334in"
height="0.2222222222222222in"} is found by:
{width="1.5277777777777777in" height="0.3194444444444444in"}. (56)
A correction factor between the gain {width="0.20833333333333334in"
height="0.2222222222222222in"} and the estimated one
{width="0.20833333333333334in" height="0.2222222222222222in"} is given by:
{width="0.9027777777777778in" height="0.25in"}. (57)
Note that the prediction error is given by:
{width="2.263888888888889in" height="0.2916666666666667in"} (58)
**12.2 kbit/s mode**
The correction factor {width="0.2638888888888889in" height="0.25in"} is
computed using a mean energy value, {width="0.5277777777777778in"
height="0.20833333333333334in"} dB. The correction factor
{width="0.2638888888888889in" height="0.25in"} is quantified using a 5‑bit
codebook. The quantization table search is performed by minimizing the error:
{width="1.3888888888888888in" height="0.375in"}. (59)
Once the optimum value {width="0.2638888888888889in"
height="0.2638888888888889in"} is chosen, the quantified fixed codebook gain
is given by {width="0.7916666666666666in" height="0.2638888888888889in"}.
**10.2 kbit/s mode**
The correction factor {width="0.2638888888888889in" height="0.25in"} is
computed using a mean energy value, {width="0.5277777777777778in"
height="0.20833333333333334in"} dB. The adaptive codebook gain
{width="0.2361111111111111in" height="0.25in"}and the correction factor
{width="0.2638888888888889in" height="0.25in"} are jointly vector quantized
using a 7-bit codebook. The gain codebook search is performed by minimizing
equation (63).
**7.95 kbit/s mode**
The correction factor {width="0.2638888888888889in" height="0.25in"} is
computed using a mean energy value, {width="0.5277777777777778in"
height="0.20833333333333334in"} dB. The same scalar codebooks as for the 12.2
kbit/s mode is used for quantization of the adaptive codebook gain
{width="0.2361111111111111in" height="0.25in"} and the correction factor
{width="0.2638888888888889in" height="0.25in"}. The search of the codebooks
starts with finding 3 candidates for the adaptive codebook gain. These
candidates are the best codebook value in scalar quantization and the two
adjacent codebook values. These 3 candidates are searched together with the
correction factor codebook minimizing the term of equation (63).
An adaptor based on the coding gain in the adaptive codebook decides if the
coding gain is low. If this is the case, the correction factor codebook is
searched once more minimizing a modified criterion in order to find a new
quantized fixed codebook gain. The modified criterion is given by:
{width="4.096527777777778in" height="0.375in"} (60)
where {width="0.3333333333333333in" height="0.2222222222222222in"} and
{width="0.34652777777777777in" height="0.2222222222222222in"} are the energy
(the squared norm) of the LP residual and the total excitation, respectively.
The criterion is searched with the already quantized adaptive codebook gain
and the correction factor {width="0.2638888888888889in"
height="0.2638888888888889in"} that minimizes (60) is selected. The balance
factor {width="0.16666666666666666in" height="0.1527777777777778in"} decides
the amount of energy matching in the modified criterion. This factor is
adaptively decided based on the coding gain in the adaptive codebook as
computed by:
{width="1.8888888888888888in" height="0.6388888888888888in"}. (61)
If the coding gain _ag_ is less than 1 dB, the modified criterion is employed,
except when an onset is detected. An onset is said to be detected if the fixed
codebook gain in the current subframe is more than twice the value of the
fixed codebook gain in the previous subframe. A hangover of 8 subframes is
used in the onset detection so that the modified criterion is not used for the
next 7 subframes either if an onset is detected. The balance factor
{width="0.16666666666666666in" height="0.1527777777777778in"} is computed from
the median filtered adaptive coding gain. The current and the _ag_ -values for
the previous 4 subframes are median filtered to get
{width="0.3194444444444444in" height="0.2222222222222222in"}. The
{width="0.16666666666666666in" height="0.1527777777777778in"}-factor is
computed by:
{width="2.5277777777777777in" height="0.7916666666666666in"}. (62)
**7.40 kbit/s mode**
The correction factor {width="0.2638888888888889in"
height="0.2076388888888889in"} is computed using a mean energy value,
{width="0.5277777777777778in" height="0.20833333333333334in"} dB. The adaptive
codebook gain {width="0.2361111111111111in" height="0.25in"}and the correction
factor {width="0.2638888888888889in" height="0.2076388888888889in"} are
jointly vector quantized using a 7-bit codebook. The gain codebook search is
performed by minimizing the square of the weighted error between original and
reconstructed speech which is given by
{width="5.069444444444445in" height="0.34652777777777777in"} (63)
where {width="0.1388888888888889in" height="0.1388888888888889in"} is the
target vector, {width="0.1388888888888889in" height="0.18055555555555555in"}
is the filtered adaptive codebook vector, and {width="0.125in"
height="0.1388888888888889in"} is the filtered fixed codebook vector.
**6.70 kbit/s mode**
The correction factor {width="0.2638888888888889in" height="0.25in"} is
computed using a mean energy value, {width="0.7083333333333334in"
height="0.20833333333333334in"} dB. The adaptive codebook gain
{width="0.2361111111111111in" height="0.25in"}and the correction factor
{width="0.2638888888888889in" height="0.25in"} are jointly vector quantized
using a 7-bit codebook. The gain codebook search is performed by minimizing
equation (63).
**5.90, 5.15 kbit/s modes**
The correction factor {width="0.2638888888888889in" height="0.25in"} is
computed using a mean energy value, {width="0.5277777777777778in"
height="0.20833333333333334in"} dB. The adaptive codebook gain
{width="0.2361111111111111in" height="0.25in"}and the correction factor
{width="0.2638888888888889in" height="0.25in"} are jointly vector quantized
using a 6-bit codebook. The gain codebook search is performed by minimizing
equation (63).
**4.75 kbit/s mode**
The correction factors are computed using a mean energy value,
{width="0.5277777777777778in" height="0.20833333333333334in"} dB. The adaptive
codebook gains and the correction factors are jointly vector quantized every
10 ms. This is done by minimizing a weighted sum of the error criterion (63)
for each of the two subframes. The default values on the weighing factors are
1. If the energy of the second subframe is more than two times the energy of
the first subframe, the weight of the first subframe is set to 2. If the
energy of the first subframe is more than four times the energy of the second
subframe, the weight of the second subframe is set to 2.
### 5.8.3 Update past quantized adaptive codebook gain buffer (all modes)
After the gain quantization, the buffer with past adaptive codebook gains is
updated, regardless of the value of the _GpC_flag._ That is,
{width="2.4166666666666665in" height="0.25in"}.
## 5.9 Memory update (all modes)
An update of the states of the synthesis and weighting filters is needed in
order to compute the target signal in the next subframe.
After the two gains are quantified, the excitation signal,
{width="0.3333333333333333in" height="0.2222222222222222in"}, in the present
subframe is found by:
{width="2.513888888888889in" height="0.2638888888888889in"}, (64)
where {width="0.2361111111111111in" height="0.25in"} and
{width="0.20833333333333334in" height="0.2222222222222222in"} are the
quantified adaptive and fixed codebook gains, respectively,
{width="0.3194444444444444in" height="0.2222222222222222in"} the adaptive
codebook vector (interpolated past excitation), and
{width="0.3194444444444444in" height="0.2222222222222222in"} is the fixed
codebook vector (algebraic code including pitch sharpening). The states of the
filters can be updated by filtering the signal {width="1.0555555555555556in"
height="0.2222222222222222in"} (difference between residual and excitation)
through the filters {width="0.4861111111111111in"
height="0.2638888888888889in"} and {width="1.19375in"
height="0.2916666666666667in"} for the 40‑sample subframe and saving the
states of the filters. This would require 3 filterings. A simpler approach
which requires only one filtering is as follows. The local synthesized speech,
{width="0.3194444444444444in" height="0.2222222222222222in"}, is computed by
filtering the excitation signal through {width="0.4861111111111111in"
height="0.2638888888888889in"}. The output of the filter due to the input
{width="1.0555555555555556in" height="0.2222222222222222in"} is equivalent to
{width="1.19375in" height="0.2222222222222222in"}. So the states of the
synthesis filter {width="0.4861111111111111in" height="0.2638888888888889in"}
are given by {width="1.25in" height="0.2361111111111111in"}. Updating the
states of the filter {width="1.19375in" height="0.2222222222222222in"} can be
done by filtering the error signal {width="0.3194444444444444in"
height="0.2222222222222222in"} through this filter to find the perceptually
weighted error {width="0.4305555555555556in" height="0.2361111111111111in"}.
However, the signal {width="0.4305555555555556in"
height="0.2361111111111111in"} can be equivalently found by:
{width="2.125in" height="0.2638888888888889in"}, (65)
Since the signals {width="0.3333333333333333in"
height="0.2222222222222222in"}, {width="0.3333333333333333in"
height="0.2361111111111111in"}, and {width="0.3194444444444444in"
height="0.2222222222222222in"} are available, the states of the weighting
filter are updated by computing {width="0.4305555555555556in"
height="0.2361111111111111in"} as in equation (65) for {width="0.875in"
height="0.20833333333333334in"}. This saves two filterings.
**4.75 kbit/s mode**
The memory update in the first and third subframes use the unquantized gains
in equation (64). After the second and fourth subframes respectively, when the
gains are quantized, the state is recalculated using the quantized gains.
# 6 Functional description of the decoder
The function of the decoder consists of decoding the transmitted parameters
(LP parameters, adaptive codebook vector, adaptive codebook gain, fixed
codebook vector, fixed codebook gain) and performing synthesis to obtain the
reconstructed speech. The reconstructed speech is then post‑filtered and
upscaled. The signal flow at the decoder is shown in figure 4.
## 6.1 Decoding and speech synthesis
The decoding process is performed in the following order:
**Decoding of LP filter parameters:** The received indices of LSP quantization
are used to reconstruct the quantified LSP vectors. The interpolation
described in clause 5.2.6 is performed to obtain 4 interpolated LSP vectors
(corresponding to 4 subframes). For each subframe, the interpolated LSP vector
is converted to LP filter coefficient domain {width="0.20833333333333334in"
height="0.2361111111111111in"}, which is used for synthesizing the
reconstructed speech in the subframe.
The following steps are repeated for each subframe:
1) **Decoding of the adaptive codebook vector:** The received pitch index
(adaptive codebook index) is used to find the integer and fractional parts of
the pitch lag. The adaptive codebook vector {width="0.3194444444444444in"
height="0.2222222222222222in"} is found by interpolating the past excitation
{width="0.3333333333333333in" height="0.2222222222222222in"} (at the pitch
delay) using the FIR filter described in clause 5.6.
2) **Decoding of the innovative codebook vector:** The received algebraic
codebook index is used to extract the positions and amplitudes (signs) of the
excitation pulses and to find the algebraic codevector
{width="0.3194444444444444in" height="0.2222222222222222in"}. If the integer
part of the pitch lag, _T_ , is less than the subframe size 40, the pitch
sharpening procedure is applied which translates into modifying
{width="0.3194444444444444in" height="0.2222222222222222in"} by
{width="1.5555555555555556in" height="0.2361111111111111in"}, where
{width="0.1388888888888889in" height="0.2222222222222222in"} is the decoded
pitch gain, {width="0.2361111111111111in" height="0.25in"}, bounded by
[0.0,1.0] or [0.0,0.8], depending on mode.
3) **Decoding of the adaptive and fixed codebook gains:** In case of scalar
quantization of the gains (12.2 kbit/s and 7.95 kbit/s modes) the received
indices are used to readily find the quantified adaptive codebook gain,
{width="0.2361111111111111in" height="0.25in"}, and the quantified fixed
codebook gain correction factor, {width="0.2638888888888889in"
height="0.2638888888888889in"}, from the corresponding quantization tables. In
case of vector quantization of the gains (all other modes), the received index
gives both the quantified adaptive codebook gain,
{width="0.2361111111111111in" height="0.25in"}, and the quantified fixed
codebook gain correction factor, ${\hat{g}}_{\text{gc}}$. The estimated fixed
codebook gain $g_{c}^{'}$ is found as described in clause 5.7. First, the
predicted energy is found by:
{width="1.3888888888888888in" height="0.5277777777777778in"} (66)
and then the mean innovation energy is found by:
{width="1.7222222222222223in" height="0.6111111111111112in"}. (67)
The predicted gain {width="0.20833333333333334in"
height="0.2222222222222222in"} is found by:
{width="1.5277777777777777in" height="0.3194444444444444in"}. (68)
The quantified fixed codebook gain is given by:
{width="0.7916666666666666in" height="0.25in"}. (69)
4) **Smoothing of the fixed codebook gain (10.2, 6.70, 5.90, 5.15, 4.75 kbit/s
modes):** An adaptive smoothing of the fixed codebook gain is performed to
avoid unnatural fluctuations in the energy contour. The smoothing is based on
a measure of the stationarity of the short-term spectrum in the **q** domain.
The smoothing strength is computed from this measure. An averaged **q** -value
is computed for each frame _n_ by:
{width="2.2916666666666665in" height="0.2361111111111111in"}. (70)
For each subframe _m_ , a difference measure between the averaged vector and
the quantized and interpolated vector is computed by:
{width="2.1805555555555554in" height="0.5965277777777778in"}, (71)
where _j_ runs over the 10 LSPs. Furthermore, a smoothing
factor,{width="0.2361111111111111in" height="0.2222222222222222in"}, is
computed by:
{width="2.611111111111111in" height="0.3194444444444444in"}, (72)
where the constants are set to {width="0.6111111111111112in"
height="0.2222222222222222in"} and {width="0.7083333333333334in"
height="0.2222222222222222in"}. A hangover period of 40 subframes is used
where the {width="0.2361111111111111in" height="0.2222222222222222in"}-value
is set 1.0 if the {width="0.375in" height="0.2222222222222222in"} has been
above 0.65 for 10 consecutive frames. A value of 1.0 corresponds to no
smoothing. An averaged fixed codebook gain value is computed for each subframe
by:
{width="0.125in" height="0.2222222222222222in"}{width="1.5in"
height="0.5277777777777778in"}. (73)
The fixed codebook gain used for synthesis is now replaced by a smoothed value
given by:
{width="1.8194444444444444in" height="0.2916666666666667in"}. (74)
5) **Anti-sparseness processing (7.95, 6.70, 5.90, 5.15, 4.75 kbit/s modes):**
An adaptive anti-sparseness post-processing procedure is applied to the fixed
codebook vector {width="0.3194444444444444in" height="0.2222222222222222in"}in
order to reduce perceptual artefacts arising from the sparseness of the
algebraic fixed codebook vectors with only a few non-zero samples per
subframe. The anti-sparseness processing consists of circular convolution of
the fixed codebook vector with an impulse response. Three pre-stored impulse
responses are used and a number {width="0.9583333333333334in"
height="0.20833333333333334in"} is set to select one of them. A value of 2
corresponds to no modification, a value of 1 corresponds to medium
modification, while a value of 0 corresponds to strong modification. The
selection of the impulse response is performed adaptively from the adaptive
and fixed codebook gains. The following procedure is employed:
> {width="1.3888888888888888in" height="1.4861111111111112in"}
Detect onset by comparing the fixed codebook gain to the previous fixed
codebook gain. If the current value is more than twice the previous value an
onset is detected.
If not onset and {width="0.7361111111111112in"
height="0.20833333333333334in"}, the median filtered value of the current and
the previous 4 adaptive codebook gains are computed. If this value is less
than 0.6, {width="0.7361111111111112in" height="0.20833333333333334in"}.
If not onset, the {width="0.4861111111111111in"
height="0.20833333333333334in"}-value is restricted to increase by one step
from the previous subframe.
If an onset is declared, the {width="0.4861111111111111in"
height="0.20833333333333334in"}-value is increased by one if it is less than
2.
6) **Computing the reconstructed speech:** The excitation at the input of the
synthesis filter is given by:
{width="1.5694444444444444in" height="0.2638888888888889in"}. (75)
Before the speech synthesis, a post‑processing of excitation elements is
performed. This means that the total excitation is modified by emphasizing the
contribution of the adaptive codebook vector:
{width="3.8465277777777778in" height="0.8055555555555556in"} (76)
Adaptive gain control (AGC) is used to compensate for the gain difference
between the non‑emphasized excitation {width="0.3333333333333333in"
height="0.2361111111111111in"} and emphasized excitation
{width="0.3333333333333333in" height="0.2361111111111111in"} The gain scaling
factor _η_ for the emphasized excitation is computed by:
{width="2.1527777777777777in" height="0.9722222222222222in"} (77)
The gain‑scaled emphasized excitation signal ${\hat{u}}^{'}\left( n \right)$
is given by:
{width="0.94375in" height="0.2361111111111111in"}. (78)
The reconstructed speech for the subframe of size 40 is given by:
{width="2.763888888888889in" height="0.5277777777777778in"}. (79)
where ${\hat{a}}_{i}$ are the interpolated LP filter coefficients.
7) **Additional instability protection** : An additional instability
protection is implemented in the speech decoder which is monitoring overflows
in the synthesis filter. If an overflow has occurred in the synthesis part,
the whole adaptive codebook memory, $v(n),n\text{=-}(\text{143} +
\text{11}),\text{.}\text{.}\text{.},\text{39}$ is scaled down by a factor of
4, and the synthesis filtering is repeated using this down-scaled memory. I.e.
in this case step 6) is repeated, except that the post-processing in (76) -
(78) of the excitation signal is by-passed.
The synthesized speech {width="0.3194444444444444in"
height="0.2361111111111111in"} is then passed through an adaptive postfilter
which is described in the following clause.
## 6.2 Post‑processing
### 6.2.1 Adaptive post‑filtering (all modes)
The adaptive postfilter is the cascade of two filters: a formant postfilter,
and a tilt compensation filter. The postfilter is updated every subframe of 5
ms.
The formant postfilter is given by:
{width="1.2361111111111112in" height="0.5555555555555556in"} (80)
where {width="0.3611111111111111in" height="0.2638888888888889in"} is the
received quantified (and interpolated) LP inverse filter (LP analysis is not
performed at the decoder), and the factors {width="0.2222222222222222in"
height="0.2361111111111111in"} and {width="0.2222222222222222in"
height="0.2361111111111111in"} control the amount of the formant
post‑filtering.
Finally, the filter {width="0.4305555555555556in"
height="0.2361111111111111in"} compensates for the tilt in the formant
postfilter {width="0.4861111111111111in" height="0.2638888888888889in"} and is
given by:
{width="1.1388888888888888in" height="0.2777777777777778in"} (81)
where {width="0.625in" height="0.2222222222222222in"} is a tilt factor, with
{width="0.19375in" height="0.2222222222222222in"} being the first reflection
coefficient calculated on the truncated ({width="0.5833333333333334in"
height="0.2222222222222222in"}) impulse response,
{width="0.4305555555555556in" height="0.2638888888888889in"}, of the filter
{width="1.2222222222222223in" height="0.2777777777777778in"}.
{width="0.19375in" height="0.2222222222222222in"} is given by:
{width="2.7083333333333335in" height="0.5694444444444444in"}. (82)
The post‑filtering process is performed as follows. First, the synthesized
speech {width="0.3194444444444444in" height="0.2361111111111111in"} is inverse
filtered through {width="0.5965277777777778in" height="0.2916666666666667in"}
to produce the residual signal {width="0.3194444444444444in"
height="0.2222222222222222in"}. The signal {width="0.3194444444444444in"
height="0.2222222222222222in"} is filtered by the synthesis filter
{width="0.7361111111111112in" height="0.2777777777777778in"}. Finally, the
signal at the output of the synthesis filter {width="0.7361111111111112in"
height="0.2777777777777778in"} is passed to the tilt compensation filter
{width="0.44375in" height="0.2361111111111111in"} resulting in the
post‑filtered speech signal {width="0.4305555555555556in"
height="0.2638888888888889in"}.
Adaptive gain control (AGC) is used to compensate for the gain difference
between the synthesized speech signal {width="0.3194444444444444in"
height="0.2361111111111111in"} and the post‑filtered signal
{width="0.4305555555555556in" height="0.2638888888888889in"}. The gain scaling
factor {width="0.2638888888888889in" height="0.2361111111111111in"} for the
present subframe is computed by:
{width="1.2083333333333333in" height="1.0833333333333333in"}. (83)
The gain‑scaled post‑filtered signal {width="0.375in"
height="0.2222222222222222in"} is given by:
{width="1.3465277777777778in" height="0.2638888888888889in"} (84)
where $\beta_{\text{sc}}(n)$ is updated in sample‑by‑sample basis and given
by:
{width="2.2222222222222223in" height="0.2361111111111111in"} (85)
where $\alpha$ is a AGC factor with value of 0.9.
**12.2, 10.2 kbit/s modes**
The adaptive post‑filtering factors are given by:
{width="0.5965277777777778in" height="0.2361111111111111in"},
{width="0.69375in" height="0.2361111111111111in"} and
{width="1.5277777777777777in" height="0.5138888888888888in"}. (86)
**7.95, 7.40, 6.70, 5.90, 5.15, 4.75 kbit/s modes**
The adaptive post‑filtering factors are given by:
{width="0.6527777777777778in" height="0.2222222222222222in"},
{width="0.5965277777777778in" height="0.2222222222222222in"} and
{width="0.5555555555555556in" height="0.2222222222222222in"}.
### 6.2.2 High-pass filtering and up-scaling (all modes)
The high-pass filter serves as a precaution against undesired low frequency
components. A filter cut-off frequency of 60 Hz is used, and the filter is
given by
{width="4.0in" height="0.4583333333333333in"}. (87)
Up‑scaling consists of multiplying the post‑filtered speech by a factor of 2
to compensate for the down‑scaling by 2 which is applied to the input signal.
# 7 Detailed bit allocation of the adaptive multi-rate codec
The detailed allocation of the bits in the adaptive multi-rate speech encoder
is shown for each mode in table 9a-9h. These tables show the order of the bits
produced by the speech encoder. Note that the most significant bit (MSB) of
each codec parameter is always sent first.
Table 9a: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 244 bits/20 ms, 12.2 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 ‑ s7 index of 1^st^ LSF submatrix s8 ‑ s15 index
of 2^nd^ LSF submatrix s16 ‑ s23 index of 3^rd^ LSF submatrix s24 sign of
3^rd^ LSF submatrix s25 ‑ s32 index of 4^th^ LSF submatrix s33 ‑ s38 index of
5^th^ LSF submatrix subframe 1  
s39 ‑ s47 adaptive codebook index s48 ‑ s51 adaptive codebook gain s52 sign
information for 1^st^ and 6^th^ pulses s53 ‑ s55 position of 1^st^ pulse s56
sign information for 2^nd^ and 7^th^ pulses s57 ‑ s59 position of 2^nd^ pulse
s60 sign information for 3^rd^ and 8^th^ pulses s61 ‑ s63 position of 3^rd^
pulse s64 sign information for 4^th^ and 9^th^ pulses s65 ‑ s67 position of
4^th^ pulse s68 sign information for 5^th^ and 10^th^ pulses s69 ‑ s71
position of 5^th^ pulse s72 ‑ s74 position of 6^th^ pulse s75 ‑ s77 position
of 7^th^ pulse s78 ‑ s80 position of 8^th^ pulse s81 ‑ s83 position of 9^th^
pulse s84 ‑ s86 position of 10^th^ pulse s87 ‑ s91 fixed codebook gain
subframe 2  
s92 ‑ s97 adaptive codebook index (relative) s98 ‑ s141 same description as
s48 ‑ s91 subframe 3  
s142 ‑ s194 same description as s39 ‑ s91 subframe 4  
s195 ‑ s244 same description as s92 ‑ s141
* * *
Table 9b: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 204 bits/20 ms, 10.2 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s17
index of 2^nd^ LSF subvector s18 -- s26 index of 3^rd^ LSF subvector subframe
1  
s27 -- s34 adaptive codebook index s35 sign information for 1^st^ and 5^th^
pulses s36 sign information for 2^nd^ and 6^th^ pulses s37 sign information
for 3^rd^ and 7^th^ pulses s38 sign information for 4^th^ and 8^th^ pulses
s39-s48 position for 1^st^, 2^nd^, and 5^th^ pulses s49-s58 position for
3^rd^, 6^th^, and 7^th^ pulses s59-s65 position for 4^th^ and 8^th^ pulses s66
-- s72 codebook gains subframe 2  
s73 -- s77 adaptive codebook index (relative) s78 -- s115 same description as
s35 -- s72 subframe 3  
s116 -- s161 same description as s27 -- s72 subframe 4  
s162 -- s204 same description as s73 -- s115
* * *
Table 9c: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 159 bits/20 ms, 7.95 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s9 index of 1^st^ LSF subvector s10 ‑ s18
index of 2^nd^ LSF subvector s19 -- s27 index of 3^rd^ LSF subvector subframe
1  
s28 -- s35 adaptive codebook index s36 -- s39 position of 4^th^ pulse s40 --
s42 position of 3^rd^ pulse s43 -- s45 position of 2^nd^ pulse s46 -- s48
position of 1^st^ pulse s49 sign information for 4^th^ pulse s50 sign
information for 3^rd^ pulse s51 sign information for 2^nd^ pulse s52 sign
information for 1^st^ pulse s53 -- s56 adaptive codebook gain s57 -- s61 fixed
codebook gain subframe 2  
s62 -- s67 adaptive codebook index (relative) s68 -- s93 same description as
s36 -- s61 subframe 3  
s94 -- s127 same description as s28 -- s61 subframe 4  
s128 -- s159 same description as s62 -- s93
* * *
Table 9d: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 148 bits/20 ms, 7.40 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s17
index of 2^nd^ LSF subvector s18 -- s26 index of 3^rd^ LSF subvector subframe
1  
s27 -- s34 adaptive codebook index s35 -- s38 position of 4^th^ pulse s39 --
s41 position of 3^rd^ pulse s42 - s44 position of 2^nd^ pulse s45 -- s47
position of 1^st^ pulse s48 sign information for 4^th^ pulse s49 sign
information for 3^rd^ pulse s50 sign information for 2ndd pulse s51 sign
information for 1^st^ pulse s52 -- s58 codebook gains subframe 2  
s59 -- s63 adaptive codebook index (relative) s64 -- s87 same description as
s35 -- s58 subframe 3  
s88 -- s119 same description as s27 -- s58 subframe 4  
s120 -- s148 same description as s59 -- s87
* * *
Table 9e: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 134 bits/20 ms, 6.70 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s17
index of 2^nd^ LSF subvector s18 -- s26 index of 3^rd^ LSF subvector subframe
1  
s27 -- s34 adaptive codebook index s35 -- s38 position of 3^rd^ pulse s39 --
s42 position of 2^nd^ pulse s43 -- s45 position of 1^st^ pulse s46 sign
information for 3^rd^ pulse s47 sign information for 2^nd^ pulse s48 sign
information for 1^st^ pulse s49 -- s55 codebook gains subframe 2  
s56 -- s59 adaptive codebook index (relative) s60 -- s80 same description as
s35 -- s55 subframe 3  
s81 -- s109 same description as s27 -- s55 subframe 4  
s110 -- s134 same description as s56 -- s80
* * *
Table 9f: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 118 bits/20 ms, 5.90 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s17
index of 2^nd^ LSF subvector s18 -- s26 index of 3^rd^ LSF subvector subframe
1  
s27 -- s34 adaptive codebook index s35 -- s39 position of 2^nd^ pulse s40 --
s43 position of 1^st^ pulse s44 sign information for 2^nd^ pulse s45 sign
information for 1^st^ pulse s46 -- s51 codebook gains subframe 2  
s52 -- s55 adaptive codebook index (relative) s56 -- s72 same description as
s35 -- s51 subframe 3  
s73 -- s97 same description as s27 -- s51 subframe 4  
s98 -- s118 same description as s52 -- s72
* * *
Table 9g: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 103 bits/20 ms, 5.15 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s16
index of 2^nd^ LSF subvector s17 -- s23 index of 3^rd^ LSF subvector subframe
1  
s24 -- s31 adaptive codebook index s32 position subset s33 -- s35 position of
2^nd^ pulse s36 -- s38 position of 1^st^ pulse s39 sign information for 2^nd^
pulse s40 sign information for 1^st^ pulse s41 -- s46 codebook gains subframe
2  
s47 -- s50 adaptive codebook index (relative) s51 -- s65 same description as
s32 -- s46 subframe 3  
s66 -- s84 same description as s47 -- s65 subframe 4  
s85 -- s103 same description as s47 -- s65
* * *
Table 9h: Source encoder output parameters in order of occurrence and bit
allocation within the speech frame of 95 bits/20 ms, 4.75 kbit/s mode.
* * *
Bits (MSB‑LSB) Description s1 -- s8 index of 1^st^ LSF subvector s9 ‑ s16
index of 2^nd^ LSF subvector s17 -- s23 index of 3^rd^ LSF subvector subframe
1  
s24 -- s31 adaptive codebook index s32 position subset s33 -- s35 position of
2^nd^ pulse s36 -- s38 position of 1^st^ pulse s39 sign information for 2^nd^
pulse s40 sign information for 1^st^ pulse s41 -- s48 codebook gains subframe
2  
s49 -- s52 adaptive codebook index (relative) s53 -- s61 same description as
s32 -- s40 subframe 3  
s62 - s65 same description as s49 -- s52 s66 -- s82 same description as s32--
s48 subframe 4  
s83 -- s95 same description as s49 -- s61
* * *
# 8 Homing sequences
## 8.1 Functional description
The adaptive multi-rate speech codec is described in a bit‑exact arithmetic to
allow for easy type approval as well as general testing purposes of the
adaptive multi-rate speech codec.
The response of the codec to a predefined input sequence can only be foreseen
if the internal state variables of the codec are in a predefined state at the
beginning of the experiment. Therefore, the codec has to be put in a so called
home state before a bit‑exact test can be performed. This is usually done by a
reset (a procedure in which the internal state variables of the codec are set
to their defined initial values). The codec mode of the speech encoder and
speech decoder shall be set to the tested codec mode by external means at
reset.
To allow a reset of the codec in remote locations, special homing frames have
been defined for the encoder and the decoder, thus enabling a codec homing by
inband signalling.
The codec homing procedure is defined in such a way, that in either direction
(encoder or decoder) the homing functions are called after processing the
homing frame that is input. The output corresponding to the first homing frame
is therefore dependent on the used codec mode and the codec state when
receiving that frame and hence usually not known. The response of the encoder
to any further homing frame is by definition the corresponding decoder homing
frame for the used codec mode. The response of the decoder to any further
homing frame is by definition the encoder homing frame. This procedure allows
homing of both, the encoder and decoder from either side, if a loop back
configuration is implemented, taking proper framing into account.
## 8.2 Definitions
**Encoder homing frame:** The encoder homing frame consists of 160 identical
samples, each 13 bits long, with the least significant bit set to \"one\" and
all other bits set to \"zero\". When written to 16‑bit words with left
justification, the samples have a value of 0008 hex. The speech decoder has to
produce this frame as a response to the second and any further decoder homing
frame if at least two decoder homing frames were input to the decoder
consecutively. The encoder homing frame is identical for all codec modes.
**Decoder homing frame:** There exist eight different decoder homing frames,
which correspond to the eight AMR codec modes. Using one of these codec modes,
the corresponding decoder homing frame is the natural response of the speech
encoder to the second and any further encoder homing frame if at least two
encoder homing frames were input to the encoder consecutively. In [4], for
each decoder homing frame the parameter values are given.
## 8.3 Encoder homing
Whenever the adaptive multi-rate speech encoder receives at its input an
encoder homing frame exactly aligned with its internal speech frame
segmentation, the following events take place:
Step 1: The speech encoder performs its normal operation including VAD and SCR
and produces in accordance with the used codec mode a speech parameter frame
at its output which is in general unknown. But if the speech encoder was in
its home state at the beginning of that frame, then the resulting speech
parameter frame is identical to that decoder homing frame, which corresponds
to the used codec mode (this is the way how the decoder homing frames were
constructed).
Step 2: After successful termination of that operation the speech encoder
provokes the homing functions for all sub‑modules including VAD and SCR and
sets all state variables into their home state. On the reception of the next
input frame, the speech encoder will start from its home state.
NOTE: Applying a sequence of N encoder homing frames will cause at least N‑1
decoder homing frames at the output of the speech encoder.
## 8.4 Decoder homing
Whenever the speech decoder receives at its input a decoder homing frame,
which corresponds to the used codec mode, then the following events take
place:
Step 1: The speech decoder performs its normal operation and produces a speech
frame at its output which is in general unknown. But if the speech decoder was
in its home state at the beginning of that frame, then the resulting speech
frame is replaced by the encoder homing frame. This would not naturally be the
case but is forced by this definition here.
Step 2: After successful termination of that operation the speech decoder
provokes the homing functions for all sub‑modules including the comfort noise
generator and sets all state variables into their home state. On the reception
of the next input frame, the speech decoder will start from its home state.
NOTE 1: Applying a sequence of N decoder homing frames will cause at least N‑1
encoder homing frames at the output of the speech decoder.
NOTE 2: By definition (!) the first frame of each decoder test sequence must
differ from the decoder homing frame at least in one bit position within the
parameters for LPC and first subframe. Therefore, if the decoder is in its
home state, it is sufficient to check only these parameters to detect a
subsequent decoder homing frame. This definition is made to support a
delay‑optimized implementation in the TRAU uplink direction.
{width="6.454166666666667in" height="2.5833333333333335in"}
Figure 2: Simplified block diagram of the CELP synthesis model
{width="8.613194444444444in" height="6.361805555555556in"}
Figure 3: Simplified block diagram of the adaptive multi-rate encoder
{width="8.3875in" height="4.551388888888889in"}
Figure 4: Simplified block diagram of the adaptive multi-rate decoder
# 9 Bibliography
1) M.R. Schroeder and B.S. Atal, \"Code‑Excited Linear Prediction (CELP): High
quality speech at very low bit rates,\" in Proc. _ICASSP\'85_ , pp. 937‑940,
1985.
2) L.R. Rabiner and R.W. Schaefer. _Digital processing of speech signals_.
Prentice‑Hall Int., 1978.
3) F. Itakura, \"Line spectral representation of linear predictive
coefficients of speech signals,\" _J. Acoust. Soc. Amer._ , vol. 57,
Supplement no. 1, S35, 1975.
4) F.K. Soong and B.H. Juang, \"Line spectrum pair (LSP) and speech data
compression\", in _Proc. ICASSP\'84_ , pp. 1.10.1‑1.10.4.
5) K.K Paliwal and B.S. Atal, \"Efficient vector quantization of LPC
parameters at 24 bits/frame\", _IEEE Trans. Speech and Audio Processing_ ,
vol. 1, no 1, pp. 3‑14, 1993.
6) P. Kabal and R.P. Ramachandran, \"The computation of line spectral
frequencies using Chebyshev polynomials\", _IEEE Trans. on ASSP_ , vol. 34,
no. 6, pp. 1419‑1426, Dec. 1986.
7) K. Järvinen, J. Vainio, P. Kapanen, T. Honkanen, P. Haavisto, R. Salami, C.
Laflamme, and J.-P. Adoul, "GSM enhanced full rate speech codec\", in _Proc.
ICASSP'97_ , pp. 771‑774.
8) T. Honkanen, J. Vainio, K. Järvinen, P. Haavisto, R. Salami, C. Laflamme,
and J.-P. Adoul, "Enhanced full rate speech codec for IS-136 digital cellular
system\", in _Proc. ICASSP'97_ , pp. 731‑734.
9) R. Hagen, E. Ekudden, B. Johansson, and W.B. Kleijn, "Removal of sparse-
excitation artefacts in CELP\", in _Proc. ICASSP'98_ , pp. I-145‑I-148.
#
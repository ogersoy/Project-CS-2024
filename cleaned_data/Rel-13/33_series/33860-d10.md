# Foreword
This Technical Report has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
Machine to Machine (M2M) communication represents a significant growth
opportunity for the 3GPP ecosystem. To support the so called 'Internet of
Things' (IoT), 3GPP operators have to address usage scenarios with devices
that are power efficient (with battery life of several years), can be reached
in challenging coverage conditions e.g. indoor and basements and, more
importantly, are cheap enough so that they can be deployed on a mass scale and
even be disposable.
TR 45.820[2] studies the need to adapt the security frame work of the proposed
candidate techniques to suit the need of the emerging Internet of Things
market. Any of the alternative solutions studied within the scope of
FS_IoT_LC, for example the so-called \"clean slate solution\", could
potentially select to operate with an architecture using the Gb interface. All
these solutions use the Gb interface.
# 1 Scope
The present document contains a study of the EGPRS access security in relation
to cellular IoT, and an evaluation of possible technical security enhancements
needed to support such services. Different possible deployment scenarios for
Cellular IoT, and related stage 2 solutions are being studied in TR 45.820
[2].
**The scope of this study is limited to investigate the feasibility of
improving the access security aspects of Gb mode. In more detail, the scope
includes:**
1) Investigate potential security threats, such as man in the middle attacks.
2) Investigate potential security enhancements between the UE and SGSN to
mitigate said threats.
3) Define what security procedures and security algorithms that are
recommended to be used by for Cellular IoT devices in Gb mode. This may be
procedures and algorithms already specified in earlier 3GPP releases or it
could be new procedures and algorithms being introduced as part of this
feasibility study.
4) The potential security enhancements as part of this study item should aim
at minimising the impacts to the GPRS core network.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TR 45.820: \"Cellular System Support for Ultra Low Complexity and Low
Throughput Internet of Things\".
[3] 3GPP TR 23.060: \"General Packet Radio Service (GPRS)\".
[4] 3GPP TS 43.020: \"Security related network functions\".
[5] 3GPP TS 35.215: \"Confidentiality and Integrity Algorithms UEA2 & UIA2;
Document 1: UEA2 and UIA2 specifications\".
[6] 3GPP TS 35.201: \"Specification of the 3GPP Confidentiality and Integrity
Algorithms; Document 1: f8 and f9 Specification\".
[7] 3GPP TS 44.064: \"Logical Link Control (LLC) layer specification\".
[8] 3GPP TS 24.301: \"Non-Access-Stratum (NAS) protocol for Evolved Packet
System (EPS)\".
[9] J. Passki and T. Ritter: \"An Adaptive Ciphertext Attack Against \"I⊕C\"
Block Cipher Moders with an Oracle. \"May. 2012.
https://eprint.iacr.org/2012/292.pdf
[10] 3GPP TS 33. 401: \"3GPP System Architecture Evolution (SAE): Security
architecture\".
[11] Z. Shelby, K. Hartke, and C. Bormann: \"The Constrained Application
Protocol (CoAP)\". RFC 7252, June 2014.
[12] GP-140681: \"Traffic model for Cellular IoT (update of GP-140560)\".
[13] 3GPP TR 33. 821: \"Rationale and track of security decisions in Long Term
Evolved (LTE) RAN / 3GPP System Architecture Evolution (SAE)\".
[14] D. A. McGrew and John Viega: \"The Security and Performance of the
Galois/Counter Mode (GCM) of Operation\" (Full Version).
http://eprint.iacr.org/2004/193.pdf.
[15] T. Kohno, J. Viega, and D. \"Whiting: The CWC Authenticated Encryption
(Associated Data) Mode\".
http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/cwc/cwc-
spec.pdf
[16] P. Rogaway, M. Bellare, J. Black and T. Krovetz: OCB:\"A Block-Cipher
Mode of Operation for Efficient Authenticated Encryption\".
http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ocb/ocb-
spec.pdf.
[17] 3GPP TS 24.008: \" Mobile radio interface Layer 3 specification; Core
network protocols; Stage 3\".
[18]: 3GPP TR 43.064: \" General Packet Radio Service (GPRS); Overall
description of the GPRS radio interface; Stage 2\".
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply.\ An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
CIoT Cellular System Support for Ultra Low Complexity and Low Throughput
Internet of Things
KDctr Key Derivation Counter
K~med~ Medium term key, derived from K, and used in the derivation of Ktc and
Kti
Ktc Session key of Gb based cellular IoT for confidentiality protection
Kti Session key of Gb based cellular IoT for integrity protection
# 4 Cellular IoT
## 4.1 Overview of Cellular IoT
## 4.2 The baseline architecture for Cellular IoT services
### 4.2.1 User plane (Gb mode)
The user plane in Gb mode [3] consists of a layered protocol structure
demonstrated in Figure 4.2.1-1. The figure shows only the protocol layer LLC
and layers above. The present document is limited to study protocol layers
between the MS and SGSN. In the current Gb mode, the ciphering of the user
plane is done at LLC layer.
{width="5.4375in" height="2.3333333333333335in"}
Figure 4.2.1-1: User Plane for Gb mode
### 4.3.2 Control plane (Gb mode)
The control plane in Gb mode [3] consists of a layered protocol structure
demonstrated in Figure 4.3.2-1. The figure shows only the protocol layer LLC
and the layer above. The present document is limited to study protocol layers
between the MS and SGSN. In the current Gb mode, the authentication is done at
GMM/SM layer, and ciphering of the control plane at LLC layer.
Figure 4.3.2-1: Control Plane MS - SGSN in Gb mode
# 5 Key Issues
## 5.1 Key Issue #1: Entity authentication and key agreement
### 5.1.1 Key issue details
This key issue includes the normal authentication and key agreement problems
that exist in all similar 3GPP networks. For example, the SGSN needs to know
the identity of the CIoT UE, and to be ensured that the CIoT UE is genuine and
authorized to get service via the network. Information related to the identity
and authorization of the CIoT UE is needed not only for security purposes but
also e.g. for charging. Similarly, the CIoT UE needs to be ensured that the
network is trustworthy, and has access to the secret that the UE shared with
the home network. A way to establish trustworthiness of the network is
verifying that its session keys were supplied to it by the home network. This
is achieved in UMTS AKA by putting a message authentication code MAC on the
challenge. The authentication challenges need to be fresh otherwise an
attacker can force the re-use of keys. The latter is a well-known weakness of
GSM authentication.
There are some new system features that are specific to CIoT. CIoT UE may be
more stationary; however, also more traditional mobility patterns can be
foreseen. CIoT UEs may be turned off without the need for connectivity for the
majority of the time. The number of CIoT UEs per base station may also be
increased on massive scale. These CIoT specific new system features bring some
new challenges to the authentication and key agreement:
\- The frequency of authentication may be very different from the existing
3GPP systems. There is a clear interest of extending the time between
authentications because of the power limitations in the CIoT UE side, and
because of the high number of CIoT UEs served by one base station.
\- The frequency of authentication may strengthen requirements to the length
of the key(s) used for message protection. Less frequent authentication would
suggest the use of longer key(s). An example why a key length of 64 bits is
inadequate is given in the Key Issue on Eavesdropping.
### 5.1.2 Security threats
The following security threats are foreseen:
\- Malicious CIoT UEs may try to access the network.
\- Malicious base stations may try to fool the CIoT UE to be detached from a
genuine base station or to be attached to malicious base stations.
\- If the frequency of authentication is very low, the safety of the session
key(s) may be increasingly jeopardized if the keys are too short. Also, the
longer a session key remains, the greater the risk of it leaking.
\- The shorter the session key is, the more easily it may be compromised. It
is plausible, though, that there is a upper limit for the key length such that
increasing the key length beyond this limit would not result in a practical
gain in security for CIoT anymore.
### 5.1.3 Potential security requirements
The security solutions should address the following potential security
requirements:
\- CIoT UE shall not accept replayed authentication challenges.
\- CIoT UE shall not accept authentication challenges generated by unknown
sources.
\- The proposed key agreement solutions should consider the potential low
frequency of authentication when determining the key length.
\- If possible, session keys should be securely updated with much lower data
transmission than a full authentication.
## 5.2 Key Issue #2: Eavesdropping
### 5.2.1 Key issue details
The messages sent over the air-interface are vulnerable to eavesdropping.
Therefore, access security is provided.
In GPRS, access security extends between UE and SGSN. UE and SGSN agree on a
particular encryption algorithm in the control and user planes.
Some privacy sensitive data related to the subscriber, like the IP address,
need to be protected. They can be protected by LLC layer encryption, but not
by any higher-layer encryption.
Some CIoT UEs may want to rely on the security provided by GPRS, and their
applications may require a certain level of security, which then implies that
only cryptographic algorithms of certain strength are acceptable for the CIoT
UE. This required level of security may then be expressed as a security policy
that is implemented locally on the CIoT UE. In this way, the CIoT UE is not
dependent on any security policy the SGSN may want to enforce.
Furthermore, both CIoT UE and SGSN have an interest that the algorithm(s) they
agree to use is/are the strongest they have in common.
It is also worth noting that there are countries where the use of encryption
algorithms is not possible.
### 5.2.2 Security threats
The following security threats are foreseen:
\- Confidentiality of signalling or user data may be compromised.
\- One possible reason for such a compromise is that a weak encryption
algorithm is used that the attacker can break while the data protected by the
session key remains sensitive. E.g. a 64-bit encryption key is too short to
give strong protection. This is made even worse if such an encryption key is
in use for a very long time.
\- An attacker may try to influence the selection of the encryption algorithm
in order to prevent the IoT UE and the SGSN to select the strongest common
encryption algorithm that is also strong enough to satisfy the local security
policies in the UE and the SGSN respectively. E.g. an attacker can force a UE
to accept NULL encryption by simply not sending an Authentication and
Ciphering Request message or sending one with encryption set to NULL. There
currently is no integrity protection in GPRS. So, the UE is left without any
protection in this case.
### 5.2.3 Potential security requirements
The security solutions should address the following potential security
requirements:
A CIoT UE should have a locally implemented security policy that includes a
statement on acceptable encryption algorithms. This policy should be stored
securely in the UE to prevent unauthorized modification.
NOTE: Locally implemented security policies in the UE side would require more
study.
\- The signalling and the user data shall be encrypted using the strongest
common encryption algorithm between CIoT UE and SGSN that is also strong
enough to satisfy the local security policies in the UE and the SGSN
respectively.
\- If the CIoT UE has a security policy regarding cryptographic algorithms in
place then a connection with an SGSN offering no acceptable algorithm shall be
rejected.
\- Bidding down of the encryption algorithms shall be prevented.
\- Encryption keys shall be long enough to provide strong protection against
brute force cryptanalysis.
## 5.3 Key Issue #3: Unauthorized modification of signalling data
### 5.3.1 Key issue details
In current GPRS, an attacker may enforce the use of no protection of
signalling data or protection by a weak encryption algorithm.
Furthermore, even if a strong encryption algorithm is used a man-in-the-middle
could modify individual bits in a message while leaving encryption intact. The
fact that a stream cipher is used for encryption and the error detecting code
is linear makes the task for the attacker easier. If the attacker knows the
plaintext then he can modify it to turn it into a plaintext of his choice. The
technical prerequisite for the attacker is that he can toggle individual bits
in an LLC frame while being able to forward the otherwise unchanged frame
transparently between UE and SGSN and that the attacker knows the frame
structure, including the division into headers, plaintext and error detecting
code. If the length of each data segment in the signaling message is fixed, it
is easy for an attacker to make a meaningful modification at the appropriate
place on the encrypted signaling message by flipping one or more bits of the
cipher text. Actually as shown in [9], even if the length of data segment is
dynamic, an attacker is able to manipulate the cipher text to decrypt to
arbitrary plaintext. These attacks do not require breaking stream cipher.
Moreover, the receiver cannot perceive them if no data integrity protection is
employed.
In general, roaming is required for all services. However, there will be some
UEs for which their HPLMN operator does not expect the UE to roam between
countries allowing encryption and countries not allowing encryption. Support
of GEA0 will be needed only for UEs possibly roaming into countries not
allowing encryption or where the home operator is located in a country not
allowing encryption.
### 5.3.2 Security threats
The most obvious threat is that the attacker can modify the Authentication and
Ciphering procedure, which results in a bidding down attack and consequently
in the loss of data confidentiality or data integrity. This is described in
another key issue.
Furthermore, some mobility management messages can be sent unprotected in
current GPRS. This could result in a Denial-of-Service attack.
Finally, the attacker could modify mobility management messages as described
in the key issue details. This could also result in a Denial-of-Service
attack. E.g., a successful sending of a Routing Area Update message or a De-
registration message could result in a temporary unreachability of the UE
until the UE contacts the network the next time.
### 5.3.3 Potential security requirements
The security solutions should address the following potential security
requirements:
\- Modification of mobility management and session management messages shall
be prevented.
\- Cryptographic keys used to provide data integrity shall be long enough to
provide strong protection against brute force cryptanalysis.
\- Integrity of signaling data in CIOT shall be protected by using the message
authentication code rather than using an encryption algorithm, just like the
integrity protection of signaling data in E-UTRAN networks [10].
\- For sufficient security, merely strong encryption of signaling messages is
not enough. Message authentication code algorithms shall be applied to
signaling messages
## 5.4 Key Issue #4: Unauthorized modification of user data
### 5.4.1 Key issue details
It is well known that the encryption does not ensure the integrity of the
plaintext. This is especially true for a stream cipher. An attacker usually
knows the frame structure of user data and the meaning of each data segment,
such as header and payload of the CoAP protocol, which is a standardized
application protocol in IoT [11]. It is not so difficult for an attacker to
launch a meaningful modification by altering one or more bits in the encrypted
user data without breaking stream cipher.
### 5.4.2 Security threats
User data in IoT are usually modelled as low throughput and long traffic
inter-arrival time [12]. The applications of IoT are usually used for the
remote information retrieve or remote system control. This is quite different
from the user data in real time communication whose traffic arrival is
constant and continuous. Real time communication is tolerant to the packet
loss or data modification because this usually does not change the content of
a real time communication [13]. A user at most perceives a noise in this case.
Also, in IoT, user data can more appropriately be viewed as \"signalling
data\", with respect to information classification. Therefore, while an
attacker's interest, opportunity, and non-detectability to modify human-
generated user data can generally be viewed as low, this need not be the case
for modifying IoT user data in several use cases. Thus we cannot deduce that
the integrity of user data in CIoT will not be protected only because
integrity of user data is not required in GPRS, UTRAN and E-UTRAN networks.
The latter were designed for mainly human-generated user data The modification
of user data in the CIoT scenario is judged to be a more valid threat than
that of the modification of human-originated user data.
### 5.4.3 Potential security requirements
User data can be discarded at the link layer to avoid the delivery to the
upper layer for further processing if data modification is detected at the
link layer. This can save the energy consumption since the upper layer doesn't
need to process the compromised data packet.
Considering the efficiency, IoT applications may rely on the security schemes
in the link layer to ensure data confidentiality and integrity. Accordingly,
SGSN shall support integrity protection of user data. Integrity protection of
user data shall be optional-to-use at the link layer.
## 5.5 Key Issue #5: Null-encryption and unauthorized transmission of user
plane data
### 5.5.1 Key issue details
Null-encryption algorithm is currently assumed to be included as an
alternative to markets where the use of encryption is not allowed. Encryption
is used to protect, not only the control plane, but also the user plane.
Threats and issues related to the use of null-encryption with control plane
are discussed elsewhere (see Key Issue #3: Unauthorized modification of
signalling data).
In legacy GPRS, the attacker needs to wait for the UE to be re-authenticated.
After the re-authentication, the attacker can send and receive data. If re-
authentication is known to be absent for battery saving reasons, the attacker
can try sending data any time. The attacker just signals to the BSS that it
needs to send data and the connection is opened even when the authentic CIoT
UE was sleeping (or even absent, e.g. broken or stolen). If the SGSN decides
to re-authenticate at some point, the attacker needs to wait until the
original CIoT UE wakes up and re-authenticates.
### 5.5.2 Security threats
The following security threats are foreseen:
\- There is a risk for an attacker to send unauthorized user data if the null-
encryption is in use.
### 5.5.3 Potential security requirements
The security solutions should address the following potential security
requirements:
\- If null-encryption is in use, the SGSN shall protect against unauthorized
user plane, e.g. user plane originated from an attacker.
\- If null-encryption is in use, the CIoT UE shall protect itself against
unauthorized user plane, e.g. triggering messages originated from an attacker.
\- These solutions shall take battery lifetime into account.
# 6 Solutions
## 6.1 Solution #1: Integrity protection of signalling and algorithm
negotiation
### 6.1.1 General
This solution addresses key issues related to entity authentication and key
agreement, and data integrity.
It is assumed that integrity protection of user plane, if appropriate, is
performed at some upper layer outside the scope of the present document.
It is also assumed that UMTS AKA is mandated in order to guarantee that the
authentication challenges are genuine, and fresh, and key material for
integrity protection key is available.
NOTE: Recommendations related to the lifetime of UMTS AKA, and consequently
the lifetime of integrity key have not been give. This is seen as a local
deployment aspect.
### 6.1.2 Control Plane (Gb mode)
It is proposed that the control plane in Gb mode is enhanced by adding
integrity protection between CIoT UE and SGSN, see a demonstrative figure in
6.1.1-1. UMTS AKA is run at GMM/SM layer creating the keying material, and the
integrity protection is done at LLC layer using the integrity key (IK')
created with the key derivation function from the AKA session keys.
Figure 6.1.1-1: Enhanced Control Plane CIoT UE - SGSN in Gb mode
### 6.1.3 Protection of algorithm negotiation
It is proposed to re-use the algorithm negotiation mechanism from UMTS/LTE.
The CIoT UE sends identifiers for the encryption and integrity algorithms that
it supports to the SGSN e.g. in the Attach Request message. The SGSN then
echoes these identifiers back to the CIoT UE in an integrity protected
message, e.g. in the Authentication and Ciphering Request message. If the CIoT
UE notices that the identifiers sent to the network are different from the
received ones, it assumes that a Man-in-the-middle attack has taken place and
drops the connection.
The SGSN also selects the encryption and integrity algorithm, and indicates
the selected algorithms to the Cellular IoT UE in an integrity protected
message, e.g. in the Authentication and Ciphering Request message. The CIoT UE
is then able to detect potential bidding-down attacks which potentially could
lead to an attacker to turn off the encryption.
This solution proposes that integrity protection is supported in the LLC
layer. Integrity protection is activated in the LLC layer by the GMM layer in
the SGSN before the SGSN sends off the GMM Authentication and Ciphering
Request message to the CIoT UE. Integrity protection is activated in the LLC
layer by the GMM layer in the CIoT UE before the GMM layer in the CIoT UE
sends off the GMM Authentication and Ciphering Response message to the SGSN.
A problem was identified though that the CIoT UE does not have the integrity
key and the network selected integrity algorithm available in the LLC layer
when the CIoT UE receives the GMM Authentication and Ciphering Request message
from the SGSN including the echoed algorithm identifiers and the network
selected encryption and integrity algorithms. This implies that the LLC layer
in the CIoT UE is not able to verify any Message Authentication Code (MAC)
provided in the LLC protocol when it receives GMM Authentication and Ciphering
Request message.
NOTE: This is a protocol specific problem which needs to be analysed in stage
3 work.
The integrity algorithm negotiation procedure is described as bellow, similar
to cipher algorithm negotiation.
Figure 6.1.3-1: Integrity algorithm negotiation
1) Cellular IoT UE sends attach request to SGSN. The cipher algorithms and
integrity algorithms supported by the Cellular IoT UE are included in the MS
network capability parameters.
2) SGSN obtains AVs (quintets) from HLR/HSS based on IMSI.
3) SGSN determines that the request UE is a cellular IoT UE based on the MS
network capability parameters. SGSN selects a cipher algorithm and an
integrity algorithm from the MS network capability and then derives cipher key
(Ktc) and integrity key (Kti). Ktc and Kti can be 128bits length.
4) The GMM layer in the SGSN activates integrity protection in the LLC layer
by assigning an integrity key Kti and the network selected integrity algorithm
to the LLC layer.
5) SGSN sends Authentication and ciphering request including the chosen cipher
algorithm and integrity algorithm and MS network capability to Cellular IoT
UE. The Authentication and ciphering request is integrity protected by the LLC
layer.
6) Cellular IoT UE runs UMTS AKA with the USIM and derives Ktc and Kti from CK
and IK. The Cellular IoT UE verifies the MAC by utilizing a key derived from
Kti, and if the check of the MAC is successful then Cellular IoT UE checks the
echoed MS network capability. The Cellular IoT UE verifies that there has been
no attack on MS Network Capability originally sent by the Cellular IoT UE in
GMM Attach Request.
7) The GMM layer in the CIoT UE activates integrity protection in the LLC
layer by assigning an integrity key Kti and the network selected integrity
algorithm to the LLC layer.
8) Cellular IoT UE sends authentication and ciphering response to SGSN. The
Authentication and ciphering response message is integrity protected by the
LLC layer. The GMM layer in the SGSN receives the Authentication and ciphering
Response message and checks the RES.
9) The GMM layer in the CIoT UE activates ciphering in the LLC layer by
assigning a ciphering key Ktc and the network selected ciphering algorithm to
the LLC layer.
10) The GMM layer in the SGSN activates ciphering in the LLC layer by
assigning a ciphering key Ktc and the network selected ciphering algorithm to
the LLC layer.
11) The communication between Cellular IoT UE and SGSN can be confidentiality
protected and integrity protected by using the encryption key Ktc and the
integrity key Kti.
### 6.1.4 Integrity algorithms
The integrity algorithms used in this solution are specified in Clause 6.3.
### 6.1.5 Integrity key derivation
Cellular IoT UE and SGSN can derive integrity key from CK and IK. For example,
as defined in TS 33.102 Annex B.5, Ktc~128~ is the 128 most significant bits
of KDF outputs, and the Key input to KDF is the concatenation of CK and IK
(i.e. CK \|\| IK). The 128 least significant bits of KDF output is the
integrity key (i.e. Kti~128~).
### 6.1.6 Interworking with legacy GPRS
CIoT devices are not assumed to interwork with legacy SGSNs, however, enhanced
SGSNs may still need to serve legacy GPRS mobile stations. The SGSNs may use
the presence of integrity algorithms as an indication on which UEs use legacy
GPRS security, and which UEs use enhanced GPRS security.
Editor's note: Security threats related to an enhanced SGSN serving both
legacy GPRS and CIoT are FFS. E.g. it should be studied if legacy UEs and CIoT
UEs are allowed to access the same APN.
### 6.1.7 Message Authentication Code
The 4 bytes long MAC is carried in the LLC message. One option for allowing
SGSN to serve both legacy UEs and CIoT UEs, would be to use a spare bit in the
control field portion of a LLC header to indicate if integrity protection has
been applied by the sending LLC entity to the message. If the spare bit
indicates integrity protection, the LLC entity would need to further process
that LLC message before further processing can occur. This would allow
extending the structure of LLC frame format more freely, e.g. allowing the MAC
being an extension to current LLC frame (see figure 6.1.4-1), or allowing the
4 bytes long MAC being a replacement of the current 3 bytes long Frame Check
Sequence Field.
NOTE: This is a protocol specific problem which needs to be analysed in stage
3 work.
{width="2.373611111111111in" height="2.620138888888889in"}
Figure 6.1.4-1: A potential extension of LLC protocol to carry MAC
## 6.2 Solution #2: Data efficient rekeying
### 6.2.1 General
This solution addresses the problem that infrequent authentication leads to
session keys having undesirably long lifetimes.
The USIM key K is a long-term(typically permanent) key. Ktc and Kti are
intended to be relatively short-lived session keys. This solution introduces
an interim, medium-term key, which we can call K~med~. It separates the
functions of authentication and session key generation, allowing session key
generation to be done much more frequently than authentication, with far less
data transmission required.
### 6.2.2 Generation of K~med~
K~med~ is generated from K using a full UMTS AKA, or a slight variant thereof.
K~med~ is generated in the same way that CK, or IK, or CK\|\|IK, are generated
today. The important difference, though, is that K~med~ is retained on the
USIM, not released to the ME. K~med~ could be 128 or 256 bits long
### 6.2.3 Generation of Ktc and Kti
There's a key derivation counter KDctr -- let's say two bytes -- stored on the
USIM. KDctr starts at 0 whenever a new value of K~med~ is created, and it will
increment.
The network determines when a new session key Ktc or Kti should be generated,
and sends a session key generation request message to the mobile device. The
mobile device and network agree a new incrementing value of KDCTR (there are
various ways to do this, see below). The mobile device passes the new KDctr
value to the USIM, and:
\- if the new KDctr is greater than the previous one, then the USIM derives a
new session key from K~med~ and KDctr, and returns the session key to the
mobile device; the session key is then used for encryption or integrity
protection on the radio interface;
\- if the new KDctr is less than or equal to the previous one, the USIM
rejects it. That way, even someone controlling the mobile device can't make
the USIM release either previous or future values of the session key.
New values of Ktc and Kti could be generated simultaneously or independently.
Is it necessary to integrity protect the session key generation request
message? Not doing so would reduce downlink transmission and save battery
life. Attacks that might be possible without integrity protection include the
following:
\- An attacker might be able to trick the endpoints into raising KDctr to its
maximum value, but the denial of service that that would create would be very
short lived, immediately rectified with a new full authentication operation.
\- An attacker who can temporarily compromise the device could send spoofed
session key generation request messages to the USIM using each possible KDctr
value in turn, and obtain the resulting session keys. This would then allow
the attacker to impersonate the legitimate mobile device for as long as the
current K~med~ remains in place, because the attacker will already have all of
the session keys that the network may ask it to generate during that time.
The second of these attacks seems more serious. A compromise solution would be
to include an optional message authentication code in the session key
generation message, with the USIM enforcing a policy that at least every nth
session key generation message needs to be integrity protected.
KDctr needs to be agreed between the device and the serving node. There are a
number of ways that this might be done:
\- it could be sent from the device to the serving node;
\- better, from a device battery perspective, it could be sent from the
serving node to the device;
\- some data efficiency optimisation may be possible, e.g.
(a only a few least significant bits are sent from one end to the other, and
we assume that the remaining bits can be kept synchronised;
(b or, only a few least significant bits are usually sent from one end to the
other, and occasionally a slightly longer message is sent to update the
remaining bits;
(c or some sort of already existing packet counter or similar value may be
(partially) re-used as the KDCTR.
Note also that the input value used for short-term key derivation doesn't
absolutely have to be an incrementing counter. It could be a random value, for
instance. A counter is simpler, though, and likely to be most efficient.
### 6.2.4 Key derivation in the network
Corresponding key derivation needs to be done on the network side too. There
are two alternative approaches to managing the keys on the network side:
1\. K~med~ is held back by the AuC, or by a secure proxy sat in front of the
HLR; the short lived session keys are derived here when needed, and sent to
the SGSN that needs them. So that SGSN never receives K~med~, only the session
keys Ktc and Kti. This means more signalling between the HLR and the SGSN, but
that may still be acceptable.
2\. Or, K~med~ is held in the SGSN, and the session key derivation is done in
the SGSN.
\- For improved security, the storage and use of K~med~ could be within a
Secure Execution Environment inside the SGSN. As with the mobile-device-to-
USIM interface, the SEE only accepts KDctr values that are higher than
previous ones.
### 6.2.5 Further details and analysis
Further detail and analysis of the Data Efficient Rekeying solution can be
found in Annex C.
## 6.3 Solution #3: Algorithms for ciphering and integrity protection
### 6.3.1 General
This solution addresses key issues related to eavesdropping and unauthorized
modification of signalling data. It is proposed that the following algorithms
are specified for EASE_IoT:
\- GEA0 for null-encryption.
\- GEA4/GIA4 based on Kasumi 128.
\- GEA5/GIA5 based on SNOW 3G.
NOTE1: Support of ZUC would have been an alternative to support of GEA0.
NOTE2: This solution is related to the solution proposal in clause 6.1.
### 6.3.2 Null ciphering algorithm
If GEA0 is selected, the ciphering function implemented in the LLC layer is
disabled according to TS 44.064 [7].
NOTE 1: GEA0 provides no security.
### 6.3.3 Ciphering algorithm
#### 6.3.3.1 Inputs and outputs
The input parameters to the ciphering algorithm GEA4 are specified in TS
43.020 [4]. Figure 6.3.3.1-1 illustrates the use of the ciphering algorithm
GEA4.
Figure 6.3.3.1-1: Ciphering of data with GEA4
The input parameters to the ciphering algorithm GEA5 are a 128-bit cipher key
named Ktc, a 32-bit INPUT as specified in TS 43.020 [4], a 5-bit bearer
identity BEARER with a static value \"00000\", the 1-bit direction of the
transmission i.e. DIRECTION, and the length of the keystream required i.e.
LENGTH. The DIRECTION bit is 0 for uplink and 1 for downlink.
Figure 6.3.3.1-2 illustrates the use of the ciphering algorithm GEA5 to
encrypt plaintext by applying a keystream using a bit per bit binary addition
of the plaintext and the keystream. The plaintext may be recovered by
generating the same keystream using the same input parameters and applying a
bit per bit binary addition with the ciphertext.
Figure 6.3.3.1-2: Ciphering of data with GEA5
Based on the input parameters the algorithm generates the output keystream
block KEYSTREAM which is used to encrypt the input plaintext block PLAINTEXT
to produce the output ciphertext block CIPHERTEXT.
The input parameter LENGTH affects only the length of the KEYSTREAM BLOCK, not
the actual bits in it.
#### 6.3.3.2 GEA5
NOTE: This section is presented here only for demonstrative purposes, and
represents only one possible way of specifying the GEA5 algorithm. The actual
specification would need to be done in ETSI SAGE.
GEA5 is based on SNOW 3G and is identical to UEA2 as specified in TS 35.215
[5] with the following exceptions to the initialization of the algorithm
(differences being that COUNT-C[0], ... COUNT-C[31] is replaced by INPUT[0],
... INPUT[31], and that BEARER[0] ... BEARER[4] is replaced by 0 \|\| 0 \|\| 0
\|\| 0 \|\| 0)::
> IV3 = INPUT[0] \|\| INPUT [1] \|\| INPUT [2] \|\| ... \|\| INPUT [31]
>
> IV2 = 0 \|\| 0 \|\| 0 \|\| 0 \|\| 0 \|\| DIRECTION[0] \|\| 0 \|\| ... \|\| 0
>
> IV1 = INPUT[0] \|\| INPUT [1] \|\| INPUT [2] \|\| ... \|\| INPUT [31]
>
> IV0 = 0 \|\| 0 \|\| 0 \|\| 0 \|\| 0 \|\| DIRECTION[0] \|\| 0 \|\| ... \|\| 0
### 6.3.4 Integrity algorithm
#### 6.3.4.1 Inputs and outputs
The input parameters to the integrity algorithm are a 128-bit integrity key
named Kti, a 32-bit INPUT, a 5-bit bearer identity called BEARER with a static
value \"00000\", the 1-bit direction of the transmission i.e. DIRECTION, and
the message itself i.e MESSAGE. The DIRECTION bit is 0 for uplink and 1 for
downlink. The bit length of the MESSAGE is LENGTH.
Figure 6.3.4.1-1 illustrates the use of the integrity algorithm GIA to
authenticate the integrity of messages.
Figure 6.3.4.1-1: Derivation of MAC/XMAC
Based on these input parameters the sender computes a 32-bit message
authentication code (MAC) using the integrity algorithm GIA. The message
authentication code is then appended to the message when sent. For integrity
protection algorithms the receiver computes the expected message
authentication code (XMAC) on the message received in the same way as the
sender computed its message authentication code on the message sent and
verifies the data integrity of the message by comparing it to the received
message authentication code, i.e. MAC.
#### 6.3.4.2 GIA4
NOTE: This section is presented here only for demonstrative purposes, and
represents only one possible way of specifying the GIA4 algorithm. The actual
specification would need to be done in ETSI SAGE.
GIA4 is based on Kasumi 3G and is implemented in the same way as UIA1 as
specified TS 35.201 [6] with the following exceptions to the initialization of
the algorithm (differences being that COUNT-C[0], ... COUNT-C[31] is replaced
by INPUT[0], ... INPUT[31], and that BEARER[0] ... BEARER[4] is replaced by 0
\|\| 0 \|\| 0 \|\| 0 \|\| 0):
> We concatenate INPUT, INPUT, MESSAGE and DIRECTION. We then append a single
> \"1\" bit, followed by between 0 and 63 \"0\" bits so that the total length
> of the resulting string PS (padded string) is an integral multiple of 64
> bits, i.e.:
>
> PS = INPUT[0]...INPUT[31] INPUT[0]...INPUT[31]
> MESSAGE[0]...MESSAGE[LENGTH-1] DIRECTION[0] 1 0*
>
> Where 0* indicates between 0 and 63 \"0\" bits.
#### 6.3.4.3 GIA5
NOTE: This section is presented here only for demonstrative purposes, and
represents only one possible way of specifying the GIA5 algorithm. The actual
specification would need to be done in ETSI SAGE.
GIA5 is based on SNOW 3G and is identical to UIA2 as specified in TS 35.215
[5] with the following exceptions to the initialization of the algorithm
(differences being that COUNT-C[0], ... COUNT-C[31] is replaced by INPUT[0],
... INPUT[31], and that BEARER[0] ... BEARER[4] is replaced by 0 \|\| 0 \|\| 0
\|\| 0 \|\| 0):
> IV3 = INPUT[0] \|\| INPUT [1] \|\| INPUT [2] \|\| ... \|\| INPUT [31]
>
> IV2 = 0 \|\| 0 \|\| 0 \|\| 0 \|\| 0 \|\| DIRECTION[0] \|\| 0 \|\| ... \|\| 0
>
> IV1 = INPUT[0] \|\| INPUT [1] \|\| INPUT [2] \|\| ... \|\| INPUT [31]
>
> IV0 = 0 \|\| 0 \|\| 0 \|\| 0 \|\| 0 \|\| DIRECTION[0] \|\| 0 \|\| ... \|\| 0
## 6.4 Solution #4: Protection for CIoT enhanced GPRS Layer 3 - GMM messages
### 6.4.1 General
This solution addresses the key issue #3 - Unauthorized modification of
signalling data.
For Cellular IoT we should mimic the integrity protection mechanism defined in
LTE as much as possible.
The table below (Table 1) shows how encryption is applied to GMM messages in
GPRS, how integrity protection and encryption are applied to EMM messages in
LTE and how we could apply the same principles in LTE to GMM messages in
Cellular IoT. We can classify the analysis as follows:
\- CONDITIONAL INTEGRITY: In LTE, NAS messages are integrity protected if the
MME and/or LTE UE have a valid security context. In Cellular IoT, GMM messages
are integrity protected if the sending SGSN or sending CIOT UE have a valid
security context. For the receiving SGSN or receiving CIOT UE, the processing
of the received GMM message when the check of the MAC fails or when the
receiving part has no valid security context should follow exactly the
conditions specified for LTE in TS 24.301 [8].
NOTE: One can see that this is important from the following text in TS 24.301
section 4.4.4.3: \"Once the secure exchange of NAS messages has been
established for the NAS signalling connection, the receiving EMM or ESM entity
in the MME shall not process any NAS signalling messages unless they have been
successfully integrity checked by the NAS.\" This means that, in particular,
no UE-initiated DETACH request can be processed by the MME even when the UE is
in idle mode (as NAS security is considered established even when the UE is
idle). This prevents an important DoS attack.
\- CONDITIONAL ENCRYPTION: NAS messages are encrypted if secure exchange of
NAS messages (see TS 24.301 sub-clause 4.4.2.3) has been established in LTE.
GMM messages are encrypted in GPRS and Cellular IoT, if sending UE or sending
SGSN have a valid security context and encryption has been activated.
\- RESTRICTIONS INTEGRITY: In LTE, NAS messages that can be sent without
integrity protection but which require some further restrictions for their
usage. In Cellular IoT, GMM messages that can be sent without integrity
protection but which require some further restrictions for their usage.
\- P-TMSI signature: In GPRS, P-TMSI signature is used to provide some
protection for the Attach and Routing Area Update Requests. In Cellular IoT,
these messages are protected as CONDITIONAL INTEGRITY as in LTE; however,
P-TMSI signature can be used to provide some additional security in handover
if the integrity fails.
Table 6.4.1-1: Integrity protection and ciphering applied to EMM message in
LTE and GMM message in GPRS and Cellular IoT
+---------+---------+---------+---------+---------+---------+---------+ | EMM | Int | Int | P-TMSI | C | C | C | | message | egrity\ | egrity\ | si | onfiden | onfiden | onfiden | | in | pro | pro | gnature | tiality | tiality | tiality | | LTE/\ | tected\ | tected\ | in GPRS | pr | pr | pr | | GMM | in LTE | in | | otected | otected | otected | | message | | Ce | | in\ | in | in GPRS | | in GPRS | | llular\ | | LTE | C | | | and | | IoT | | | ellular | | | C | | | | | IoT | | | ellular | | | | | | | | IoT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | COND | YES | NO | NO | NO | | ATTACH | ITIONAL | ITIONAL | (op | | | | | REQU | IN | IN | tional) | | | | | EST/GMM | TEGRITY | TEGRITY | | | | | | ATTACH | | (o | | | | | | REQUEST | | ptional | | | | | | | | P-TMSI | | | | | | | | sig | | | | | | | | nature) | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | ATTACH | | | | | | | | ACCEPT/ | | | | | | | | GMM | | | | | | | | ATTACH | | | | | | | | ACCEPT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | ATTACH | | | | | | | | CO | | | | | | | | MPLETE/ | | | | | | | | GMM | | | | | | | | ATTACH | | | | | | | | C | | | | | | | | OMPLETE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | COND | N/A | COND | COND | NO | | ATTACH | ITIONAL | ITIONAL | | ITIONAL | ITIONAL | | | REJ | IN | IN | | ENC | ENC | | | ECT/GMM | TEGRITY | TEGRITY | | RYPTION | RYPTION | | | ATTACH | | | | | | | | REJECT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | COND | YES | NO | NO | NO | | T | ITIONAL | ITIONAL | (op | | | | | RACKING | IN | IN | tional) | | | | | AREA | TEGRITY | TEGRITY | | | | | | UPDATE | | (o | | | | | | RE | | ptional | | | | | | QUEST/\ | | P-TMSI | | | | | | GMM | | sig | | | | | | ROUTING | | nature) | | | | | | AREA | | | | | | | | UPDATE\ | | | | | | | | REQUEST | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | T | | | | | | | | RACKING | | | | | | | | AREA | | | | | | | | UPDATE | | | | | | | | A | | | | | | | | CCEPT/\ | | | | | | | | GMM | | | | | | | | ROUTING | | | | | | | | AREA | | | | | | | | UPDATE\ | | | | | | | | ACCEPT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | T | | | | | | | | RACKING | | | | | | | | AREA | | | | | | | | UPDATE | | | | | | | | COM | | | | | | | | PLETE/\ | | | | | | | | GMM | | | | | | | | ROUTING | | | | | | | | AREA | | | | | | | | UPDATE | | | | | | | | C | | | | | | | | OMPLETE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | COND | N/A | COND | COND | NO | | T | ITIONAL | ITIONAL | | ITIONAL | ITIONAL | | | RACKING | IN | IN | | ENC | ENC | | | AREA | TEGRITY | TEGRITY | | RYPTION | RYPTION | | | UPDATE | | | | | | | | R | | | | | | | | EJECT/\ | | | | | | | | GMM | | | | | | | | ROUTING | | | | | | | | AREA | | | | | | | | UPDATE | | | | | | | | REJECT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | RESTR | RESTR | N/A | COND | COND | NO | | I | ICTIONS | ICTIONS | | ITIONAL | ITIONAL | | | DENTITY | IN | IN | | ENC | ENC | | | REQU | TEGRITY | TEGRITY | | RYPTION | RYPTION | | | EST/GMM | (only | (only | | | | | | I | IMSI | IMSI | | | | | | DENTITY | can be | can be | | | | | | REQUEST | re | re | | | | | | | quested | quested | | | | | | | without | without | | | | | | | in | in | | | | | | | tegrity | tegrity | | | | | | | pro | pro | | | | | | | tection | tection | | | | | | | if | if | | | | | | | network | network | | | | | | | does | does | | | | | | | not | not | | | | | | | have a | have a | | | | | | | valid | valid | | | | | | | s | s | | | | | | | ecurity | ecurity | | | | | | | c | c | | | | | | | ontext) | ontext) | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | RESTR | RESTR | N/A | RESTR | RESTR | NO | | I | ICTIONS | ICTIONS | | ICTIONS | ICTIONS | | | DENTITY | IN | IN | | ENC | ENC | | | RE | TEGRITY | TEGRITY | | RYPTION | RYPTION | | | SPONSE/ | (only | (only | | | | | | GMM | IMSI | IMSI | | (only | (only | | | I | can be | can be | | IMSI | IMSI | | | DENTITY | sent | sent | | can be | can be | | | R | without | without | | sent | sent | | | ESPONSE | in | in | | without | without | | | | tegrity | tegrity | | c | c | | | | pro | pro | | onfiden | onfiden | | | | tection | tection | | tiality | tiality | | | | if UE | if UE | | pro | pro | | | | does | does | | tection | tection | | | | not | not | | if UE | if UE | | | | have a | have a | | does | does | | | | valid | valid | | not | not | | | | s | s | | have a | have a | | | | ecurity | ecurity | | valid | valid | | | | c | c | | s | s | | | | ontext) | ontext) | | ecurity | ecurity | | | | | | | c | c | | | | | | | ontext) | ontext) | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | AUTHENT | ITIONAL | | | ITIONAL | | | | ICATION | IN | | | ENC | | | | REQUEST | TEGRITY | | | RYPTION | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | AUTHENT | ITIONAL | | | ITIONAL | | | | ICATION | IN | | | ENC | | | | R | TEGRITY | | | RYPTION | | | | ESPONSE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | AUTHENT | ITIONAL | | | ITIONAL | | | | ICATION | IN | | | ENC | | | | FAILURE | TEGRITY | | | RYPTION | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | AUTHENT | ITIONAL | | | ITIONAL | | | | ICATION | IN | | | ENC | | | | REJECT | TEGRITY | | | RYPTION | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | NO | N/A | N/A | | S | (with | | | | | | | ECURITY | new EPS | | | | | | | MODE | s | | | | | | | COMMAND | ecurity | | | | | | | | c | | | | | | | | ontext) | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | YES | N/A | N/A | | S | | | | | | | | ECURITY | | | | | | | | MODE | | | | | | | | C | | | | | | | | OMPLETE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | S | ITIONAL | | | ITIONAL | | | | ECURITY | IN | | | ENC | | | | MODE | TEGRITY | | | RYPTION | | | | REJECT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | GMM | N/A | YES | N/A | N/A | NO | NO | | AUTHENT | | (with | | | | | | ICATION | | new | | | | | | AND | | s | | | | | | CI | | ecurity | | | | | | PHERING | | c | | | | | | REQUEST | | ontext) | | | | | +---------+---------+---------+---------+---------+---------+---------+ | GMM | N/A | YES | N/A | N/A | NO | NO | | AUTHENT | | (with | | | | | | ICATION | | new | | | | | | AND | | s | | | | | | CI | | ecurity | | | | | | PHERING | | c | | | | | | R | | ontext) | | | | | | ESPONSE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | GMM | N/A | COND | N/A | N/A | NO | NO | | AUTHENT | | ITIONAL | | | | | | ICATION | | IN | | | | | | AND | | TEGRITY | | | | | | CI | | | | | | | | PHERING | | | | | | | | FAILURE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | GMM | N/A | COND | N/A | N/A | COND | NO | | AUTHENT | | ITIONAL | | | ITIONAL | | | ICATION | | IN | | | ENC | | | AND | | TEGRITY | | | RYPTION | | | CI | | | | | | | | PHERING | | | | | | | | REJECT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | NO | N/A | N/A | | SERVICE | | | | | | | | REQUEST | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | N/A | N/A | COND | N/A | N/A | | SERVICE | ITIONAL | | | ITIONAL | | | | REJECT | IN | | | ENC | | | | | TEGRITY | | | RYPTION | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM CS | YES | N/A | N/A | YES | N/A | N/A | | SERVICE | | | | | | | | NOTIF | | | | | | | | ICATION | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM UE | COND | COND | N/A | COND | COND | COND | | in | ITIONAL | ITIONAL | | ITIONAL | ITIONAL | ITIONAL | | itiated | IN | IN | | ENC | ENC | ENC | | DETACH | TEGRITY | TEGRITY | | RYPTION | RYPTION | RYPTION | | R | | | | | | | | EQUEST/ | | | | | | | | GMM UE | | | | | | | | in | | | | | | | | itiated | | | | | | | | DETACH | | | | | | | | REQUEST | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | COND | COND | N/A | COND | COND | COND | | Network | ITIONAL | ITIONAL | | ITIONAL | ITIONAL | ITIONAL | | in | IN | IN | | ENC | ENC | ENC | | itiated | TEGRITY | TEGRITY | | RYPTION | RYPTION | RYPTION | | DETACH | | | | | | | | ACCEPT\ | | | | | | | | (for | | | | | | | | non | | | | | | | | -switch | | | | | | | | off)/ | | | | | | | | GMM | | | | | | | | Network | | | | | | | | in | | | | | | | | itiated | | | | | | | | DETACH | | | | | | | | ACCEPT\ | | | | | | | | (for | | | | | | | | non | | | | | | | | -switch | | | | | | | | off) | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | Network | | | | | | | | in | | | | | | | | itiated | | | | | | | | DETACH | | | | | | | | R | | | | | | | | EQUEST/ | | | | | | | | GMM | | | | | | | | Network | | | | | | | | in | | | | | | | | itiated | | | | | | | | DETACH | | | | | | | | REQUEST | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM UE | COND | COND | N/A | COND | COND | COND | | in | ITIONAL | ITIONAL | | ITIONAL | ITIONAL | ITIONAL | | itiated | IN | IN | | ENC | ENC | ENC | | DETACH | TEGRITY | TEGRITY | | RYPTION | RYPTION | RYPTION | | ACCEPT/ | | | | | | | | GMM UE | | | | | | | | in | | | | | | | | itiated | | | | | | | | DETACH | | | | | | | | ACCEPT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | YES | N/A | N/A | | D | | | | | | | | OWNLINK | | | | | | | | NAS | | | | | | | | TR | | | | | | | | ANSPORT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | INFOR | | | | | | | | MATION/ | | | | | | | | GMM | | | | | | | | INFO | | | | | | | | RMATION | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | STA | | | | | | | | TUS/GMM | | | | | | | | STATUS | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | NO (if | N/A | N/A | | E | | | | used as | | | | XTENDED | | | | initial | | | | SERVICE | | | | NAS | | | | REQUEST | | | | m | | | | | | | | essage) | | | | | | | | | | | | | | | | YES (if | | | | | | | | used | | | | | | | | when | | | | | | | | con | | | | | | | | nection | | | | | | | | already | | | | | | | | exists | | | | | | | | i.e. in | | | | | | | | EMM-CO | | | | | | | | NNECTED | | | | | | | | state) | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | GUTI | | | | | | | | REALL | | | | | | | | OCATION | | | | | | | | CO | | | | | | | | MMAND/\ | | | | | | | | GMM | | | | | | | | P-TMSI | | | | | | | | REALL | | | | | | | | OCATION | | | | | | | | COMMAND | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | YES | N/A | YES | YES | YES | | GUTI | | | | | | | | REALL | | | | | | | | OCATION | | | | | | | | COM | | | | | | | | PLETE/\ | | | | | | | | GMM | | | | | | | | P-TMSI | | | | | | | | REALL | | | | | | | | OCATION | | | | | | | | C | | | | | | | | OMPLETE | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | YES | N/A | N/A | | UPLINK | | | | | | | | NAS | | | | | | | | TR | | | | | | | | ANSPORT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | YES | N/A | N/A | | D | | | | | | | | OWNLINK | | | | | | | | GENERIC | | | | | | | | NAS | | | | | | | | TR | | | | | | | | ANSPORT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+ | EMM | YES | N/A | N/A | YES | N/A | N/A | | UPLINK | | | | | | | | GENERIC | | | | | | | | NAS | | | | | | | | TR | | | | | | | | ANSPORT | | | | | | | +---------+---------+---------+---------+---------+---------+---------+
## 6.5 Solution #5: Activating integrity protection for user data in bearer
layer
### 6.5.1 General
This solution is used to activate integrity protection for user data in bearer
layer. User data integrity is an optional-to-use feature. Enhanced SGSN
decides whether integrity protection of use plane is needed or not based on
UE's subscriber data.
### 6.5.2 Solution
The principle is that an indication of activating integrity protection for
user data is stored as part of subscriber data in HLR/HSS. The indication is
an optional flag in subscriber data.
The SGSN gets the subscription data during Insert Subscriber Data procedure.
After receiving the subscriber data, and based on other policies, the eSGSN
knows whether this UE needs integrity protection of user data.
The eSGSN may not have subscriber data when performing the authentication and
ciphering procedure. So the eSGSN can not send the indication of activating
integrity protection of user data in authentication and ciphering procedure.
The indication of activating integrity protection of user data can only be
carried in messages which are sent after the eSGSN gets the subscriber data,
e.g., Attach Accept message, RAU accept message, etc.
## 6.6 Solution #6: Authenticated encryption
### 6.6.1 General
Authenticated encryption schemes are usually more efficient than the
conventional schemes where encryption and MAC computation are separately
carried out. This has been demonstrated in [14] that even an authenticated
encryption scheme with the heaviest computation overhead like CWC [15] is
faster than the conventional scheme where AES-CBC is used for encryption, and
HMAC-SHA1 is used for data integrity respectively. The software performance is
shown in the following table [14]:
Table1 Software performance in megabits per second on 1 GHz processer
* * *
Message size (Bytes) 16 20 40 44 64 128 256 552 576 1024 1500 CWC 45.7 51.9
73.4 75.5 88.1 104 116 127 126 131 124 CBC-HMAC 6.3 8 15.2 16.6 23.4 39 64.5
96 97 117 129
* * *
Moreover, an efficient authenticated encryption scheme is merely 6.5% slower
than the privacy-only mode CBC [16]. This means that we can achieve both
confidentiality and data integrity with a comparable computation cost of
encryption, if an efficient authenticated encryption scheme is employed.
### 6.6.2 Conclusion
Despite performance benefits regarding processor load, there are situations in
which confidentiality or integrity protection are required separately. Thus
AEAD may not always be applicable. No performance benefits regarding message
lengths are seen.
## 6.7 Solution #7: GIA with INPUT-I and CONSTANT-F
### 6.7.1 General
The LLC protocol specific input values for the new GIA algorithms are
currently under study in SA3 and ETSI SAGE. For example, it has been proposed
that the GIA would use the encryption specific modulo counter INPUT, a new
integrity specific counter COUNT-I, and new algorithm specific CONSTANT(s) as
input parameters. This is a new partial solution showing an option of
specifying a new integrity specific counter INPUT-I and a frame specific
constant CONSTANT-F.
### 6.7.1 Integrity algorithm
#### 6.7.1.1 Inputs and outputs
The input parameters to the integrity algorithm are a 128-bit integrity key
named Ki128, a 32-bit INPUT-I, the 1-bit direction of the transmission i.e.
DIRECTION, and the message itself i.e MESSAGE. The DIRECTION bit is 0 for
uplink and 1 for downlink.
Figure 6.7.1.1-1 illustrates the use of the integrity algorithm GIA to
authenticate the integrity of messages.
Figure 6.7.1.1-1: Derivation of MAC/XMAC
Based on these input parameters the sender computes a 32-bit message
authentication code (MAC) using the integrity algorithm GIA. The message
authentication code is then appended to the message when sent. For integrity
protection algorithms the receiver computes the expected message
authentication code (XMAC) on the message received in the same way as the
sender computed its message authentication code on the message sent and
verifies the data integrity of the message by comparing it to the received
message authentication code, i.e. MAC.
#### 6.7.1.2 INPUT-I
The Input-I parameter is generated according to the following algorithm if the
frame is a UI frame:
Input-I = ( ( i-IOV‑UI ⊗ SX ) + LFN + OC ) modulo 2^32^
The Input-I parameter is generated according to the following algorithm if the
frame is an I frame:
Input-I = ( i-IOV‑I + LFN + OC ) modulo 2^32^
where:
\- i-IOV‑UI is a 32 bit random value generated by SGSN.
\- i-IOV‑I is a 32 bit random value generated by SGSN.
All other values of Input-I (i.e. SX, LFN, OC) are as specified for Input
(ciphering), see TS 44.064 Annex A.
#### 6.7.1.3 CONSTANT-F
The Constant-F parameter is a frame-dependent static sting.
If the frame is an UI frame, the Constant-F is the concatenation of two static
strings:
Constant-F = \"UI-frame GIA\" \|\| n
> where the n is the number of the GIA algorithm that is in use (i.e. n=\"4\"
> for GIA4, and n=\"5\" for GIA5)
If the frame is an I frame, the Constant-F is the concatenation of two static
strings:
Constant-F = \"I-frame GIA\" \|\| n
> where the n is the number of the GIA algorithm that is in use (i.e. n=\"4\"
> for GIA4, and n=\"5\" for GIA5)
## 6.8 Solution #8: Implementation of integrity protection in LLC protocol
### 6.8.1 General
This solution addresses key issue on both control plane and user plane
integrity, and proposes a way to implement the integrity protection at LLC
protocol.
NOTE: This solution explores the implementation options of the integrity
protection. How integrity protection is implemented is up to stage 3 to
decide.
### 6.8.2 Integrity protection bit, integrity mode bit and MAC
This solution assumes that once the integrity protection has been turned on,
there is an integrity protection indication bit in the control field of the
LLC message that allows the receiving entity to know that the message does not
include a 3 octet long FCS field but instead a 4 octet long MAC. The
indication bit is also discussed in solution #1 section 6.1.7.
It is proposed to follow the same principle as in the EPS NAS security where
the ciphering of the information field is performed first, and the MAC is
calculated over the cleartext address and control fields, and the ciphered
information field. Figure 6.8.2-1 demonstrates a possible implementation.
{width="6.83125in" height="2.4069444444444446in"}
Figure 6.8.2-1: LLC message format when integrity protection is used
In order to achieve similar functionality that is currently achieved by the
\"unprotected mode\" (where messages with erroneous FCS fields are delivered
to the upper layer), the control field of UI frame is enhanced by a new
Integrity Mode (IM) bit. The control field bits also include the Integrity
protection (I) bit if integrity protection is in use, and FCS field is
replaced by MAC. Figure 6.8.2-2 demonstrates a potential implementation of
these new bits.
Figure 6.8.2-2: New control bits related to integrity protection
**Integrity protection bit (I)**
If integrity protection is in use, the integrity protection bit (I) indicates
that the three octets long FCS field has been replaced by four octets long
MAC.
The I bit is set to 1 to indicate the presence of four octets long MAC. FCS
field is not present.
The I bit value 0 is not specified.
**Integrity Mode bit (IM)**
If integrity protection is in use, the integrity mode bit (IM) indicates the
behaviour of the LLC layer at the receiving side if the MAC verification
fails. The IM bit replaces PM bit in legacy UI frame content.
The IM bit is set to 1 to indicate that in the case of MAC verification fails,
the message is discarded, and not delivered to the upper layer.
NOTE: It is possible that this one message type (when I_bit = 1 and IM_bit =
1) includes both the FCS field and MAC. From security point of view, however,
this is not required. The functionality that would be achieved by including
both fields would be that messages that may include bit errors are still
discarded. However, protecting the FCS field with the integrity key would not
provide enhanced security because the assumption in this special case is that
the verification of the MAC will fail. The FCS field can be modified by third
parties.
The IM bit is set to 0 to indicate that in the case of MAC verification fails,
the message is not discarded but delivered to the upper layer. LLC layer
indicates the upper layer that the integrity protection failed.
Table 6.8.2-1 demonstrates how the new IM bit and the existing encryption (E)
are related to each other.
* * *
IM E UI frame information field 0 0 message with failed MAC delivered, non-
ciphered information 0 1 message with failed MAC delivered, ciphered
information 1 0 message with failed MAC discarded, non-ciphered information 1
1 message with failed MAC discarded, ciphered information
* * *
Table 6.8.2-1: UI frame information field
Layer 3 -- LLC primitives are used by the Layer 3 to request the LLC protocol
for transmission of L3-PDU. These primitives should be enhanced to include
indications if the message needs to be integrity protected or not. If the
request is about unconfirmed transmission, also the integrity mode needs to be
indicated.
Layer 3 -- LLC primitives are also used by the LLC protocol to notify the
layer 3 on activities related to the requests. These primitives should be
enhanced to notify the layer 3 if the integrity protection is available to the
SAPI in case integrity protection was requested. The use of integrity
protection for other SAPIs than GMM function is a local decision of the SGSN,
and may not be available to all layer 3 protocols.
Layer 3 -- LLC primitives are also used by the LLC protocol to deliver the
received L3‑PDU to layer 3. These primitives should be enhanced to include
indications if the message was integrity protected or not. If the L3-PDU is
received as an unconfirmed transmission using the integrity mode that allows
the delivery of a message with a failed MAC, the indication needs to tell if
the verification of the MAC failed or was successful.
\"LLGMM\" Layer 3 -- LLC primitives are used specifically for the SAPI between
the LLC layer and the GMM function. These primitives need to be enhanced to
allow GMM function to authorize the use of integrity protection for other
Layer 3 protocols, e.g. for the user plane. This is because the availability
of integrity protection for other SAPIs than the GMM function is a local
decision of the SGSN.
# 7 Evaluation
## 7.1 Authentication and key agreement
Editor's note: This clause will be updated to reflect decisions taken for
Annex C of this document.
In the scope of study on EC-GSM, the frequency of authentication may be very
different from the existing 3GPP systems. Then, the time between
authentications could be considerably extended, while session keys to protect
user plane and control plane should be short-lived session keys.
Solution#2 is the only candidate solution that enables the CIoT session keys
Ktc and Kti to have short lifetimes thanks to an interim key K~med~ stored
similarly to the subscription key K within the USIM. The other solutions rely
on CIoT session keys Ktc and Kti, whose lifetimes can be very long since the
authentication frequency can be very low.
# 8 Conclusions
The conclusions are documented in Annex C.
###### ### Annex A: Solution #A: Early solution for EASE
# A.1 General
It may take some time until SGSNs that implement the functionality required by
solution#1 in clause 6.1 of TR 33.860 have been widely deployed. On the other
hand, Cellular IoT use cases that are deployed today or will be deployed in
the near term could benefit from a few simple measures that would
significantly enhance the security level of present GPRS deployments. The
present solution proposes such simple enhancements.
These simple enhancements prevent the currently published attacks related to
impersonation, eavesdropping, and bidding down by a false base station. But
the present solution does not attain the same security level as solution#1.
The known remaining vulnerabilities are addressed below. The seriousness of
these vulnerabilities also depends on the use case.
**The present solution is not intended to be the only security solution for
CIoT. It is rather meant to give guidance for use CIoT cases using GPRS that
are currently deployed or need to be deployed soon.**
The key technical element of the present solution is the enforcement of strong
security requirements by the UE: by a policy hard-coded into the CIoT UE, the
UE enforces the use of UMTS AKA and rejects any authentication request for 2G
AKA and any connection that is offered with NULL encryption or weak
encryption. The security between the UE and the SGSN otherwise remains as
specified today, i.e. both signalling and user plane are encrypted, but not
integrity-protected. In particular, no changes to SGSN specifications are
required.
The rigidity of the security policy hard-coded into the CIoT UE comes with the
following restriction:
\- Roaming into networks that offer only NULL encryption or weak encryption is
not possible.
This implies that, in particular, global roaming is not possible as some
countries do not allow encryption. Global roaming is a requirement for the
general CIoT case, as stated by GERAN. This further implies that the present
solution cannot serve as the only security solution for CIoT. It should be
noted, though, that many CIoT use cases assume stationary UEs or limited
roaming.
# A.2 Control Plane (Gb mode)
The security for the control plane in Gb mode remains as specified today, i.e.
encryption is applied, but not integrity. Regarding encryption algorithms:
GEA0, GEA1, GEA2 and GEA3 are forbidden for the present solution.
# A.3 Authentication
The UE rejects any communication with any SGSN that does not offer UMTS AKA,
i.e. the UE rejects, in particular, communication with any pre-Rel-99 SGSN.
SGSNs from later releases do support UMTS AKA.
# A.4 Protection of algorithm negotiation
Algorithm negotiation is protected from bidding down by the security policy
hard-coded into the UE: the UE will simply reject any Ciphering Mode command
offering encryption algorithms that do not comply with its policy.
# A.5 Interworking with legacy GPRS
SGSNs that support the encryption algorithms required by the CIoT UE can serve
both CIoT UEs and legacy UEs without any problem.
Editor's Note: how do you ensure co-existence of the solution in the present
clause with long-term solution, e.g. solution#1?
# A.6 Security considerations
Editor's Note: attacks where UICC is moved between MEs need further study.
(Risk of downgrade, USIM-ME binding may help.)
The present solution prevents the currently published attacks related to
impersonation, eavesdropping, and bidding down by a false base station, which
constitute the biggest security threats in today's 2G networks, in the
following way:
**\- Impersonation** : The known attacks require breaking the encryption key,
which is possible by attacks on access security only when the encryption
algorithm is 'weak'. (Attacks on the core network, e.g. on SS7, for finding
the key are possible, but out of scope of the present TR.)
**\- Eavesdropping** : This can be achieved by breaking the key of a weak
encryption algorithm or by bidding down to the NULL algorithms, or a
combination of bidding down and breaking the key. None is possible with the
solution proposed here.
**\- Bidding down** : This is not possible for the proposed solution as the
security policy in the UE enforces that no weak encryption algorithms are
accepted.
**Residual vulnerabilities:**
_Basis for attacks:\_ Attacks against the present solution could be based on
the fact that certain signalling messages can be sent unciphered (cf. 24.008,
4.7.1.2).
Other attacks could be based on the fact that a skilled attacker may be able
to modify signalling messages even when they are ciphered, without the
receiver noticing. Considerable skill seems required on the radio part, while
the cryptographic part seems straightforward. It is not clear how practical
such an attack would be; no corresponding publications are currently known.
_Background_ : When a message is encrypted with a stream cipher (even a strong
one) and an attacker knows (part of) the plaintext and the position of this
known plaintext in the bit stream, and the attacker has sufficient radio
skills, then the attacker can achieve a modification of the deciphered text,
as seen by the receiver, in a targeted way by toggling specific bits in the
ciphered bit stream and correspondingly adapt the checksum (if it is linear),
without having to break the stream cipher. The GPRS encryption mechanism uses
a stream cipher and a linear checksum (CRC in the LLC layer, cf. TS 44.064,
5.5).
_Potential Denial-of-Service attacks_ :\ The attacker may be able to modify
cause values in signalling messages so that the UE is e.g. forbidden to attach
to the PLMN. This effect would last until the next time the UE would be
switched off and on again (or the SIM would be removed). It is obvious that
this would constitute a problem in particular for CIoT UEs as they are not
attended by humans. A possible remedy for UEs that are stationary or roaming
in a limited number of PLMNs would be for the UE to ignore such cause values
that are obviously faked. UEs in general could at least try to re-attach after
some time.
The attacker may also be able to modify signalling messages so that the UE
becomes unreachable. This effect would last until the next time the UE would
initiate a session. So, use cases where UEs may be assumed to always initiate
a session to report data (e.g. sensors or meters) may be less vulnerable to
this attack.
_How much does signalling integrity help?\_ It should also be noted that it is
open whether the introduction of signalling integrity in GPRS according to
solution#1 could completely protect from the above Denial of Service attacks.
The answer to this question depends on a detailed analysis of which signalling
message can be integrity-protected, and even on how the state machines in the
SGSN would handle integrity failures (cf. paging attack, 2013 [ref tba]). This
analysis is currently not available. Note further that even in UMTS, where
signalling integrity is provided, certain signalling messages that may be used
to cause DoS may be processed by the recipient even if sent unprotected (cf.
TS 24.008, 4.1.1.1.1).
###### ### Annex B: Analysis of data efficient rekeying
# B.1 Battery life cost of existing AKA
## B.1.1 Assumptions on power budget and power consumption
TR 45.820 [2] gives the following summary of the power consumed under various
transmit and receive circumstances:
Table 7.3.6.4-1/3GPP TR 45.820: Power consumption assumptions for NB-CIoT
energy consumption analysis
* * *
Operating mode Power (mW) Notes
Transmit\ Integrated PA 500 +23 dBm with 45% PA efficiency for class B
(including Tx/Rx switch insertion loss) plus 60 mW for other circuitry. (+23
dBm)
                   External PA              460          +23 dBm with 50% PA efficiency for class B (including Tx/Rx switch insertion loss) plus 60 mW for other circuitry.
Receive Synchronization (PSCH) 80 Accounts for more complex digital processing
during synchronization, using FFT based cross-correlation for PSS detection.
                   Normal\                  70           Includes FFT based OFDM demodulation, based on sampling rate of 240 kHz.
                   (PBCH, PDCCH, PDSCH)
Sleep 3 Corresponds to maintaining accurate timing by keeping RF frequency
reference active.
Standby 0.015 Common assumption.
* * *
We may therefore assume that reception of a downlink key agreement message
such as an Authentication Request consumes 70mW, while transmission of an
uplink key agreement message such as an Authentication Response consumes
460mW.
TR 45.820 [2](clause 4.1.4) also states the following target: \"The power
consumption of MTC devices compared with legacy GPRS (non EGPRS) should be
reduced so that they can have up to ten years battery life with battery
capacity of 5 Wh (Watt-hours), even in locations with adverse coverage
conditions, where up to 20 dB coverage extension over legacy GPRS might be
needed.\" We may therefore take 5 Watt hours as the lifetime battery capacity.
TR 45.820[2] (clause 4.1.1) states a minimum target date rate of 160 bit per
second. It is reasonable to assume this also as the minimum data transmission
rate for signalling messages on the radio interface.
## B.1.2 Analysis of existing AKA
The Authentication Request and Authentication Response messages in GPRS are as
follows (taken from TS 24.008[17]):
Table B.1.2.1: AUTHENTICATION REQUEST message content
* * *
IEI Information element Type/Reference Presence Format Length Mobility
management Protocol discriminator M V 1/2 protocol discriminator 10.2  
Skip Indicator Skip Indicator M V 1/2 10.3.1  
Authentication Request Message type M V 1 message type 10.4  
Ciphering key sequence Ciphering key sequence M V 1/2 number number  
10.5.1.2  
Spare half octet Spare half octet M V 1/2 10.5.1.8  
Authentication Auth. parameter RAND M V 16 parameter RAND (UMTS challenge or
GSM challenge) 10.5.3.1  
20 Authentication Auth. parameter AUTN O TLV 18 Parameter AUTN 10.5.3.1.1
* * *
Total length: 37 octets. AUTN is always included in a 3G AKA request.
Table B.1.2.2: AUTHENTICATION RESPONSE message content
* * *
IEI Information element Type/Reference Presence Format Length Mobility
management Protocol discriminator M V 1/2 protocol discriminator 10.2  
Skip Indicator Skip Indicator M V 1/2 10.3.1  
Authentication Response Message type M V 1 message type 10.4  
Authentication Response Auth. Response parameter M V 4 parameter 10.5.3.2  
21 Authentication Response Auth. Response parameter O TLV 3-14 Parameter
(extension) 10.5.3.2.1
* * *
Total length: 6-20 octets depending on the length of RES (in particular 6
octets for a 32-bit RES, 12 octets for a 64-bit RES)
If we assume the minimal CIoT data transmission rate of 160 bps, and that keys
are refreshed every day, then we can calculate the impact on the battery as
follows:
Table B.1.2.3: Battery impact
* * *
                              Octets   Bits/sec   Seconds   mW    Joules   Every x days   Joules in 10 years   Percentage of 5Wh
Auth request 37 160 1.85 70 0.1295 1 473.00 2.63%
Auth response, 32-bit RES 6 160 0.3 460 0.138 1 504.04 2.80%
Auth response, 64-bit RES 12 160 0.6 460 0.276 1 1008.09 5.60%
Total from request and 5.43% response with 32-bit RES
* * *
This is a significant but not overwhelming impact on battery life.
If instead keys are refreshed once a week, then we can calculate the impact on
the battery as follows:
Table B.1.2.3: Battery impact
* * *
                              Octets   Bits/sec   Seconds   mW    Joules   Every x days   Joules in 10 years   Percentage of 5Wh
Auth request 37 160 1.85 70 0.1295 7 67.57 0.38%
Auth response, 32-bit RES 6 160 0.3 460 0.138 7 72.01 0.40%
Auth response, 64-bit RES 12 160 0.6 460 0.276 7 144.01 0.80%
Total from request and 0.78% response with 32-bit RES
* * *
Here the impact on battery life is small, at the cost of have longer lived
session keys with consequently increased risk of session key leakage. (This
risk is hard to quantify, though.)
If the data rate for message transmission is higher than 160bps, then the time
taken to transmit each message is proportionately lower, and the power
consumption is also lower in approximately the same proportion.
# B.2 Possible details of a data efficient rekeying approach
In the \"old fashioned\" cellular security architecture, there's a subscriber
key K that typically never changes for the lifetime of a subscription, and
from it are derived session keys used for radio interface security. With Data
Efficient Rekeying, an intermediate key K~med~ is introduced: K~med~ is
derived from K, and session keys are derived from K~med~. The lifetime of
K~med~ is limited, but much longer than the lifetime of a session key.
## B.2.1 Use of key sequence numbers
The ciphering key sequence number in GPRS is a label assigned to each session
key (Kc). It allows the SGSN and UE to continue to use a previously generated
Kc, referring to that Kc by its label, and confirming (with a modest risk of
error under certain circumstances) that they still have the same key in
common.
In the data efficient rekeying solution, key sequence numbers can be used in a
similar way, but with sequence numbers for both K~med~ and the session key
sets. A suggested approach is as follows:
\- In the SGSN-to-UE message used for authentication and K~med~ generation,
the SGSN includes a four-bit K~med~ sequence number. Values between 1 and 15
decimal will be used for the K~med~ Sequence Number (i.e. any four-bit value
except for 0000).
\- As soon as it receives and validates an incoming authentication and K~med~
generation message, the USIM generates a first set of session keys (Ktc, Kti)
from K~med~. To do this, a 16-bit KDctr is used as input. The most significant
12 bits for this first session key generation will always be all zeroes. The
least significant 4 bits of KDctr will also be used as the Session Key
Sequence Number (SKSN). These 4 bits are selected by the USIM, to be different
from the most recently used SKSN, and not using the value 0000 (binary). In
general, a recommended way for the USIM to select the new SKSN value is as
follows (interpreting SKSNs as decimals): if old SKSN = 15 then new SKSN = 1,
otherwise new SKSN = old SKSN + 1 mod 16. This will minimise the likelihood
that a UE and SGSN have the same SKSN in common when in fact the session keys
are different (e.g. because the UE moved off this SGSN and then returned to it
later, having updated session keys in the meantime; or just because some
session key generation request messages were missed).
\- In the authentication and K~med~ generation response message, along with
RES, the UE includes the 4-bit SKSN value that is associated with the first
set of session keys that was generated from the new K~med~, as described
above. This 4-bit value can be encoded in the Skip Indicator \-- see section
B.2.2. To be clear, in this case the Session Key Sequence Number is being
selected by the USIM and sent on the uplink to the SGSN (unlike in regular
GPRS where the CKSN is sent on the downlink).
\- Every subsequent session key generation request message from the SGSN to
the UE will include both the K~med~ sequence number (for the current K~med~)
and the Session Key Sequence Number (for the session keyset to be newly
created as a result of this request). The K~med~ Sequence Number can be
encoded in the Skip Indicator -- see section B.2.3. The SKSN also forms part
of the 16-bit counter KDctr -- see clause B.2.3.
## B.2.2 Derivation of K~med~ from K
The message exchange used to derived K~med~ from K is very similar to the
existing authentication request and response. The differences are that:
\- Different message type codes should be defined, taking the place of the
\"Authentication request message type\" and \"Authentication response message
type\" fields in the request and response messages respectively. These can
still each be one octet in length.
\- In place of the 4-bit Ciphering Key Sequence Number will be the 4-bit
K~med~ Sequence Number -- see section B.2.1.
\- Within the response message, the UE encodes a 4-bit SKSN in the 4-bit Skip
Indicator. This SKSN is for the first session key set that it has generated
from the new K~med~ -- see section B.2.1.
Thus the length of the messages involved in authentication and K~med~
agreement, in a Data Efficient Rekeying solution, can be the same as the
length of the messages involved in a regular AKA exchange. The messages are
shown in tables B.2.2.1 and B.2.2.2.
Table B.2.2.1: AUTHENTICATION AND K~med~ GENERATION REQUEST message content
* * *
Information element Type/Reference Presence Format Length Mobility management
Protocol discriminator M V 1/2 protocol discriminator  
Skip Indicator Skip Indicator M V 1/2
Authentication Request Message type M V 1 message type  
K~med~ Sequence Number K~med~ Sequence Number M V 1/2
Spare half octet Spare half octet M V 1/2
Authentication Auth. parameter RAND M V 16 parameter RAND (UMTS challenge or
GSM challenge)  
Authentication Auth. parameter AUTN O TLV 18 Parameter AUTN
* * *
Total length: 37 octets. AUTN is always included in a 3G AKA request.
Table B.2.2.1: AUTHENTICATION AND K~med~ GENERATION RESPONSE message content
* * *
Information element Type/Reference Presence Format Length Mobility management
Protocol discriminator M V 1/2 protocol discriminator  
Skip Indicator, equal to SKSN for Skip Indicator M V 1/2 new session key set  
Authentication Response Message type M V 1 message type  
Authentication Response Auth. Response parameter M V 4 parameter  
Session Key Generation Session key generation M V 1 Authentication Expectation
(NEW) Expectation parameter  
Authentication Response Auth. Response parameter O TLV 3-14 Parameter
(extension)
* * *
Total length: 6-20 octets depending on the length of RES (in particular 6
octets for a 32-bit RES, 12 octets for a 64-bit RES)
Because the first SKSN is chosen to be non-zero (see section B.2.1), the Skip
Indicator will not have the value 0000 in the response message, for
compatibility with the existing use of the Skip Indicator -- see TS 24.008
section 10.3.1.
The Session Key Generation Authentication Expectation field is used by the
USIM to tell the SGSN two things:
\- Six bits of the octet are used to tell the SGSN how often the USIM requires
Session Key Generation. 0 means never, 1 means every time, and any other
integer value n between 2 and 63 means that every n^th^ message needs to be
integrity protected. In more detail: the USIM maintains a counter, which is
set to zero every time either a valid Authentication and K~med~ Generation
Request or a valid integrity protected Session Key Derivation Request message
is received, and incremented by one every time an unauthenticated Session Key
Derivation Request message is received; if incrementing the counter for a
newly received, unauthenticated Session Key Derivation Request message makes
the counter value equal to (or greater than) the Session Key Generation
Authentication Frequency, then it does not obey the received message. Instead,
an uplink message is returned, called a Session Key Update Request -- see
section B.2.3.
\- The other two bits of the octet are used to tell the SGSN what length of
Message Authentication Code it expects for an authenticated Session Key
Derivation Request message. 00 means 32 bits, 01 means 64 bits, 10 means 96
bits and 11 means 128 bits. If the value of the six-bit part of the field is 0
then the UICC sets these two bits to 00, and the SGSN ignores them.
## B.2.3 Derivation of session keys from K~med~
When a new set of session keys (Ktc, Kti) is to be derived from K~med~, the
SGSN will send a Session Key Derivation Request message to the UE. This will
be a newly defined message, comparable to (but much shorter than) an
Authentication Request message. A proposed structure for the Session Key
Derivation Request message is shown in Table B.2.3.1.
Table B.2.3.1: Possible structure of session key derivation request (non-EPS)
* * *
IEI Information element Type/Reference Presence Format Length Mobility
management Protocol discriminator M V 1/2 protocol discriminator  
Skip Indicator, used to carry K~med~ Skip Indicator M V 1/2 Sequence Number  
Session key derivation Request Message type M V 1 message type (NEW)  
Session Key Sequence Session Key Sequence M V 1/2 Number (used for Ktc/Kti
pair) Number  
Remainder of KDctr (NEW) Key derivation counter M V 3/2
        Message Authentication Code            Message authentication code   O          TLV      6-18
        (NEW)
* * *
Total length: either 4 or 10-22 octets
The SGSN may include a Message Authentication Code (MAC) in this request
message, of length 32, 64, 96 or 128 bits. An alternative message structure,
saving two octets in an integrity protected request message with a 32-bit MAC,
would be to have a different Message Type for an integrity protected session
key derivation request; in that case the Message Authentication Code field
could be split into two, one mandatory 4-octet field (format=V) for the first
32 bits, and one optional 3-14 octet message (format=TLV) for any further
octets of the MAC. K~med~ is the secret key input to the MAC algorithm. It is
assumed that a single, fixed integrity algorithm (to be specified) is used for
the MAC computation -- we do not propose to support multiple algorithms.
KDctr is a 16-bit value. The least significant 4 bits of KDctr are also used
as the Session Key Sequence Number. The most significant 12 bits of KDctr are
sent in the \"Remainder of KDctr\" field shown in Table B.2.1. The value of
KDctr is maintained in memory for each attacked USIM, and every time a new
session key generation request message is sent, KDctr increments by one. This
ensures that the SKSN cycles through all possible 4-bit values in sequence,
repeatedly. Note that there is no need to avoid the value 0 for the SKSN; the
value 0 is only avoided on the occasion of the very first session key
derivation from a new K~med~, when the USIM (not the SGSN) is selecting the
SKSN, and the SKSN is transmitted in a Skip Indicator.
Because the K~med~ Sequence Number was chosen to be non-zero (see section
B.2.1), the Skip Indicator will not have the (binary) value 0000, for
compatibility with the existing use of the Skip Indicator -- see TS 24.008
section 10.3.1.
We may also define a Session Key Update Request that the mobile device can
send to the SGSN to trigger recovery if either the mobile device detects that
session keys are wrong, or the USIM receives more unauthenticated Session Key
Derivation Request messages in succession than its policy allows:
Table B.2.3.2: Possible structure of session key update request (non-EPS)
* * *
IEI Information element Type/Reference Presence Format Length Mobility
management Protocol discriminator M V 1/2 protocol discriminator  
Skip Indicator, used to carry K~med~ Skip Indicator M V 1/2 Sequence Number  
Session key update Request Message type M V 1 message type (NEW)  
KDctr (NEW) Key derivation counter M V 2
* * *
Total length: 4 octets
The KDctr field in this message is set equal to the current counter value
stored on the USIM (this can be a readable file on the USIM).
After receiving a Session Key Update Request Message, the SGSN should always
include integrity protection in its next Session Key Derivation Message, and
should always use a KDctr value higher than the one received from the mobile
device. If the KDctr value received from the USIM is the maximum possible
(2^16^ -- 1) then the SGSN needs to send a new Authentication and K~med~
Generation Request.
## B.2.4 Battery impact
If we again assume the minimal CIoT data transmission rate of 160 bps, that a
new K~med~ value is created once per year, and that session keys are refreshed
every day, then we can calculate the impact on the battery as follows:
Table B.2.4.1: Battery impact
* * *
                                   Octets   Bits/sec   Seconds   mW    Joules   Every x days   Joules in 10 years   Percentage of 5Wh
Auth and K~med~ generation 37 160 1.85 70 0.1295 365 1.296 0.01% request  
Auth and K~med~ generation 6 160 0.3 460 0.138 365 1.381 0.01% response,
32-bit RES  
Auth and K~med~ generation 12 160 0.6 460 0.276 365 2.762 0.02% response,
64-bit RES  
Session key generation request 4 160 0.2 70 0.014 1 51.135 0.28%
Total from request and 0.30% response with 32-bit RES
* * *
This is a lower battery life impact than if session keys are updated once a
week using standard AKA, but now with session keys updated every day.
Note: Session key generation request messages are unacknowledged. There is
therefore a somewhat greater risk of a message being lost, and hence that the
network updates its session key but the US does not, than with a full AKA
exchange. If that happens, there will be a certain battery life cost involved
in the recovery process.
###### ### Annex C: Access security related functions for enhanced General
Packet Radio Service (GPRS) in relation to Cellular Internet of Things (CIoT)
# C.1 Introduction
## C.1.1 General
NOTE: This Annex is a placeholder for security procedures for enhanced GPRS in
relation to Cellular Internet of Things. This annex will eventually copied
into a new annex in TS 43.020. The content of this annex is not to be taken as
normative in this document.
The provisions in the present Annex apply to procedures between an MS and an
SGSN whenever the MS capability contains at least one non-NULL integrity
algorithm.
In particular, the provisions in the present Annex apply to MSs supporting EC-
EGPRS according to TS 43.064[18].
## C.1.2 Considerations on bidding down attacks
An MS conforming to the provisions in the present annex shall reject
connections to legacy SGSNs that do not provide the enhanced security features
described in the present annex.
NOTE: The reason for this requirement is that an MS cannot know whether it
receives a reply without signalling integrity protection from a genuine legacy
SGSN or from a false SGSN that intercepted the request from the MS.
Consequently, the MS would be susceptible to bidding down attacks during the
Attach procedure that could nullify the security gains offered by the
provisions in the present Annex.
# C.2 Authentication and key agreement
The security feature related to the entity authentication is as defined by TS
33.102 [18] subclause 5.1.2.
UMTS AKA is the authentication and key agreement procedure that shall be used
over enhanced GPRS in relation to Cellular IoT (as specified in TS 33.102
[18]). 2G AKA and 2G SIM shall not be used by the ME or by the network. If the
ME receives a 2G AKA RAND, it shall ignore it.
An ME that has EC-EGPRS radio capability shall support the UICC(USIM)-ME
interface as specified in TS 31.102 [18].
When using USIM AKA, the USIM shall compute CK and IK which are sent to the
ME. If the USIM computes a Kc (i.e. GPRS Kc) from CK and IK using conversion
function c3 as described in TS 33.102 [18], and sends it to the ME, then the
ME shall ignore such GPRS Kc and not store the GPRS Kc on USIM or in ME.
The CK/IK produced by UMTS AKA shall be used by the ME and the eSGSN as the
basis of the keying material for CIoT control plane (CP) and user plane (UP)
ciphering key (Kc128) as well as CP integrity protection key (Ki128).
NOTE: Key derivation of Kc128 and Ki128 is specified in subclause C.6.
# C.3 Ciphering and integrity mode negotiation
The message sequence flow below describes the information transfer at initial
connection establishment, authentication and start of integrity protection and
ciphering (if used).
Figure C.3-1: Integrity algorithm negotiation
1) MS sends an Attach request to the eSGSN. The cipher algorithms and
integrity algorithms supported by the MSshall be included in the MS network
capability parameters. The MS network capability shall contain one set of
encryption algorithms and one set of integrity algorithms. Furthermore, the MS
network capability optionally contains an indication that the MS supports user
plane integrity.
Editor's note: It is FFS if the MS network capability needs to be sent in
other messages than in Attach.
Editor's note: It is FFS whether the MS network capability shall support the
optional inclusion of an additional parameter indicating that the MS requires
the use of user plane integrity.
2) eSGSN obtains AVs (quintets) from HLR/HSS based on IMSI.
3) eSGSN checks for the presence of a non-NULL integrity algorithm in the MS
network capability parameters. If present the eSGSN continues according to the
provisons in the present annex, otherwise the eSGSN continues according to the
provisons in Annex D of the present document. Then the eSGSN selects one
cipher algorithm and one integrity algorithm from the MS network capability
and then derives the cipher key (Kc128) and the integrity key (Ki128).
4) eSGSN sends Authentication and Ciphering request including the chosen
cipher algorithm and integrity algorithm and MS network capability to MS. The
Authentication and Ciphering request is integrity protected by the message
authentication code MAC-I-1. MAC-I-1 is carried at GMM layer.
5) If the MAC-I-1 is not present, the MS shall terminate the connection. MS
runs UMTS AKA with the USIM and derives the Kc128 and the Ki128 from the
CK/IK. The MS verifies the message authentication code MAC-I-1, and if the
check of the MAC-I-1 is successful then MS checks that the echoed MS network
capability is the same as the one it sent. If the verification of MAC-I-1
fails the SGSN terminates the procedure.
6) MS sends Authentication and Ciphering response to the eSGSN. MS calculates
the MAC-I-2 using the integrity key Ki128 and the network selected integrity
algorithm.MAC-I-2 is carried at GMM layer.
7) If ciphering is used, the MS activates it by assigning the ciphering key
Kc128 and the network selected ciphering algorithm, and uses it for the
subsequent messages.
8) The eSGSN receives the Authentication and Ciphering Response message and
verifies the MAC-I-2, and checks the RES. If ciphering is used, eSGSN
activates it by assigning the ciphering key Kc128 and the network selected
ciphering algorithm, and uses it for the subsequent messages. If the MS
indicated support for user plane integrity then eSGSN decides whether to
provide user plane integrity. For this decision, the eSGSN may use information
from the subscriber profile.
9) The Attach Accept message is sent integrity protected with MAC-I-3. MAC-I-3
is carried at LLC layer. If the eSGSN decided to provide user plane integrity
the SGSN includes an indicator that user plane integrity is provided.
10) The MS verifies the MAC-I-3, and the ciphering and integrity mode
negotiation is completed.
11) NOTE: The SGSN makes the final decision on the security services provided.
The MS may have a local security policy mandating the use of user plane
integrity. If the SGSN decides to not enable user plane integrity the MS may
decide to reject the connection. This is similar to a situation where a local
security policy on the MS mandates the use of ciphering, but the SGSN does not
enable ciphering.
Editor's note: The definition of MAC-I-1, MAC-I-2, MAC-I-3 is FFS.
Editor's note: It is FFS whether descriptions similar to the one for the
Attach procedure are needed for idle mode mobility and handover.
# C.4 Protection of GMM messages
Editor's note: This section needs to be aligned with stage 3 specification
when they are available. For example, the references to the LTE specifications
should be replaced by the references to the stage 3 Cellular IoT
specifications of CT1.
Integrity protection and encryption of GMM messages for CIoT enhanced GPRS
shall follow the same principle as with protection (integrity protection and
encryption) of corresponding LTE EMM messages as described in TS 24.301 [8].
The GMM messages for CIoT enhanced GPRS which are not corresponding to any
existing LTE EMM messages in TS 24.301 [8], shall be integrity protected and
encrypted in the following way:
The GMM AUTHENTICATION AND CIPHERING REQUEST message and the GMM
AUTHENTICATION AND CIPHERING RESPONSE message shall be integrity protected
with the new security context and shall not be encrypted.
The GMM AUTHENTICATION AND CIPHERING FAILURE message and the GMM
AUTHENTICATION AND CIPHERING REJECT message shall be integrity protected if
the sending eSGSN or the sending CIoT UE has a valid security context. For the
receiving eSGSN or receiving CIoT UE, the processing of the received GMM
message when the check of the MAC fails or when the receiving part has no
valid security context should follow exactly the description as specified for
the UE in clause 4.4.4.2 and as specified for the MME in clause 4.4.4.3 in LTE
in TS 24.301 [8]. The GMM AUTHENTICATION AND CIPHERING FAILURE message shall
not be encrypted. The GMM AUTHENTICATION AND CIPHERING REJECT message shall be
encrypted if sending eSGSN has a valid security context and encryption has
been activated.
# C.5 Algorithms for ciphering and integrity protection
## C.5.1 Null ciphering algorithm
If GEA0 is selected, the ciphering function implemented in the LLC layer shall
be disabled according to TS 44.064 [7].
NOTE: GEA0 provide no security.
## C.5.2 Ciphering algorithm
### C.5.2.1 Inputs and outputs
The input parameters to the ciphering algorithm GEA4 are as specified in TS
43.020.
Editor's note: The input parameters to the ciphering algorithm GEA5 are FFS.
Figure C.5.2.1-1 illustrates the use of the ciphering algorithm GEA5 (draft
design) to encrypt plaintext by applying a keystream using a bit per bit
binary addition of the plaintext and the keystream. The plaintext may be
recovered by generating the same keystream using the same input parameters and
applying a bit per bit binary addition with the ciphertext.
Figure C.5.2.1-1 on Ciphering of data with GEA5 is FFS.
Based on the input parameters the algorithm generates the output keystream
block KEYSTREAM which is used to encrypt the input plaintext block PLAINTEXT
to produce the output ciphertext block CIPHERTEXT.
### C.5.2.2 GEA5
Editor's note: The specification of GEA5 algorithm is FFS in ETSI SAGE. GEA5
is based on SNOW 3G and is identical to UEA2 as specified in TS 35.215 with
some exceptions to the initialization of the algorithm.
## C.5.3 Integrity algorithm
### C.5.3.1 Inputs and outputs
Editor's note: The input parameters to the integrity algorithms are FFS.
Figure C.5.3.1-1 illustrates a possible use of the integrity algorithm GIA
(draft design) to authenticate the integrity of messages.
Figure C.5.3.1-1 on Derivation of MAC/XMAC is FFS.
Based on these input parameters the sender computes a 32-bit message
authentication code (MAC) using the integrity algorithm GIA. The message
authentication code is then appended to the message when sent. The receiver
computes the expected message authentication code (XMAC) on the message
received in the same way as the sender computed its message authentication
code on the message sent and verifies the data integrity of the message by
comparing it to the received message authentication code, i.e. MAX.
### C.5.3.2 GIA4
Editor's note: The specification of GIA4 algorithm is FFS in ETSI SAGE. GIA4
is based on Kasumi 3G and is implemented in the same way as UIA1 as specified
TS 35.201 with some exceptions to the initialization of the algorithm.
### C.5.3.3 GIA5
Editor's note: The specification of GIA5 algorithm is FFS in ETSI SAGE. GIA5
is based on SNOW 3G and is identical to UIA2 as specified in TS 35.215 with
some exceptions to the initialization of the algorithm.
# C.6 Derivation of Kc128 and Ki128
MS and eSGSN derive the control plane and user plane ciphering key (Kc128) and
the control plane and user plane integrity protection key (Ki128) from CK and
IK. Kc128 and Ki128 shall only be derived by the MS and the network when using
enhanced GPRS in relation to CIoT.
The key Kc128 shall be used as an input only to the GEA ciphering algorithms
which require 128-bit key. The Kc128 is specified in TS 33.102 Annex B [18].
The key Ki128 shall be used as an input only to the GIA integrity protection
algorithms which require 128-bit key.
The input string to the KDF is the concatenation of CK and IK (i.e., CK \|\|
IK). The KDF returns a 256-bit output, where the 128 least significant bits
are identified with Ki128.
\- FC = 0x??
\- P0 = (not used)
\- L0 = (not used)
No input parameters (Pi, Li) are used by this function.
# C.7 Integrity protection of user plane
Integrity protection of user plane is an optional-to-use feature.
The SGSN may use the subscriber data received from HLR/HSS when it decides
whether to activate integrity protection of user plane for a certain
subscriber. The subscriber data may include a flag for indicating whether to
activate the integrity protection of user plane.
###### ### Annex D: Comparison of authenticated encryption schemes
# D.1 Feature comparison
The following features should be compared when an authenticated encryption is
used for cellular IOT. The features are summarized in table 1.
a) Probably secure: Three schemes are proved secure by assuming that the
underlying block cipher is pseudorandom permutation. This does not mean these
schemes are absolutely secure. But this is better than no security proof.
b) Online message processing: A message can be processed without knowing the
length of whole message in advance. This is highly desired for a memory
restricted environment.
c) Underlying cipher requirement: CCM is bundled with a block cipher with the
block size of 128 bits, while GCM and OCB can work on a block cipher with the
block size of 64 bits or 128 bits. It is worth noting that some lightweight
encryption algorithms are designed with 64 bits block size for efficiency
reasons [7].
Table 1 Summary of features
* * *
Feature CCM GCM OCB Provably secure Yes Yes Yes Online No Yes Yes Cipher
requirement 128bits block size 128 or 64 bits block size 128 or 64 bits block
size
* * *
# D.2 Performance comparison
a) Memory requirement: CCM has the smallest ROM usage since it mostly relies
on the block cipher, and no other special function is used. The code for GCM
is the largest due to the multiplier over a binary Galois field. The RAM usage
follows the same pattern. GCM has the largest RAM usage as it applies the
extra pre-computation table for speed acceleration.
b) Computation cost: CCM possesses the highest computation overhead among
three schemes as it needs two cipher invocations for each plaintext block,
while the other two schemes require merely one cipher call for each plaintext
block plus the special function with low computation complexity.
c) Speed: If GCM applies the 64 Kbytes pre-computation table for accelerating
the multiplication, its speed is faster than OCB. However this kind of
implementation cannot be used in the IOT environment where RAM is usually not
larger than 10 Kbytes [8]. So we apply the GCM with 256 Bytes pre-computation
table for IOT environments, which is denoted as GCM256. As shown in Table 2
[9], GCM256 is faster than CCM when the message size is larger than 20 bytes.
It also outperforms the OCB when the message size is smaller than 44 bytes.
This is appropriate for IOT environment where most packets are between 30 and
60 bytes in length [10].
Table D.2.1: Software performance in megabits per second on 1 GHz processer
* * *
Message size (Bytes) 16 20 40 44 64 128 256 552 576 1024 1500 CCM 91.3 88.9
123 133 142 171 163 168 168 174 172 GCM256 88.4 107 148 160 177 162 171 183
184 181 183 OCB 89.5 85.7 140 150 185 225 255 261 265 273 275
* * *
#
# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The present document specifies the Voice Activity Detector (VAD) to be used in
the Discontinuous Transmission (DTX) for the digital cellular
telecommunications system.
Archive en_300965v080000p0.zip which accompanies the present document,
contains test sequences, as described in clause A.2.
> en_300965v080000p0.zip Annex B: Test sequences for the GSM Full Rate speech
> codec; Test sequences files *.inp, *.cod, *.vad.
The specification from which the present document has been derived was
originally based on CEPT documentation, hence the presentation of the present
document may not be entirely in accordance with the ETSI/PNE Rules.
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
## 1 Scope
The present document specifies the Voice Activity Detector (VAD) to be used in
the Discontinuous Transmission (DTX) as described in GSM 06.31. It also
specifies the test methods to be used to verify that a VAD complies with the
technical specification.
The requirements are mandatory on any VAD to be used either in the GSM Mobile
Stations (MS)s or Base Station Systems (BSS)s.
## 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or non‑specific.
  * For a specific reference, subsequent revisions do not apply.
```{=html}
``` \- For a non-specific reference, the latest version applies. In the case
of a reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] GSM 01.04: \"Digital cellular telecommunications system (Phase 2+);
Abbreviations and acronyms\".
[2] GSM 06.10: \"Digital cellular telecommunications system(Phase 2+); Full
rate speech; Transcoding\".
[3] GSM 06.12: \"Digital cellular telecommunications system(Phase 2+); Full
rate speech; Comfort noise aspect for full rate speech traffic channels\".
[4] GSM 06.31: \"Digital cellular telecommunications system(Phase 2+); Full
rate speech; Discontinuous Transmission (DTX) for full rate speech traffic
channels\".
# 3 Abbreviations
Abbreviations used in the present document are listed in GSM 01.04 [1].
# 4 General
The function of the VAD is to indicate whether each 20 ms frame produced by
the speech encoder contains speech or not. The output is a binary flag which
is used by the TX DTX handler defined in GSM 06.31 [4].
The ETS is organized as follows.
Clause 2 describes the principles of operation of the VAD.
In clause 3, the computational details necessary for the fixed point
implementation of the VAD algorithm are given. This clause uses the same
notation as used for computational details in GSM 06.10.
The verification of the VAD is based on the use of digital test sequences.
Clause 4 defines the input and output signals and the test configuration,
whereas the detailed description of the test sequences is contained in clause
A.2.
The performance of the VAD algorithm is characterized by the amount of audible
speech clipping it introduces and the percentage activity it indicates. These
characteristics for the VAD defined in the present document have been
established by extensive testing under a wide range of operating conditions.
The results are summarized in clause A.3.
# 5 Functional description
The purpose of this clause is to give the reader an understanding of the
principles of operation of the VAD, whereas the detailed description is given
in clause 3. In case of discrepancy between the two descriptions, the detailed
description of clause 3 shall prevail.
In the following subclauses of clause 2, a Pascal programming type of notation
has been used to describe the algorithm.
## 5.1 Overview and principles of operation
The function of the VAD is to distinguish between noise with speech present
and noise without speech present. The biggest difficulty for detecting speech
in a mobile environment is the very low speech/noise ratios which are often
encountered. The accuracy of the VAD is improved by using filtering to
increase the speech/noise ratio before the decision is made.
For a mobile environment, the worst speech/noise ratios are encountered in
moving vehicles. It has been found that the noise is relatively stationary for
quite long periods in a mobile environment. It is therefore possible to use an
adaptive filter with coefficients obtained during noise, to remove much of the
vehicle noise.
The VAD is basically an energy detector. The energy of the filtered signal is
compared with a threshold; speech is indicated whenever the threshold is
exceeded.
The noise encountered in mobile environments may be constantly changing in
level. The spectrum of the noise can also change, and varies greatly over
different vehicles. Because of these changes the VAD threshold and adaptive
filter coefficients must be constantly adapted. To give reliable detection the
threshold must be sufficiently above the noise level to avoid noise being
identified as speech but not so far above it that low level parts of speech
are identified as noise. The threshold and the adaptive filter coefficients
are only updated when speech is not present. It is, of course, potentially
dangerous for a VAD to update these values on the basis of its own decision.
This adaptation therefore only occurs when the signal seems stationary in the
frequency domain but does not have the pitch component inherent in voiced
speech. A tone detector is also used to prevent adaptation during information
tones.
A further mechanism is used to ensure that low level noise (which is often not
stationary over long periods) is not detected as speech. Here, an additional
fixed threshold is used.
A VAD hangover period is used to eliminate mid‑burst clipping of low level
speech. Hangover is only added to speech‑bursts which exceed a certain
duration to avoid extending noise spikes.
## 5.2 Algorithm description
The block diagram of the VAD algorithm is shown in figure 2.1. The individual
blocks are described in the following subclauses. ACF, N and sof are
calculated in the speech encoder.
Figure 2.1: Functional block diagram of the VAD
The global variables shown in the block diagram are described as follows:
‑ ACF are auto‑correlation coefficients which are calculated in the speech
encoder defined in GSM 06.10 (subclause 3.1.4, see also clause A.1). The
inputs to the speech encoder are 16 bit 2\'s complement numbers, as described
in GSM 06.10, subclause 4.2.0;
‑ av0 and av1 are averaged ACF vectors;
‑ rav1 are autocorrelated predictor values obtained from av1;
‑ rvad are the autocorrelated predictor values of the adaptive filter;
‑ N is the long term predictor lag value which is obtained every sub‑segment
in the speech coder defined in GSM 06.10;
‑ ptch indicates whether the signal has a steady periodic component;
‑ sof is the offset compensated signal frame obtained in the speech coder
defined in GSM 06.10;
‑ pvad is the energy in the current frame of the input signal after filtering;
‑ thvad is an adaptive threshold;
‑ stat indicates spectral stationarity;
‑ vvad indicates the VAD decision before hangover is added;
‑ vad is the final VAD decision with hangover included.
### 5.2.1 Adaptive filtering and energy computation
Pvad is computed as follows:
$$$\text{Pvad} = \text{rvad}_{0}\text{acf}_{0} + 2\sum_{i =
1}^{8}\text{rvad}_{i}\text{acf}_{i}$
This corresponds to performing an 8th order block filtering on the input
samples to the speech encoder, after zero offset compensation and
pre‑emphasis. This is explained in clause A.1.
### 5.2.2 _ACF_ averaging
Spectral characteristics of the input signal have to be obtained using blocks
that are larger than one 20 ms frame. This is done by averaging the
auto‑correlation values for several consecutive frames. This averaging is
given by the following equations:
Where n represents the current frame, _n‑1_ represents the previous frame etc.
The values of constants are given in table 2.1.
Table 2.1: Constants and variables for ACF averaging
+--------------+-----------+-----------------+-------------------+ | **Constant** | **Value** | **Variable** | **Initial value** | +--------------+-----------+-----------------+-------------------+ | frames | 4 | previous ACF\'s | All set to 0 | | | | | | | | | av0 & av1 | | +--------------+-----------+-----------------+-------------------+
### 5.2.3 Predictor values computation
The filter predictor values aav1 are obtained from the auto‑correlation values
av1 according to the equation:
where:
+----------------------------------------------------------------------+ | ‑ ‑ | | | | **[R]{.underline}** = \| av1[0], av1[1], av1[2], av1[3], | | av1[4], av1[5], av1[6], av1[7] \| | | | | \| av1[1], av1[0], av1[1], av1[2], av1[3], av1[4], | | av1[5], av1[6] \| | | | | \| av1[2], av1[1], av1[0], av1[1], av1[2], av1[3], | | av1[4], av1[5] \| | | | | \| av1[3], av1[2], av1[1], av1[0], av1[1], av1[2], | | av1[3], av1[4] \| | | | | \| av1[4], av1[3], av1[2], av1[1], av1[0], av1[1], | | av1[2], av1[3] \| | | | | \| av1[5], av1[4], av1[3], av1[2], av1[1], av1[0], | | av1[1], av1[2] \| | | | | \| av1[6], av1[5], av1[4], av1[3], av1[2], av1[1], | | av1[0], av1[1] \| | | | | \| av1[7], av1[6], av1[5], av1[4], av1[3], av1[2], | | av1[1], av1[0] \| | | | | ‑ ‑ | +----------------------------------------------------------------------+
and:
+------------------------------------------------------------------------+ | ‑ ‑ ‑ ‑ | | | | **[p]{.underline}** = \|av1[1]\| **[a]{.underline}** = \|aav1[1]\| | | | | \|av1[2]\| \|aav1[2]\| | | | | \|av1[3]\| \|aav1[3]\| | | | | \|av1[4]\| \|aav1[4]\| | | | | \|av1[5]\| \|aav1[5]\| | | | | \|av1[6]\| \|aav1[6]\| | | | | \|av1[7]\| \|aav1[7]\| | | | | \|av1[8]\| \|aav1[8]\| | | | | ‑ ‑ ‑ ‑ | +------------------------------------------------------------------------+
aav1[0] = ‑1
av1 is used in preference to av0 as av0 may contain speech.
The autocorrelated predictor values rav1 are then obtained:
### 5.2.4 Spectral comparison
The spectra represented by the autocorrelated predictor values rav1 and the
averaged auto‑correlation values av0 are compared using the distortion measure
dm defined below. This measure is used to produce a Boolean value stat every
20 ms, as given by these equations:
difference = \|dm ‑ lastdm\|
lastdm = dm
stat = difference \= nthresh
The following operations are done after the VAD decision and when the current
LTP lag values (N0 .. N3) are available, this reduces the delay of the VAD
decision. (N{‑1} = N3 of previous segment.)
lagcount = 0
for j = 0 to 3 do
begin
smallag = maximum(Nj,N{j‑1}) mod minimum(Nj,N{j‑1})
if minimum(smallag,minimum(Nj,N{j‑1})‑smallag) \ thvad
### 5.2.9 VAD hangover addition
VAD hangover is only added to bursts of speech greater than or equal to
burstconst blocks. The Boolean variable vad indicates the decision of the VAD
with hangover included. The values of the constants are given in table 2.6.
The hangover algorithm is as follows:
if vvad then increment(burstcount) else burstcount = 0
if burstcount >= burstconst then
begin
hangcount = hangconst;
burstcount = burstconst
end
vad = vvad or (hangcount >= 0)
if hangcount >= 0 then decrement(hangcount)
Table 2.6: Constants and variables for VAD hangover addition
* * *
Constant Value Variable Initial value
burstconst\ 3\ burstcount\ 0\ hangconst 5 hangcount ‑1
* * *
# 6 Computational details
In the next paragraphs, the detailed description of the VAD algorithm follows
the preceding high level description. This detailed description is divided in
ten clauses related to the blocks of figure 2.1 (except periodicity updating)
in the high level description of the VAD algorithm.
Those clauses are:
1) adaptive filtering and energy computation;
2) ACF averaging;
3) predictor values computation;
4) spectral comparison;
5) periodicity detection;
6) threshold adaptation;
7) VAD decision;
8) VAD hangover addition;
9) periodicity updating;
10) information tone detection.
The VAD algorithm takes as input the following variables of the RPE‑LTP
encoder (see the detailed description of the RPE‑LTP encoder GSM 06.10):
‑ L_ACF[0..8], auto‑correlation function (GSM 06.10/4.2.4);
‑ scalauto, scaling factor to compute the L_ACF[0..8] (GSM 06.10/4.2.4);
‑ Nc, LTP lag (one for each sub‑segment, GSM 06.10/4.2.11);
‑ sof, offset compensated signal frame (GSM 06.10/4.2.2).
So four Nc values are needed for the VAD algorithm.
The VAD computation can start as soon as the L_ACF[0..8] and scalauto
variables are known. This means that the VAD computation can take place after
part 4.2.4 of GSM 06.10 (Auto‑correlation) of the LPC analysis clause of the
RPE‑LTP encoder. This scheme will reduce the delay to yield the VAD
information. The periodicity updating (included in subclause 2.2.5) and
information tone detection, are done after the processing of the current
speech encoder frame.
All the arithmetic operations and names of the variables follow the RPE‑LTP
detailed description. To increase the precision within the fixed point
implementation, a pseudo‑floating point representation of some variables is
used. This stands for the following variables (and related constants) of the
VAD algorithm:
pvad: Energy of filtered signal;
thvad: Threshold of the VAD decision;
acf0: Energy of input signal.
For the representation of these variables, two integers (16 bits) are needed:
‑ one for the exponent (e_pvad, e_thvad, e_acf0);
‑ one for the mantissa (m_pvad, m_thvad, m_acf0).
The value e_pvad represents the lowest power of 2 just greater or equal to the
actual value of pvad and the m_pvad value represents a integer which is always
greater or equal to 16384 (normalized mantissa). It means that the pvad value
is equal to:
This scheme guarantees a large dynamic range for the pvad value and always
keeps a precision of 16 bits. All the comparisons are easy to make by
comparing the exponents of two variables and the VAD algorithm needs only one
pseudo‑floating point addition. All the computations related to the
pseudo‑floating point variables require very simple 16 or 32 bits arithmetic
operations defined in the detailed description of the RPE‑LTP encoder. This
pseudo‑floating point arithmetic is only used in subclauses 3.1 and 3.6.
Table 3.1 gives a list of all the variables of the VAD algorithm that must be
initialized in the reset procedure and kept in memory for processing the
subsequent frame of the RPE‑ LTP encoder. The types (16 or 32 bits) and
initial values of all these variables are clearly indicated and their related
subclause is also mentioned. The bit exact implementation uses other temporary
variables that are introduced in the detailed description whenever it is
needed.
Table 3.1: Initial values for variables to be stored in memory
+-----------------+-----------------+-----------------+------------+ | Names of | type (# of | Initialization: | Subclause: | | variables: | bits): | | | +-----------------+-----------------+-----------------+------------+ | Adaptive filter | | | | | coefficients: | | | | +-----------------+-----------------+-----------------+------------+ | > rvad[0] | 16 | 24 576 | 3.1, 3.6 | +-----------------+-----------------+-----------------+------------+ | > rvad[1] | 16 | ‑16 384 | 3.1, 3.6 | +-----------------+-----------------+-----------------+------------+ | > rvad[2] | 16 | 4 096 | 3.1, 3.6 | +-----------------+-----------------+-----------------+------------+ | > rvad[3..8] | 16 | 0 | 3.1, 3.6 | +-----------------+-----------------+-----------------+------------+ | Scaling factor | | | | | of | | | | | ravd[0..8]: | | | | +-----------------+-----------------+-----------------+------------+ | > normrvad | 16 | 7 | 3.1, 3.6 | +-----------------+-----------------+-----------------+------------+ | Delay line of | | | | | the | | | | | a | | | | | uto‑correlation | | | | | coefficients: | | | | +-----------------+-----------------+-----------------+------------+ | > L | 32 | 0 | 3.2 | | _sacf[0..26] | | | | +-----------------+-----------------+-----------------+------------+ | > L | 32 | 0 | 3.2 | | _sav0[0..35] | | | | +-----------------+-----------------+-----------------+------------+ | Pointers on the | | | | | delay lines: | | | | +-----------------+-----------------+-----------------+------------+ | > pt_sacf | 16 | 0 | 3.2 | +-----------------+-----------------+-----------------+------------+ | > pt_sav0 | 16 | 0 | 3.2 | +-----------------+-----------------+-----------------+------------+ | Distance | | | | | measure: | | | | +-----------------+-----------------+-----------------+------------+ | > L_lastdm | 32 | 0 | 3.4 | +-----------------+-----------------+-----------------+------------+ | Periodicity | | | | | counters: | | | | +-----------------+-----------------+-----------------+------------+ | > oldlagcount | 16 | 0 | 3.5, 3.9 | +-----------------+-----------------+-----------------+------------+ | > | 16 | 0 | 3.5, 3.9 | | veryoldlagcount | | | | +-----------------+-----------------+-----------------+------------+ | Adaptive | | | | | threshold: | | | | +-----------------+-----------------+-----------------+------------+ | > e_thvad | 16 | 20 | 3.6 | | > (exponent) | | | | +-----------------+-----------------+-----------------+------------+ | > m_thvad | 16 | 31 250 | 3.6 | | > (mantissa) | | | | +-----------------+-----------------+-----------------+------------+ | Counter for | | | | | adaptation: | | | | +-----------------+-----------------+-----------------+------------+ | > adaptcount | 16 | 0 | 3.6 | +-----------------+-----------------+-----------------+------------+ | Hangover flags: | | | | +-----------------+-----------------+-----------------+------------+ | > burstcount | 16 | 0 | 3.8 | +-----------------+-----------------+-----------------+------------+ | > hangcount | 16 | ‑1 | 3.8 | +-----------------+-----------------+-----------------+------------+ | LTP lag memory: | | | | +-----------------+-----------------+-----------------+------------+ | > oldlag | 16 | 40 | 3.9 | +-----------------+-----------------+-----------------+------------+ | Tone Detection | | | | +-----------------+-----------------+-----------------+------------+ | > tone | 16 | 0 | 3.10 | +-----------------+-----------------+-----------------+------------+
## 6.1 Adaptive filtering and energy computation
This subclause computes the e_pvad and m_pvad variables which represent the
pvad value. It needs the L_ACF[0..8] and scalauto variables of the RPE‑LTP
algorithm and the rvad[0..8] and normrvad variables produced by subclause 3.6
of the VAD algorithm. It also computes a floating point representation of
L_ACF[0] (e_acf0 and m_acf0) used in subclause 3.6.
**Test if L_ACF[0] is equal to 0:**
IF ( scalauto \> 19;
\| NEXT i:
**Computation of e_acf0 and m_acf0:**
e_acf0 = add( 32, (scalvad \> 1 );
IF ( L_temp \> 16;
## 6.2 ACF averaging
This subclause uses the L_ACF[0..8] and the scalvad variables to compute the
array L_av0[0..8] and L_av1[0..8] used in subclause 3.3 and 3.4.
**Computation of the scaling factor:**
scal = sub( 10, (scalvad \> scal;
\| L_av0[i] = L_add( L_sacf[i], L_temp );
\| L_av0[i] = L_add( L_sacf[i+9], L_av0[i] );
\| L_av0[i] = L_add( L_sacf[i+18], L_av0[i] );
\| L_sacf[ pt_sacf + i ] = L_temp;
\| L_av1[i] = L_sav0[ pt_sav0 + i ];
\| L_sav0[ pt_sav0 + i] = L_av0[i];
\| NEXT i:
**Update of the array pointers:**
IF ( pt_sacf == 18 ) THEN pt_sacf = 0;
ELSE pt_sacf = add( pt_sacf, 9);
IF ( pt_sav0 == 27 ) THEN pt_sav0 = 0;
ELSE pt_sav0 = add( pt_sav0, 9);
## 6.3 Predictor values computation
This subclause computes the array rav1[0..8] needed for the spectral
comparison and the threshold adaptation. It uses the L_av1[0..8] computed in
subclause 3.2, and is divided in the three following subclauses:
‑ Schur recursion to compute reflection coefficients.
‑ Step up procedure to obtain the aav1[0..8].
‑ Computation of the rav1[0..8].
### 6.3.1 Schur recursion to compute reflection coefficients
This subclause is identical to the one used in the RPE‑LTP algorithm. The
array vpar[1..8] is computed with the array L_av1[0..8] as an input.
**Schur recursion with 16 bits arithmetic:**
IF( L_av1[0] == 0 ) THEN
\|== FOR i = 1 to 8:
\| vpar[i] = 0;
\|== NEXT i:
\| EXIT; /continue with subclause 3.3.2/
temp = norm( L_av1[0] );
\|== FOR k=0 to 8:
\| sacf[k] = ( L_av1[k] \> 16;
\|== NEXT k:
**Initialize array P[..] and K[..] for the recursion:**
\|== FOR i=1 to 7:
\| K[9‑i] = sacf[i];
\|== NEXT i:
\|== FOR i=0 to 8:
\| P[i] = sacf[i];
\|== NEXT i:
**Compute reflection coefficients:**
\|== FOR n=1 to 8:
\| IF( P[0] \ 0 ) THEN vpar[n] = sub( 0, vpar[n] );
\| IF ( n == 8 ) THEN EXIT; /continue with subclause 3.3.2/
\|
\| Schur recursion:
\|
\| P[0] = add( P[0], mult_r( P[1], vpar[n] ) );
\|==== FOR m=1 to 8‑n:
\| P[m] = add( P[m+1], mult_r( K[9‑m], vpar[n] ) );
\| K[9‑m] = add( K[9‑m], mult_r( P[m+1], vpar[n] ) );
\|==== NEXT m:
\|
\|== NEXT n:
### 6.3.2 Step‑up procedure to obtain the aav1[0..8]
**Initialization of the step‑up recursion:**
L_coef[0] = 16384 \> 16; / takes the msb /
\|== L_work[i] = L_add( L_coef[i], L_mult( vpar[m], temp ) );
\|== NEXT i
\|=
\|== FOR i = 1 to m‑1:
\|== L_coef[i] = L_work[i];
\|== NEXT i
\|=
\|= L_coef[m] = vpar[m] \> 19;
\| NEXT i:
### 6.3.3 Computation of the rav1[0..8]
\|= FOR i= 0 to 8:
\|= L_work[i] = 0;
\|== FOR k = 0 to 8‑i:
\|== L_work[i] = L_add( L_work[i], L_mult( aav1[k], aav1[k+i] ) );
\|== NEXT k:
\|= NEXT i:
IF ( L_work[0] == 0 ) THEN normrav1 =0;
ELSE normrav1 = norm( L_work[0] );
\|= FOR i= 0 to 8:
\|= rav1[i] = ( L_work[i] \> 16;
\|= NEXT i:
Keep the normrav1 for use in subclause 3.4 and 3.6.
## 6.4 Spectral comparison
This subclause computes the variable stat needed for the threshold adaptation.
It uses the array L_av0[0..8] computed in subclause 3.2 and the array
rav1[0..8] computed in subclause 3.3.3.
**Re‑normalize L_av0[0..8]:**
IF ( L_av0[0] == 0 ) THEN
\| FOR i = 0 to 8:
\| sav0[i] = 4095;
\| NEXT i:
ELSE
\| shift = norm( L_av0[0] );
\|= FOR i = 0 to 8:
\|= sav0[i] = ( L_av0[i] \> 16;
\|= NEXT i:
**Compute partial Σ of dm:**
L_ Σ p = 0;
\|= FOR i = 1 to 8:
\|= L_ Σ p = L_add( L_ Σ p, L_mult( rav1[i], sav0[i] ) );
\|= NEXT i:
**Compute the division of partial Σ by sav0[0]:**
IF ( L_ Σ p \> 16;
\| IF ( sav0[0] >= temp ) THEN
\| \| divshift = 0;
\| \| temp = div( temp, sav0[0] );
\| ELSE
\| \| divshift = 1;
\| \| temp = sub( temp, sav0[0] );
\| \| temp = div( temp, sav0[0] );
\|
\| IF( divshift == 1 ) THEN L_dm = 32768;
\| ELSE L_dm = 0;
\|
\| L_dm = L_add( L_dm, temp) \> shift;
L_dm = L_add( L_dm, ( rav1[0] \> normrav1;
**Compute the difference and save L_dm:**
L_temp = L_sub( L_dm, L_lastdm );
L_lastdm = L_dm;
IF ( L_temp \= 4 ) THEN ptch = 1;
ELSE ptch = 0;
## 6.6 Threshold adaptation
This subclause uses the variables e_pvad, m_pvad, e_acf0 and m_acf0 computed
in subclause 3.1. It also uses the flags stat (see subclause 3.4) and ptch
(see subclause 3.5). It follows the flowchart represented on figure 2.2.
Some constants, represented by a floating point format, are needed and a
symbolic name (in capital letter) for their exponent and mantissa is used;
table 3.2 lists all these constants with the symbolic names associated and
their numerical constant values.
Table 3.2: List of constants
* * *
Constant Exponent Mantissa
pth\ E_PTH = 19\ M_PTH = 18 750\ margin\ E_MARGIN = 27\ M_MARGIN = 19 531\
plev E_PLEV = 20 M_PLEV = 25 000
* * *
NOTE: Floating point representation of constants used in subclause 3.6:\ pth =
2(E_PTH)x(M_PTH/32768).\ margin = 2(E_MARGIN)x(M_MARGIN/32768).\ plev =
2(E_PLEV)x(M_PLEV/32768).
**Test if acf0 \ > 5 ) );
IF ( m_thvad \> 1;
e_temp = add( e_pvad, 1 );
IF ( L_temp > 32767 ) THEN
\| L_temp = L_temp >> 1;
\| e_temp = add( e_temp, 1 );
m_temp = L_temp;
**Test if thvad \ > 4 ) );
\| IF ( L_temp > 32767 ) THEN
\| \| m_thvad = L_temp >> 1;
\| \| e_thvad = add( e_thvad,1 );
\| ELSE m_thvad = L_temp;
\| comp2 = 0;
\| IF ( e_temp \> 1;
\| e_temp = add( e_pvad, 1 );
ELSE
\| IF ( e_pvad > E_MARGIN ) THEN
\| \| temp = sub( e_pvad, E_MARGIN );
\| \| temp = M_MARGIN >> temp;
\| \| L_temp = L_add( m_pvad, temp );
\| \| IF ( L_temp > 32767) THEN
\| \| \| e_temp = add( e_pvad, 1 );
\| \| \| m_temp = L_temp >> 1;
\| \| ELSE
\| \| \| e_temp = e_pvad;
\| \| \| m_temp = L_temp;
\| ELSE
\| \| temp = sub( E_MARGIN, e_pvad );
\| \| temp = m_pvad >> temp;
\| \| L_temp = L_add( M_MARGIN, temp );
\| \| IF (L_temp > 32767) THEN
\| \| \| e_temp = add( E_MARGIN, 1);
\| \| \| m_temp = L_temp >> 1;
\| \| ELSE
\| \| \| e_temp = E_MARGIN;
\| \| \| m_temp = L_temp;
**Test if thvad > pvad + margin:**
comp = 0;
IF ( e_thvad > e_temp) THEN comp = 1;
IF (e_thvad == e_temp) THEN IF (m_thvad > m_temp) THEN comp =1;
IF ( comp == 1 ) THEN
\| e_thvad = e_temp;
\| m_thvad = m_temp;
**Initialize new rvad[0..8] in memory:**
normrvad = normrav1;
\|= FOR i = 0 to 8:
\|= rvad[i] = rav1[i];
\|= NEXT i:
**Set adaptcount to adp + 1:**
adaptcount = 9;
## 6.7 VAD decision
This subclause only outputs the result of the comparison between pvad and
thvad using the pseudo‑floating point representation of thvad and pvad. The
values e_pvad and m_pvad are computed in subclause 3.1 and the values e_thvad
and m_thvad are computed in subclause 3.6.
vvad = 0;
IF (e_pvad > e_thvad) THEN vvad = 1;
IF (e_pvad == e_thvad) THEN IF (m_pvad > m_thvad) THEN vvad =1;
## 6.8 VAD hangover addition
This subclause finally sets the vad decision for the current frame to be
processed.
IF ( vvad == 1 ) THEN burstcount = add( burstcount, 1 );
ELSE burstcount = 0;
IF ( burstcount >= 3 ) THEN
\| hangcount = 5;
\| burstcount = 3;
vad = vvad;
IF ( hangcount >= 0 ) THEN
\| vad = 1;
\| hangcount = sub( hangcount, 1 );
## 6.9 Periodicity updating
This subclause must be delayed until the LTP lags are computed by the RPE‑LTP
algorithm. The LTP lags called Nc in the speech encoder are renamed lags[0..3]
(index 0 for the first sub‑ segment of the frame, 1 for the second and so on).
**Loop on sub‑segments for the frame:**
lagcount = 0;
\|= FOR i = 0 to 3:
\|= Search the maximum and minimum of consecutive lags.
\|= IF ( oldlag > lags[i] ) THEN
\|= \| minlag = lags[i];
\|= \| maxlag = oldlag;
\|= ELSE
\|= \| minlag = oldlag;
\|= \| maxlag = lags[i] ;
\|=
\|= **Compute smallag (modulo operation not defined ):**
\|=
\|= smallag = maxlag;
\|== \| FOR j = 0 to 2:
\|== \| IF (smallag >= minlag) THEN smallag =sub( smallag, minlag);
\|== \| NEXT j;
\|=
\|= **Minimum of smallag and minlag ‑ smallag:**
\|=
\|= temp = sub( minlag, smallag );
\|= IF ( temp \ smax ) THEN smax = temp;
\|== NEXT k;
**Computation of the scaling factor:**
IF ( smax == 0 ) THEN scalauto = 0;
ELSE scalauto = sub( 4, norm( smax \ 0 ) THEN
\| temp = 16384 >> sub( scalauto,1);
\|== FOR k = 0 to 159:
\| sofh[k] = mult_r( sofh[k], temp);
\|== NEXT k:
**Compute the L_ACF[..]:**
\|== FOR k=0 to 4:
\| L_acfh[k] = 0;
\|==== FOR i=k to 159:
\| L_temp = L_mult( sofh[i], sofh[i‑k] );
\| L_acfh[k] = L_add( L_acfh[k], L_temp );
\|==== NEXT i:
\|== NEXT k:
### 6.10.3 Computation of the reflection coefficients
This subclause calculates the reflection coefficients rc[1..4] from the input
array L_acfh[0..4]. This procedure is identical to the one in subclause 3.3.1
and the RPE‑LTP codec, with the exception that only four reflection
coefficients are calculated.
**Schur recursion with 16 bits arithmetic:**
IF( L_acfh[0] == 0 ) THEN
\|== FOR i = 1 to 4:
\| rc[i] = 0;
\|== NEXT i:
\| EXIT; /continue with subclause 3.10.4/
temp = norm( L_acfh[0] );
\|== FOR k=0 to 4:
\| sacf[k] = ( L_acfh[k] \> 16;
\|== NEXT k:
**Initialize array P[..] and K[..] for the recursion:**
\|== FOR i=1 to 3:
\| K[5‑i] = sacf[i];
\|== NEXT i:
\|== FOR i=0 to 4:
\| P[i] = sacf[i];
\|== NEXT i:
**Compute reflection coefficients:**
\|== FOR n=1 to 4:
\| IF( P[0] \ 0 ) THEN rc[n] = sub( 0, rc[n] );
\| IF ( n == 4 ) THEN EXIT; /continue with subclause 3.10.4/
\|
**Schur recursion:**
\| P[0] = add( P[0], mult_r( P[1], rc[n] ) );
\|==== FOR m=1 to 4‑n:
\| P[m] = add( P[m+1], mult_r( K[5‑m], rc[n] ) );
\| K[5‑m] = add( K[5‑m], mult_r( P[m+1], rc[n] ) );
\|==== NEXT m:
\|
\|== NEXT n:
### 6.10.4 Filter coefficient calculation
This subclause calculates the direct form filter coefficients a[1..2] from the
reflection coefficients rc[1..4].
**Step‑up procedure to obtain the a[1..2]:**
temp = rc[1] >> 2;
a[1] = add( temp, mult_r( rc[2], temp ) );
a[2] = rc[2] >> 2;
### 6.10.5 Pole Frequency Test
This subclause uses the direct form filter coefficients a[1..2] to determine
the pole frequency of the second order LPC analysis. If the pole frequency is
less than 385 Hz tone is set to 0 and clause 3 terminates.
L_den = L_mult ( a[1], a[1] );
L_temp = a[2] \> 16;
\| L_den = L_mult ( temp, 3189 );
\| L_temp = L_sub ( L_num, L_den );
\| IF ( L_temp \ 32 bit*/
\| \| L_Temp = L_Add( L_Temp , L_Temp1 );
\| \| NEXT n
\| L_Temp = L_temp >> 2;
\| mean (LAR(i)) = L_Temp; /*conversion 32 ‑‑> 16 bit*/
\| NEXT i;
**xmax averaging**
L_Temp = 8; /* const. for rounding*/
\| FOR n = 1 to 4:
\| \| FOR i = 1 to 4:
\| \| L_Temp1 = xmax[j‑n](i); /*conversion 16 ‑‑> 32 bit*/
\| \| L_Temp = L_Add( L_Temp , L_Temp1 );
\| \| NEXT i
\| NEXT n
L_Temp = L_Temp >> 4;
mean (xmax) = L_Temp; /*conversion 32 ‑‑> 16 bit*/
## A.2.2 File format description
All the *.inp and *.cod files are written in binary using 16 bit words, while
all *.vad files are written in ASCII format. The sizes of the files are shown
in table A.2.1, A.2.2 and A.2.3. The detailed format of the *.inp and *.cod
files is in accordance with the descriptions given in GSM 06.10 clause 5.
Table A.2.1: File sizes for *.inp extension files
* * *
File: Frames: Size in bytes: spec_a1.inp 22 7 040 spec_a2.inp 22 7 040
spec_c1.inp 48 15 360 spec_c2.inp 48 15 360 spec_c3.inp 48 15 360 spec_c4.inp
48 15 360 adapt_i1.inp 67 21 440 adapt_i2.inp 48 15 360 adapt_m1.inp 403 128
960 adapt_m2.inp 376 120 320 pitch1.inp 35 11 200 pitch2.inp 35 11 200
freq_sw.inp 560 179 200 pred1.inp 126 40 320 pred2.inp 126 40 320 pole1.inp 97
31 040 pole2.inp 42 13 440 safety.inp 5 16 00 good_sp.inp 312 99 840
bad_sp.inp 312 99 840
* * *
Table A.2.2: File sizes for *.cod extension files
+-----------------+---------+----------------+ | File: | Frames: | Size in bytes: | +-----------------+---------+----------------+ | > spec_a1.cod | 22 | 3 344 | +-----------------+---------+----------------+ | > spec_a2.cod | 22 | 3 344 | +-----------------+---------+----------------+ | > spec_c1.cod | 48 | 7 296 | +-----------------+---------+----------------+ | > spec_c2.cod | 48 | 7 296 | +-----------------+---------+----------------+ | > spec_c3.cod | 48 | 7 296 | +-----------------+---------+----------------+ | > spec_c4.cod | 48 | 7 296 | +-----------------+---------+----------------+ | > adapt_i1.cod | 67 | 10 184 | +-----------------+---------+----------------+ | > adapt_i2.cod | 48 | 7 296 | +-----------------+---------+----------------+ | > adapt_m1.cod | 403 | 61 256 | +-----------------+---------+----------------+ | > adapt_m2.cod | 376 | 57 152 | +-----------------+---------+----------------+ | > pitch1.cod | 35 | 5 320 | +-----------------+---------+----------------+ | > pitch2.cod | 35 | 5 320 | +-----------------+---------+----------------+ | > freq_sw.cod | 560 | 85 120 | +-----------------+---------+----------------+ | > pred1.cod | 126 | 19 152 | +-----------------+---------+----------------+ | > pred2.cod | 126 | 19 152 | +-----------------+---------+----------------+ | > pole1.cod | 97 | 14 744 | +-----------------+---------+----------------+ | > pole2.cod | 42 | 6 384 | +-----------------+---------+----------------+ | > safety.cod | 5 | 760 | +-----------------+---------+----------------+ | > good_sp.cod | 312 | 47 424 | +-----------------+---------+----------------+ | > bad_sp.cod | 312 | 47 424 | +-----------------+---------+----------------+
Table A.2.3: File sizes for *.vad extension files
+-----------------+---------+----------------+ | File: | Frames: | Size in bytes: | +-----------------+---------+----------------+ | > spec_a1.vad | 22 | 88 | +-----------------+---------+----------------+ | > spec_a2.vad | 22 | 88 | +-----------------+---------+----------------+ | > spec_c1.vad | 48 | 192 | +-----------------+---------+----------------+ | > spec_c2.vad | 48 | 192 | +-----------------+---------+----------------+ | > spec_c3.vad | 48 | 192 | +-----------------+---------+----------------+ | > spec_c4.vad | 48 | 192 | +-----------------+---------+----------------+ | > adapt_i1.vad | 67 | 268 | +-----------------+---------+----------------+ | > adapt_i2.vad | 48 | 192 | +-----------------+---------+----------------+ | > adapt_m1.vad | 403 | 1 612 | +-----------------+---------+----------------+ | > adapt_m2.vad | 376 | 1504 | +-----------------+---------+----------------+ | > pitch1.vad | 35 | 140 | +-----------------+---------+----------------+ | > pitch2.vad | 35 | 140 | +-----------------+---------+----------------+ | > freq_sw.inp | 560 | 2 240 | +-----------------+---------+----------------+ | > pred1.vad | 126 | 504 | +-----------------+---------+----------------+ | > pred2.vad | 126 | 504 | +-----------------+---------+----------------+ | > pole1.vad | 97 | 388 | +-----------------+---------+----------------+ | > pole2.vad | 42 | 168 | +-----------------+---------+----------------+ | > safety.vad | 5 | 20 | +-----------------+---------+----------------+ | > good_sp.vad | 312 | 1 248 | +-----------------+---------+----------------+ | > bad_sp.vad | 312 | 1 248 | +-----------------+---------+----------------+
# A.3 VAD performance
In optimizing a VAD a difficult trade‑off has to be made between speech
clipping which reduces the subjective performance of the system, and the
average activity factor. The benefit of DTX is increased as the average
activity factor is reduced. However, in general, a reduction of the activity
will be associated with a greater risk for audible speech clipping.
In the optimization process, great emphasis has been placed on avoiding
unnecessary speech clipping. However, it has been found that a VAD with
virtually no audible clipping would result in a very high activity and very
little DTX advantage.
The VAD specified in this technical specification introduces audible and
possibly objectionable clipping in certain cases, mainly with low input
levels. However, a comprehensive evaluation programme consisting of about 600
individual conversations conducted in a wide range of realistic conditions, it
was found that about 90% of the conversations were free from objectionable
clipping.
The voice activity performance of the VAD is summarized in table A.3.1. The
activity figures are averages of a large number of conversations covering
factors like different talkers, noise characteristics and locations. It should
be noted that the actual activity of a particular talker in a specific
conversation may vary considerably relative to the averages given. This is due
both to the variation in talker behaviour as well as to the level dependency
of the VAD (the channel activity has been found to decrease by about 0,5
points of percentage per dB level reduction). However, as mentioned above, a
decreased speech input level increases the risk of objectionable speech
clipping.
All the values given are activity figures, i.e. the % of time the radio
channel has to be on.
Table A.3.1: Summary of channel activity
* * *
Telephone\ Situation Typical channel\ instrument activity factor:
Handset Quiet location 55%
Handset Moderate office\ 60% noise with\  
voice interference
Handset Strong voice\ 65‑70% interference (e.g.\  
airport/railway station)
Handsfree/\ Variable vehicle\ 60% handset noise
* * *
# A.4 Pole frequency calculation
This annex describes the algorithm used to determine whether the pole
frequency for a second order analysis of the signal frame is less than 385 Hz.
The filter coefficients for a second order synthesis filter are calculated
from the first two unquantized reflection coefficients rc[1..2] obtained from
the speech encoder. This is done using the routine described in subclause
3.10.4. If the filter coefficients a[0..2] are defined such that the synthesis
filter response is given by:
H(z) = 1 / (a[0] + a[1]z^‑1^ + a[2]z^‑2^ ) (1)
Then the positions of the poles in the Z‑plane are given by the solutions to
the following quadratic:
a[0]z^2^ + a[1]z + a[2] = 0, a[0] = 1 (2)
The positions of the poles, z, are therefore:
z = re ± j*sqrt(im), j^2^ = ‑1 (3)
where:
re = ‑ a[1] / 2 (4)
im = (4*a[2] ‑ a[1]^2^ ) / 4 (5)
If im is negative then the poles lie on the real axis of the Z‑plane and the
signal is not a tone and the algorithm terminates. If re is negative then the
poles lie in the left hand side of the Z‑plane and the frequency is greater
than 2 000 Hz and the prediction error test can be performed.
If im is positive and re is positive then the poles are complex and lie in the
right hand side of the Z‑plane and the frequency in Hz is related to re and im
by the expression:
freq = arctan (sqrt(im)/re ) * 4 000 / π (6)
Having ensured that both im and re are positive, the test for a dominant
frequency less than 385 Hz can be derived by substituting Equations 4 and 5
into Equation 6 and re‑arranging:
(4*a[2] ‑ a[1]^2^ ) / a[1]^2^ \< (tan(π*385/4 000))^2^ (7)
or
(4*a[2] ‑ a[1]^2^ ) / a[1]^2^ \< 0.0973 (8)
If this test is true then the signal is not a tone and the algorithm
terminates, otherwise the prediction error test is performed.
###### ## Annex B (normative): Test sequences
The test vectors are described in the present document are supplied in archive
en_300965v080000p0.zip which accompanies the present document. The files
contained in this archive are listed in clause A.2.
The full rate test vectors apply to both GSM Phase 1 and Phase 2. However, the
files pole1.* pole2.* pred1.* pred2.* and freq_sw.* are not required for Phase
1 (uplink and downlink) and Phase 2 uplink implementations.
#
# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
3GPP defined the Generic Authentication Architecture (GAA). The adoption of
GAA by other standardization bodies showed that some services can not make the
assumption that the User Equipment (UE) has always the possibility to connect
to the Bootstrapping Server Function (BSF). This specification introduces a
generic push layer that makes use of the GBA Push Function as specified in TS
33.223 [2].
# 1 Scope
The present document specifies a generic push layer that makes use of the GBA
Push Function as specified in TS 33.223 [2]. The GPL specification includes a
message format, protection algorithms and processing model. GPL assumes that
keys and other SA parameters have been preinstalled in the push NAF and the
UE. GPL is a protection protocol that can be applied in a unidirectional
fashion.
The rationale for GPL is that having each application specify its own security
mechanisms would for obvious reasons lead to duplication of work,
specifications and implementations. Using a generic secure push layer avoids
these problems. A generic secure push layer may also relieve the applications
using the service of having to be aware of inner working of the security
layer\'s. As an analogy, TS 33.222 [4] can be mentioned, which provides a
generic security layer for HTTP based applications.
There are two main approaches that can be taken when designing the security
for the push messages, either each application that uses a push feature
specifies its own security mechanisms based on the presence of the security
association, or a generic security layer is introduced that provides security
services to the applications, which then do not need to be aware of the inner
workings of the security layer.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or nonâ€‘specific.
  * For a specific reference, subsequent revisions do not apply.
  * For a non-specific reference, the latest version applies. In the > case of a reference to a 3GPP document (including a GSM document), > a non-specific reference implicitly refers to the latest version > of that document _in the same Release as the present document_.
[1] 3GPP TS 33.220: \"Generic Authentication Architecture (GAA); Generic
bootstrapping architecture\".
[2] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[3] 3GPP TS 33.223: \"Generic Authentication Architecture (GAA); Generic
bootstrapping architecture: Push Function\"
[4] 3GPP TS 33.222: \"Generic Authentication Architecture (GAA); Access to
network application functions using Hypertext; Transfer Protocol over
Transport Layer Security (HTTPS)\"
[5] FIPS PUB 180-2 (2002): \"Secure Hash Standard\".
[6] IETF RFC 2104 (1997): \"HMAC: Keyed-Hashing for Message Authentication\".
[7] ISO/IEC 10118-3:2004: \"Information Technology -- Security techniques --
Hash-functions -- Part 3: Dedicated hash-functions\".
> [8] NIST Special Publication 800-38A: \"Recommendation for Block Cipher
> Modes of Operation\"
>
> [9] FIPS PUB 197: \"Advanced Encryption Standard\"
[10] OMA-WAP-TS-WSP-V1_0-20020920-C: \"Wireless Session Protocol 1.0\"
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
TR 21.905 [2], TS 33.220 [1] and the following apply.
SN_h The highest received sequence number received in an integrity protected
GPL message used for replay protection.
SN_s A counter used to generate sequence numbers for outgoing messages.
Editor\'s Note: Further definitions to be filled in, if needed.
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in TR 21.905
[2] and the following apply. An abbreviation defined in the present document
takes precedence over the definition of the same abbreviation, if any, in TR
21.905 [2].
GBA Generic Bootstrapping Architecture
GPI GBA Push Information
GPL Generic Push Layer
NAF Network Application Function
KDF Key Derivation Function
MAC Message Authentication Code
SA Security Association
SAID Security Association Identifier
SN Sequence Number
Editor\'s Note: The above list is tentative and needs to be enhanced, if
needed.
# 4 GBA Push layer Requirements
Editor's Note: Further study on the potential implementations needs to be
performed. In S3-070690 one potential implementation was presented and
discussed.
## 4.1 Session concept
It is reasonable to expect that there will exist NAF based services that rely
on some form of per terminal session concept, and which would benefit from
pushing more than one message based on the same security association. An
example could be a virus-signature update server. It is possible that the
virus signatures are delivered in multiple pushed messages (for size
limitation reasons of the underlying push transport mechanism), and it would
then be inefficient to establish a new security association for each message.
This requires that the generic secure push layer provides replay protection in
addition to integrity protection (and possibly confidentiality protection).
Figure 4.1-1 depicts the usage scenario, where a secure session with three
push messages are delivered from the NAF to the UE after establishing the
security association to protect them. Note that steps 1 and 2 in Figure 4.1-1
are out of scope for this specification. One way to achieve steps 1 and 2 is
to use TS 33.223 [3].
**Figure 4.1-1:** Example of a secure session
If GPL was to provide a complete session concept including reliability of
delivered messages using timeouts/acknowledges and re-transmissions, re-
establishement of the sessions, re-ordering of messages etc., GPL would be
unnecessarily complex and the size of the GPL messages would be too large for
many applications (e.g., when the underlying transport is SMS). Therefore GPL
shall only provide sufficient session state to ensure that the security of
multiple GPL messages are not compromized. GPL shall hence provide the
security services confidentiality, integrity protection and replay protection
for a GPL session.
If a more complex session concept is required by the application, where the
session concept includes services other than security services, then, e.g.,
WSP [10] could be applied on top of GPL, but this is out of scope for this
specification.
Even though it shall be possible to have a secure one-way channel from the
push NAF to the terminal (for broadcast only terminals) a return channel _may_
be present. An example of this is OMA\'s location based services, where a
server requests location information from a terminal, which responds with its
location information. This request/response exchange may be repeated every ten
minutes. It is prudent to require that it shall be possible to secure also
such a return channel. The security of the return channel can conveniently be
based on the same security association as the one-way channel.
## 4.2 Requirements
The following requirements shall be posed for the generic secure push layer:
R1: It shall perform encapsulation of generic application layer messages from
the push NAF to the terminal.
R2: It shall allow sending multiple messages based on the same security
association.
R3: Integrity protection and confidentiality protection shall be possible to
provide for the messages. Integrity protection is mandatory to apply, while
confidentiality protection is optional to apply.
R4: Detection of replayed messages within the same session shall be possible.
R5: If uplink messages are present in the application protocol, it shall be
possible to apply the same level of protection to these messages, based on
keys derived from the Ks(_ext/int)_NAF.
# 5 GPL Processing
## 5.1 Processing Model
GPL is located between the transport mechanism (which could eg. be SMS, IP,
IP/UDP) and the application.
When receiving a GPL protected message, the recipient transfers the message to
the GPL. How the recipient knows that the message is a GPL message is up to
each transport mechanism to define. It could be through, e.g., a special
application ID that is tagged onto the message, in which case a GPL
application ID needs to be defined.
After GPL processing is complete, the message is delivered to the transport
layer again. This time around the GPL application ID and GPL related data is
removed from the message, and what remains is a regular application data
message (which is routed to the intended application using the transport
layers normal dispatching mechanism). The processing model is depicted in
Figure 5.1-1.
{width="5.059027777777778in" height="3.3965277777777776in"}
Figure 5.1-1: The processing model for the generic push layer for GPL agnostic
applications. Inbound processing to the right and outbound processing to the
left.
Applications in a receiver where GPL is used for protection do not have to be
aware of the GPL. In particular, any legacy application can use the GPL for
protection without any modifications in the UE. One possibility is that the
transport mechanism is configured to protect messages for the application, and
in this case the application does not need to be aware of GPL as indicated in
the figure. Another possibility is that, for an application which wishes to
protect messages, it may be necessary to be aware of the GPL. The reason for
this is that the application needs to inform the GPL about which security
association to use for the message (i.e., the application calls the GPL module
directly, and the GPL module may either pass the GPL encapsulated message to
the transport mechanism, or return it to the application).
## 5.2 Session Start
A session is considered started in one peer when a GPL Security Association
(SA) is configured. For the NAF, this means that the session shall be
considered initiated as soon as it has received the GPI from the BSF and
configured the NAF SA (see [3]) and corresponding GPL-SA. For the UE, the
session shall be considered started when it has received a GPI and configured
its GPL-SA.
In addition to the GPI, the GPL module needs to get GPL policy information for
the session, e.g., which encryption and integrity algorithms to use etc. The
policy information may be decided by the application itself or by some other
management entity.
When a GPI is delivered together with a GPL message (combined delivery), the
sender shall choose the policy to use for the downlink messages and it shall
be included in the GPL message. The NAF shall in this case chose a cipher
suite for downlink GPL messages, life-time for the NAF SA (and hence
implicitly for the downlink and possible uplink GPL-SA), SAID for the downlink
GPL-SA and SAID for the uplink GPL-SA (if required) etc, and the UE shall (in
case an uplink is present) choose the cipher suite for the uplink. It is
recommended that the UE chooses the same cipher suite for the uplink as the
NAF chose for the down link.
## 5.3 Session Termination
Sessions are not explicitly terminated, i.e., there is no specific GPL message
for closing a session. A GPL-SA life time is kept by each peer and when that
time is reached, the GPL-session is over and the NAF-SA, corresponding
downlink GPL-SA and corresponding uplink GPL-SA (if it exists) shall be
deleted.
Editor\'s Note: It is FFS what the lifetime of the session shall be. It could,
e.g., be the same as the lifetime for the Ks or the Ks_(ext/int)_NAF.
## 5.4 GPL Security Association
A GPL security association (GPL-SA) is the data kept by each peer required for
processing of either inbound or outbound GPL messages. That is, in case there
is a bi-directional communication link, each peer shall keep two GPL-SAs, one
for the inbound traffic, and one for the outbound traffic.
The GPL-SA shall be derived from a NAF SA (see TS 33.223 [3] for further
information on NAF SAs). A GPL-SA shall be deleted by the NAF and the UE if
the corresponding NAF SA is deleted and vice versa.
Each GPL-SA shall be associated with an identifier, the SAID, which shall be
unique for each GPL-SA within the GPL module. This means that the same SAID
refers to two different GPL-SAs if one of the GPL-SAs is inbound (at the
receiver) and the other is outbound (at the sender).
The GPL-SA contains at least the following items:
**SAID:** An identity which uniquely identifies the GPL-SA with the GPL-
module.
**Master key:** A 256-bit key used as master key for the key derivations of
integrity and encryption keys.
**SN_h:** The highest received sequence number received in an integrity
protected GPL message used for replay protection. This state-variable is only
used in an inbound GPL-SA.
**SN_s:** A counter used to generate sequence numbers for outgoing messages.
The counter shall be increased for each message output. This state-variable is
only used in an outbound GPL-SA.
**Cipher suite:** The cipher suite used for protection of messages. A cipher
suite shall consist of one integrity protection algorithm, one encryption
algorithm, and one key derivation algorithm.
**Key Indication ID:** It indicates which type of NAF key should be used (
Ks_ext_NAF or Ks_int_NAF) in GBA_U case.
NOTE: The type of the key could already be known by the type of the
application (ME/UICC). The sender of the GPL message has to ensure that the
use of this indication is consistent with such information.
**Life-time of the GPL-SA:** This is the expiry time of the GPL-SA in the same
time format as used for the Ks-life time in GBA. The life-time of the GPL-SA
shall be the same as the life-time of the corresponding NAF SA.
## 5.5 Message Format
### 5.5.1 Data Unit Transfer Format
A GPL message is laid out as shown in Figure 5.5.1-1. The GPL message
encapsulates an application message in the GPL payload, and protects the
message.
Figure 5.5.1-1: Format of a GPL message
Each field is encoded in network byte order (i.e., big endian) and with the
most significant bit being bit number zero. All fields are octet aligned. The
fields of the message are the following.
**Ver (4 bits):** The version of the GPL protocol encoded as an integer. The
version of any message conforming to this specification shall use the value 1,
i.e., the first nibble of the message is 0x1.
**Reserved (3 bits):** These bits are reserved for future versions of this
specification. Implementations conforming to this specification shall set
these bits to zero before transmitting a message, and the receiver of the
message shall ignore these bits.
**SN (16 bits):** The sequence number used for synchronizing the encryption
and providing replay-protection.
**Cipher suite (8 bits):** The cipher suite used for protection of the
message. The cipher suite consists of one integrity protection algorithm, one
encryption algorithm, and one key derivation algorithm.
**Key Indication ID(1 bits):** It indicates which type of NAF-keys should be
used in GBA_U case. When Key indication ID equals to 1, it means Ks_ext_NAF
should be used. When Key indication ID equals to 0, it means Ks_int_NAF should
be used. Key Indication ID shall be ignored by the UE in case of GBA-ME.
**SAID length (8 bits):** The length of the SAID in number of octets.
**SAID (variable length):** The identity of the GPL security association used
for protection of the message.
**MAC (variable length):** The message authentication code providing integrity
protection of the message. The length of this field is determined by the size
of the output of the integrity protection algorithm used, but shall be a
multiple of 8 bits.
**GPL Payload (variable length):** The actual application message that is
protected. The length of the message shall be a multiple of 8 bits, and must
be padded by the application unless this condition is met. Any such padding is
up to the application and is out of scope for this specification.
**Padding (variable length):** Padding as required by the encryption
transform. Exactly how the padding is generated, verified and removed is
defined by each encryption transform. In case the encryption transform does
not require padding, this field is not present.
## 5.6 Inbound processing
Editor\'s Note: It is FFS if improvement of the processing steps is needed.
Before processing of any inbound GPL message, the GPL module initiates the
GPL-SA. The initialization consists of the following steps:
  1. Set the highest received sequence number SN_h equal to zero.
  2. Set the master key equal to the master key received from the SA establishment procedure.
When a GPL message arrives at the receiver\'s GPL module, the following
processing steps shall be taken:
  1. Verify that the version field in the GPL header is equal to 1. If this is not the case the message shall be discarded and the processing shall stop.
  2. Verify that the cipher-suite indicated in the GPL-message is supported. If this is not the case the message shall be discarded and the processing shall stop.
  3. Retrieve the GPL-SA which corresponds to the SAID in the GPL header. If no GPL-SA matching the SAID is found, the message shall be discarded and the processing shall stop.
  4. Verify that the sequence number carried in the SN field has not yet been received. One way of accomplishing this is to verify that the sequence number in the SN field is larger than the currently highest received sequence number SN_h. If this is not the case, the message shall be discarded and the processing shall stop. When SN_h is equal to 0xffff, all messages with the given SAID shall be discarded and the processing shall stop. It is not mandatory to implement this particular replay mechanism (which is not robust against message reordering), but the receiver\'s GPL module shall verify that the sequence number in the SN field has not been received before in a valid message.
  5. Compute a MAC using the integrity algorithm indicated by the cipher suite. The MAC is computed over the entire GPL-message, and during the computation, the MAC field shall be treated as containing all zeros. After MAC is computed, it shall be compared to the MAC carried in the MAC field. If the two MACs differ, the message shall be discarded and the processing shall stop.
  6. Update the replay protection state. In case the mechanism described in step 3 is used, the state-variable SN_h is set equal to the SN read from the GPL header.
  7. Decrypt the message using the decryption transform indicated by the cipher suite field and remove possible padding from the message.
  8. Return the payload of the GPL message (i.e., what remains after removing the GPL header and possible padding) to the transport mechanism the message was received from.
If the processing is stopped by the GPL module before the full processing is
complete an error indication may be returned from the GPL module.
## 5.7 Outbound processing
Before processing of any outbound GPL message, the GPL module initiates the
GPL-SA. The initialization consists of the following steps:
  1. Set the sequence number counter SN_s equal to one.
  2. Set the master key equal to the master key received from the SA establishment procedure.
When an application message arrives at the sender\'s GPL module, the following
processing steps shall be taken:
  1. If SN_s is equal to 0xffff, the processing shall stop and an error indication shall be returned from the GPL module.
  2. Fill in the version number 1 in the Ver field of the GPL header. Fill in the cipher suite value as defined by the GPL-SA in the GPL header. Copy the state-variable SN_s to the SN field of the GPL header. Fill in the SAID field of the GPL header with the SAID of the GPL-SA indicated by the caller of the GPL module.
  3. Retrieve the GPL-SA which corresponds to the SAID as indicated by the caller of the GPL module. If no GPL-SA is found, the processing shall stop.
  4. Encrypt the message using the encryption transform defined by the GPL-SA and if needed add padding to the message.
  5. Set the MAC field of the GPL header to zero and compute a MAC over the entire GPL message using the integrity transform defined by the GPL-SA. Copy the resulting MAC to the MAC field of the GPL header.
  6. Increase the state-variable SN_s by one.
  7. Return the GPL protected message to the caller of the GPL module.
If the processing is stopped by the GPL module before the full processing is
complete an error indication may be returned from the GPL module.
## 5.8 Interworking with GBA Push
### 5.8.1 Initialization of GPL-SA from a NAF SA
#### 5.8.1.1 General
A NAF SA shall be associated with one downlink GPL-SA and may be associated
with an uplink GPL-SA. The NAS SA is defined in TS 33.223 [3]. See that
specification for the definitions of the fields of the NAS SA that are
assigned to the corresponding fields of the GPL-SA.
#### 5.8.1.2 Initialization of downlink GPL-SA from a NAF SA
The NAF shall initialize the downlink GPL-SA from the corresponding NAF SA
before sending the first GPL message to the UE. The NAF shall:
  * Set the GPL-SA SAID equal to the NAF SA\'s DL_SA_Id.
  * Set the GPL-SA master key equal to External NAF-key or Ks_int_NAF according to the NAF SA.
  * Set the GPL-SA SN_s equal to 1.
  * Set the life-time of the GPL-SA equal to the life-time of the NAF SA.
  * Set the cipher suite and key indication ID according to the applications policy.
The UE shall initialize the downlink GPL-SA from the corresponding NAF SA when
the NAS FA has been established (e.g., after processing a GPI). The UE shall:
  * Set the GPL-SA SAID equal to the NAF SA\'s DL_SA_Id.
  * Set the GPL-SA master key equal to External NAF-key or Ks_int_NAF according to the NAF SA.
  * Set the GPL-SA SN_h equal to 0.
  * Set the life-time of the GPL-SA equal to the life-time of the NAF SA.
  * Set the cipher suite and key indication ID according to the applications policy.
#### 5.8.1.3 Initialization of uplink GPL-SA from a NAF SA
If the application requires an uplink GPL-SA, the NAF shall initialize the
uplink GPL-SA from the corresponding NAF SA before processing the first uplink
GPL message from the UE. The NAF shall:
  * Set the GPL-SA SAID equal to the NAF SA\'s UL_SA_Id.
  * Set the GPL-SA master key equal to External NAF-key or Ks_int_NAF according to the NAF SA.
  * Set the GPL-SA SN_h equal to 0.
  * Set the life-time of the GPL-SA equal to the life-time of the NAF SA.
  * Set the cipher suite and key indication ID according to the applications policy.
The UE shall initialize the uplink GPL-SA from the corresponding NAF SA after
the NAF SA has been established (e.g., after processing a GPI) and before
sending the first uplink GPL message to the NAF. The UE shall:
  * Set the GPL-SA SAID equal to the NAF SA\'s UL_SA_Id.
  * Set the GPL-SA master key equal to External NAF-key or Ks_int_NAF according to the NAF SA.
  * Set the GPL-SA SN_s equal to 1.
  * Set the life-time of the GPL-SA equal to the life-time of the NAF SA.
  * Set the cipher suite and key indication ID according to the applications policy.
### 5.8.2 Combined delivery
Editor\'s Note: TBD
## 5.9 Cipher suites
The following cipher suites are defined for use with GPL:
**Cipher suite 1:**
**ID:** 0x01
**Encryption algorithm: CTR-** AES128 as specified in [8] and [9]. The start
value T~1~ for the counter shall be equal to GPL-IV as defined further down in
this clause. The standard incrementing function is used with m=16, according
to appendix B in [8], i.e. the 16 least significant bits in T behave like a
counter while the 112 most significant bits are static and equal the 112 most
significant bits of the GPL-IV.
**Integrity protection algorithm:** HMAC-SHA256-32 as specified in [5], [6]
and [7]. The MAC is hence 32 bits long.
**Key derivation function:** As specified in TS 33.220 Annex B. The input to
the KDF is the 256-bit master key and the string S~1~ defined by:
  * FC = **TBD**
Editor\'s Note: A separate FC value needs to be registered in TS 33.220. GPL
requires only one FC value and will manage GPL internal key separation using
string constants in (P0, L0).
  * P0 = key-purpose
  * L0 = length of the string key-purpose as a 16-bit integer.
  * P1 = direction indicator
  * L1 = length of direction indicator (i.e., 0x00 0x01)
  * P2 = cipher suite ID
  * L2 = length of cipher suite ID (i.e., 0x00 0x01)
The key-purpose string shall be \"gba-push-enc\" for encryption keys and
\"gba-push-int\" for integrity keys. The 128 least significant bits of the KDF
output are used as key bits.
In case of bi-directional usage of GPL there is a need for two pairs of GPL-
SAs, one for each direction. The direction indicator shall be set accordingly
for the pair. The direction indicator shall be 0x00 for the GPL-SA protecting
messages from the NAF to the UE and 0x01 for messages sent from the UE to the
NAF (if such an SA is required by the application).
The initialization vectors for GPL (GPL-IVs) for CTR-AES128 shall be
constructed as follows:
SN \|\| 000...0,
where SN is the 16-bit sequence number for the GPL message. The IV is then
padded on the right with zeroes so that the resulting string is 128-bits long.
**Cipher suite 2:**
**ID:** 0x02
Cipher suite 2 shall be exactly as cipher suite1 with the only difference that
the MAC shall be defined as:
**Integrity protection algorithm:** HMAC-SHA256-64
###### ## Annex A (informative): Use cases
# A.1 Generic Push Layer - use case for terminals without a return channel
This clause describes a use case, how an application could make use of GBA
Push.
The goal of the application is to be able to securely push a message from an
application server (implemented in a push NAF) to a terminal. For example, the
push NAF pushes a message to a UE, including the latest virus-signatures. This
is a case which can be of interest for terminals without a return channel,
e.g., pure broadcast terminals.
This functionality can be separated into two distinct phases: establishment of
the security association between the push NAF and the terminal, and the
protection of the message. The security association contains keys derived from
the Ks_(ext/int)_NAF. The two phases are depicted in Figure A-1, where phase 1
includes steps (1) and (2), and phase 2 includes step (3). The security
associations are established between the push NAF and the UE as a result of
phase 1.
The establishment of the security association boils down to establishment of
the Ks, followed by establishment of the Ks_(ext/int)_NAF. Depending on the Ks
model this may be done in one procedure, but this is out of scope for this use
case.
When it comes to the protection of the actual message that is to be pushed
there are two options, either the push is a one-time occurrence, or the
concept of a session can be introduced. A session would here mean that a
secure one-way communication channel is established between the push NAF and
the terminal. The first phase is out of scope for this specification, which
only deals with the second phase.
**Figure A.1-1:** The two phases involved in securely pushing a message to a
UE from an application server
# A.2 Specific use cases
## A.2.1 Network initiated NAF Key Refesh and Distribution of Keys
This use case is related to key distribution to terminals that receive
broadcasted content and need a key be able to render the content and to key
refresh for an existing security association. Keys could be pushed to the
terminal at regular intervals to avoid having long-lived keys in the system.
As the push message could be sent out over the broadcast system a back channel
cannot be assumed to be available in all cases.
Services that have not their inbuild key refresh mechanism (e.g. like MBMS)
may want to push a new security association to a user. The reasons for that
might be continuous user service experience (e.g. keys expire during some
critical time period), to spread load evenly on the network side or there is
some maintenance in the network at the time of expiry (e.g. on the NAF to BSF
connection which causes reduced bandwidth). The maximum Ks lifetime is known
by the BSF and the NAF, if the NAF desires a fresh key (because it expires or
for NAF policy reasons) it can proactively push a new security association to
the UE.
Characteristics:
  * Some UE's require the security association to be established at a predefined time before the old key expires
  * There exists already a Ua security association, for the case where the keys are refreshed.
  * The service consumption may occur much later then the security provisioning.
  * The old NAF keys might be NAF keys generated in a GBA run according to TS 33.220 or in a GBA Push run.
  * GBA_ME must be supported and GBA_U support might be needed, but not for OMA BCAST and MBMS, since those have their own inbuild refresh solution. Nevertheless, GBA Push might be useful for MBMS.
## A.2.2 Distribution of Tokens
This use case is very similar to the key distribution case except for one
important difference and that is that the token should be presented to the
service provider over an IP connection. Thus, it can be assumed that a back-
channel exists and that this back channel could be used to report the success
of a GBA Push. On the other hand, the usefulness of the solution would be
diminished if delivery of the tokens only was allowed to take place to
terminals that are on-line, which would be required to get a timely success
report and exclude use of deferred delivery channels.
## A.2.3 MBMS GBA_U Use Case
GBA PUSH could be useful for MBMS.
GBA was created to secure MBMS and to allow UICC-based solution by means of
GBA_U. In case of use of GBA PUSH for MBMS, it should be possible to send GBA
PUSH messages protected by means of keys stored on the UICC, i.e. Ks_int_NAF-
related keys. GBA PUSH solution shall support GBA_U.
## A.2.4 OMA related Use Cases
OMA BCAST provided use-cases for GBA PUSH. One of this use-case is OMA BCAST
smart card profile, which requires GBA PUSH solution with endpoint in the
UICC. Consequently, GBA PUSH solution shall support GBA_U. In particular, OMA
provided the following information:
\"**_The smart card based service protection profile uses MBMS GBA mechanisms
for registration and long term key delivery. It would be advantageous to also
for this profile have network initiated registration and delivery of long term
keys. A secure GBA PUSH mechanism would enable such a solution._** \"
Others OMA use-cases could rely on GBA_U-based GBA PUSH solution. E.g. OMA SEC
group identified GBA PUSH-based key management as a good enhancement for
future device management and client provisioning releases. This GBA PUSH
solution could rely on Ks_ext_NAF/Ks_int_NAF keys to reinforce the security.
But, for those use-cases, there is no OMA requirement mandating that GBA PUSH
solution shall address the case of endpoint in the UICC.
## A.2.5 Network Initiated Services
There are quite a number of services that are initiated from the network,
which require that the terminal connects to a server in the network. Examples
of OMA defined enablers having this modus operandi are e.g. Device Management
(DM), Download DRM (DLDRM), DRM, and Secure User Plane Location (SUPL). In all
these cases it is assumed that the triggering push message can be sent over
SMS.
Having an efficient secure push system would allow greater flexibility as
trusted parameters and keys could be sent in the trigger and provisioned
parameters like server and sender white-lists could be avoided. Furthermore, a
secure push would also allow protection against replay and DoS attacks.
As the services require that the terminal connects to the network there is a
back-channel in these use cases. When the terminal connects to the server, the
initiating NAF will implicitly receive a confirmation that a GBA Push has
succeeded. The success could then be reported by the server to the BSF via the
NAF.
A special case of a network initiated service is the case, where the operator
may want to update securely information on the terminal e.g. device management
or client provisioning. The UE has not contacted the operator before and hence
can not be securely triggered to bootstrap (i.e. usage of SMS or WAP Push).
The device management information should be pushed in a secure manner to the
UE and the pushing may occur at a fixed point of time or during a pre-defined
period. It must be ensured that the originator of the management message is
authorized and that only the correct terminal can utilize the data.
Characteristics:
  * The usage of the transferred information (called management message) to the UE may occur directly after the provisioning.
  * Source of the management message must be identifiable i.e. the NAF
  * Only authorized recipients of the management message should be able to utilize it.
  * Security association establishment (Upa) and delivery of the management message (Ua) might not occur together. Operator may want to send several messages secured by the same SA.
  * Management information is targeted for the terminal, hence Ks_NAF support is sufficient.
## A.2.6 BSF and HSS Load Balancing for Broadcast
GBA is used for MBMS and OMA BCAST. The main advantage of broadcast is that
many devices can be served with content at the same time. Typical broadcast
scenarios include soccer games, olympics, eurovision contest and other events
of general interest. If a majority of the UE make the GBA bootstrapping run
just before the event starts, then the BSF server and the HSS have to deal
with a large load. Therefore it seems desirable, that the network can trigger
the registration and delivery of the long term keys and many UEs can be
provisioned with GBA credentials (NAF keys) at times, where the BSF is having
a low load e.g. the night before the event. The receiving terminal also
supports GBA and in case, that it receives a broadcast message, for which no
security association is available, then it start a GBA run according to TS
33.220.
Characteristics:
\- Many UE's that require a security association at a specific time for
service consumption.
> \- If GBA Push and GBA sessions according to TS 33.220 are managed together,
> then BSF can re-use Ks that was created for GBA Push for the GBA run
> according to TS 33.220. This also may work the other way around, that the Ks
> that has been established according to TS 33.220 could be used for GBA Push.
> If there is no uplink channel then this re-usage can not take place.
>
> \- It may be possible that there in no uplink channel available or it is
> undesired (due to network load) that many UE\'s make an uplink access at
> almost the same time (in the same area).
\- The service consumption may occur much later then the security
provisioning.
> \- Terminal should also support GBA according to TS 33.220 to allow service
> usage for the case that the SA via GBA Push did not arrive.
\- GBA according to TS 33.220 is used (if supported) only for the case that no
SA was received.
\- The service that needs load balancing may require GBA (TS 33.220) or GBA_U
support from the UE.
## A.2.7 Download of vouchers / tickets
One application that has been discussed is to distribute vouchers/tickets for
different types of public events or collection of physical goods by pushing a
corresponding vouchers/ticket to the customers' mobile phone. The distribution
could be scheduled to take place close in time to when the event starts to
minimize the risk that the voucher/ticket is erased, lost in some other way or
duplicated or it could be distributed well in advance to distribute the load
on the network.
Vouchers/tickets need to be securely delivered to the legitimate receiver as
they usually are not personalized.
If the distribution mechanism is reliable there is no need to report the
reception of the voucher back to the issuer. Even with unreliable delivery
channels reporting back is probably not needed as the user would note that the
ticket has not been delivered and the user could then contact the issuer and
ask for a retransmission.
The consumption of the voucher/ticket can not be used as a reliable means for
reporting the success of the download. There are two reasons for this. The
first one is that the vouchers may be consumed via off-line devices. The
second reason is that the consumption may take place a long time after
delivery.
Note also that this type of use case should work with deferred delivery of the
message containing the voucher/ticket. If the receiver has turned off his
phone, he should receive the message a soon as he turns the phone on again.
## A.2.8 Distribution of news / information / commands
Distribution of news/information/commands, like stock prices or work orders,
to employees need protection, especially integrity protection and source
authentication, but in many cases also confidentiality protection. Such
information should preferably be distributed over a system supporting deferred
delivery to relieve the service provider of having to keep track of the user
status and to make the information available as soon as the user switches on
his terminal.
## A.2.9 Set-top box use-case
It also exists the use-case of set-top box equipped with UICC reader and
without return channel to the network. This use case implies that the GBA PUSH
messages would be protected by means of the UICC.
## A.2.10 Summary
The use cases and their characteristics above give rise to the following
requirements:
(1) There are use cases, where the Ua protocol may terminate in the UICC and
use cases, where it terminates in ME.
(2) GBA Push should support both GBA_ME and GBA_U.
(3) Separate delivery of Ua and Upa messages should be supported.
(4) The Upa bootstrapping should be able to support unidirectional message
delivery (e.g. Upa over broadcast).
Editor\'s note: There are several use-cases to push GBA PUSH protected
messages towards the UICC: OMA BCAST smart card profile, MBMS, set-to box use-
cases. Hence, GBA PUSH shall support GBA_U.
#
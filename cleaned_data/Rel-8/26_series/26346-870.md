# Foreword
This Technical Specification has been produced by the 3^rd^ Generation
Partnership Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
MBMS is a point-to-multipoint service in which data is transmitted from a
single source entity to multiple recipients. Transmitting the same data to
multiple recipients allows network resources to be shared.
The MBMS bearer service offers two modes:
  * Broadcast Mode.
  * Multicast Mode.
MBMS user services can be built on top of the MBMS bearer service. Further,
the MBMS User Services may use other UMTS bearer services to deliver data. The
present document specifies two delivery methods for the MBMS user services:
download and streaming. Examples of applications using the download delivery
method are news and software upgrades. Delivery of live music is an example of
an application using the streaming delivery method.
There can be several MBMS user services. The objective of the present document
is the definition of a set of media codecs, formats and transport/application
protocols to enable the deployment of MBMS user services. The present document
takes into consideration the need to maximize the reuse of components of
already specified services like PSS and MMS.
# 1 Scope
The present document defines a set of media codecs, formats and
transport/application protocols to enable the deployment of MBMS user services
either over the MBMS bearer service or other UMTS Bearer Services within the
3GPP system.
In this version of the specification, only MBMS download and streaming
delivery methods are specified. The present document does not preclude the use
of other delivery methods.
The present document includes information applicable to network operators,
service providers and manufacturers.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or non‑specific.
  * For a specific reference, subsequent revisions do not apply.
  * For a non-specific reference, the latest version applies. In the > case of a reference to a 3GPP document (including a GSM document), > a non-specific reference implicitly refers to the latest version > of that document _in the same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 22.146: \"Multimedia Broadcast/Multicast Service; Stage 1\".
[3] 3GPP TS 22.246: \"Multimedia Broadcast/Multicast Service (MBMS) user
services; Stage 1\".
[4] 3GPP TS 23.246: \"Multimedia Broadcast/Multicast Service (MBMS);
Architecture and functional description\".
[5] 3GPP TS 25.346: \"Introduction of Multimedia Broadcast/Multicast Service
(MBMS) in the Radio Access Network (RAN); Stage 2\".
[6] IETF STD 0064/RFC 3550 (July 2003): \"RTP: A Transport Protocol for Real-
Time Applications\", H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson.
[7] IETF STD 0006/RFC 0768 (August 1980): \"User Datagram Protocol\", J.
Postel.
[8] IETF STD 0005/RFC 0791 (September 1981): \"Internet Protocol\", J. Postel.
[9] IETF RFC 3926 (October 2004): \"FLUTE - File Delivery over Unidirectional
Transport\", T. Paila, M. Luby, R. Lehtonen, V. Roca, R. Walsh.
[10] IETF RFC 3450 (December 2002): \"Asynchronous Layered Coding (ALC)
Protocol Instantiation\", M. Luby, J. Gemmell, L. Vicisano, L. Rizzo, J.
Crowcroft.
[11] IETF RFC 3451 (December 2002): \"Layered Coding Transport (LCT) Building
Block\", M. Luby, J. Gemmell, L. Vicisano, L. Rizzo, M. Handley, J. Crowcroft.
[12] IETF RFC 5052 (August 2007): \"Forward Error Correction (FEC) Building
Block\", M. Luby, M. Watson, L. Vicisano.
[13] IETF RFC 3695 (February 2004): \"Compact Forward Error Correction (FEC)
Schemes\", M. Luby, L. Vicisano.
[14] IETF RFC 4566 (July 2006): \"SDP: Session Description Protocol\", M.
Handley, V. Jacobson and C. Perkins.
[15] IETF RFC 4570 (July 2006): \"Session Description Protocol (SDP) Source
Filters\", B. Quinn, R. Finlayson.
[16] Void.
[17] IETF RFC 3048 (January 2001): \"Reliable Multicast Transport Building
Blocks for One-to-Many Bulk-Data Transfer\", B. Whetten, L. Vicisano, R.
Kermode, M. Handley, S. Floyd, M. Luby.
[18] IETF RFC 2616 (June 1999): \"Hypertext Transfer Protocol -- HTTP/1.1\".
[19] IETF STD 0066/RFC 3986 (January 2005): \"Uniform Resource Identifier
(URI)\".
[20] 3GPP TS 33.246: \"3G Security; Security of Multimedia Broadcast/Multicast
Service (MBMS)\".
[21] OMG: \"Unified Modeling Language (UML), version 1.5\" (formal/03-03-01).
[22] W3C Recommendation 28 October 2004: \"XML Schema Part 2: Datatypes Second
Edition\".
[23] IETF RFC 5234 (January 2008): \"Augmented BNF for Syntax Specifications:
ABNF\", D. Crocker and P. Overell.
[24] 3GPP TS 26.290: \"Audio codec processing functions; Extended Adaptive
Multi-Rate - Wideband (AMR-WB+) codec; Transcoding functions\".
[25] 3GPP TS 26.304: \"Floating-point ANSI-C code for the Extended Adaptive
Multi-Rate - Wideband (AMR-WB+) codec\".
[26] 3GPP TS 26.273: \"Speech codec speech processing functions; Extended
Adaptive Multi-Rate - Wideband (AMR-WB+) speech codec; Fixed-point ANSI-C
code\".
[27] Void.
[28] 3GPP TS 26.401: \"General audio codec audio processing functions;
Enhanced aacPlus general audio codec; General description\".
[29] 3GPP TS 26.410: \"General audio codec audio processing functions;
Enhanced aacPlus general audio codec; Floating-point ANSI-C code\".
[30] 3GPP TS 26.411: \"General audio codec audio processing functions;
Enhanced aacPlus general audio codec; Fixed-point ANSI-C code\".
[31] W3C Recommendation 04 February 2004: \"Extensible Markup Language (XML)
1.1\", T. Bray, J. Paoli, C. Sperberg-McQueen, E. Maler, F. Yergeau and J.
Cowan.
[32] 3GPP TS 26.244: \"Transparent end-to-end streaming service; 3GPP file
format (3GP)\".
[33] IETF RFC 4867 (April 2007): \"RTP Payload Format and File Storage Format
for the Adaptive Multi-Rate (AMR) and Adaptive Multi-Rate Wideband (AMR-WB)
Audio Codecs\", J. Sjoberg, M. Westerlund, A. Lakaniemi, Q. Xie.
[34] IETF RFC 4352 (January 2006): \"RTP Payload Format for the Extended
Adaptive Multi-Rate Wideband (AMR-WB+) Audio Codec\", Sjoberg J. et al.
[35] IETF RFC 3984 (February 2005): \"RTP payload Format for H.264 Video\", S.
Wenger, M.M. Hannuksela, T. Stockhammer, M. Westerlund, D. Singer.
[36] Void.
[37] IETF RFC 2557 (March 1999): \"MIME Encapsulation of Aggregate Documents,
such as HTML (MHTML)\", J. Palme, A. Hopmann, N. Shelness.
[38] IETF RFC 3890 (September 2004): \"A Transport Independent Bandwidth
Modifier for the Session Description Protocol (SDP)\", M. Westerlund.
[39] IETF RFC 3556 (July 2003): \"Session Description Protocol (SDP) Bandwidth
Modifiers for RTP Control Protocol (RTCP) Bandwidth\", S. Casner.
[40] 3GPP TS 24.008: \"Mobile radio interface Layer 3 specification; Core
network protocols; Stage 3\".
[41] IETF RFC 3640 (November 2003): \"RTP Payload Format for Transport of
MPEG-4 Elementary Streams\", J. van der Meer, D. Mackie, V. Swaminathan, D.
Singer, P. Gentric.
[42] IETF RFC 1952 (May 1996): \"GZIP file format specification version 4.3\",
P. Deutsch.
[43] ITU-T Recommendation H.264 (03/2009): \"Advanced video coding for generic
audiovisual services\" \| ISO/IEC 14496-10 (2009): \"Information technology -
Coding of audio-visual objects - Part 10: Advanced Video Coding\".
[44] Void.
[45] ITU-T Recommendation H.263 (1998): \"Video coding for low bit rate
communication\".
[46] ITU-T Recommendation H.263 - Annex X (04/01): \"Annex X: Profiles and
levels definition\".
[47] 3GPP TS 26.234: \"Transparent end-to-end streaming service; Protocols and
codecs\".
[48] 3GPP TS 26.071: \"AMR speech codec; General description\".
[49] 3GPP TS 26.090: \"AMR speech codec; Transcoding functions\".
[50] 3GPP TS 26.073: \"AMR speech Codec; C-source code\".
[51] 3GPP TS 26.104: \"ANSI-C code for the floating-point Adaptive Multi-Rate
(AMR) speech codec\".
[52] 3GPP TS 26.171: \"AMR speech codec, wideband; General description\".
[53] 3GPP TS 26.190: \"Mandatory Speech Codec speech processing functions AMR
Wideband speech codec; Transcoding functions\".
[54] 3GPP TS 26.173: \"ANCI-C code for the Adaptive Multi Rate - Wideband
(AMR-WB) speech codec\".
[55] 3GPP TS 26.204: \"ANSI-C code for the floating-point Adaptive Multi-Rate
Wideband (AMR‑WB) speech codec\".
[56] Scalable Polyphony MIDI Specification Version 1.0, RP-34, MIDI
Manufacturers Association, Los Angeles, CA, February 2002.
[57] Scalable Polyphony MIDI Device 5-to-24 Note Profile for 3GPP Version 1.0,
RP-35, MIDI Manufacturers Association, Los Angeles, CA, February 2002.
[58] \"Standard MIDI Files 1.0\", RP-001, in \"The Complete MIDI 1.0 Detailed
Specification, Document Version 96.1\", The MIDI Manufacturers Association,
Los Angeles, CA, USA, February 1996.
[59] Mobile DLS, MMA specification v1.0, RP-41 Los Angeles, CA, USA. 2004.
[60] Mobile XMF Content Format Specification, MMA specification v1.0, RP-42,
Los Angeles, CA, USA. 2004.
[61] ITU-T Recommendation T.81 (1992) \| ISO/IEC 10918-1:1993: \"Information
technology - Digital compression and coding of continuous-tone still images -
Requirements and guidelines\".
[62] C-Cube Microsystems (September 1992): \"JPEG File Interchange Format\",
Version 1.02.
[63] CompuServe Incorporated (1987): \"GIF Graphics Interchange Format: A
Standard defining a mechanism for the storage and transmission of raster-based
graphics information\", Columbus, OH, USA. See at
http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/GIF87a.txt.
[64] CompuServe Incorporated (1990): \"Graphics Interchange Format: Version
89a\", Columbus, OH, USA.
[65] IETF RFC 2083 (March 1997): \"PNG (Portable Networks Graphics)
Specification Version 1.0\", T. Boutell.
[66] **W3C Working Draft 27 October 2004: \"** Scalable Vector Graphics (SVG)
1.2\", http://www.w3.org/TR/2004/WD-SVG12-20041027/.
[67] W3C Working Draft 13 August 2004: \"Mobile SVG Profile: SVG Tiny, Version
1.2\", http://www.w3.org/TR/2004/WD-SVGMobile12-20040813/.
[68] Standard ECMA-327 (June 2001): \"ECMAScript 3rd Edition Compact
Profile\".
[69] WAP Forum Specification (Octobeer 2001): \"XHTML Mobile Profile\",
http://www.openmobilealliance.org/tech/affiliates/wap/wap-277-xhtmlmp-20011029-a.pdf.
[70] ISO/IEC 10646-1 (2000): \"Information technology - Universal Multiple-
Octet Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual
Plane\".
[71] The Unicode Consortium: \"The Unicode Standard\", Version 3.0 Reading,
MA, Addison-Wesley Developers Press, 2000, ISBN 0-201-61633-5.
[72] 3GPP TS 26.245: \"Transparent end-to-end Packet switched Streaming
Service (PSS); Timed text format\".
[73] IETF RFC 4646: \"**Tags for the Identification of Languages** \".
[74] ISO 639: \"Codes for the representation of names of languages\".
[75] ISO 3166: "_Codes for the representation of names of countries and their
subdivisions_ ".
[76] Void.
[77] 3GPP TS 23.003: "Numbering, addressing and identification"
[78] IETF RFC 1305 (March 1992): \"Network Time Protocol (Version 3)
Specification, Implementation\".
[79] OMA Push OTA Protocol (25-April-2001): WAP-235-PushOTA-20010425-a
http://www.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-235-pushota-20010425-a.pdf
[80] IETF RFC 3711 (March 2004): \"The Secure Real-time Transport Protocol
(SRTP)\", M. Baugher, D. McGrew, M. Naslund, E. Carrara, K. Norrman.
[81] IETF STD065/RFC 3551: \"RTP Profile for Audio and Video Conferences with
Minimal Control\", Schulzrinne H. and Casner S., July 2003.
[82] IETF RFC 4648: \"The Base16, Base32, and Base64 Data Encodings\",
Josefsson S., Ed., October 2006.
[83] IETF RFC 3023: \"XML Media Types\", M. Murata, S. St.Laurent, D. Kohn,
January 2001.
[84] IETF RFC 2030: \"Simple Network Time Protocol (SNTP) Version 4 for IPv4,
IPv6 and OSI\", D. Mills, October 1996.
[85] OMA OMNA Registered PUSH Application ID list
http://www.openmobilealliance.org/tech/omna/omna-push-app-id.htm
[86] 3GPP TR 26.936: "Performance characterization of 3GPP audio codecs".
[87] 3GPP TS 25.413: \"UTRAN Iu interface Radio Access Network Application
Part (RANAP) signalling\".
[88] IETF RFC 2326: \"Real Time Streaming Protocol (RTSP)\", Schulzrinne H.,
Rao A. and Lanphier R., April 1998.
[89] 3GPP TS 26.142: \"Dynamic and Interactive Multimedia Scene\".
[90] \"Service Guide for Mobile Broadcast Services\", Open Mobile Alliance,
OMA-TS-BCAST_ServiceGuide-V1_0, Candidate Version 1.0 -- 29 May 2007.
[91] IETF RFC 5053 (October 2007): "Raptor Forward Error Correction Scheme for
Object Delivery", M. Luby, A. Shokrollahi, M. Watson, T. Stockhammer.
[92] IETF RFC 5285: \"A General Mechanism for RTP Header Extensions\", D.
Singer, H. Desineni, July 2008.
[93] IETF RFC 4396: \"RTP Payload Format for 3rd Generation Partnership
Project (3GPP) Timed Text\", Rey J. and Matsui Y., February 2006.
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply:
**Broadcast session:** See 3GPP TS 22.146 [2].
**Forward Error Correction (FEC):** in the context of MBMS, a FEC mechanism is
used at the application layer to allow MBMS receivers to recover lost SDUs
**FLUTE channel:** equivalent to an ALC/LCT channel\ An ALC/LCT channel is
defined by the combination of a sender and an address associated with the
channel by the sender (RFC 3926 [9]).
**Multicast joining:** See 3GPP TS 22.146 [2].
**Multicast session:** See 3GPP TS 22.146 [2].
**Multimedia Broadcast/Multicast Service (MBMS):** See 3GPP TS 22.146 [2].
**MBMS over a Single Frequency Network: See 3GPP TS 25.346 [5]**
**MBMS user services:** MBMS User Service may use more than one Multimedia
Broadcast/Multicast Service (bearer service) and more than one Broadcast
and/or Multicast session
See 3GPP TS 22.246 [3].
**MBMS user service discovery/announcement:** user service discovery refers to
methods for the UE to obtain the list of available MBMS user services along
with information on the user service and the user service announcement refers
to methods for the MBMS service provider to make the list of available MBMS
user services along with information on the user service available to the UE
**MBMS user service initiation:** UE mechanisms to setup the reception of MBMS
user service data\ The initiation procedure takes place after the discovery of
the MBMS user service
**MBMS delivery method:** mechanism used by a MBMS user service to deliver
content\ An MBMS delivery method uses MBMS bearers in delivering content and
may make use of associated procedures.
**MBMS download delivery method:** delivery of discrete objects (e.g. files)
by means of a MBMS download session
**MBMS streaming delivery method:** delivery of continuous media (e.g. real-
time video) by means of a MBMS streaming session
**MBMS download session:** time, protocols and protocol state (i.e.
parameters) which define sender and receiver configuration for the download of
content files
**MBMS streaming session:** time, protocols and protocol state (i.e.
parameters) which define sender and receiver configuration for the streaming
of content
**RTP Session** : The RTP and RTCP traffic sent to a specific IP multicast
address and port pair (one port each for RTP and RTCP) during the time period
the session is specified to exist. An RTP session is used to transport a
single media type (e.g. audio, video, or text). An RTP session may contain
several different streams of RTP packets using different SSRCs.
**Unicast Bearer Service** : Synonymously used as the term "UMTS Bearer
Services with interactive and/or streaming traffic classes".
## 3.2 Abbreviations
For the purposes of the present document, the following abbreviations apply:
ALC Asynchronous Layered Coding
APN Access Point Name
AVC Advanced Video Coding
BM-SC Broadcast-Multicast - Service Centre
CC Congestion Control
DIMS Dynamic and Interactive Multimedia Scenes
ERT Expected Residual Time
ESI Encoding Symbol ID
FDT File Delivery Table
FEC Forward Error Correction
FLUTE File deLivery over Unidirectional Transport
FMT Feedback Message Type
GGSN Gateway GPRS Support Node
GPRS General Packet Radio Service
IANA Internet Assigned Numbers Authority
IP Internet Protocol
LCT Layered Coding Transport
MBMS Multimedia Broadcast/Multicast Service
MBSFN MBMS over a Single Frequency Network
MIME Multipurpose Internet Mail Extensions
MMS Multimedia Messaging Service
MS Mobile Station
MSK _MBMS Service Key_
_MTK MBMS Traffic Key_
_MUK MBMS User Key_
NTP Network Time Protocol
PDP Packet Data Protocol
PSS Packet-switched Streaming Service
PTM Point To Multipoint
PTP Point To Point
RTP Real-time Transport Protocol
SBN Source Block Number
SCT Sender Current Time
SDP Session Description Protocol
SDU Service Data Unit
SEI Supplemental Enhancement Information
SGSN Serving GPRS Support Node
SNTP Simple Network Time Protocol
TMGI Temporary Mobile Group Identity
TOI Transport Object Identifier
TSI Transport Session Identifier
UDP User Datagram Protocol
UE User Equipment
UML Unified Modelling Language
URI Uniform Resource Identifier
URL Uniform Resource Locator
USD User Service Description
UTC Universal Time Coordinated
XML eXtensible Markup Language
# 4 MBMS system description
## 4.1 MBMS functional layers
Three distinct functional layers are defined for the delivery of MBMS-based
service. They are Bearers, Delivery method and User service. Figure 1 depicts
these layers with examples of bearer types, delivery methods and applications.
> **Bearers:** Bearers provide the mechanism by which IP data is transported.
> MBMS bearers as defined in 3GPP TS 23.246 [4] and 3GPP TS 22.146 [3] are
> used to transport multicast and broadcast traffic in an efficient one-to-
> many manner and are the foundation of MBMS-based services. MBMS bearers may
> be used jointly with unicast PDP contexts in offering complete service
> capabilities.
>
> **Delivery Method:** When delivering MBMS content to a receiving application
> one or more delivery methods are used. The delivery layer provides
> functionality such as security and key distribution, reliability control by
> means of forward-error-correction techniques and associated delivery
> procedures such as file-repair, delivery verification. Two delivery methods
> are defined, namely download and streaming. Delivery methods may be added
> beyond the current release. Delivery methods may use MBMS bearers and may
> make use of point-to-point bearers through a set of MBMS associated
> procedures.
>
> **User service:** The MBMS User service enables applications. Different
> applications impose different requirements when delivering content to MBMS
> subscribers and may use different MBMS delivery methods. As an example a
> messaging application such as MMS would use the download delivery method
> while a streaming application such as PSS would use the streaming delivery
> method.
Figure 1: Functional Layers for MBMS User Service
## 4.2 MBMS User Service Entities
Figure 2 shows the MBMS user service entities and their inter-relations.
Relation cardinality is depicted as well.
Figure 2: Entities and Relations
An MBMS user service is an entity that is used in presenting a complete
service offering to the end-user and allowing him to activate or deactivate
the service. It is typically associated with short descriptive material
presented to the end-user, which would potentially be used by the user to
decide whether and when to activate the offered service.
A single service entity can contain multiple distinct multimedia objects or
streams, which may need to be provided over various MBMS download or MBMS
streaming sessions. A download session or a streaming session is associated
with either an unicast bearer or one or more MBMS bearers and a set of
delivery method parameters specifying how content is to be received on the
mobile side. The MBMS User Service Session may be mapped either on MBMS Bearer
Services or on unicast bearer services.
A set of one or more MBMS bearers can be used for delivering data as part of
an MBMS download or streaming session. As an example, the audio and visual
parts can be carried on separate MBMS bearers. However, it is recommendated to
transfer MBMS download and/or streaming sessions, which belong to the same
MBMS user service on the same MBMS bearer service.
An MBMS bearer (identified by IP multicast address and APN) might be used in
providing data to more than one MBMS download or streaming session (3GPP TS
22.246 [3], clause 5).
## 4.3 MBMS bearer service architecture
The MBMS Bearer Service Architecture is defined in 3GPP TS 23.246 [4]. The
MBMS User Service interfaces to the MBMS system via 3 entities.
  * The BM-SC.
  * The GGSN.
  * The UE.
The BM-SC provides functions for MBMS user service provisioning and delivery
to the content provider. It can also serve as an entry point for IP MBMS data
traffic from the MBMS User Service source.
The GGSN serves as an entry point for IP multicast traffic as MBMS data from
the BM-SC.
## 4.4 Functional Entities to support MBMS User Services
### 4.4.1 MBMS User Service Architecture
Figure 3 depicts the MBMS network architecture showing MBMS related entities
involved in providing MBMS user services.
{width="5.354861111111111in" height="3.2916666666666665in"}
Figure 3: MBMS network architecture model
MBMS User Service architecture is based on an MBMS receiver on the UE side and
a BM-SC on the network side.
The use of the Gmb and Gi interface in providing IP multicast traffic and
managing MBMS bearer sessions is described in detailed in 3GPP TS 23.246 [4].
Details about the BM-SC functional entities are given in figure 4.
{width="6.488194444444445in" height="4.875694444444444in"}
Figure 4: BM-SC sub-functional structure
The Session and Transmission function is further subdivided into the MBMS
Delivery functions and the Associated Delivery functions.
The BM-SC and UE may exchange service and content related information either
over point-to-point bearers or MBMS bearers whichever is suitable. To that end
the following MBMS procedures are provided:
  * User Service Discovery / Announcement providing service description > material to be presented to the end-user as well as application > parameters used in providing service content to the end-user.
  * MBMS-based delivery of data/content from the BM-SC to the UE over IP > multicast or over IP unicast.
\- The data/content is optionally confidentiality and/or integrity protected
\- The data/content is optionally protected by an forward error correction
code
  * Key Request and Registration procedure for receiving keys and key > updates.
  * Key distribution procedures whereby the BM-SC distributes key > material required to access service data and delivered content.
  * Associated Delivery functions are invoked by the UE in relation to > the MBMS data transmission. The following associated delivery > functions are available:
\- File repair for download delivery method used to complement missing data.
\- Delivery verification and reception statistics collection procedures.
The interfaces between internal BM-SC functions are outside the scope of the
present document.
A \"Proxy and Transport function\" may be located between the \"Session and
Transmission Function\" and the GGSN. The \"Proxy and Transport function\" is
transparent to the \"Session and Transmission function\". The "Proxy and
Transport" function is defined in sub-clause 5.1.3 of [4].
### 4.4.1a Content Provider / Multicast Broadcast Source
The Content Provider/Multicast Broadcast Source may provide discrete and
continuous media, as well as service descriptions and control data, to the BM-
SC to offer services at a time. An MBMS User Service may use one or several
MBMS delivery methods simultaneously. The Content Provider/Multicast Broadcast
Source may also be a 3rd Party Content Provider/Multicast Broadcast Source.
The Content Provider/Multicast Broadcast Source function may reside within the
operator\'s network or may be provided from outside the operator\'s network.
The Content Provider/Multicast Broadcast Source can also configure the Session
and Transmission functions (e.g. delivery or associated delivery). The
interface between the Content Provider/Multicast Broadcast Source and the BM-
SC is outside the scope of the present document.
### 4.4.2 MBMS Key Management Function
The MBMS Key Management function is used for distributing MBMS keys (Key
Distribution subfunction) to authorized UEs. Before the UE can receive MBMS
keys, the UE needs to register to the Key Request subfunction of the Key
Management function by indicating the MBMS User Service Id. Once registered,
the UE can request missing MBMS keys from the BM-SC by indicating the specific
MBMS key Id. In order for the UE to stop the BM-SC to send MBMS key updates a
deregistration with the MBMS User Service Id is needed.
If the MBMS User Service does not require any MBMS data protection, then the
UE shall not register for key management purposes.
A detailed description of all key management procedures is provided in 3GPP TS
33.246 [20].
### 4.4.3 MBMS Session and Transmission Function
The MBMS Session and Transmission function transfers the actual MBMS session
data to the group of MBMS UEs using either MBMS Bearer Services or unicast
bearer services. The MBMS Session and Transmission function interacts with the
GGSN through the Gmb Proxy function to activate and release the MBMS
transmission resources.
The session and transmission function may compress headers of MBMS data in
some cases. Further, the session and transmission function may need to add
synchronization information for the MBMS payload e.g. in case of MBSFN
transmissions. For details on usage of synchronization and header compression
see 3GPP TS 23.246 [4] and 3GPP TS 25.346 [5].
The function contains the MBMS delivery methods, which use the MBMS bearer
service for distribution of content. Further this function contains a set of
Associated-Delivery Functions, which may be invoked by the UE in relation to
the MBMS data transmission (e.g. after the MBMS data transmission).
The BM-SC Session and Transmission function is further described in later
clauses of the present document as well as in 3GPP TS 23.246 [4].
MBMS user services data may be integrity and/or confidentiality protected as
specified within 3GPP TS 33.246 [20], and protection is applied between the
BM-SC and the UE. This data protection is based on symmetric keys, which are
shared between the BM-SC and the UEs accessing the service.
MBMS user services may also be protected against packet loss between BM-SC and
UE using a forward error correction code.
### 4.4.4 User Service Discovery / Announcement function
The User Service Discovery / Announcement provides service description
information, which may be delivered via the Session and Transmission function
or via the Interactive Announcement function. This includes information, which
is necessary to initiate an MBMS user service as described in sub-clause
5.3.1. Metadata for the service descriptions are described in sub-clause 5.2.
### 4.4.5 Interactive Announcement Function
An Interactive Announcement Function may offer alternative means to provide
service descriptions to the UE using HTTP or be distributed through other
interactive transport methods.
### 4.4.6 MBMS UE
The MBMS UE hosts the MBMS User Services receiver function. The MBMS receiver
function may receive data from MBMS bearer services or from unicast bearer
services. The MBMS receiver function may receive data from several MBMS User
Services simultaneously. According to the MBMS UE capabilities, some MBMS UEs
may be able to receive data belonging to one MBMS User Service from several
MBMS Bearer Services simultaneously. The MBMS receiver function uses
interactive bearers for user service initiation / termination, user service
discovery and associated delivery procedures.
In case the MBMS user service is secured, the UE needs one or more
cryptographic MBMS service keys, therefore the UE requests the relevant
cryptographic MBMS service keys using the BM-SC Key Request function. The
received keys (i.e. MSK) are then used for securing the MBMS session.
## 4.5 Usage of identity of MBMS session
The Session Identity of the MBMS session is provided with the MBMS session
start procedure from the BM-SC to the GGSN via the Gmb protocol in the MBMS
Session Identity information element. The "MBMS Session Identity" information
element is specified in [77]. The size of the Session Identity field is 1
octet. The MBMS Session Identity is forwarded with the MBMS SESSION START
REQUEST message through the system and received by the MBMS UE with the paging
message.
The usage of the MBMS Session Identity is optional. The MBMS Session Identity
is only applicable to MBMS download delivery sessions. The MBMS transmission
resources are activated as described in sub-clause 5.4. Each MBMS session of
the MBMS User Service may be activated using a different MBMS session
identifier. The MBMS UE determines, based on the MBMS Session Identity value,
whether the files of the upcoming MBMS download session were already received.
If the files have already been completely received, the MBMS UE does not
respond to the notification of the MBMS Session.
The association of MBMS Session Identities to files is determined by the BM-SC
and communicated within the File Delivery Table. This association of a MBMS
Session Identity to files is valid until a particular expiry time, also
signalled within the File Delivery Table. If a UE has not received a File
Delivery Table associating a given MBMS Session Identity to a specific file or
set of files, or a previously received association has expired, then the UE
shall assume that the MBMS Session Identity value is associated to new files
which has not yet been received and shall respond as normal to MBMS
notifications with that Session Identity value.
A single MBMS Session Identity value may be associated with a single file or
with a set of files. Once a MBMS Session Identity value has been associated
with a particular file or a set of files, this association shall not be
changed before the expiry of the validity time for that MBMS Session Identity
value. In particular, a File Delivery Table including some files that has
previously been associated with a particular Session Identity value must
include all files previously associated with that value, even if it is not
intended to include all the files within the MBMS transmission session.
An FDT instance includes the MBMS Session Identity expiry time and associates
the MBMS Session Identity expiry times with particular MBMS Session Identity
values.
If the MBMS Session Identity is used by the BM-SC, the BM-SC shall also
provide the session repetition number of that MBMS transmission session on the
Gmb interface.
If the BM-SC starts using the MBMS Session Identity for one MBMS Bearer
Service, the BM-SC may still decide not to use the MBMS Session Identity for a
later MBMS transmission on that MBMS bearer service (e.g. when an MBMS session
is transmitted only once).
After determining that all files for a MBMS Session Identity value has been
received, the UE shall not respond to MBMS notifications for the MBMS Bearer
Service with that MBMS Session Identity value until the MBMS Session Identity
is expired. Once the MBMS Session Id has expired, the content is no longer
guaranteed to be repeated, and therefore the UE may begin to respond to MBMS
notifications for the associated MBMS Bearer Service.
The BM-SC may send FDT instances on a separate transmission session or
interleaved with other data packets of the same transmission session. An FDT
instance may describe more files than the files to be transmitted over the
same transmission session as that FDT instance.
## 4.6 Time Synchronization between the BM-SC and MBMS UEs
A number of MBMS metadata fragments and File Delivery Table (FDT) contain NTP
encoded time values. NTP uses UTC as reference time and is independent from
time zones. In order to process the time information from the BM-SC correctly,
the MBMS UEs shall be time synchronized with the BM-SC with a tolerance of +/-
1 second. The BM-SC shall offer an SNTP time server. The MBMS UEs should use
SNTP to synchronize the time with the BM-SC. The MBMS UE should not use the
SNTP time synchronization service more often than once in 30 days to avoid
scalability issues.
The BM-SC shall support the SNTP anycast mode [84]. An anycast client in the
MBMS UE sends a request to a designated IPv4 or IPv6 local broadcast address
or multicast group address. One or more SNTP anycast servers reply and include
a timestamp with their current time and its precision. BM-SC SNTP servers
shall only respond if they have a valid synchronisation time and shall not
leave the timestamp blank, such that the SNTP Leap Indicator (LI) field shall
not use the value 3 (warning: unsynchronised). Any MBMS SNTP client shall use
the anycast mode each time it performs SNTP synchronisation; the client does
not need to keep server address state data and changes in the SNTP server
addressing will not affect each subsequent synchronisation operation.
For IPv4, the Internet Assigned Numbers Authority (IANA) has assigned the
multicast group address 224.0.1.1 for NTP, which is used by both multicast
servers and anycast clients. For IPv6, the IANA has assigned the multicast
group address FF0X:0:0:0:0:0:0:101. These NTP assignments apply to SNTP usage
as well. The SNTP server will join these IP multicast groups.
# 5 Procedures and protocols
## 5.1 Introduction
This clause specifies the MBMS User service procedures and protocols.
## 5.2 User Service Discovery/Announcement
### 5.2.1 Introduction
User service discovery refers to methods for the UE to obtain a list of
available MBMS user services or user service bundles along with information on
the user services. Part of the information may be presented to the user to
enable service selection.
User service announcement refers to methods for the MBMS service provider to
announce the list of available MBMS user services and user service bundles,
along with information on the user services, to the UE.
In order for the user to be able to initiate a particular service, the UE
needs certain metadata information. The required metadata information is
described in sub-clause 5.2.2.
According to 3GPP TS 23.246 [4], in order for this information to be available
to the UE operators/service providers may consider several service discovery
mechanisms. User service announcement may be performed over a MBMS bearer or
via other means. The download delivery method is used for the user service
announcement over a MBMS bearer. The user service announcement mechanism based
on the download delivery method is described in sub-clause 5.2.3. The user
service announcement using interactive announcement function is described in
sub-clause 5.2.4. Other user service announcement and discovery mechanisms by
other means than the download delivery method are out of scope of the present
document.
### 5.2.2 MBMS User Service Description Metadata Fragments
#### 5.2.2.1 Introduction
MBMS User Service Discovery/ Announcement is needed in order to advertise MBMS
Streaming and MBMS Download User Services and User Service Bundles in advance
of, and potentially during, the User Service sessions described. The User
Services are described by metadata (objects/files) delivered using the
download delivery method as defined in clause 7 or using interactive
announcement functions.
MBMS User Service Discovery/Announcement involves the delivery of fragments of
metadata to many receivers in a suitable manner. The metadata itself describes
details of services. A _metadata fragment_ is a single uniquely identifiable
block of metadata. An obvious example of a metadata fragment would be a single
SDP file ([14]).
The metadata consists of:
  * a metadata fragment object describing details of a single or a > bundle of MBMS user services (defined in sub-clause 11.2);
  * a metadata fragment object(s) describing details of MBMS user > service sessions (defined in sub-clause 7.3 and 8.3);
  * a metadata fragment object(s) describing details of Associated > delivery methods (defined in sub-clause 9.5);
  * a metadata fragment object(s) describing details of service > protection (defined in sub-clause 11.3);
```{=html}
``` \- a metadata fragment object describing details of the FEC repair data >
stream.
Metadata management information consists of:
  * a metadata envelope object(s) allowing the identification, > versioning, update and temporal validity of a metadata fragment > (defined in sub-clause 11.1).
The metadata envelope and metadata fragment objects are transported as file
objects in the same download session either as separate referencing files or
as a single embedding file - see sub-clause 5.2.3.3. A single metadata
envelope shall describe a single metadata fragment, and thus instances of the
two are paired. A service announcement sender shall make a metadata envelope
instance available for each metadata fragment instance. The creation and use
of both an embedded envelope instance and a referenced envelope instance for a
particular fragment instance is not recommended.
The metadata envelope and metadata fragment objects may be compressed using
the generic GZip algorithm specified in RFC 1952 [42] as content/transport
encoding for transmission. Where used over an MBMS bearer, this shall be
according to Download delivery content encoding using FLUTE - see sub-clause
7.2.5.
Figure 5: Simple Description Data Model
Figure 5 illustrates the simple data model relation between these description
instances using UML [21] for a single User Service Bundle Description.
NOTE: \"N\" means any number in each instance.
One MBMS User Service Bundle Description shall contain at least one User
Service Description instance and may contain several. The User Service Bundle
Description may refer to a single FEC Repair Stream Description.
One MBMS User Service Description instance shall include at least one delivery
method description instance. The delivery method description shall refer to
one session description instance.
The delivery method description may contain references to a service protection
description and an associated delivery procedure description. Several delivery
methods may reference the same service protection description.
If the associated delivery procedure description is present in the user
service description instance, it may be referenced by one or more delivery
methods.
An MBMS user service description allows the association of delivery methods to
one or more access systems. The association is used to describe the use of
separate access systems for the same MBMS user service. One delivery method
may be offered throughout one or more radio access systems. The use of
separate MBMS bearer services for the same MBMS user service is described in
sub-clause 5.1.5.2 of [4].
Multipart MIME [37] may be used to concatenate the descriptions into one
document for transport.
#### 5.2.2.2 Session Description
One or more session descriptions are contained in one session description
object. The session description instance shall be formatted according to the
Session Description Protocol (SDP) [14]. Each session description instance
must describe either one Streaming session or one FLUTE Download session. A
session description for a Streaming session may include multiple media
descriptions for RTP sessions. The _sessionDescriptionURI_ references the
session description object. The session description is specified in sub-clause
7.3 for the MBMS download delivery method and in subclause 8.3 for the MBMS
streaming delivery method.
#### 5.2.2.3 Associated Delivery Procedure Description
The description and configuration of associated delivery procedures is
specified in clause 9. The _associatedProcedureDescriptionURI_ references the
associated delivery procedure instance.
An associated delivery procedure description may be delivered on a dedicated
announcement channel and updated on a dedicated announcement channel as well
as in-band with an MBMS download session.
If an associated delivery procedure description for File-Repair operations is
available, then the MBMS receiver may use the file repair service as specified
in sub-clause 9.3.
If an associated delivery procedure description for reception reporting is
available, then the MBMS receiver shall provide reception reports as specified
in sub-clause 9.4.
#### 5.2.2.4 Service Protection Description
The security description fragment contains the key identifiers and procedure
descriptions for one delivery method. When different delivery methods use the
same security description, the same security description document is
referenced from the different delivery method elements.
The security description contains key identifiers and the server address to
request the actual key material. To avoid overload situations, the same load
balancing principles as in the associated delivery procedures are used. The
key management server shall be selected as defined in sub-clause 9.3.5. The
back-off time shall be determined as defined in sub-clause 9.3.4.
The XML schema for the service protection description is defined in sub-clause
11.3.
#### 5.2.2.5 FEC Repair Stream Description
The streaming delivery method's FEC has separate stream for repair data, which
is described by the FEC Repair Stream Description. The FEC Repair Stream
Description shall be done using SDP [14]. This SDP file is referenced by the
_bundleDescription_ element in the service description. The FEC Repair Stream
described is common for all FEC protected packet flows within the MBMS User
Service Bundle Description instance.
### 5.2.3 User Service Announcement over a MBMS bearer
#### 5.2.3.1 General
Both the metadata envelope and metadata fragment objects are transported as
file objects in the same download session.
To receive a Service Announcement User Service the client shall obtain the
session parameters for the related MBMS download session transport. This may
be using a separate Service Announcement session.
NOTE: The user service announcements are not protected when sent over MBMS
bearer. See 3GPP TS 33.246 [20]
#### 5.2.3.2 Metadata Envelope Transport
The metadata envelope object is transported as a file object in the same MBMS
service announcement download session as its metadata fragment file object
(i.e. in-band with the metadata fragment session).
#### 5.2.3.3 Metadata Envelope and Metadata Fragment Association with FLUTE
The MBMS Download service announcement session FDT Instances provide URIs for
each transported object. The metadata envelope _metadataURI_ field shall use
the same URI for the metadata fragment as is used in the FDT Instances for
that metadata fragment file. Thus, the fragment can be mapped to its
associated envelope in-band of a single MBMS download session.
In the referencing case, each metadata envelope and corresponding metadata
fragment shall be grouped together by the FDT using the grouping mechanism
described in sub-clause 7.2.5. This reduces the complexity of requesting both
fragment and envelope for each pair, thus it is recommended that only the
metadata fragment (fileURI) be requested from the download client (which will
result in both fragment and envelope being received using the grouping
mechanism).
### _5.2.4_ User Service Announcement using Interactive Announcement Function
User service descriptions may be transported to the UE using HTTP and other
interactive transport methods. A BM-SC may provide the service descriptions on
request. Further protocol specifications of interactive announcement functions
are outside of the scope of this specification.
Aggregated MBMS service announcement documents as specified in sub-clause
5.2.5 may be used with the interactive announcement functions. UEs shall
support the disassembly of aggregated MBMS service announcement documents. UEs
shall support Gzip decoding of MBMS service description objects for
interactive transport (BM-SC use of Gzip is optional in accordance with sub-
clause 5.2.2).
The BM-SC may use Metadata Envelopes as described in clause 11.1, and UEs
shall support their use with the Interactive Announcement Function. Where
metadata envelopes are not used, only the latest delivery of a metadata
fragment shall be used by the UE, and the BM-SC shall ensure timely,
consistent, size-limited and secure delivery of metadata by means outside the
scope of this document.
### 5.2.5 User Service Announcement over point-to-point push bearers.
#### 5.2.5.1 General
User service announcement over point-to-point push bearers have several
characteristics that differ from user service announcement over a MBMS bearer.
It is not essential that the metadata envelope made available by the service
announcement sender is transmitted to the MBMS terminal. In the case that both
the metadata envelope and metadata fragment objects are transported, it is a
limitation of the solution that the metadata fragment must either be embedded
within the metadata envelope, or that the metadata fragment must be referenced
by the metadata envelope and they are both contained within a multipart MIME
container [37]. In either configuration, both the metadata envelope and the
metadata fragment objects are transported as file objects in the same download
session.
This sub-clause covers both metadata transport and metadata fragmentation
aspects of Service Announcement. Service Announcement over point-to-point push
bearers is specified.
NOTE: The user service announcements are not protected when sent over point-
to-point push bearers. See 3GPP TS 33.246 [20].
#### 5.2.5.2 Supported Metadata Syntaxes
The supported metadata syntaxes are as defined in sub-clause 11.1 of this
document.
#### 5.2.5.3 Consistency Control and Syntax Independence
The consistency control and syntax independence is as defined in sub-clause
11.1 of this document.
#### 5.2.5.4 Metadata Envelope Definition
The metadata envelope definition is as defined in sub-clause 11.1 of this
document.
#### 5.2.5.5 Delivery of the Metadata Envelope
An instance of metadata fragment shall either be embedded within the metadata
envelope or be included in a multipart MIME container together with the
envelope. The envelope and fragment are, by definition, transported together
and in-band of the same transport session.
The Metadata Envelope includes a reference (_metadataURI_) to the associated
metadata fragment using the same URI as the fragment file is identified by in
the Service Announcement. Thus, Metadata Envelope can be mapped to its
associated metadata fragment.
#### 5.2.5.6 Metadata Envelope Transport
The metadata envelope object is transported as a file object in the same MBMS
service announcement download session as its metadata fragment file object
(i.e. in-band with the metadata fragment session).
#### 5.2.5.7 User service announcement over SMS bearers
User service announcements over SMS bearers are formatted according to the OMA
Push OTA specification [79].
OTA-WSP shall be used over the SMS bearer. Application port addressing shall
be used as specified in [79]. The application ID to be used is 0x9023 as
allocated by OMNA [85].
Either confirmed or unconfirmed push may be used. In either case, the
primitive shall contain the Push Headers parameter. Within this parameter, the
Content-Type header shall be included and the Content-Encoding header shall be
included if GZip is used.
#### 5.2.5.8 User service announcement over HTTP push bearers
User service announcements over HTTP push bearers are formatted according to
the OMA Push OTA specification [79].
OTA-HTTP shall be used over the HTTP push bearer. Application port addressing
shall be used as specified in [79]. The application ID to be used is 0x9023 as
allocated by OMNA [85].
The Content-Encoding header shall be included if GZip is used.
### _5.2.6 Metadata Fragment Encapsulation to aggregate Service Announcement
Documents_
The present document defines a number of metadata fragments to describe MBMS
user services. A metadata fragment is a single uniquely identifiable block of
metadata. Generally, more than one metadata fragment is necessary to provide
all necessary parameters to initiate an MBMS User Service. Typically, metadata
fragments are provided in separate documents. Each metadata fragment is
labelled with its MIME type.
Multipart MIME may be used to encapsulate metadata fragments into an aggregate
service announcement document. The aggregate document may contain metadata
fragments of several MBMS user services. It is recommended, that any such
aggregate service announcement document contains all the referenced metadata
fragments of each MBMS user service description it contains (i.e. in the same
multipart MIME structure).
An aggregate service announcement document shall encapsulate metadata
fragments according to RFC 2557 [37]. The first encapsulated file of an
aggregate service announcement document is the root resource. The root
resource shall be either an MBMS user service description or a metadata
envelope (as a referencing index). The service description metadata is defined
in sub-clause 5.2.2.4. The metadata envelope is defined in sub-clause 5.2.3.3.
The type field of the multipart/related header shall be set to
application/mbms-user-service-description-parameter in case the root resource
is a user service description instance. The type field of the
multipart/related header shall be set to application/mbms-envelope in case the
root resource is a metadata envelope.
### _5.2.7 Registration and Deregistration Procedure for MBMS User Service
Consumption_
The MBMS User Service Description Fragment may include a registration
description. If the registration description is present in the MBMS User
Service Description Fragment, then the UE shall use the registration and
deregistration procedures as defined in this section.
A registration request is then initiated by the UE, in order to receive the
complete user service description. The registration procedure is performed
using HTTP 1.1 [18] POST message towards the indicated RegistrationURL.
A successful registration response shall start with a 200 OK status line in
the response header and shall contain in the body the metadata fragments that
are referenced by the USD in a multipart MIME container.
The registration request shall be formatted according to the following XML
schema and using the RegistrationRequest element.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
A de-registration procedure is used by the UE to de-register at the end of the
user service consumption, in case a registration procedure has been performed.
The de-registration request shall be sent to a registration server (preferably
the one with which the registration procedure has been performed). The de-
registration procedure consists of sending an HTTP 1.1 POST request with an
XML body formatted according to the XML schema above, using the
DeregistrationRequest element.
The MIME type of the message body of the registration and deregistration
request shall be set to "text/xml".
The _IMEI_ element contains, if present, the International Mobile Equirment
Identifier as defined in [77].
The _MSISDN_ element contains the Mobile Subscriber ISDN Number as defined in
[77].
The _ServiceID_ element contains the unique MBMS User Service Identifier as
defined in clause 11.2.1.1.
## 5.3 User Service Initiation/Termination
### 5.3.1 Initiation of MBMS Bearer Service based Services
MBMS User Service initiation refers to UE mechanisms to set-up the reception
of MBMS user service data. During the User Service Initiation procedure, a set
of MBMS Bearers may be activated. The User Service Initiation procedure takes
place after the discovery of the MBMS user service.
Figure 6: Initiation of an MBMS User Service
> 1\. The User Service Initiation Procedure is triggered and takes a User
> Service Description as input that has been obtained e.g. by executing the
> MBMS User Service discovery and announcement functions.
>
> 2\. The MBMS UE registers to the MBMS User Service, if registration is
> required for the MBMS User Service. If security functions are activated for
> the MBMS User Service, the MBMS UE requests MBMS service keys. The keys are
> sent to the UE, after the user is authorized to receive the MBMS service.
> The request shall be authenticated. Details on the MBMS User Service
> Registration procedure are described in 3GPP TS 33.246 [20].
>
> 3\. The MBMS UE uses the MBMS activation procedure to activate the MBMS
> Bearer Service. The MBMS activation procedure is the MBMS Multicast Service
> activation procedure and the MBMS Broadcast activation procedure as defined
> in 3GPP TS 23.246 [4]. In case the MBMS Broadcast Mode is activated, there
> is no activation message sent from the UE to the BM-SC. The activation is
> locally in the UE. Note that the MBMS Bearer Services may already be active
> and in use by another MBMS User Service.
>
> 3n. In case the MBMS User Service uses several MBMS Bearer Services, the
> User Service Description contains several description items. In that case,
> the MBMS receiver function repeats the activation procedure for each MBMS
> Bearer Service as described in 3.
### 5.3.2 Termination of MBMS Bearer Service based Services
MBMS user service termination refers to the UE mechanisms to terminate the
reception of MBMS user services. A set of MBMS Bearers may be deactivated
during this procedure.
Figure 7: Termination of an MBMS user service
> 1\. The User Service termination Procedure is triggered. A reference to the
> User Service to terminate is provided as parameter.
>
> 2\. The MBMS UE deregisters, when registration was required for the MBMS
> User Service. If security functions are activated for the MBMS User Service,
> the MBMS UE deregisteres the security association for the MBMS User
> Services. Details on the MBMS User Service Deregistration procedure are
> described in 3GPP TS 33.246 [20].
>
> 3\. If no other MBMS User Service uses the MBMS Bearer service, the MBMS UE
> uses the MBMS deactivation procedure to deactivate the MBMS Bearer Services.
> The MBMS deactivation procedure represents the MBMS Multicast service
> deactivation procedure and the MBMS Broadcast deactivation procedure as
> described in 3GPP TS 23.246 [4]. In case the MBMS Broadcast Mode is
> deactivated, there is no message sent to the BM‑SC. The deactivation is only
> locally in the UE.
>
> 3n. In case the MBMS User Service uses several Bearer Services, the UE
> repeats the deactivation procedure for each Bearer Service as described in
> 3.
### 5.3.3 Initiation of Unicast Bearer Service based Services
Unicast Bearer Service based MBMS User Service initiation refers to the
mechanisms to set-up the reception of MBMS user service data via a UMTS Bearer
Service with interactive and/or streaming straffic class.
In case of the initiation of a MBMS Streaming delivery method or a combined
MBMS Streaming and MBMS Download delivery method, the Packet Switched
Streaming Service (PSS) as defined in 3GPP TS 26.234 [47] shall be used. The
establishement of a PSS session is described in clause 5.1 of 3GPP TS 26.234
[47].
In case of the initiation of a MBMS Download delivery method, the MBMS UE is
registered in the BM-SC for OMA-PUSH based reception of the files with the BM-
SC.
### 5.3.4 Termination of Unicast Bearer Service based Services
Unicast Bearer Service based MBMS user service termination refers to the
mechanisms to terminate the reception of MBMS user service data via a UMTS
Bearer Service with interactive and/or streaming straffic class.
In case of the termination of a MBMS Streaming delivery method or a combined
MBMS Streaming and MBMS Download delivery method, the Packet Switched
Streaming Service (PSS) as defined in 3GPP TS 26.234 [47] shall be used. The
termination of a PSS session is described in clause 5.3 of 3GPP TS 26.234
[47].
In case of the termination of a MBMS Download delivery method, the MBMS UE is
deregistered in the BM-SC so that the OMA-PUSH based reception of the files
with the BM-SC will be terminated.
### 5.3.5 Scalable Service Initiation and Termination for MBMS Services
#### 5.3.5.1 General
MBMS service initiation and termination as defined in clauses 5.3.1 to 5.3.4
may consist of network interactions such as sending an IGMP Join or Leave
message to the network as described in sections 8.2 and 8.7 of 3GPP TS 23.246
[4]. Initiation and termination procedures may be triggered at the MBMS UE by
the user or be scheduled to happen automatically. Upon (or after) receiving a
user service announcement, the MBMS UE may render the information about the
advertised services to the user to assist him in the service selection. The
user may decide to receive a given service and hence trigger the service
initiation procedure. Alternatively, the user may declare his interest in a
specific service a-priori and upon receiving the service announcement for that
specific service, the MBMS UE may schedule the initiation procedure at or
around the start time of the session. Similarly, the MBMS UE may schedule the
termination procedure at or around the session end time.
As a consequence, MBMS UEs may be oriented to start their service initiation
and termination procedures at the same time or during a relatively short
period. This may cause network congestion, especially during the multicast of
a popular service, as all MBMS UEs may be time synchronized.
#### 5.3.5.2 Randomization of Service Initiation over Time
The MBMS User Service description may contain parameters to uniformly
randomize the User Service Initiation procedures of the MBMS UEs. Security
functions may be part of the User Service Initiation procedure as defined in
clause 5.3.1. If a user service initiation randomization is defined for a user
service, then the overload prevention definition in the service protection
description shall be ignored for the service initiation. For randomizing the
time of the initiation procedure, the MBMS UE shall understand the following
parameters, which may be signalled by the BM-SC in the MBMS user service
description as described in section 11.2.1:
  1. _initiationStartTime_ parameter is used by the BM-SC to signal to the MBMS UE the start time for the User Service Initiation procedure randomization period. If the _initiationStartTime_ parameter is not present, the MBMS UE uses the time of the Service Annoucement reception as the start time.
  2. _protectionPeriod_ parameter is used by the BM-SC to signal to the MBMS UE the duration of the critical time periods, during which congestion shall be avoided. The MBMS UEs shall randomly spread the initiation procedure using the _randomTimePeriod_ during this protection period.
  3. _randomTimePeriod_ parameter is used by the BM-SC to signal to the MBMS UE the duration of an interval over which initiation procedures shall be randomly deferred. The MBMS UE calculates a random time out of the _randomTimePeriod interval to defer_ the execution of the initiation procedure.
The MBMS UE shall start its initiation procedure immediately if the procedure
is triggered outside of protection periods.
#### 5.3.5.3 Randomization of Service Termination over Time
The MBMS User Service description may contain parameters to uniformly
randomize the User Service Termination procedures of the MBMS UEs. For
randomizing the time of the termination procedure, the MBMS UE shall
understand the following parameters, which may be signalled by the BM-SC in
the MBMS USD as described in section 11.2.1:
  1. _protectionPeriod_ parameter is used by the BM-SC to signal to the MBMS UE the duration of the critical time period, during which congestion needs to be avoided. The MBMS UEs shall randomly spread the termination procedure using the _randomTimePeriod_ during this period and starting from the session end time.
  2. _randomTimePeriod_ parameter is used by the BM-SC to signal to the MBMS UE the duration of an interval over which termination procedures shall be randomly deferred. The termination procedure is only randomized during the _protectionPeriod._
If the termination procedure is triggered before the session end time or after
the protection period end time, the MBMS UE shall start its termination
procedure immediately. If it is in a protection period, the MBMS UE shall
defer its termination procedure to a random time spread over an interval of
duration _randomTimePeriod_.
## 5.4 MBMS Data Transfer Procedure
### 5.4.1 MBMS Data Transfer Procedure using MBMS Bearer Services
MBMS Data Transfer procedure using MBMS Bearer Services refers to the network
(and UE) mechanism to transfer (and receive) data for one MBMS User Service on
one or several MBMS Bearer Services.
{width="6.013194444444444in" height="3.426388888888889in"}
NOTE: Security related interactions are not depicted in the sequence.
Figure 8: Procedure of MBMS Data Transfer
> 1\. The MBMS Delivery Method for the MBMS User Service is triggered by the
> MBMS User Service Provider. Note, details of the trigger are beyond of the
> present document.
>
> 2\. - 2n. The MBMS Delivery function uses the MBMS Session Start Procedure
> to the GGSN, possibly through the Gmb Proxy function to activate all MBMS
> Bearer Services, which belong to the MBMS User Service. The MBMS Bearer
> service to be activated is uniquely identified by the TMGI.
Note. MBMS Bearer services might be activated only to a subset of the
available access systems (see 3GPP TS 23.246 [4]). In case MBMS User Services
or delivery methods are not available throughout all access systems, the BM-SC
describes this transmission strategy in the MBMS User Service Description (see
sub-clause 5.2.2).
> 3\. - 3n. The data of the MBMS user service are transmitted to all listening
> MBMS UEs. Several MBMS Bearer services may be used to transmit the MBMS user
> service data. MBMS user service data may be integrity and/or confidentiality
> protected. In case MBMS user service data are integrity and/or
> confidentiality protected, MBMS traffic keys are delivered simultaneously on
> the same or a different MBMS bearer. Optionally, syncronization information
> for MBSFN may be added to the MBMS User Data. The headers of MBMS User data
> may optionally be compressed (see 3GPP TS 23.246 [4] and TS 25.346 [5])
>
> 4\. - 4n. The MBMS Delivery function uses the MBMS Session Stop procedure to
> trigger the GGSN, possibly through the Gmb Proxy function to release all
> MBMS Bearer Service for this User Service. A unique identifier for the MBMS
> Bearer service to be deactivated (i.e. the TMGI) is passed on as a
> parameter.
>
> 5\. In case associated delivery procedures are allowed or requested for an
> MBMS User Service, the MBMS UE sends an associated-delivery procedure
> request to the associated -delivery function. The BM-SC may authenticate the
> user. See 3GPP TS 33.246 [20]. The MBMS UE may need to wait a random time
> before it starts the associated delivery procedure according to clause 9.
### 5.4.2 MBMS Data Transfer Procedure using other UMTS Bearer Services
MBMS Data Transfer procedure using other UMTS Bearer Services refers to the
network (and UE) mechanism to transfer (and receive) data for one MBMS User
Service on one or more Unicast Bearer Services.
In case the MBMS Data belong to a MBMS Streaming delivery session or a
combined MBMS Streaming and MBMS Download delivery session, the Packet
Switched Streaming Service (PSS) as defined in 3GPP TS 26.234 [47] shall be
used.
In case the MBMS Data belong to a MBMS Download delivery session, the MBMS
data is transferred using OMA-PUSH.
## 5.5 MBMS Protocols
Figure 9 illustrates the protocol stack used by MBMS User services. The grey-
shaded protocols and functions are outside of the scope of the present
document. MBMS security functions and the usage of HTTP-digest and SRTP are
defined in 3GPP TS 33.246 [20].
Figure 9: Protocol stack view of the MBMS User Services
# 6 Introduction on Delivery Methods
Two delivery methods are defined in the present document - the download
delivery method and the streaming delivery method. MBMS delivery methods make
use of MBMS bearers for content delivery but may also use the associated
procedures defined in clause 9.
Use of MBMS bearers by the download delivery method is described in clause 7.
The File Repair Procedure and the Reception Reporting Procedure (described in
clause 9) may be used by the download delivery method.
Use of MBMS bearers by the streaming delivery method is described in clause 8.
# 7 Download Delivery Method
## 7.1 Introduction
MBMS download delivery method uses the FLUTE protocol (RFC 3926 [9]) when
delivering content over MBMS bearers. MBMS download delivery method may use
OMA PUSH [79] when delivering content over other UMTS bearers. Usage of FLUTE
protocol is described in clause 7.2. The Usage of OMA Push is described in
clasue 7.4. The FLUTE session set-up with RTSP is defined in clause 7.5.
FLUTE is built on top of the Asynchronous Layered Coding (ALC) protocol
instantiation (RFC 3450 [10]). ALC combines the Layered Coding Transport (LCT)
building block [11], a congestion control building block and the Forward Error
Correction (FEC) building block ([12]) to provide congestion controlled
reliable asynchronous delivery of content to an unlimited number of concurrent
receivers from a single sender. As mentioned in (RFC 3450 [10]), congestion
control is not appropriate in the type of environment that MBMS download
delivery is provided, and thus congestion control is not used for MBMS
download delivery. See figure 10 for an illustration of FLUTE building block
structure. FLUTE is carried over UDP/IP, and is independent of the IP version
and the underlying link layers used.
Figure 10: Building block structure of FLUTE
ALC uses the LCT building block to provide in-band session management
functionality. The LCT building block has several specified and under-
specified fields that are inherited and further specified by ALC. ALC uses the
FEC building block to provide reliability. The FEC building block allows the
choice of an appropriate FEC code to be used within ALC, including using the
no-code FEC code that simply sends the original data using no FEC coding. ALC
is under-specified and generally transports binary objects of finite or
indeterminate length. FLUTE is a fully-specified protocol to transport files
(any kind of discrete binary object), and uses special purpose objects - the
File Description Table (FDT) Instances - to provide a running index of files
and their essential reception parameters in-band of a FLUTE session.
## 7.2 FLUTE usage for MBMS download
The purpose of download is to deliver content in files. In the context of MBMS
download, a file contains any type of MBMS data (e.g. 3GPP file (Audio/Video),
Binary data, Still images, Text, Service Announcement metadata).
In the present document the term \"file\" is used for all objects carried by
FLUTE (with the exception of the FDT Instances).
UE applications for MBMS user services built upon the download delivery method
have three general approaches to getting files from the FLUTE receiver for a
joined session:
  * **Promiscuous:** Instruct FLUTE to promiscuously receive all files > available. Promiscuous reception can be suitable for single > purpose sessions (generally with limited number and/or size of > files) although uncertainty over the quality and content of files > makes this approach generally undesirable.
  * **One-copy:** Instruct FLUTE to receive a copy of one or more > specific files (identified by the fileURI) - and potentially > leaving the session following reception of one copy of all the > specified files. Specifying the download file ensures that the UE > has an upper bound to the quantity of files downloaded. One-copy > reception requires prior knowledge of the file identifiers > (fileURIs).
  * **Keep-updated:** Instruct FLUTE to receive one or more specific > files and continue to receive any updates to those files. As with > one-copy, the keep-updated approach bounds the quantity of files > downloaded and requires prior knowledge of the file identifiers.
NOTE: The present document does not prevent or endorse changing download
reception approach, and any related file list, during the life of the download
session. Discovery of session content lists (including file lists) out-of-band
of the delivery method sessions is beyond the scope of the present document.
The interaction of these file download modes and the caching directives is
defined in section 7.2.13.
MBMS clients and servers supporting MBMS download shall implement the FLUTE
specification (RFC 3926 [9]), as well as ALC (RFC 3450 [10]) and LCT (RFC 3451
[11]) features that FLUTE inherits. In addition, several optional and extended
aspects of FLUTE ,as described in the following clauses, shall be supported.
One FDT instance is typically bound to one MBMS transmission session. It is
therefore recommended, that each MBMS transmission session should contain one
or more repetitions of the same FDT instance.
### 7.2.1 Fragmentation of Files
Fragmentation of files shall be provided by a blocking algorithm (which
calculates source blocks from source files) and a symbol encoding algorithm
(which calculates encoding symbols from source blocks).
### 7.2.2 Symbol Encoding Algorithm
The \"Compact No-Code FEC scheme\" - [12] (FEC Encoding ID 0, also known as
\"Null-FEC\") shall be supported.
The Raptor FEC scheme is described in sub-clause 7.2.12.
A UE that supports MBMS User Services shall support a decoder for the Raptor
FEC scheme.
If a UE that supports MBMS User Services receives a mathematically sufficient
set of encoding symbols generated according to the encoder specification in
[91] for reconstruction of a source block then the decoder shall recover the
entire source block. Note that the example decoder described in [91] clause
5.5 fulfils this requirement.
### 7.2.3 Blocking Algorithm
In the case of the Compact No-Code FEC scheme [12] (FEC Encoding ID 0), then
the \"Algorithm for Computing Source Block Structure\" described within the
FLUTE specification (RFC 3926 [9]) shall be used.
In the case of Raptor forward error correction, then the algorithm defined in
[91] shall be used.
The values of _N_ , _Z_ , _T_ and _A_ shall be set such that the sub-block
size is less than 256KB.
### 7.2.4 Congestion Control
For simplicity of congestion control, FLUTE channelization shall be provided
by a single FLUTE channel with single rate transport.
### 7.2.5 Content Encoding of Files for Transport
Files may be content encoded for transport, as described in [9], in the
Download delivery method using the generic GZip algorithm as specified in RFC
1952 [42]. UEs shall support GZip content decoding of FLUTE files (GZIP RFC
1952 [42], clause 9).
### 7.2.6 Transport File Grouping
Files downloaded as part of a multiple-file delivery are generally related to
one another. Examples include web pages, software packages, and the
referencing metadata envelopes and their metadata fragments. FLUTE clients
analyse the XML-encoded FDT Instances as they are received, identify each
requested file, associate it with FLUTE packets (using the TOI) and discover
the relevant in-band download configuration parameters of each file.
An additional \"group\" field in the FLUTE FDT instance and file elements
enables logical grouping of related files. A FLUTE receiver should download
all the files belonging to all groups where one or more of the files of those
groups have been requested. However, a UE may instruct its FLUTE receiver to
ignore grouping to deal with special circumstances, such as low storage
availability.
The group names are allocated by the FLUTE sender and each specific group name
shall group the corresponding files together as one group, including files
describes in the same and other FDT Instances, for a session.
Group field usage in FDT Instances is shown in the FDT XML schema (clause
7.2.10). Each file element of an FDT Instance may be labelled with zero, one
or more group names. Each FDT Instance element may be labelled with zero, one
or more group names which are inherited by all files described in that FDT
Instance.
### 7.2.7 Signalling of Parameters with Basic ALC/FLUTE Headers
FLUTE and ALC mandatory header fields shall be as specified in [9, 10] with
the following additional specializations:
  * The length of the CCI (Congestion Control Identifier) field shall be > 32 bits and it is assigned a value of zero (C=0).
  * The Transmission Session Identifier (TSI) field shall be of length > 16 bits (S=0, H=1, 16 bits).
  * The Transport Object Identifier (TOI) field should be of length 16 > bits (O=0, H=1).
  * Only Transport Object Identifier (TOI) 0 (zero) shall be used for > FDT Instances.
  * The following features may be used for signalling the end of session > and end of object transmission to the receiver:
\- The Close Session flag (A) for indicating the end of a session.
\- The Close Object flag (B) for indicating the end of an object.
In FLUTE the following applies:
  * The Sender Current Time present flag (T) shall be set to zero.
  * The Expected Residual Time present flag (R) shall be set to zero.
  * The LCT header length (HDR_LEN) shall be set to the total length of > the LCT header in units of 32-bit words.
  * For \"Compact No-Code FEC scheme\" [12], the FEC Payload ID shall > be set according to RFC 3695 [13] such that a 16 bit SBN (Source > Block Number) and then the 16 bit ESI (Encoding Symbol ID) are > given.
  * For "MBMS FEC scheme", the FEC Payload ID shall be set according to > Section 7.2.10 below.
### 7.2.8 Signalling of Parameters with FLUTE Extension Headers
FLUTE extension header fields EXT_FDT, EXT_FTI , EXT_CENC [9] shall be used as
follows:
  * EXT_FTI shall be included in every FLUTE packet carrying symbols > belonging to any FDT Instance.
  * FLUTE packets carrying symbols of files (not FDT Instances) shall > not include an EXT_FTI.
  * FDT Instances shall not be content encoded and therefore EXT_CENC > shall not be used.
In FLUTE the following applies:
  * EXT_FDT is in every FLUTE packet carrying symbols belonging to any > FDT Instance.
  * FLUTE packets carrying symbols of files (not FDT instances) do not > include the EXT_FDT.
### 7.2.9 Signalling of Parameters with FDT Instances
The extended FLUTE FDT instance schema defined in clause 7.2.10.1 (based on
the one in RFC 3926 [9]) shall be used. In addition, the following applies to
both the session level information and all files of a FLUTE session.
The inclusion of these FDT Instance data elements is mandatory according to
the FLUTE specification:
  * Content-Location (URI of a file).
  * TOI (Transport Object Identifier of a file instance).
  * Expires (expiry data for the FDT Instance).
Additionally, the inclusion of these FDT Instance data elements is mandatory.
Note the following elements are optional in the FDT schema to stay aligned
with the IETF RFC defined schema:
  * Content-Length (source file length in bytes).
  * Content-Type (content MIME type).
  * FEC Encoding ID.
Other FEC Object Transmission Information specified by the FEC scheme in use:
NOTE: The FEC Object Transmission Information elements used are dependent on
the FEC scheme, as indicated by the FEC Encoding ID.
  * FEC-OTI-Maximum-Source-Block-Length.
  * FEC-OTI-Encoding-Symbol-Length.
  * FEC-OTI-Max-Number-of-Encoding-Symbols.
  * FEC-OTI-Scheme-Specific-Info.
NOTE 1: RFC 3926 [9] describes which part or parts of an FDT Instance may be
used to provide these data elements.
These optional FDT Instance data elements may or may not be included for FLUTE
in MBMS:
  * Complete (the signalling that an FDT Instance provides a complete, > and subsequently unmodifiable, set of file parameters for a FLUTE > session may or may not be performed according to this method).
  * Content-Encoding.
  * Content-MD5: represents a digest of the transport object. The file > server should indicate the MD5 hash value whenever multiple > versions of the file are anticipated for the download session.
NOTE 2: The values for each of the above data elements are calculated or
discovered by the FLUTE sender.
The FEC-OTI-Scheme-Specific-Info FDT Instance data element contains
information specific to the FEC scheme indicated by the FEC Encoding ID
encoded using base64.
### 7.2.10 FDT Schema
#### 7.2.10.1 Extended FLUTE FDT Schema
The below XML Schema shall be use for the FDT Instance.
The XML schema described in clause 7.2.10.3 is within this schema reference
using the relative URI \"ietf-flute-fdt.xsd\".
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
#### 7.2.10.2 3GPP FDT Extension Type Schema
The extension of the IETF FLUTE FDT schema is done using the following schema
definition:
\
\
\
\
\
\
\
\
\
\
\
\
\
\\
\
\
#### 7.2.10.3 IETF FDT Schema
Below is the XML schema that has been used to validate the above XML schema
extension.
> Note: As the schema in RFC 3926 is not valid there exist no stable
> reference, thus this specification will include this schema until IETF has
> published an updated version of the schema.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
#### 7.2.10.4 Example of FDT
\
\
\
\93\
\
\
\93\
\
\93\
\
#### 7.2.10.5 3GPP FDT Extensions
The following schema defines the new elements
\
\
**\ **
**\ **
**\ **
**\ **
**\ **
**\ **
**\ **
**\ **
**\ **
**\ **
\
### 7.2.11 MBMS Session Identify
The _MBMS-Session-Identity_ element associates the file to the identity of the
MBMS session. If the file will be part of several MBMS transmission sessions,
then a list of MBMS session identities is defined.
The _MBMS-Session-Identity-Expiry_ element associates an expiration time with
a MBMS session identity value. Similar to the FLUTE FDT expiration time, the
MBMS session identity expiration time (_value_ attribute) is expressed within
the FDT Instance payload as a 32 bit data field. The value of the data field
represents the 32 most significant bits of a 64 bit Network Time Protocol
(NTP) [78] time value. These 32 bits provide an unsigned integer representing
the time in seconds relative to 0 hours 1 January 1900.
### 7.2.12 FEC Scheme definition
#### 7.2.12.1 General
This clause defines an FEC encoding scheme for the MBMS forward error
correction code defined in [91] for the download delivery method. This scheme
is identified by FEC Encoding ID 1. The FEC Payload ID format and FEC Object
Transmission Information format are as defined in [91], sub-clauses 3.1 and
3.2 respectively.
### 7.2.13 Caching Directives
A file download service may indicate the caching recommendations for a
specific file or set of files that are delivered using FLUTE. The caching
directives are to be used with the file download modes as follows:
  * Promiscuous mode: it is recommended to use the caching directives > with the promiscuous mode as it enables improved management of the > storage at the UE. Applications make use of available copies of > files as long as their respective caching time is still valid. In > case one or several files have expired and the download session is > still available, the UE should join the FLUTE session and download > the expired files. Alternatively, the UE may attempt to retrieve > the file using HTTP and the file URL.
  * One-Copy mode: Caching directives may be used with the one-copy mode > to indicate the validity of a certain file. Applications > requesting the file will receive the cached file as long as it is > still valid. A file that is not expected to be static may indicate > a long expiry time or permanent validity.
  * Keep-Updated mode: it is recommended to use the caching directives > with the keep-updated mode to indicate the validity of a certain > file. Applications requesting the file will receive the cached > file as long as it is still valid.
The caching functionality defines three different caching directives:
  * **no-cache** : this directive is used to indicate to the receiver not > to cache a specific file (or set of files). This is probably > useful in the case where the file is expected to be highly dynamic > (changes to the file occur quite often) or if the file will be > used only once by the receiver application.
```{=html}
``` \- **max-stale** : this directive indicates to the FLUTE receiver that a >
specific file (or set of files) should be cached for an indefinite > period of
time, if possible. The file has no expiry date.
```{=html}
``` \- **Expires** : this directive is used by the server to indicate the >
expected expiry time of a specific file (or set of files). It > indicates a
date and time value in the HTTP date format or in the > NTP timestamp format.
The syntax of the caching directives is described in section 7.2.10.5.
### 7.2.14 Indicating a full FDT snapshot
If the server wants to inform the client about the current FDT snapshot, the
server shall set the "FullFDT" attribute in the FLUTE FDT instance file. If
the "FullFDT" attribute is set, the FDT instance shall be equivalent to the
full File Delivery Table. Note FDT instances with a higher FDT instance ID may
again extend the File Delivery Table.
A new attribute \"FullFDT\" is created within the element \"FDT-Instance\" of
the FDT to indicate to the receivers that the FDT Instance contains the exact
set of Transport Objects that are currently scheduled for transmission by the
sender, in the actual FLUTE session.
The XML syntax of the \"FullFDT\" attribute within the FLUTE FDT is the
following.
\
\
\
\
This attribute differs from the existing \"Complete\" attribute in that the
\"Complete\" attribute indicates that no new objects description will be
provided in future FDT Instances within this session.
No assumption shall be made about the fact that a given FDT instance for which
the attribute \"FullFDT\" is absent or set to FALSE, contains the exact set of
Transport Objects that are currently scheduled for transmission by the sender,
in the actual FLUTE session.
When two FDT instances with attribute \"FullFDT\" is equal to TRUE are
received by a receiver and valid in a given time (that is to say they have not
expired), the FDT instance with the highest FDT Instance ID shall be used by
the terminal.
## 7.3 SDP for Download Delivery Method
### 7.3.1 Introduction
RFC 3926 [9] describes required and optional parameters for FLUTE session and
media descriptors. This clause specifies SDP for FLUTE session that is used
for the MBMS download and service announcement sessions. The formal
specification of the parameters is given in ABNF ([23]).
### 7.3.2 SDP Parameters for MBMS download session
The semantics of a Session Description of an MBMS download session includes
the following parameters:
  * The sender IP address.
  * The number of channels in the session.
  * The destination IP address and port number for each channel in the > session per media.
  * The Transport Session Identifier (TSI) of the session.
  * The start time and end time of the session.
  * The protocol ID (i.e. FLUTE/UDP).
  * Media type(s) and fmt-list.
  * Data rate using existing SDP bandwidth modifiers.
  * Mode of MBMS bearer per media.
  * FEC capabilities and related parameters.
  * Service-language(s) per media.
This list includes the parameters required by FLUTE - RFC 3926 [9]
These shall be expressed in SDP ( [14] and [15]) syntax according to the
following clauses.
#### 7.3.2.1 Sender IP address
There shall be exactly one IP sender address per MBMS download session, and
thus there shall be exactly one IP source address per complete MBMS download
session SDP description. The IP source address shall be defined according to
the source-filter attribute (\"a=source-filter:\") ( [14] and [15]) for both
IPv4 and IPv6 sources, with the following exceptions:
1\. Exactly one source address may be specified by this attribute such that
exclusive-mode shall not be used and inclusive-mode shall use exactly one
source address in the \.
2\. There shall be exactly one source-filter attribute per complete MBMS
download session SDP description, and this shall be in the session part of the
session description (i.e. not per media).
3\. The * value shall be used for the \ subfield, even when the
MBMS download session employs only a single LCT (multicast) channel.
#### 7.3.2.2 Number of channels
Only one FLUTE channel is allowed per FLUTE session in the present document
and thus there is no further need for a descriptor of the number of channels.
#### 7.3.2.3 Destination IP address and port number for channels
The FLUTE channel shall be described by the media-level channel descriptor.
These channel parameters shall be per channel:
  * IP destination address.
  * Destination port number.
The IP destination address shall be defined according to the \"connection
data\" field (\"c=\") of SDP ( [14]). The destination port number shall be
defined according to the \ sub-field of the media announcement field
(\"m=\") of SDP ( [14]).
The presence of a FLUTE session on a certain channel shall be indicated by
using the \"_m-_ line\" in the SDP description as shown in the following
example:
_m=application 12345 FLUTE/UDP 0_
_c=IN IP6 FF1E:03AD::7F2E:172A:1E24/1_
In the above SDP attributes, the _m_ -line indicates the media used and the
_c_ -line indicates the corresponding channel. Thus, in the above example, the
_m_ -line indicates that the media is transported on a channel that uses FLUTE
over UDP. Further, the _c_ -line indicates the channel address, which, in this
case, is an IPv6 address.
#### 7.3.2.4 Transport Session Identifier (TSI) of the session
The combination of the TSI and the IP source address identifies the FLUTE
session. Each TSI shall uniquely identify a FLUTE session for a given IP
source address during the time that the session is active, and also for a
large time before and after the active session time (this is also an LCT
requirement - RFC 3451 [11]).
The TSI shall be defined according the SDP descriptor given below. There shall
be exactly one occurrence of this descriptor in a complete FLUTE SDP session
description and it shall appear at session level.
The syntax in ABNF is given below:
flute-tsi-line = \"a=flute-tsi:\" tsi CRLF
tsi = 1*15DIGIT
#### 7.3.2.5 Multiple objects transport indication
RFC 3626 [9] requires the use of the Transport Object Identifier (TOI) header
field (with one exception for packets with no payload when the A flag is
used). The transport of a single FLUTE file requires that multiple TOIs are
used (TOI 0 for FDT Instances). Thus, there is no further need to indicate to
receivers that the session carries packets for more than one object and no SDP
attribute (or other FLUTE out of band information) is needed for this.
#### 7.3.2.6 Session Timing Parameters
A MBMS download session start and end times shall be defined according to the
SDP timing field (\"t=\") ( [14]).
#### 7.3.2.7 Mode of MBMS bearer per media
A new MBMS bearer mode declaration attribute is defined which results in,
e.g.:
  * a=mbms-mode:broadcast 123869108302929 1
OR
  * a=mbms-mode:broadcast-sfn 123869108302929
The MBMS bearer mode declaration attribute shall be used in session
descriptions using one or more MBMS broadcast mode media or broadcast-sfn mode
media. If all media declarations use MBMS broadcast mode or broadcast-sfn
mode, then the SDP attribute may be declared at session level. In that case
the session level attribute applies to all media without a media level
occurance of the \"mbms-mode\" attribute. If one or more media using MBMS
multicast mode is present in the same declaration as media using MBMS
broadcast mode, then only media using the MBMS broadcast mode or broadcast-sfn
mode will contain the \"mbms-mode\" attribute.
mbms-bearer-mode-declaration-line = \"a=mbms-mode:\" (\"broadcast\" SP tmgi SP
mbms-counting-information) / ("broadcast-mbsfn" SP tmgi) CRLF
tmgi = 1*15DIGIT
mbms-counting-indication = 1 * DIGIT
Note: Please find below an example of the building of the TMGI:
UK MCC = 234 (MCC Digit 1 = 2; MCC Digit 2 = 3 and MCC Digit 3 = 4)
Vodafone UK MNC = 15
Therefore, with padding, Vodafone UK MNC = 15F (MNC Digit 1 = 1; MNC Digit 2 =
5 and MNC Digit 3 = F)
MBMS Service ID = 70A886
Therefore, TMGI = 70A886 32F451 (Hex)
Therefore, TMGI = 123869108302929 (Decimal)
The Temporary Mobile Group Identity (tmgi) information element is defined in
TS 24.008 [40] including the coding of the fields. . Octets 3 to 8 (MBMS
Service ID, MCC and MNC) shall be placed in the tmgi attribute of the MBMS
bearer mode declaration line, and are encoded as a decimal number. Octet 3 is
the most significant octet. As this is encoded as a decimal number, leading
zeros of the MBMS Service ID field may be omitted.
The MBMS Counting Information (mbms-counting-information) information element
is defined in TS 25.413 [87] and indicates whether the RAN level counting
procedures are applicable or not for the MBMS broadcast mode. The value 0
corresponds to the information element value of "not counting" and the value 1
corresponds to the information element value "counting".
#### 7.3.2.8 FEC capabilities and related parameters
A new FEC-declaration attribute is defined which results in, e.g.:
  * a=FEC-declaration:0 encoding-id=1
This attribute may be used on both session-level and media-level. Multiple
instances are allowed to specify several different FEC declarations. The
attribute is used on session level to define FEC declarations used by multiple
media components. On media level it is used to define FEC declarations which
are only valid for a single media component. If FEC declarations on both
session and media level use the same reference number (fec-ref) then the media
level declaration takes precedence for that media component. Each media
component references one FEC declaration using the "a=FEC" attribute.
This attribute is optional to use for the download delivery method as the
information will be available elsewhere (e.g. FLUTE FDT Instances). If this
attribute is not used, and no other FEC-OTI information is signalled to the UE
by other means, the UE may assume that support for FEC id 0 is sufficient
capability to enter the session.
A new FEC-declaration reference attribute is defined which results in, e.g.:
  * a=FEC:0
This is a media-level only attribute, used as a short hand to reference one of
one or more FEC-declarations.
The syntax for the attributes in ABNF [23] is:
fec-declaration-line = \"a=FEC-declaration:\" fec-ref SP fec-enc-id [\";\" SP
fec-inst-id] CRLF
fec-ref = 1*3DIGIT ; value is the SDP-internal identifier for FEC-declaration.
fec-enc-id = \"encoding-id=\" enc-id
enc-id = 1*DIGIT ; value is the FEC encoding ID used
fec-inst-id = \"instance-id=\" inst-id
inst-id = 1*DIGIT ; value is the FEC Instance ID used.
fec-line = \"a=FEC:\" fec-ref CRLF
#### 7.3.2.9 Service-language(s) per media
The existing SDP attribute \"a=lang\" is used to label the language of any
language-specific media. The values are taken from [73] which in turn takes
language and (optionally) country tags from ISO 639 [74] and ISO 3166 [75]
(e.g. \"a=lang:EN-US\"). These are the same tags used in the User Service
Description XML.
#### 7.3.2.10 Bandwidth Specification
The maximum bit-rate required by this FLUTE session shall be specified using
the \"AS\" bandwidth modifier [14] on media level. The Application Specific
(AS) bandwidth for a FLUTE session shall be the largest sum of the sizes of
all packets transmitted during any one second long period of the session,
expressed as kilobits. The size of the packet shall be the complete packet,
i.e. IP, UDP and FLUTE headers, and the data payload.
### 7.3.3 SDP Examples for FLUTE Session
Here is a full example of SDP description describing a FLUTE session:
_v=0_
_o=user123 2890844526 2890842807 IN IP6 2201:056D::112E:144A:1E24_
_s=File delivery session example_
_i=More information_
_t=2873397496 2873404696_
_a=mbms-mode:broadcast 123869108302929 1_
_a=FEC-declaration:0 encoding-id=1_
_a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9_
_a=flute-tsi:3_
_m=application 12345 FLUTE/UDP 0_
_c=IN IP6 FF1E:03AD::7F2E:172A:1E24/1_
_b=64_
_a=lang:EN_
_a=FEC:0_
## 7.4 OMA Push usage for MBMS Download
### 7.4.1 Introduction
OMA Push may be used for MBMS download reception when MBMS Bearers are not
available. The MBMS UE registers its MSISDN with the BM-SC to receive the
Download Sessions using OMA Push. The BM-SC distributes FLUTE FDT instance
which allows the MBMS UE to fetch files of interest.
If the MBMS UE is out of its home network and if at least one
_unicastAccessURI_ element is available in the deliver method description, the
MBMS UE should register its MBMS Download Services with the BM-SC.
### 7.4.2 HTTP registration and deregistration procedure
The MBMS UE may register and deregister for unicast service delivery, if the
MBMS User Service Description for this service includes at least one
_unicastAccessURI_ element in the _deliveryMethod_ element.
The HTTP (RFC 2616 [18]) GET method is used for this purpose. If more than one
_unicastAccessURI_ is provided in the _deliveryMethod_ element, the UE shall
randomly select one.
In the following, we give the details of the syntax used for the above request
method in ABNF [23].
  * unicast_access_request_http_URL = unicast_access_URI \"?\" > query
  * unicast_access_URI = \ Description; URI-reference is as defined in [19].>
  * query = action "&" serviceId \"&\" msisdn
  * action = "action=" ("register" \| "Register" \| "deregister" \| > "Deregister")
  * serviceId = \"serviceId=\" \ the User Service Description>
  * msisdn = "msisdn=" 1*DIGIT \
\
\
\
\
\
\
\
\
\
\
\
The UE will then have necessary information about all files in the FLUTE
session including their fileURIs, content encodings, content lengths etc.
## 7.5 FLUTE session setup and control with RTSP
### 7.5.1 Introduction
In case the MBMS User Service contains MBMS Streaming and MBMS Download
delivery sessions, it may be beneficial to control all flows with RTSP. The
prime use case of FLUTE session set-up and control with RTSP is for sending
MBMS streaming associated presentation data.
### 7.5.2 SDP handling
The FLUTE specific SDP extensions are defined in clause 7. For the FLUTE
session establishment using RTSP, a control URI as defined in [88] shall be
present for the FLUTE media description. Note, a control URI is defined by the
\"a=control:\" SDP field according to [88].
### 7.5.3 RTSP SETUP Method
The control URI as defined in [88] shall be present for each FLUTE media
description in the SDP. The control URI is used within the RTSP SETUP method
to establish the described FLUTE sessions.
The RTSP transport protocol specifier for FLUTE as defined in [88] shall be
\"FLUTE/UDP\". One and only one UDP port is allocated for each FLUTE channel.
The following RTP specific parameters shall be used in the transport request
and responds header for FLUTE sessions:
  * client_port: This parameter provides the unicast FLUTE port(s) on > which the client has chosen to receive FLUTE data.
  * server_port: This parameter provides the unicast FLUTE port(s) on > which the server has chosen to send data.
### 7.5.4 RTSP PLAY Method
The PLAY method tells the server to start sending data including FLUTE session
data as defined in [88]. The RTSP server forwards the FLUTE packets as
according by the RTSP range header in the RTSP PLAY.
Only ntp and clock range units may be used with the \"Range\" headers. Normal
Play Time (NPT) indicates the stream absolute position relative to the
beginning of the presentation. The NPT consists of a decimal fraction.The
clock range header describe the absolute time expressed as ISO 8601
timestamps, using UTC (GMT).
### 7.5.5 RTSP PAUSE Method
The PAUSE request causes the stream delivery including all FLUTE sessions to
be interrupted (halted) as defined in [88].
### 7.5.6 RTSP TEARDOWN Method
The TEARDOWN client to server request stops the stream delivery including all
FLUTE data delivery for the given URI, freeing the resources associated with
it. Details for the TEARDOWN method are defined in [88].
# 8 Streaming delivery method
## 8.1 Introduction
The purpose of the MBMS streaming delivery method is to deliver continuous
multimedia data (i.e. speech, audio, video and DIMS) over an MBMS bearer.
Using MBMS Streaming delivery on unicast is defined in clause 8.5. This
delivery method complements the download delivery method which consists of the
delivery of files. The streaming delivery method is particularly useful for
multicast and broadcast of scheduled streaming content.
## 8.2 Transport protocol
RTP is the transport protocol for MBMS streaming delivery. RTP provides means
for sending real-time or streaming data over UDP and is already used for the
transport of PSS in 3GPP. RTP provides RTCP for feedback about the
transmission quality. The transmission of RTCP packets in the downlink (sender
reports) is allowed. In this version of the specification, RTCP RR shall be
turned off by SDP RR bandwidth modifiers. Note that in the context of MBMS
detection of link aliveness is not necessary.
### 8.2.1 RTP payload formats for media
The RTP payload formats and corresponding MIME types are closely aligned with
those defined in PSS [47] . For RTP/UDP/IP transport of continuous media the
following RTP payload formats shall be used:
  * AMR narrow-band speech codec (see sub-clause 10.2) RTP payload > format according to RFC 4867 [33]. A MBMS client is not required > to support multi-channel sessions.
  * AMR wideband speech codec (see sub-clause 10.2) RTP payload format > according to RFC 4867 [33]. A MBMS client is not required to > support multi-channel sessions.
  * Extended AMR-WB codec (see sub-clause 10.3) RTP payload format > according to [34].
  * Enhanced aacPlus codec (see sub-clause 10.3) RTP payload format and > MIME types according to RFC 3640 [41], namely the Low Bit-Rate > AAC or the High Bit-Rate AAC modes.
  * H.264 (AVC) video codec (see sub-clause 10.5) RTP payload format > according to RFC 3984 [35]. An MBMS client supporting H.264 > (AVC) is required to support all three packetization modes: single > NAL unit mode, non-interleaved mode and interleaved mode. For the > interleaved packetization mode, an MBMS client shall support > streams for which the value of the \"sprop-deint-buf-req\" MIME > parameter is less than or equal to MaxCPB * 1000 / 8, inclusive, > in which \"MaxCPB\" is the value for Video Coding Layer (VCL) > parameters of the H.264 (AVC) profile and level in use, as > specified in [43].
  * DIMS (see sub-clause 10.12) RTP payload format according to [89].
  * Timed Text (see sub-clause 10.10) RTP payload format according to > [93].
### 8.2.2 FEC mechanism for RTP
The "MBMS FEC scheme" is described in sub-clause 8.2.2.8.
A UE that supports MBMS User Services shall support a decoder for the "MBMS
FEC scheme". The use of MBMS FEC by the sender is recommended, but it is
permitted not to use it. In the case where the FEC is not used by the sender,
the FEC Layer should not be used (i.e. RTP is mapped onto UDP directly).
This sub-clause defines a generic mechanism for applying Forward Error
Correction to streaming media. The mechanism consists of three components:
(i) construction of an FEC source block from the source media packets
belonging to one or several UDP packet flows related to a particular segment
of the stream(s) (in time). The UDP flows include RTP, RTCP, SRTP and MIKEY
packets.
(ii) modification of source packets to indicate the position of the source
data from the source packet within the source block
(iii)definition of repair packets, sent over UDP, which can be used by the FEC
decoder to reconstruct missing portions of the source block.
The mechanism does not place any restrictions on the source data which can be
protected together, except that the source data is carried over UDP. The data
may be from several different UDP flows that are protected jointly.
A receiver supporting the streaming delivery method shall support the packet
format for FEC source packets and may also support the packet format for FEC
repair packets.
At the sender, the mechanism begins by processing original UDP packets to
create:
(i) a stored copy of the original packets in the form of a source block; and
(ii) FEC source packets for transmission to the receiver.
After constructing the source block from the original UDP payloads to be
protected and their flow identity (based on destination IP address and UDP
port), the FEC encoder generates the desired amount of FEC protection data,
i.e. encoding symbols. These repair symbols are then sent using the FEC repair
packet format to the receiver. The FEC repair packets are sent to a UDP
destination port different from any of the original UDP packets\' destination
port(s) as indicated by the signaling.
The receiver recovers the original packets directly from the FEC source
packets and buffers them at least min-buffer-time to allow time for the FEC
repair. The receiver uses the FEC source packets to construct a (potentially
incomplete) copy of the source block, using the Source FEC Payload ID in each
packet to determine where in the source block the packet shall be placed. The
indication of the UDP flow (i.e. destination IP address and UDP port number)
that the packet is part of, is included in the source block with the UDP
payload.
If any FEC source packets have been lost, but sufficient FEC source and FEC
repair packets have been received, FEC decoding can be performed to recover
the FEC source block. The original packets UDP payload and UDP flow identity
can then be extracted from the source block and provided to the upper layer.
If not enough FEC source and repair packets were received, only the original
packets that were received as FEC source packets will be available. The rest
of the original packets are lost.
If a UE that supports MBMS User Services receives a mathematically sufficient
set of encoding symbols generated according to the encoder specification in
Annex B for reconstruction of a source block, then the decoder shall recover
the entire source block. Note that the example decoder described in [91]
clause 5.5 fulfils this requirement.
Note that the receiver must be able to buffer all the original packets and
allow time for the FEC repair packets to arrive and FEC decoding to be
performed before media playout begins. The min-buffer-time parameter specified
in sub-clause 8.3.1.8 helps the receiver to determine a sufficient duration
for initial start-up delay.
The Source and Repair FEC payload IDs are used to associate the FEC source
packets and FEC repair packets, respectively, to a source block. The Source
and Repair FEC payload ID formats are part of the definition of the FEC
scheme. Each FEC scheme is identified by an FEC Encoding ID and, in the case
of underspecified FEC schemes, FEC Instance ID, values. One FEC scheme for the
streaming delivery method is specified in sub-clause 8.2.2.8. Any FEC schemes
using the packet formats defined in the present document shall be systematic
FEC codes and may use different FEC payload ID formats for FEC source packets
and FEC repair packets.
The protocol architecture is illustrated in figure 11.
Figure 11: FEC mechanism for the streaming delivery method interaction diagram
Figure 11 depicts how one or more out of several possible packet flows of
different types (Audio, video, DIMS, text RTP and RTCP flows, MIKEY flow) are
sent to the FEC layer for protection. The source packets are modified to carry
the FEC payload ID and a new flow with repair data is generated. The receiver
takes the source and repair packets and buffers them to perform, if necessary,
the FEC decoding. After appropriate buffering received and recovered source
packets are forwarded to the higher layers. The arrows in the figure indicate
distinct data flows.
#### 8.2.2.1 Sending Terminal Operation (Informative)
It is assumed that the sender has constructed or received original data
packets for the session. These may be RTP, RTCP, MIKEY or other UDP packets.
The following procedures are based on the UDP payload and the identity of the
UDP flow.
In order to FEC protect a sequence of original data packets, the sender
constructs a source block as specified in sub-clause 8.2.2.6 to which the FEC
algorithm is to be applied, and includes the original source packet data
within FEC source packets. The following operations describe a possible way to
generate compliant FEC source packet and FEC repair packet streams:
1\. Each original packet is placed in the source block. In doing so, the
Source FEC Payload ID information to be included in the FEC payload ID of the
FEC source packet can be determined. In the source block the identity of the
packet's flow is marked using the Flow ID. See sub-clauses 8.2.2.6 and 8.2.2.7
for details.
2\. The FEC source packet is constructed according to sub-clause 8.2.2.4. The
identity of the original flow is maintained by the source packet through the
use of the destination UDP port number and destination IP address, which has
been advertised (for example using SDP), as carrying FEC source packets
generated from an original stream of a particular protocol (e.g. RTP, RTCP,
SRTP, MIKEY etc.). See sub-clause 8.2.2.13.
3\. The generated FEC source packet is sent using UDP.
When a source block is complete, the FEC encoder generates encoding symbols
and places these symbols into FEC repair packets, to be conveyed to the
receivers. These repair packets are sent using normal UDP procedures to a
unique destination port to separate it from any of the source packet flows.
In particular cases it may be advantageous not to use FEC for some source
blocks and to signal this to the receiver. In this case the sender may send
one or more empty repair packets consisting exclusively of the Repair FEC
Payload ID. This will be helpful in particular for selective FEC where some of
the source blocks (e.g. consisting of reference video frames) are FEC
protected while others (e.g. consisting exclusively of non-reference frames)
will not be protected.
#### 8.2.2.2 Receiving Terminal Operation (Informative)
The following describes a possible receiver algorithm, when receiving an FEC
source or repair packet:
1\. If a FEC source packet is received (as indicated by the UDP port on which
was received):
a. The original source packet is reconstructed by removing the Source FEC
Payload ID. The resulting packet is buffered to allow time for the FEC repair.
b. The resulting packet is placed into the source block according to the
information in the Source FEC Payload ID and the source block format described
in sub-clause 8.2.2.6. The UDP port the packet was received on is used to
determine the Flow ID written into the source block.
2\. If an FEC repair packet is received (as indicated by the UDP port), the
contained encoding symbols are placed into an FEC encoding block according to
the Repair FEC Payload ID. In case the received FEC repair packet is empty,
there are no repair symbols to be placed in the FEC encoding block.
3\. If at least one source packet is missing, then FEC decoding may be
desirable. The FEC decoder determines if the encoding block constructed in
steps 1 and 2 contains enough symbols from the source and repair packets for
decoding and, if so, performs the decoding operation. If only empty FEC repair
packets are received, the receiver may start immediately some procedures to
conceal the effect of missing media data.
4\. Any missing source packets that were reconstructed during the decoding
operation are then buffered as normal received packets (see step 1a above).
Note that the above procedure may result in that not all original packets are
recovered, and they must simply be marked as being lost.
Obviously, buffering and packet re-ordering are required to insert any
reconstructed packets in the appropriate place in the packet sequence if that
is necessary according to the used higher layer protocol (RTP, RTCP or MIKEY).
To allow receivers to determine the minimal start-up buffering requirement for
FEC decoding, the min-buffer-time parameter indicates a minimum initial
buffering time that is sufficient regardless of the position of the stream in
which the reception starts.
#### 8.2.2.3 (Void)
#### 8.2.2.4 Packet format for FEC source packets
The packet format for FEC source packets shall be used to encapsulate an
original UDP packet.. As depicted in figure 12, it consists of the original
UDP packet, followed by the Source FEC payload ID.
* * *
IP Header UDP Header Original UDP Payload Source FEC Payload ID
* * *
Figure 12: Structure of the FEC packet format for FEC source packets
The destination IP address and UDP port shall be set as indicated in the
session control signalling. This ensures that the receiver can determine which
protocols and FEC Payload ID formats are used for this flow. The remaining
fields in the IP and UDP headers shall be set according to their
specifications.
The UDP payload shall consist of the original UDP Payload followed by the
Source FEC Payload ID.
The Source FEC Payload ID consists of information required for the operation
of the FEC algorithm. Its construction is specified in sub-clause 8.2.2.9.
The FEC Source packets over IP and UDP are indicated to be used for a flow by
using one of the SDP protocol identifiers "UDP/MBMS-FEC/RTP/AVP", "UDP/MBMS-
FEC/RTP/SAVP" depending on the upper layer protocol RTP/AVP or RTP/SAVP
respectively. If MIKEY is FEC protected and encapsulated in source packets,
then it is indicated in the security description using the _fecProtection_
element and the destination IP address.
#### 8.2.2.5 Packet Format for Repair packets
The packet format for FEC repair packets carries, as its payload, encoding
symbols generated by the FEC encoding process. The format of a FEC repair
packet is depicted in figure 13. The UDP payload consists of the Repair FEC
Payload ID, and zero, one or more repair symbols. The format of the Repair FEC
payload ID is defined in clause 8.2.2.10.
* * *
IP Header UDP Header Repair FEC Payload ID Repair symbols
* * *
Figure 13: Payload structure for FEC repair packets
The repair packet sent over IP and UDP is indicated in the SDP using the
protocol identifier "UDP/MBMS-REPAIR".
#### 8.2.2.6 Structure of the FEC source block
This clause defines the layout of the FEC source block.
The FEC source block shall contain at least one complete UDP packet payload
(i.e. excluding the IP and UDP headers), and three octets indicating the UDP
flow from which the packet was taken and the length of the UDP packet. Note:
this implies that no source UDP packet be larger than the length of the FEC
source block minus 3.
Let
_n be the number of UDP packets in the source block. n is determined
dynamically during the source block construction process._
_R~i~ denote the octets of the UDP payload of the ith UDP packet to be added
to the source block._
_l~i\ ~_ be the length of _R~i~_ in octets.
_L~i~_ denote two octets representing the value of _l~i~_ in network byte
order (high order octet first).
_f~i~_ denote an integer "flow ID" identifying the UDP flow from which the
i^th^ packet was taken
_F~i~_ denote a single octet representing the value of _f~i~_
_s~i~_ be the smallest integer such that _s~i~T >= (l~i~+3)_.
_P~i~_ denote _s~i~T_ -( _l~i~_ +3) zero octets. Note: _P~i~_ are padding
octets to align the start of each UDP packet with the start of a symbol.
_T_ be the source symbol size in bytes.
Then, the source block is constructed by concatenating _F~i~ ,L~i~_ , _R~i~_ ,
_P~i~_ for _i_ = 1, 2, ... _n_. and the source block size, S = sum {_s~i~T_ ,
_i_ =1, ..., _n_}.
A UDP flow is uniquely defined by an IP source and destination address and UDP
source and destination port value. The assignment of Flow ID values to UDP
flows is described in sub-clauses 8.2.2.13 and 8.3.1.9.
#### 8.2.2.7 FEC block Construction algorithm and example (informative)
When the original UDP packet is placed into the source block, the value of the
UDP flow identifier, F, followed by the value of the UDP payload length, L,
are first written as a single byte and two-byte value in network byte order
(i.e. with high order byte first) respectively into the first available bytes
in the source block, followed by the UDP packet payload itself (i.e. not
including the IP/UDP headers). Following this, if the next available byte is
not the first byte of a new symbol, then padding bytes up to the next symbol
boundary shall be included using the value 0 in each byte. As long as any
source UDP packets remain to be placed, the procedure is repeated starting
each UDP flow identifier at the start of the next encoding symbol.
An example of forming a source block is given in figure 14 below. In this
example, three UDP packets of lengths 26, 52 and 103 bytes have been placed
into a source block with symbol size T = 16 bytes. The first two packets are
from UDP flow 0 and the third from UDP flow 1. Each entry in Figure 14 is a
byte and the rows correspond to the source symbols and are numbered from 0 to
12. B~i,j~ denotes the (j+1)th byte of the (i+1)th UDP packet.
* * *
0 26 _B_ 0,0 _B_ 0,1 _B_ 0,2 _B_ 0,3 _B_ 0,4 _B_ 0,5 _B_ 0,6 _B_ 0,7 _B_ 0,8
_B_ 0,9 _B_ 0,10 _B_ 0,11 _B_ 0,12  
_B_ 0,13 _B_ 0,14 _B_ 0,15 _B_ 0,16 _B_ 0,17 _B_ 0,18 _B_ 0,19 _B_ 0,20 _B_
0,21 _B_ 0,22 _B_ 0,23 _B_ 0,24 _B_ 0,25 0 0 0 0 52 _B_ 1,0 _B_ 1,1 _B_ 1,2
_B_ 1,3 _B_ 1,4 _B_ 1,5 _B_ 1,6 _B_ 1,7 _B_ 1,8 _B_ 1,9 _B_ 1,10 _B_ 1,11 _B_
1,12  
_B_ 1,13 _B_ 1,14 _B_ 1,15 _B_ 1,16 _B_ 1,17 _B_ 1,18 _B_ 1,19 _B_ 1,20 _B_
1,21 _B_ 1,22 _B_ 1,23 _B_ 1,24 _B_ 1,25 _B_ 1,26 _B_ 1,27 _B_ 1,28 _B_ 1,29
_B_ 1,30 _B_ 1,31 _B_ 1,32 _B_ 1,33 _B_ 1,34 _B_ 1,35 _B_ 1,36 _B_ 1,37 _B_
1,38 _B_ 1,39 _B_ 1,40 _B_ 1,41 _B_ 1,42 _B_ 1,43 _B_ 1,44 _B_ 1,45 _B_ 1,46
_B_ 1,47 _B_ 1,48 _B_ 1,49 _B_ 1,50 _B_ 1,51 0 0 0 0 0 0 0 0 0 1 103 _B_ 2,0
_B_ 2,1 _B_ 2,2 _B_ 2,3 _B_ 2,4 _B_ 2,5 _B_ 2,6 _B_ 2,7 _B_ 2,8 _B_ 2,9 _B_
2,10 _B_ 2,11 _B_ 2,12  
_B_ 2,13 _B_ 2,14 _B_ 2,15 _B_ 2,16 _B_ 2,17 _B_ 2,18 _B_ 2,19 _B_ 2,20 _B_
2,21 _B_ 2,22 _B_ 2,23 _B_ 2,24 _B_ 2,25 _B_ 2,26 _B_ 2,27 _B_ 2,28 _B_ 2,29
_B_ 2,30 _B_ 2,31 _B_ 2,32 _B_ 2,33 _B_ 2,34 _B_ 2,35 _B_ 2,36 _B_ 2,37 _B_
2,38 _B_ 2,39 _B_ 2,40 _B_ 2,41 _B_ 2,42 _B_ 2,43 _B_ 2,44 _B_ 2,45 _B_ 2,46
_B_ 2,47 _B_ 2,48 _B_ 2,49 _B_ 2,50 _B_ 2,51 _B_ 2,52 _B_ 2,53 _B_ 2,54 _B_
2,55 _B_ 2,56 _B_ 2,57 _B_ 2,58 _B_ 2,59 _B_ 2,60 _B_ 2,61 _B_ 2,62 _B_ 2,63
_B_ 2,64 _B_ 2,65 _B_ 2,66 _B_ 2,67 _B_ 2,68 _B_ 2,69 _B_ 2,70 _B_ 2,71 _B_
2,72 _B_ 2,73 _B_ 2,74 _B_ 2,75 _B_ 2,76 _B_ 2,77 _B_ 2,78 _B_ 2,79 _B_ 2,80
_B_ 2,81 _B_ 2,82 _B_ 2,83 _B_ 2,84 _B_ 2,85 _B_ 2,86 _B_ 2,87 _B_ 2,88 _B_
2,89 _B_ 2,90 _B_ 2,91 _B_ 2,92 _B_ 2,93 _B_ 2,94 _B_ 2,95 _B_ 2,96 _B_ 2,97
_B_ 2,98 _B_ 2,99 _B_ 2,100 _B_ 2,101 _B_ 2,102 0 0 0 0 0 0
* * *
Figure 14: Source block consisting of 3 source UDP packets of lengths 26, 52
and 103 bytes.
#### 8.2.2.8 MBMS FEC scheme definition
This clause defines a FEC encoding scheme for MBMS forward error correction as
defined in Annex B for the streaming delivery method. This scheme is
identified by the FEC encoding ID 1. It utilizes the method for forming FEC
source block as defined in sub-clause 8.2.2.6. It defines two different FEC
Payload ID formats, one for FEC source packets and another for FEC repair
packets.
#### 8.2.2.9 Source FEC Payload ID
The Source FEC payload ID is composed as follows:
* * *
Source Block Number (SBN) Encoding Symbol ID (ESI)
* * *
**Source Block Number (SBN), (16 bits):** **An integer identifier for the
source block that the source data within the packet relates to**.
**Encoding Symbol ID (ESI), (16 bits):** The starting symbol index of the
source packet in the source block.
Figure 15: Source FEC Payload ID
The interpretation of the Source Block Number and Encoding Symbol Identifier
is defined in Annex B.
#### 8.2.2.10 Repair FEC payload ID
The structure of the Repair FEC Payload ID is as follows:
* * *
Source Block Number (SBN) Encoding Symbol ID (ESI) Source Block Length (SBL)
* * *
> **Source Block Number (SBN), (16 bits):** **An integer identifier for the
> source block that the repair symbols within the packet relate to**.
>
> **Encoding Symbol ID (ESI), (16 bits):** An **integer identifier for the
> encoding symbols within the packet**.
>
> **Source Block Length (SBL), (16 bits):** The number of source symbols in
> the source block.
>
> **The interpretation of the Source Block Number, Encoding Symbol Identifier
> and Source Block Length is defined in Annex B.**
Figure 16: Repair FEC Payload ID
In case of empty Repair FEC packets, the actual value of ESI is irrelevant and
it may take any value between 0X0000 and 0XFFFF.
#### 8.2.2.10a FEC Object Transmission information
The FEC Object Transmission information shall consist of:
  * the maximum source block length, in symbols
  * the symbol size, in bytes
The symbol size and maximum source block length shall be encoded into a 4
octet field (Network Byte Order) defined as follows:
* * *
Symbol Size (_T_) Maximum Source Block Length
* * *
Symbol Size (_T_) (16 bits): The size of an encoding symbol, in bytes,
Maximum Source Block Length (16 bits): The maximum length of a source block,
in symbols.
The interpretation of _T_ is defined in Annex B.
The Source Block Length signalled within the Repair FEC Payload ID of any
packet of a stream shall not exceed the Maximum Source Block Length signalled
within the FEC Object Transmission Information for the stream.
The FEC Object Transmission Information shall be communicated as described in
sub-clause 8.2.2.14. Note, the FEC Object Transmission Information is only
communicated in SDP.
#### 8.2.2.11 Hypothetical FEC Decoder
This clause specifies the hypothetical FEC decoder and its use to check packet
stream and MBMS receiver conformance.
The hypothetical FEC decoder uses the packet stream, the transmission time of
each packet, the initial buffering delay, and the SDP for the stream as
inputs. The packet stream from the beginning of the FEC source block until the
end of the stream shall comply with the hypothetical reference decoder as
specified below when the initial buffer delay equals to the value of the min-
buffer-time parameter.
The maximum hypothetical FEC decoding buffer size for MBMS streaming is 1
Mbytes. The default hypothetical FEC decoding buffer size is equal to 1
Mbytes.
For the packet stream, the buffer occupancy level of the hypothetical FEC
decoding buffer shall not exceed the value of the buf-size parameter, when it
is present in the SDP, or the default FEC decoding buffer size, when the buf-
size parameter is not present in the SDP. The output of the hypothetical FEC
decoder shall comply with the RTP payload and decoding specifications of the
media format.
The hypothetical FEC decoder operates as follows:
1) The hypothetical FEC decoding buffer is initially empty.
2) Each FEC source packet and FEC repair packet, starting from the first
packet in transmission order, is inserted into a FEC source block at its
transmission time. The FEC source block generation is done as specified in
sub-clause 8.2.2.7. The FEC source block resides in the hypothetical FEC
decoding buffer.
3) When both the last FEC source packet and the last FEC repair packet of an
FEC source block are transmitted, any elements of the FEC source block that
are not original UDP packets (e.g. FEC repair packets and potential padding
bytes) are removed from the hypothetical FEC decoding buffer.
4) Original UDP packets are not removed from the hypothetical FEC decoding
buffer before the signaled initial buffering delay has expired. Then, the
first original UDP packet in sequence number order is output and removed from
the hypothetical FEC decoding buffer immediately. Each succeeding original UDP
packet is output and removed when the following conditions are true:
i. The following time (in seconds) since the removal of the previous packet
has elapsed:
8 × (size of the previous original UDP packet _including_ UDP/IP header in
bytes) / (1 000 × (value of \"b=AS\" SDP attribute for the stream))
ii. All the packets in the same FEC source block as the original UDP packet
have been transmitted.
An MBMS client shall be capable of receiving a packet stream that complies
with the hypothetical FEC decoder. Furthermore, in the case of RTP packets,
when an MBMS client complies with the requirements for the media decoding of
the packet stream, it shall be able to de-packetize and decode the packet
stream and output decoded data at the correct rate specified by the RTP
timestamps of the received packet stream.
#### 8.2.2.12 FEC encoding procedures
FEC encoding shall be performed using the MBMS forward error correction code
defined in Annex B.
#### 8.2.2.13 Signalling
The signalling for streaming FEC consists of several components:
  * If several user services are bundled together they are indicated as a sequence of services in the User Service Bundle Description. See sub-clause 11.2.
  * A separate SDP describing the FEC repair stream and all the flow IDs referenced from the User Service Bundle Description. See sub-clauses 11.2 and 8.2.2.14.
  * SDP protocol identifiers and attributes to indicate the usage of the source packet format, how the FEC payload ID is configured and other FEC parameters such as minimal buffering delay, for the RTP/RTCP streams. See sub-clause 8.2.2.13a.
  * Security description extensions to indicate usage of FEC source packet format, and the FEC parameters. See sub-clauses 11.3 and 8.2.2.13a.
The user service description contains either a single service or several
bundled services. All of the streaming delivery methods and security
descriptions that are present within the _bundleDescription_ element must be
considered when configuring the FEC operations. This includes RTP, RTCP and
MIKEY flows. A receiver intending to perform FEC decoding to cover for packet
losses shall receive all the flows that are indicated to be sent as FEC source
packets, even if the flows are in a service currently not played out. A
receiver intending to use FEC shall also receive the FEC repair stream as
described by the FEC Repair Stream Description. The delivery method's session
description, and the security description both carry the FEC source packet
configuration information: FEC encoding ID, FEC instance ID, and FEC OTI
information. The FEC repair packet stream is configured using the similar
methods as for the source packets, with the addition of the Flow ID
information and buffer delay parameter.
#### 8.2.2.13a SDP for FEC source packet streams
To indicate the presence of the FEC layer between IP/UDP and, RTP or SRTP a
SDP protocol identifier is used. Instead of the normal RTP/AVP and RTP/SAVP
protocol identifiers, 'UDP/MBMS-FEC/RTP/AVP' and 'UDP/MBMS-FEC/RTP/SAVP' are
defined respectively. Both these protocol identifiers shall use the FMT space
rules that are used for RTP/AVP and RTP/SAVP respectively, i.e. payload types
used in the RTP session is listed. The protocol identifiers are defined in
Appendix C1.
The FEC parameters, FEC encoding ID, FEC instance ID and FEC-OTI-Extension
information are signalled using the mechanism defined in sub-clause 8.3.1.8.
The "a=FEC" SDP attribute shall be used to indicate the single definition that
is used for each media component.
For MIKEY messages the service protection description is used to indicate when
FEC source packet shall be used, see sub-clause 11.3. The FEC parameter used
is also defined in the service protection description. As all MIKEY packets
from all user services arrive on the same port, the receiver must use the
destination address to separate FEC protected packets from not FEC protected
packets. This requires that all MIKEY packets sent to a specific destination
address are either FEC protected or not. Note that it is not possible to mix
protected and non-protected packets within a single stream as there is no
mechanism to determine whether they are protected or not.
#### 8.2.2.14 SDP for FEC repair packet streams
The repair packet stream is indicated in SDP using a media block with the
protocol identifier "UDP/MBMS-REPAIR". The media type shall be "application".
The FEC parameters, FEC encoding ID, FEC instance ID, FEC-OTI-Extension
information and repair parameters (min-buffer-time) are signalled using the
mechanisms defined in sub-clause 8.3.1.9. Each media component shall reference
only one FEC declaration.
The mapping of the FEC source block flow ID (see sub-clause 8.2.2.6) to the
destination IP address and UDP port are done using the SDP attribute "a=mbms-
flowid" defined in sub-clause 8.3.1.9.
Interleaving may be signaled using the "X-3gpp-FEC-Interleaving" attribute,
which also gives the arrangement of the flows in the source block and by
consequence their transmission order. The "X-3gpp-FEC-Interleaving" attribute
is defined in sub-clause 8.3.1.11.
#### 8.2.2.15 Signalling example for FEC
This sub-clause contains a complete signalling example for a MBMS multicast
mode session using FEC with a Service description, a SDP for the streaming
delivery method, a SDP for the FEC repair stream, and a security description.
The following is an example bundleDescription.
> \
>
> \ xmlns=\"urn:3GPP:metadata:2005:MBMS:userServiceDescription\"\
> xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"
>
> fecDescriptionURI=\"http://www.example.com/3gpp/mbms/session1-fec.sdp\">
>
> \
> serviceId=\"urn:3gpp:0010120123hotdog\">\ \ sessionDescriptionURI=\"http://www.example.com/3gpp/mbms/session1.sdp\"
>
> protectionDescriptionURI=\"http://www.example.com/3gpp/mbms/sec-descript\"/>
>
> \
>
> \
The security description has the URI: http://www.example.com/3gpp/mbms/sec-
descript
> \
>
> \
> xmlns=\"urn:3GPP:metadata:2005:MBMS:securityDescription\"
>
> xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"
>
> confidentialityProtection=\"true\"
>
> integrityProtection=\"true\"
>
> uiccKeyManagement=\"true\"
>
> \
> waitTime=\"5\"
>
> maxBackOff=\"10\">
>
> \http://register.example.com/\
>
> \http://register2.example.com/\
>
> \
>
> \
>
> \
>
> \
>
> \aMoM\
>
> \aMoAAA==\
>
> \
>
> \
>
> \ srtpAuthenticationTagLength=\"4\">
>
> \
>
> \GM8M\
>
> \aMkAAA==\
>
> \
>
> \
>
> \
>
> \
> fecEncodingId=\"1\"
>
> fecOtiExtension=\"ACAEAA==\"/>
\
An example of how the SDP http://www.example.com/3gpp/mbms/session1.sdp could
look for a session containing two media streams that are FEC protected. In
this example we have assumed an audiovisual stream, using 56 kbps for video
and 12 kbps for audio. In addition another 300 bits/second of RTCP packets
from the source is used for the each of the sessions. Hence, the total media
session bandwidth is 56+12+0.3+0.3 = 68.6 kbps.
v=0\ o=ghost 2890844526 2890842807 IN IP6 _2001:210:1:2:240:96FF:FE25:8EC9_ \
s=3GPP MBMS Streaming SDP Example\ i=Example of MBMS streaming SDP file\
u=http://www.infoserver.example.com/ae600\ e=ghost\@mailserver.example.com\
c=IN IP6 FF1E:03AD::7F2E:172A:1E24\ t=3034423619 3042462419
b=AS:62
b=TIAS: 60500
a=maxprate: 25
a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9
a=FEC-declaration:0 encoding-id=1
m=video 4002 UDP/MBMS-FEC/RTP/AVP 96
b=TIAS:55000
b=RR:0
b=RS:300
a=rtpmap:96 H263-2000/90000\ a=fmtp:96 profile=3;level=10\ a=framesize:96
176-144
a=FEC:0
a=maxprate:15
m=audio 4004 UDP/MBMS-FEC/RTP/AVP 98
b=TIAS: 11500
b=RR:0
b=RS:300
a=rtpmap:98 AMR/8000
a=fmtp:98 octet-align=1
a=FEC:0
a=maxprate:10
The FEC stream used to protect the above RTP sessions and a MIKEY key stream
has the below SDP (http://www.example.com/3gpp/mbms/session1-fec.sdp):
v=0\ o=ghost 2890844526 2890842807 IN IP6 _2001:210:1:2:240:96FF:FE25:8EC9_ \
s=3GPP MBMS Streaming FEC SDP Example\ i=Example of MBMS streaming SDP file\
u=http://www.infoserver.example.com/ae600\ e=ghost\@mailserver.example.com\
c=IN IP6 FF1E:03AD::7F2E:172A:1E24\ t=3034423619 3042462419
b=AS:15
a=FEC-declaration:0 encoding-id=1
a=FEC-OTI-extension:0 ACAEAA==
a=mbms-repair: 0 min-buffer-time=2600
_a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9_
m=application 4006 UDP/MBMS-REPAIR *
b=AS:15
a=FEC:0
a=mbms-flowid: 1=FF1E:03AD::7F2E:172A:1E24/4002,
2=FF1E:03AD::7F2E:172A:1E24/4003, 3=FF1E:03AD::7F2E:172A:1E24/4004,
4=FF1E:03AD::7F2E:172A:1E24/4005, 5=FF1E:03AD::7F2E:172A:1E24/2269
a=X-3gpp-FEC-Interleaving: 1=\"reverse\", 2=\"ordered\"
A more traditional FEC configuration is shown below. The audio and video media
components use different FEC repair flows. The same principle can also be
applied when bundling several user services together.
> \
>
> \ xmlns=\"urn:3GPP:metadata:2005:MBMS:userServiceDescription\"\
> xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"
>
> fecDescriptionURI=\"http://www.example.com/3gpp/mbms/session2-fec.sdp\">
>
> \
> serviceId=\"urn:3gpp:0010120123hotdog\">\ \ sessionDescriptionURI=\"http://www.example.com/3gpp/mbms/session2.sdp\"/>
>
> \
>
> \
The SDP file from above is modified to use two different FEC flows.
v=0\ o=ghost 2890844526 2890842807 IN IP6 _2001:210:1:2:240:96FF:FE25:8EC9_ \
s=3GPP MBMS Streaming SDP Example\ i=Example of MBMS streaming SDP file\
u=http://www.infoserver.example.com/ae600\ e=ghost\@mailserver.example.com\
c=IN IP6 FF1E:03AD::7F2E:172A:1E24\ t=3034423619 3042462419
b=AS:62
b=TIAS: 60500
a=maxprate: 25
a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9
m=video 4002 UDP/MBMS-FEC/RTP/AVP 96
b=TIAS:55000
b=RR:0
b=RS:300
a=FEC-declaration:0 encoding-id=1
a=rtpmap:96 H263-2000/90000\ a=fmtp:96 profile=3;level=10\ a=framesize:96
176-144
a=FEC:0
a=maxprate:15
m=audio 4004 UDP/MBMS-FEC/RTP/AVP 98
b=TIAS: 11500
b=RR:0
b=RS:300
a=FEC-declaration:1 encoding-id=1
a=rtpmap:98 AMR/8000
a=fmtp:98 octet-align=1
a=FEC:1
a=maxprate:10
The SDP file for the two FEC streams
v=0\ o=ghost 2890844526 2890842807 IN IP6 _2001:210:1:2:240:96FF:FE25:8EC9_ \
s=3GPP MBMS Streaming FEC SDP Example\ i=Example of MBMS streaming SDP file\
u=http://www.infoserver.example.com/ae600\ e=ghost\@mailserver.example.com\
t=3034423619 3042462419
b=AS:15
_a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9_
m=application 4006 UDP/MBMS-REPAIR *
c=IN IP6 FF1E:03AD::7F2E:172A:1E24
b=AS:15
a=FEC-declaration:0 encoding-id=1
a=FEC-OTI-extension:0 ACAEAA==
a=mbms-repair: 0 min-buffer-time=2600
a=FEC:0
a=mbms-flowid: 1=FF1E:03AD::7F2E:172A:1E24/4002,
2=FF1E:03AD::7F2E:172A:1E24/4003
m=application 4008 UDP/MBMS-REPAIR *
c=IN IP6 FF1E:03AD::7F2E:172A:1E24
b=AS:15
a=FEC-declaration:1 encoding-id=1
a=FEC-OTI-extension:1 ACAEAA==
a=mbms-repair: 1 min-buffer-time=2600
a=FEC:1
a=mbms-flowid: 3=FF1E:03AD::7F2E:172A:1E24/4004,
4=FF1E:03AD::7F2E:172A:1E24/4005
### 8.2.3 General RTP Header Extension Mechanism
#### 8.2.3.1 Introduction
The General RTP Header Extension Mechanism [92] is a general mechanism to use
the header extension feature of RTP (the Real-Time Transport Protocol). The
General RTP Header Extension Mechanism should be supported.
#### 8.2.3.2 Timestamp Offset
Timestamp offsets for RTP may be transmitted using the general RTP header
extension mechanism.
The variable timestamp extension element is 32 bits long. The first byte is
the extension element header, i.e. the ID and len fields, as defined in [92].
The remaining 3 bytes are the timestamp-offset measured in the same frequency
as the RTP timestamp.
Timestamp-offset: A 24 bit unsigned integer signaling the offset of the
received packets of the same media in the tune-in FEC block. The timestamp
offset indicates at most the difference between the RTP timestamp of the
current packet and the highest RTP timestamp of packets of the same media
stream that are transmitted in the current FEC source block.
Timestamp offset shall not be used if FEC protection and Interleaving are not
being used.
The following example is a general RTP header extension block containing a
single variable timestamp extension element.
0 1 2 3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\| 0xBEDE \| length=1 \|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\| ID \| len=2 \| timestamp-offset \|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
The presence of variable timestamps is signaled in the SDP file using the
header extension specification and the URI
\"http://www.3gpp.org/2008/TimestampOffset\". The URI signals the possible
presence of timestamp offsets with the given ID.
## 8.3 Session description
SDP is provided to the MBMS client via a discovery/announcement procedure to
describe the streaming delivery session. The SDP describes one or more RTP
sessions part of the MBMS streaming session. The SDP shall be a correctly
formed SDP according to [14].
### 8.3.1 SDP Parameters for MBMS streaming session
The semantics of a Session Description of an MBMS streaming session shall
include the parameters:
  * The sender IP address.
  * The number of media in the session.
  * The destination IP address and port number for each and all of the > RTP sessions in the MBMS streaming session.
  * The start time and end time of the session.
  * The protocol ID (i.e. RTP/AVP).
  * Media type(s) and fmt-list.
  * Data rate using existing SDP bandwidth modifiers.
  * Mode of MBMS bearer per media.
  * FEC configuration and related parameters.
  * Service-language(s) per media.
  * QoE Metrics (defined in sub-clauses 8.3.2.1 and 8.4).
#### 8.3.1.1 Sender IP address
There shall be exactly one IP source address per media description within the
SDP. The IP source address shall be defined according to the source-filter
attribute (\"a=source-filter:\") [15] for both IPv4 and IPv6 sources, with the
following exceptions:
1\. Exactly one source address may be specified by this attribute such that
exclusive-mode shall not be used and inclusive-mode shall use exactly one
source address in the \.
2\. There shall be exactly one source-filter attribute per complete MBMS
streaming session SDP description, and this shall be in the session part of
the session description (i.e. not per media).
3\. The * value shall be used for the \ subfield.
#### 8.3.1.2 Destination IP address and port number for channels
Each RTP session part of a MBMS streaming session is defined by two
parameters:
  * IP destination address.
  * Destination port number(s).
The IP destination address shall be defined according to the \"connection
data\" field (\"c=\") of [14]. The destination port number shall be defined
according to the \ sub-field of the media announcement field (\"m=\") of
[14]. Multiple ports using \"/\" notation shall not be used. The RTCP port, if
used, shall be RTP port +1.
#### 8.3.1.3 Media Description
The media description line shall be used as defined in [14] for RTP. The
\ part indicates the type of media, audio, video, or text. The usage of
RTP and any applicable RTP profile shall be indicated by using the \
field of the \'_m-_ line\'. The one or more payload types that are being used
in this RTP session are enumerated in the \ part. Each payload type is
declared using the \"a=rtpmap\" attribute according to [14] and use the
\"a=fmtp\" line when required to describe the payload format parameters.
#### 8.3.1.4 Session Timing Parameters
A MBMS streaming session start and end times shall be defined according to the
SDP timing field (\"t=\") - [14].
#### 8.3.1.5 Mode of MBMS bearer per media
The MBMS bearer mode declaration attribute shall be used for MBMS streaming
sessions, as defined in sub-clause 7.3.2.7.
#### 8.3.1.6 Service-language(s) per media
The existing SDP attribute \"a=lang\" is used to label the language of any
language-specific media. The values are taken from [73] which in turn takes
language and (optionally) country tags from ISO 639 [74] and ISO 3166 [75]
(e.g. \"a=lang:EN-US\"). These are the same tags used in the User Service
Description XML.
#### 8.3.1.7 Bandwidth specification
The bit-rate required by the MBMS streaming session and its media components
shall be specified using both the \"AS\" bandwidth modifier and the \"TIAS\"
bandwidth modifier combined with \"a=maxprate\" [38] on media level in the
SDP. On session level the \"TIAS\" bandwidth modifier combined with
\"a=maxprate\" may be used, where the session level expresses the aggregated
peak bit-rate, which may be lower than the sum of the individual media
streams.
The bandwidth required for RTCP is specified by the \"RR\" and \"RS\"
bandwidth modifiers (3GPP TS 26.244 [32]) on media level for each RTP session.
The \"RR\" modifier shall be included and set to 0 to specify that RTCP
receiver reports are not used. The bandwidth used for RTCP sender reports
shall be specified using the \"RS\" bandwidth modifier.
#### 8.3.1.8 FEC Parameters
The FEC encoding ID and instance ID are provided using the \"a=FEC-
declaration\" attribute defined in sub-clause 7.3.2.8. Any OTI information for
that FEC encoding ID and instance ID is provided with below defined FEC OTI
attribute.
The FEC OTI attribute must be immediately preceded by the \"a=FEC-
declaration\" attribute (and so can be session-level and media-level). The
fec-ref maps the oti-extension to the FEC-declaration OTI it extends. The
purpose of the oti-extension is to define FEC code specific OTI required for
RTP receiver FEC payload configuration; exact contents are FEC code specific
and need to be specified by each FEC code using this attribute. The OTI for
the MBMS FEC Scheme is defined in sub-clause 8.2.2.10a.
The syntax for the attributes in ABNF [23] is:
  * sdp-fec-oti-extension-line = \"a=FEC-OTI-extension:\" fec-ref SP > oti-extension CRLF
  * fec-ref = 1*3DIGIT (the SDP-internal identifier for the associated > FEC-declaration).
  * oti-extension = base64
  * base64 = *base64-unit [base64-pad]
  * base64-unit = 4base64-char
  * base64-pad = 2base64-char \"==\" / 3base64-char \"=\"
  * base64-char = ALPHA / DIGIT / \"+\" / \"/\"
To provide the FEC repair packets with additional, non FEC specific
parameters, a session and media level SDP attribute is defined.
sdp-fec-parameter-line = "a=mbms-repair: 0*1SP fec-ref SP parameter-list CRLF
parameter-list = parameter-spec *(1*SP parameter-spec)
parameter-spec = name "=" value;
name = 1*(ALPHA / DIGIT / "-")
value = 1*(safe) ; safe defined in [14]
Currently one FEC non code-specific parameter is defined:
**min-buffer-time** : This FEC buffering parameter specifies the minimum
receiver buffer time (delay) needed to ensure that FEC repair has time to
happen regardless of the FEC source block of the stream from which the
reception starts. The value is in milliseconds and represents the wallclock
time between the reception of the first FEC source or repair packet of a FEC
source block, whichever is earlier in transmission order, and the wallclock
time when media decoding can safely start.
The parameters name and value is defined in ABNF as follows:
Min-buffer-time-parameter-name = "min-buffer-time"
Min-buffer-time-parameter-value = 1*8DIGIT ;Wallclock time in milliseconds.
The FEC declaration and FEC OTI information utilized in a specific source or
repair packet is indicated using the FEC-ref number in the a=fec lines as
described in sub-clauses 8.2.2.12 and 8.2.2.13.
#### 8.3.1.9 FEC Flow ID attribute
To indicate the mapping between destination IP address and UDP port number and
FEC source block flow IDs, the "a=mbms-flowid" SDP attribute is defined. Each
flowID that is used to construct a source block within the bundled sessions
shall be included. It is a media level attribute that shall be present in any
SDP media block using the "UDP/MBMS-REPAIR" protocol identifier.
The syntax for the attributes in ABNF [23] is:
Sdp-mbms-flowid-attr = \"a=mbms-flowid:\" *WSP flow-id-spec *(\",\" *WSP flow-
id-spec) CRLF
flow-id-spec = flowID \"=\" address-spec \"/\" port-spec
address-spec = IP4-multicast / IP6-multicast
IP4-multicast = m1 3*( \".\" decimal-uchar )
m1 = (\"22\" (\"4\"/\"5\"/\"6\"/\"7\"/\"8\"/\"9\")) / (\"23\" DIGIT ))
IP6-multicast = hexpart
hexpart = hexseq / hexseq \"::\" [ hexseq ] /
\"::\" [ hexseq ]
hexseq = hex4 *( \":\" hex4)
hex4 = 1*4HEXDIG
port-spec = 1*5DIGIT
#### 8.3.1.10 Buffer Requirement Signaling
Due to the variable bitrate nature of some media streams (especially video
streams), initial buffering at the receiver becomes necessary to smooth out
those variations. The initial buffering delay SHOULD be signaled to the
receiver in the SDP using the following media level attribute:
  * \"a=X-initpredecbufperiod:\\"
For H.263 video streams, the "X-initpredecbufperiod" indicates the required
initial pre-decoder buffering period specified according to Annex G of 3GPP TS
26.234 [47].
For H.264 video streams, the "X-initpredecbufperiod" indicates the nominal
removal time of the first access unit from the coded picture buffer (CPB).
Note that X-initpredecbufperiod is expressed as clock ticks of a 90-kHz clock.
Hence, conversion may be required if the RTP timestamp clock frequency is not
90 kHz.
#### 8.3.1.11 Interleaving Signaling
When interleaving is used in combination with FEC protection of an MBMS
service, the BM-SC may indicate to receivers the order of transmission of the
media units of a source block using the "X-3gpp-FEC-Interleaving" attribute.
It also indicates whether intra-stream interleaving (described in section G.1)
has been performed or not for each of the flows in the FEC source block.
The "X-3gpp-FEC-Interleaving" attribute is defined as follows:
Interleaving="X-3gpp-FEC-Interleaving:" SP flow_interleaving *(","
flow_interleaving) CRLF
flow_interleaving=flowID "=" ["ordered" / "mixed" / "reverse"]
flowID is the indentification of the flow as described in section 8.3.1.9. The
intra-stream interleaving modes may result in un-changed tranmission order
("Ordered"), a mixed transmission order ("Mixed"), or a reversed transmission
order ("Reverse"). For a flow that is not listed in the X-3gpp-FEC-
Interleaving attribute, the receiver should assume that no particular intra-
or inter-stream interleaving has been performed. The transmission order does
not preculde that some media units of a lower priority stream are interleaved
with the media units of higher priority stream.
### 8.3.2 SDP Example for Streaming Session
Here is a full example of SDP description describing the media streams part of
a streaming delivery session:
v=0\ o=ghost 2890844526 2890842807 IN IP4 192.168.10.10\ s=3GPP MBMS Streaming
SDP Example\ i=Example of MBMS streaming SDP file\
u=http://www.infoserver.example.com/ae600\ e=ghost\@mailserver.example.com\
_c=IN IP6 FF1E:03AD::7F2E:172A:1E24_ \ t=3034423619 3042462419
b=AS:77
a=mbms-mode:broadcast 123869108302929 1
a=source-filter: incl IN IP6 * 2001:210:1:2:240:96FF:FE25:8EC9
m=video 4002 RTP/AVP 96
b=TIAS:62000
b=RR:0
b=RS:600
a=maxprate:17
a=rtpmap:96 H264/90000\ a=fmtp:96 profile-level-id=42A01E; packetization-
mode=1; sprop-parameter-sets=Z0IACpZTBYmI,aMljiA==\ m=audio 4004 RTP/AVP 98
b=TIAS:15120
b=RR:0
b=RS:600
a=maxprate:10
a=rtpmap:98 AMR/8000
a=fmtp:98 octet-align=1
FEC is not used in that example. See clause 8.2.2.15 for an example with FEC.
#### 8.3.2.1 SDP Description for QoE Metrics
Similar as in 3GPP TS 26.234 [47], an SDP attribute for QoE, which can be used
either at session or media level, is defined below in [23] based on [14]:
  * QoE-Metrics-line = \"a\" \"=\" \"3GPP-QoE-Metrics:\" > att-measure-spec *(\",\" att-measure-spec)) CRLF
  * att-measure-spec = Metrics \";\" Sending-rate [\";\" > Measure-Range]\ > [\";\" Measure-Resolution] *([\";\" Parameter-Ext])
  * Metrics = \"metrics\" \"=\" \"{\"Metrics-Name *(\"\|\" > Metrics-Name) \" }\"
  * Metrics-Name = 1*((0x21..0x2b) / (0x2d..0x3a) / (0x3c..0x7a) / > 0x7e) ;VCHAR except \";\", \",\", \"{\" or \"}\"
  * Sending-Rate = \"rate\" \"=\" 1*DIGIT / \"End\"
  * Measure-Resolution = \"resolution\" \"=\" 1*DIGIT ; in seconds
  * Measure-Range = \"range\" \":\" Ranges-Specifier
  * Parameter-Ext = (1*DIGIT [\".\" 1*DIGIT]) / (1*((0x21..0x2b) / > (0x2d..0x3a) / (0x3c..0x7a) / 0x7c / 0x7e))
  * Ranges-Specifier = as defined in RFC 2326 [88].
An MBMS server uses this attribute to indicate that QoE metrics are supported
and shall be used if also supported by the MBMS client. When present at
session level, it shall only contain metrics that apply to the complete
session. When present at media level, it shall only contain metrics that are
applicable to individual media.
The \"Metrics\" field contains the list of names that describes the
metrics/measurements that are required to be reported in a MBMS session (see
sub-clause 8.4). The names that are not included in the \"Metrics\" field
shall not be reported during the session.
In this version of the specification, the \"Sending-Rate\" shall be set to the
value \"End\", which indicates that only one report is sent at the end of the
MBMS session.
The optional \"Measure-Resolution\" field, if used, shall define a time over
which each metrics value is calculated. The \"Measure-Resolution\" field
splits the session duration into a number of equally sized periods where each
period is of the length specified by the \"Measure-Resolution\" field. The
\"Measure-Resolution\" field is thus defining the time before the calculation
of a QoE parameter starts over. If the \"Measure-Resolution\" field is not
present the metrics resolution shall cover the period specified by the
\"Measure-Range\" field. If the \"Measure-Range\" field is not present the
metrics resolution shall be the whole session duration.
The \"Measure-Resolution\" field shall take only one value for all session
level metrics and only one value for all metrics associated to one media.
The optional \"Measure-Range\" field, if used, shall define the time range in
the stream for which the QoE metrics will be reported. There shall be only one
range per measurement specification. The range format shall be any of the
formats allowed by the media. If the \"Measure-Range\" field is not present,
the corresponding (media or session level) range attribute in SDP shall be
used. If SDP information is not present, the metrics range shall be the whole
session duration.
## 8.4 Quality of Experience
### 8.4.1 General
The MBMS Quality of Experience (QoE) metrics feature is optional for both MBMS
streaming server and MBMS client, and shall not disturb the MBMS service. An
MBMS Server that supports the QoE metrics feature shall activate the gathering
of client QoE metrics with SDP as described in sub-clauses 8.3.2.1 and 8.4.2
and via the reception reporting procedure as described in sub-clause 9.4. An
MBMS client supporting the feature shall perform the quality measurements in
accordance to the measurement definitions, aggregate them into client QoE
metrics and report the metrics to the MBMS server using the content reception
reporting procedure. The way the QoE metrics are processed and made available
is out of the scope of the present document.
### 8.4.2 QoE Metrics
An MBMS client should measure the metrics at the transport layer after FEC
decoding (if FEC is used), but may also do it at the application layer for
better accuracy.
The reporting period for the metrics is the whole streaming duration and the
measurement resolution of each reported metrics value is defined by the
\"Measure-Resolution\" field in the SDP. The reporting period may be less than
the session duration, because of late joiners or early leavers. The reporting
period shall not include any voluntary event that impacts the actual play,
such as pause, or any buffering or freezes/gaps caused by them.
The following metrics shall be derived by the MBMS client implementing QoE.
All the metrics defined below are only applicable to at least one of audio,
video, speech and timed text media types, and are not applicable to other
media types such as synthetic audio, still images, bitmap graphics, vector
graphics, and text. Any unknown metrics shall be ignored by the client and not
included in any QoE report. Among the QoE metrics, corruption duration,
successive loss of RTP packets, frame-rate deviation and jitter duration are
of media level, whereas initial buffering duration, rebuffering duration and
content access/switch time are of session level.
#### 8.4.2.1 Corruption duration metric
Corruption duration, M, is the time period from the NPT time of the last good
frame before the corruption, to the NPT time of the first subsequent good
frame or the end of the reporting period (whichever is sooner). A corrupted
frame may either be an entirely lost frame, or a media frame that has quality
degradation and the decoded frame is not the same as in error-free decoding. A
good frame is a \"completely received\" frame X that, either:
  * it is a refresh frame (does not reference any previously decoded > frames AND where none of the subsequently decoded frames reference > any frames decoded prior to X); or
  * does not reference any previously decoded frames; or
  * references previously decoded \"good frames\".
\"Completely received\" means that all the bits are received and no bit error
has occurred.
_Corruption duration, M, in milliseconds can be calculated as below:_
a) M can be derived by the client using the codec layer, in which case the
codec layer signals the decoding of a good frame to the client. A good frame
could also be derived by error tracking methods, but decoding quality
evaluation methods shall not be used.
b) In the absence of information from the codec layer, M should be derived
from the NPT time of the last frame before the corruption and N, where N is
optionally signalled from MBMS streaming server (via SDP) to the MBMS client
and represents the maximum duration between two subsequent refresh frames in
milliseconds.
c) In the absence of information from the codec layer and if N is not
signalled, then M defaults to ∞ (for video) or to one frame duration (for
audio), or the end of the reporting period (whichever is sooner).
_The_ optional parameter N as defined in point b is used with the
\"Corruption_Duration\" parameter. Another optional parameter _T_ is defined
to indicate whether the client uses error tracking or not. The value of _T_
shall be set by the client via reception reporting (sub-clause 9.5.3) as on or
off. The syntax for _N_ to be included in the \"att-measure-spec\" (sub-clause
8.3.2.1) is as follows:
  * N = \"N\" \"=\" 1*DIGIT
In MBMS reception reporting will be done only once at the end of streaming,
hence all the occurred corruption durations are summed up over each resolution
period of the stream and stored in the vector _TotalCorruptionDuration_. The
unit of this metrics is expressed in milliseconds. For each resolution
duration the number of individual corruption events are summed up and stored
in the vector _NumberOfCorruptionEvents._ These two vectors are reported by
the MBMS client as part of the reception report (sub-clauses 9.4.6 and 9.5.3).
#### 8.4.2.2 Rebuffering duration metric
Rebuffering is defined as any stall in playback time due to any involuntary
event at the client side.
The syntax for the metric \"Rebuffering_Duration\" for the QoE-Feedback header
is as defined in sub-clause 8.3.2.1.
Rebuffering starts at the NPT time of the last played frame before the
occurrence of the rebuffering.
In MBMS reception reporting will be done only once at the end of streaming,
hence all the occurred rebuffering durations are summed up over each
resolution period of the stream and stored in the vector
_TotalRebufferingDuration_. The unit of this metrics is expressed in seconds,
and can be a fractional value. The number of individual rebuffering events for
each resolution duration are summed up and stored in the vector
_NumberOfRebufferingEvents._ These two vectors are reported by the MBMS client
as part of the reception report (sub-clauses 9.4.6 and 9.5.3).
#### 8.4.2.3 Initial buffering duration metric
Initial buffering duration is the time from receiving the first RTP packet
until playing starts.
The syntax for the \"Initial_Buffering_Duration\" is as defined in sub-clause
8.3.2.1.
The metric value indicates the initial buffering duration where the unit of
this metrics is expressed in seconds, and can be a fractional value. There can
be only one measure and it can only take one value.
\"Initial_Buffering_Duration\" is a session level parameter.This value is
reported by the MBMS client as part of the reception report (sub-clauses 9.4.6
and 9.5.3).
#### 8.4.2.4 Successive loss of RTP packets
The metric \"Successive_Loss\" indicates the number of RTP packets lost in
succession (excluding FEC packets) per media channel.
The syntax for the metrics \"Successive_Loss\" is as defined in sub-clause
8.3.2.1.
In MBMS reception reporting will be done only once at the end of streaming,
hence all the number of successively lost RTP packets are summed up over each
resolution period of the stream and stored in the vector
_TotalNumberofSuccessivePacketLoss_. The unit of this metric is expressed as
an integer equal to or larger than 0. The number of individual successive
packet loss events over each resolution duration are summed up and stored in
the vector _NumberOfSuccessiveLossEvents. The number of received packets is
also summed up over each resolution duration and stored in the vector
NumberOfReceivedPackets._ These three vectors are reported by the MBMS client
as part of the reception report (sub-clauses 9.4.6 and 9.5.3).
#### 8.4.2.5 Frame rate deviation
Frame rate deviation indicates the playback frame rate information. Frame rate
deviation happens when the actual playback frame rate during a reporting
period is deviated from a pre-defined value.
The actual playback frame rate is equal to the number of frames played during
the resolution period divided by the time duration, in seconds, of the actual
measurement. For the last measurement period in the session this time duration
might be shorter than the configured measurement resolution (see 8.3.2.1 for
the definition of the measurement resolution).
_The parameter FR that denotes the pre-defined frame rate value_ is used with
the \"Framerate_Deviation\" parameter in the \"3GPP-QoE-Metrics\" attribute.
The value of FR shall be set by the server. The syntax for _FR_ to be included
in the \"att-measure-spec\" (sub-clause 8.3.2.1) is as follows:
  * FR = \"FR\" \"=\" 1*DIGIT \".\" 1*DIGIT
The syntax for the metric \"Framerate_Deviation\" is defined in sub-clause
8.3.2.1.
For the Metrics-Name \"Framerate_Deviation\", the value field indicates the
frame rate deviation value that is equal to the pre-defined frame rate minus
the actual playback frame rate. This metric is expressed in frames per second,
and can be a fractional value, and can be negative. The frame rate deviations
for each resolution period are stored in a vector and the vector is reported
by the MBMS client as part of the reception report (sub-clauses 9.4.6 and
9.5.3).
#### 8.4.2.6 Jitter duration
Jitter happens when the absolute difference between the actual playback time
and the expected playback time is larger than a pre-defined value, which is
100 milliseconds. The expected time of a frame is equal to the actual playback
time of the last played frame plus the difference between the NPT time of the
frame and the NPT time of the last played frame.
The syntax for the metric \"Jitter_Duration\" is defined in sub-clause
8.3.2.1.
In MBMS reception reporting will be done only once at the end of streaming,
hence all the Jitter_Durations are summed up over each resolution duration and
stored in the vector _TotalJitterDuration_. The unit of this metrics is
expressed in seconds, and can be a fractional value. The number of individual
events over the resolution duration are summed up and stored in the vector
_NumberOfJitterEvents._ These two vectors are reported by the MBMS client as
part of the reception report (sub-clauses 9.4.6 and 9.5.3).
#### 8.4.2.7 Content Access/Switch Time
Content access/switch time is the time that elapses between the initiation of
a content request/switch by the user and up to the time when the first packet
of the content or media stream is received.
The syntax for the metric \"Content_Access_Time\" is defined in sub-clause
8.3.2.1.
The metric value indicates the content access/switch time and the unit of this
metrics is expressed in seconds, and can be a fractional value. There can be
only one measure and it can only take one value. \"Content_Access_Time\" is a
session level parameter. This value is reported by the MBMS client as part of
the reception report (sub-clauses 9.4.6 and 9.5.3).
### 8.4.3 Example metrics initiation with SDP
This following example shows the syntax of the SDP attribute for QoE metrics.
The session level QoE metrics description (Initial buffering duration and
rebufferings) are to be monitored and reported only once at the end of the
session. Also video specific description of metrics (corruptions) are to be
monitored and reported at the end from the beginning of the stream until the
time 40s. Finally, audio specific description of metrics (corruptions) is to
be monitored with a measurement resolution of 10s and reported at the end of
the stream.
SDP example:
v=0\ o=- 3268077682 433392265 IN IP4 63.108.142.6\ s=QoE Enabled Session
Description Example\ e=support\@foo.com\ c=IN IP4 0.0.0.0\ t=0 0\
a=range:npt=0-83.660000\ a=3GPP-QoE-
Metrics:metrics={Initial_Buffering_Duration\|Rebuffering_Duration};rate=End\
a=control:*\ m=video 0 RTP/AVP 96\ b=AS:28\ a=3GPP-QoE-
Metrics:metrics={Corruption_Duration};rate=End;range:npt=0-40\
a=control:trackID=3\ a=rtpmap:96 MP4V-ES/1000\ a=range:npt=0-83.666000\
a=fmtp:96profile-level-id=8;config=000001b008000001b50900012000\ m=audio 0
RTP/AVP 98\ b=AS:13\ a=3GPP-QoE-
Metrics:metrics={Corruption_Duration};rate=End;resolution=10\
a=control:trackID=5\ a=rtpmap:98 AMR/8000\ a=range:npt=0-83.660000\ a=fmtp:98
octet-align=1\ a=maxptime:200
## 8.5 Using MBMS Streaming delivery on Unicast
If the MBMS UE supports MBMS streaming delivery on unicast, then MBMS
Streaming shall perform the functions of a PSS client [47] to deliver content
when MBMS Bearers are not usable or available and if an
alternativeAccessDelivery element is available for the delivery method in the
MBMS User Service Description. Note, if an alternativeAccessDelivery element
is available, it is presumed that the same content is offered over both PSS
and MBMS. If more than one unicastAccessURI element is available in the
alternativeAccessDelivery element, then the UE shall randomly choose one URI
to be used for unicast access to the service.
MBMS and PSS define Quality of Experience (QoE) metrics features. The UE shall
not mix MBMS and PSS QoE metrics gatherings and/or reports. QoE is negotiated,
gathered and reported separately for PSS and MBMS.
The UE may compare the SSRC values of PSS and MBMS flows. If the UE detects
that the same SSRC value is used for PSS and MBMS flows, then the UE should
assume that the same wallclock time and same random RTP timestamp offset is
used for the flows with the same SSRC value. This gives the UE an advantage
for the synchronization onto the flows. The UE does not need to wait for new,
flow specific RTCP packets.
The BM-SC and the PSS servers which provide for unicast access to the MBMS
service shall be time synchronized. The PSS server and the UE should support
UTC clock time format in the "Range" header field as defined in [88].
The UE may request a specific start time of the PSS session by indicating a
UTC clock time in the "Range" header field of the PLAY request. The UTC clock
time represents the requested streaming start point according to the timeline
of the BM-SC. This time may be calculated using the NTP timestamp of the last
received RTCP sender reports. Otherwise, the UE may either specify an NPT
range using the "now" value as a start point of the PSS session or it may
completely omit the Range header field.
If the PSS server does not support time shifting and the request contains a
range indication (other than "now") then the PSS server shall reply with the
actual range that will be played back. Examples of this are an NPT range
header field using "now" or the selected start time in UTC clock time.
A _unicastAccessURI_ element of an alternativeAccessDelivery element in the
_deliveryMethod_ element of the User Service Description may contain an RTSP
URI or a reference to an PSS SDP file.
# 9 Associated delivery procedures
## 9.1 Introduction
Associated delivery procedures describe general procedures, which start
before, during or after the MBMS data transmission phase. They provide
auxiliary features to MBMS user services in addition, and in association with,
MBMS delivery methods and their sessions. Those procedures that shall only be
permitted after the MBMS Data transmission phase may also be described as
post-delivery procedures.
To enable future backwards compatibility, clause 9 specifies generic and
extensible techniques for a potentially wide range of associated delivery
procedures.
Clauses 9.3 and 9.4 specify the associated delivery procedures that are
initiated only after an MBMS data transmission phase.
The present document describes the following associated delivery procedures:
  * File repair, for post-delivery repair of files initially delivered > as part of an MBMS download session.
  * Content reception reporting of files delivered to an MBMS UE.
These procedures are enabled by establishing a point-to-point connection; and
using the MBMS session parameters, received during User Service
Discovery/Announcement, to communicate the context (e.g. file and session in
question) to the network and the MBMS sender infrastructure. To avoid network
congestion in the uplink and downlink directions, and also to protect servers
against overload situations, the associated delivery procedures from different
MBMS UEs shall be distributed over time and resources (network elements).
An instance of an \"associated procedure description\" is an XML file that
describes the configuration parameters of one or more associated delivery
procedures.
MBMS Download receivers shall support the file repair procedure as defined in
sub-clause 9.3.
MBMS Download receivers shall support the reception reporting procedure as
defined in sub-clause 9.4.
MBMS Streaming receivers shall support reception reporting procedures (StaR
and StaR-all report types) as defined in sub-clause 9.4.
## 9.2 Associated Procedure Description
An associated procedure description instance (configuration file) for the
associated delivery procedures may be delivered to the MBMS clients:
  * during a User Service Discovery / Announcement prior to the MBMS > Download delivery session along with the session description > (out-of-band of that session); or
  * in-band within a MBMS Download delivery session.
The most recently delivered configuration file (i.e. the one with the highest
version number - as given from the envelope, see sub-clause 11.1.3) shall take
priority, such that configuration parameters received prior to, and out-of-
band of, the download session they apply to are regarded as \"initial
defaults\", and configuration parameters received during, and in-band with the
download session, overwrite the earlier received parameters. Thus, a method to
update parameters dynamically on a short time-scale is provided but, as would
be desirable where dynamics are minimal, is not mandatory.
During the User Service Discovery / Announcement Procedure, the associated
procedure description instance is clearly identified using a URI, to enable UE
cross-referencing of in and out-of-band configuration files.
The MIME application type \"application/mbms-associated-procedure-
description+xml\" as defined in clause C.7 identifies associated delivery
procedure description instances (configuration files).
In XML, each associated delivery procedure entry shall be configured using an
\"associatedProcedureDescription\" element. All configuration parameters of
one associated delivery procedure are contained as attributes of an
\"associatedProcedureDescription\" element. The elements (e.g.
\"postFileRepair\" and \"postReceptionReport\") of an
\"associatedProcedureDescription\" element identify which associated
procedure(s) to configure. The associated delivery procedure description is
specified formally as an XML schema in sub-clause 9.5.1.
## 9.3 File Repair Procedure
### 9.3.1 Introduction
The purpose of the File Repair Procedure is to repair lost or corrupted file
fragments from the MBMS download data transmission. When in
multicast/broadcast environment, scalability becomes an important issue as the
number of MBMS clients grows. Three problems must generally be avoided:
  * Feedback implosion due to a large number of MBMS clients requesting > simultaneous file repairs. This would congest the uplink network > channel.
  * Downlink network channel congestion to transport the repair data, as > a consequence of the simultaneous clients requests.
  * File repair server overload, caused again by the incoming and > outgoing traffic due to the clients\' requests arriving at the > server, and the server responses to serve these repair requests.
The three problems are interrelated and must be addressed at the same time, in
order to guarantee a scalable and efficient solution for MBMS file repair.
The principle to protect network resources is to spread the file repair
request load in time and across multiple servers.
The MBMS client:
1\. Identifies the end of transmission of files or sessions.
2\. Identifies the missing data from an MBMS download.
3\. Calculates a random _back-off time_ and selects a file repair server
randomly out of a list.
4\. Sends a _repair request_ message to the selected file repair server at the
calculated time.
When a MBMS download session of repair data is configured in the associated
delivery descriptions, a MBMS client should wait for repair data in the
defined MBMS download session on its MBMS bearer - except where the UE is
prevented from doing so due to limited simultaneous context activation
capability.
Then the file repair server:
1\. Responds with a _repair response_ message either containing the requested
data, redirecting the client to an MBMS download session, redirecting the
client to another server, or alternatively, describing an error case.
The BM-SC may also send the repair data on a MBMS bearer (possibly the same
MBMS bearer as the original download) as a function of the repair process.
The random distribution, in time, of _repair request_ messages enhances system
scalability to the total number of such messages the system can handle without
failure.
### 9.3.2 Starting Time of the Associated Delivery Procedure for MBMS Download
Delivery
FLUTE File Delivery Table (FDT) Instances include an \"expires\" attribute,
which defines the expiration time of the FDT instance. The sender must use an
expiry time relative to the current time at the BM-SC. According to RFC 3926
[9], \"the receiver SHOULD NOT use a received FDT Instance to interpret
packets received beyond the expiration time of the FDT Instance\".
The starting time of Associated Delivery Procedure for the MBMS download is
the expiration time of the FDT instance at the latest.
The MBMS UE may also choose to start the Associated Delivery Procedure before
the FDT instance expires
  * when it has received an end-of-object (B-flag) for an object or
  * when an end-of-session (A-flag) is received before the FDT instance expires. Note, the end-of session (A-flag) indicates, that no more objects nor FDT instances will be transmissed by the BM-SC.
If the MBMS UE is not capable of receiveing an MBMS transmission while using
an interactive bearer, the MBMS UE shall ignore the end-of-object flags
(B-flag).
When a particular file (URI) is present in several FDT Instances with
different TOI values, then the FDT Instance with the highest FDT Instance ID
defines the TOI for the most recent instance of the file and determines the
end of transmission time for that file. A UE shall only determine transmission
completeness for a file for the most recent instance of the file - and shall
not use FDT Instance expiry time to determine transmission completeness for
any other (TOI) instances of a file (fileURI).
NOTE 1: The intention of this sub-clause is to just start the Associated
Delivery Procedure back-off timer for the more recent instance version of a
file with respect to the FLUTE transmission session.
When a particular file (URI) is present in more than one FDT Instance with the
same TOI value, then the end of transmission time is defined by the expiration
time of the latest FDT Instance to expire.
If an FDT Instance is received describing the file after this time (giving an
FDT Instance expiry time in the future and a different TOI value) the UE shall
determine that the transmission of the file is incomplete - i.e. that more
packets may arrive within the MBMS download session for that file,
\'forgetting\' its previous file transmission complete determination.
NOTE 2: This effectively resets and stops any running timers already initiated
for an associated delivery procedure for that file.
If the MBMS UE receives an end-of-object packet (with FLUTE header B flag set
true) the MBMS UE shall determine that the transmission of that object is
complete, and shall interpret that as file transmission complete if no, more
recent, TOIs are described for the same file (URI) in any received and
unexpired FDT Instance(s).
If the MBMS UE determines that the download session is complete (as specified
in sub-clause 9.4.2) then it shall interpret this also that all the
transmissions of all files (and TOIs) described by all FDT Instances, received
from that session, are complete.
### 9.3.3 Identification of Missing Data from an MBMS Download
The session description and the MBMS download delivery protocol, FLUTE,
provide the client with sufficient information to determine the source block
and encoding symbol structure of each file. From this a client is able to
determine which source symbols should have been transmitted but have not been
received. The client is also able to determine the number of symbols it has
received for each source block of each file, and thus the number of further
symbols required to decode the block.
Thus, an MBMS client is able to identify any source symbols lost in
transmission, and the number (and ESI values where appropriate) of required
source and/or repair symbols that would complete the reconstruction of a
source block (of a file).
When the MBMS FEC scheme is used, the MBMS client shall consider already
received repair symbols when making the determination of the further symbols
required. In this case, the client should either:
  * identify a minimal set of specific symbols that, combined with the > already received symbols, allows the MBMS FEC decoder to recover > the file, or
  * identify a number, _r_ , of symbols such that reception of _r_ > previously unreceived symbols will allow the MBMS FEC decoder to > recover the file.
### 9.3.4 Back-off Timing the Procedure Initiation Messaging for Scalability
This clause describes a _back-off mode_ for MBMS download to provide
information on when a receiver, that did not correctly receive some data from
the MBMS sender during a transmission session, can start a request for a
repair session. In the following it is specified how the information and
method a MBMS client uses to calculate a time (_back‑off time_), instance of
the back-off mode, to send a file repair message to the MBMS server.
The back-off mode is represented by a _back-off unit_ , a _back-off value,_
and a _back-off window_. The two latter parameters describe the back-off time
used by the MBMS client.
_The back-off unit_ (in the time dimension) defaults to _seconds_ and it is
not signalled.
The _back-off time_ shall be given by an _offset time_ (describing the back-
off value) and a _random time period_ (describing the back-off window) as
described in the following clauses.
An MBMS client shall generate random or pseudo-random time dispersion of
_repair requests_ to be sent from the receiver (MBMS client) to the sender
(MBMS server). In this way, the repair request is delayed by a pre-determined
(random) amount of time.
The back-off timing of _repair request_ messages (i.e. delaying the sending of
_repair requests_ at the receiver) enhances system scalability to the total
number of such messages the system can handle without failure.
#### 9.3.4.1 Offset time
The _OffsetTime_ refers to the repair request suppression time to wait before
requesting repair, or in other words, it is the time that a MBMS client shall
wait after the end of the MBMS data transmission to start the file repair
procedure. An associated procedure description instance shall specify the wait
time (expressed in _back-off unit_) using the \"offset-time\" attribute.
#### 9.3.4.2 Random Time Period
The _Random Time Period_ refers to the time window length over which a MBMS
client shall calculate a _random time_ for the initiation of the file repair
procedure. The method provides for statistically uniform distribution over a
relevant period of time. An associated procedure description instance shall
specify the wait time (expressed in _back-off unit_) using the \"random-time-
period\" attribute.
The MBMS client shall calculate a uniformly distributed _Random Time_ out of
the interval between 0 and _Random Time Period_.
#### 9.3.4.3 Back-off Time
The sending of the file _repair request_ message shall start at _Back-off Time
=_ _offset-time +_ _Random Time_ , and this calculated time shall be a
relative time after the MBMS data transmission. The MBMS client shall not
start sending the repair request message before this calculated time has
elapsed after the initial transmission ends.
#### 9.3.4.4 Reset of the Back-off Timer
The reception of an updated (higher version number)
associatedDeliveryProcedureDescription and/or an updated sessionDescription
shall overwrite the timer parameters used in the back-off algorithm. Except in
the case that the offset-time, random-time-period and session end time
parameters are identical to the earlier version; the back-off time shall be
recalculated. For currently running timers this requires a reset.
### 9.3.5 File Repair Server Selection
#### 9.3.5.1 List of Server URIs
A list of file repair service URIs is provided as elements of the Associated
Delivery procedure fragment\'s _postFileRepair_ element. Service URIs host
identity may also be given as IP addresses, which may be used to avoid a
requirement for DNS messaging. The file repair service URIs of a single
associated delivery procedure description shall be of the same type, e.g. all
IP addresses of the same version, or all domain names. The number of URIs is
determined by the number of \"serviceURI\" elements, each of which shall be a
child-element of the \"procedure\" element. The \"serviceURI\" element
provides the references to the file repair server\'s resource via the
\"xs:anyURI\" value. At least one \"serviceURI\" element shall be present.
#### 9.3.5.2 Selection from the Server URI List
The MBMS client randomly selects one of the service URIs from the list, with
uniform distribution.
### 9.3.6 File Repair Request Message
Once missing file data is identified, the MBMS client sends one or more
messages to a file repair server requesting transmission of data that allows
recovery of missing file data. All file repair requests and repair responses
for a particular MBMS transmission shall take place in a single TCP session
using the HTTP protocol (RFC 2616 [18]). The repair request is routed to the
file repair server IP address resolved from the selected \"serviceURI\".
The timing of the opening of the TCP connection to the server, and the first
repair request, of a particular MBMS client is randomized over a time window
as described in sub-clause 9.3.2. If there is more than one repair request to
be made these are sent immediately after the first.
When a MBMS UE identifies symbols in repair requests these shall be source
symbols, and should include all the missing source symbols of the relevant
source block. Note, these represent information for the file repair server and
the BM-SC may use these and/or redundant symbols in providing the necessary
repair data.
#### 9.3.6.1 File Repair Request Message Format
After the MBMS download session, the receiver identifies a set of encoding
symbols which allows recovery of the missing file data and requests for their
transmission in a file repair session. Specific encoding symbols are uniquely
identified by the combination (URI, SBN, ESI).
The file repair request shall either include the URI of the file for which it
is requesting the repair data or an identifier of a set of files. URI is
required to uniquely identify the file (resource) and is found from the
download delivery method (the FLUTE FDT Instances describe file URIs).
Additionally, the repair request for single files shall contain an indication
of the MD5 hash value of the file, if present in the FDT instance declaring
the file from which data is being requested. The MD5 hash value is used to
identify a specific version of the file. The (SBN, ESI) pair uniquely
identifies an encoding symbol. For completely missed files, a Repair Request
may give only the URI of the file and optionally the MD5 hash value of the
file. If the MD5 hash value is not present, the server shall respond with the
latest version of the file.
A set of files may be fetched using the File Repair server. A client may
request all files from a specific FDT instance or a specific logical group of
a particular MBMS User Services.
The client makes a file repair request using the HTTP (RFC 2616 [18]) request
method GET. Further arguments are encoded into the URI query part (RFC 3986
[19]) as defined below and included in the HTTP GET request. If a number of
previously unreceived symbols are requested for a specific Source Block, then
the SBN is provided along with the ESI of the symbol, which is subsequent in
the symbol sequence to the latest received symbol for that source block and
the number of symbols requested. If a number of previously unreceived source
blocks are requested for a specific file, the URI should be provided along
with an SBN range starting from the first missing source block and ending with
the SBN of the last missing source block of the contiguous set of source
block. Examples for requesting contiguous and non-contiguous ranges of symbols
and source blocks or even entire files or group of files are given below.
For example, assume that in a MBMS download session a 3gp file with URI =
www.example.com/news/latest.3gp was delivered to an MBMS client. After the
MBMS download session, the MBMS client recognized that it did not receive two
packets with SBN = 5, ESI = 12 and SBN=20, ESI = 27. If the repair service URI
(from the associated delivery procedure meta data fragment) is
http://mbmsrepair1.example.com/path/repair_script and the MD5 **value of that
file is "** ODZiYTU1OTFkZGY2NWY5ODh==**",** then the HTTP GET request is as
follows:
**GET** /path/repair_script?fileURI=www.example.com/news/latest.3gp&Content-
MD5= ODZiYTU1OTFkZGY2NWY5ODh== &SBN=5;ESI=12&SBN=20;ESI=27 **HTTP/1.1**
**Host: mbmsrepair1.example.com**
A file repair session shall be used to recover the missing file data from a
single MBMS download session only. If more than one file were downloaded in a
particular MBMS download session, and, if the MBMS client needs repair data
for more than one file received in that session, the MBMS client shall send
separate HTTP GET requests for each file.
An HTTP client implementation might limit the length of the URL to a finite
value, for example 256 bytes. In the case that the length of the URL-encoded
(SBN, ESI) data exceeds this limit, the MBMS client shall distribute the
URL‑encoded data into multiple HTTP GET requests.
In any case, all the HTTP GETs of a single file repair session shall be
performed within a single TCP session and they shall be performed immediately
one after the other.
In the following, we give the details of the syntax used for the above request
method in ABNF.
In this case an HTTP GET with a normal query shall be used to request the
missing data, according to HTTP1.1 [RFC2616 [18]]
  * repair_request_http_URL = repair_service_URI \"?\" query
  * repair_service_URI = \ Delivery Procedure Description>
Where, for MBMS File Repair Request:
  * query = std_query \| alt_query
  * std_query = file_uri [\"&\" content_md5] *( \"&\" sbn_info)
  * file_uri = \"fileURI=\" URI-reference; URI-reference is as defined > in [19].
  * content_md5 = \"Content-MD5=\" 1*(ALPHA / DIGIT / \"+\" / \"/\" / > \"=\")
  * sbn_info = \"SBN=\" sbn_range
  * sbn_range = ( sbnA [ \"-\" sbnZ ] ) / ( sbnA [ \";\" esi_info] > )
  * esi_info = \"ESI=\" ((esi_range *( \",\" esi_range ) ) ) / (esiA > "+" number_symbols)
  * esi_range = esiA [ \"-\" esiZ ]
  * sbnA = 1*DIGIT; the SBN, or the first of a range of SBNs
  * sbnZ = 1*DIGIT; the last SBN of a range of SBNs
  * esiA = 1*DIGIT; the ESI, or the first of a range of ESIs
  * esiZ = 1*DIGIT; the last ESI of a range of ESIs
  * number_symbols = 1*DIGIT; the number of additional symbols > required
  * alt_query = service_id "&" ( fdt_inst_id \| fdt_group_id )
  * service_id = \"serviceId=\" \ the User Service Description>
  * fdt_inst_id = "fdtInstanceId=" \ [9] or in clause 7.3>
  * fdt_group_id = "fdtGroupId=" \
Thus, the following symbols adopt a special meaning for MBMS download URI: ? -
+ , ; & =
One example of a query on encoding symbol 34 of source block 12 of a music
file "www.example.comm/greatmusic/number1.aac\" using the provided repair
service URI \"http://mbmsrepair1.example.com/path/repair_script\" is:
  * http://mbmsrepair1.example.com/path/repair_script?fileURI= > www.example.com/greatmusic/number1.aac&SBN=12;ESI=34
An example of requesting an entire file is
  * http://mbmsrepair1.example.com/path/repair_script?fileURI= > www.example.com/greatmusic/number1.aac
An example of requesting a specific source block from a specific file version
is
```{=html}
``` \- http://mbmsrepair1.example.com/path/repair_script?fileURI=
www.example.com/greatmusic/number1.aac&Content-MD5=ODZiYTU1OTFkZGY2NWY5ODh==
For messaging efficiency, the formal definition enables several contiguous and
non-contiguous ranges to be expressed, as well as a number of symbols with
ESIs of a given value or above in a single query:
  * An entire file (like in the above example).
  * A symbol of a source block (e.g. ...&SBN=12;ESI=23).
  * A range of symbols for a certain source block (e.g. > ...&SBN=12;ESI=23-28).
```{=html}
``` \- A number of symbols with ESIs of a given value or above (e.g. >
...&SBN=12;ESI=120+10).
```{=html}
``` \- A list of symbols for a certain source block (e.g. >
...&SBN=12;ESI=23,26,28).
  * All symbols of a source block (e.g. ...&SBN=12).
  * All symbols of a range of source blocks (e.g. ...&SBN=12-19).
  * non-contiguous ranges (e.g.1. ...&SBN=12;ESI=34&SBN=20;ESI=23 also, > e.g. 2. ...&SBN=12‑19&SBN=28;ESI=23-59&SBN=30;ESI=101).
An example to request all file of a particular FDT instance is given below:
```{=html}
``` \-
http://mbmsrepair1.example.com/path/repair_script?serviceId=urn:3gpp:0010120123hotdog&fdtInstanceId=12
### 9.3.7 File Repair Response Message
Once the MBMS file repair server has assembled a set of encoding symbols that
contain sufficient data to allow the UE to reconstruct the file data from a
particular file repair request, the MBMS file repair server sends one message
to the UE. Each file repair response occurs in the same TCP and HTTP session
as the repair request that initiated it.
An MBMS client shall be prepared for any of these 5 response scenarios:
  * The server returns a repair response message where a set of encoding > symbols forms an HTTP payload as specified below (see 9.3.7.2 for > details).
  * The server returns the requested file or file groups (see 9.3.7.4 > for details).
  * The server redirects the client to a broadcast/multicast delivery > (an MBMS download session).
  * The server redirects the client to another file repair server (if a > server is functioning correctly but is temporarily overloaded).
  * An HTTP error code is returned (note that sub-clause 9.3.8 describes > the case of no server response).
For (reasonably) uniformly distributed random data losses, immediate point-to-
point HTTP delivery of the repair data will generally be suitable for all
clients. However, broadcast/multicast delivery of the requested data may be
desirable in some cases:
  * A repeat MBMS download (all or part of the files from a download > session) is already scheduled and the BM-SC prefers to handle > repairs after that repeat MBMS download.
  * Many UEs request download data (over a short period of time) > indicating that broadcast/multicast delivery of the repaired data > would be desirable.
In this case a redirect to the broadcast/multicast repair session for UEs that
have made a repair request would be advantageous.
#### 9.3.7.1 File Repair Response Messages Codes
In the case that the file repair server receives a correctly formatted repair
request which it is able to understand and properly respond to with the
appropriate repair data, the file repair server shall attempt to serve that
request without an error case.
For a direct point-to-point HTTP response with the requested data, the file
response message shall report a 200 OK status code and the file repair
response message shall consist of HTTP header and file repair response payload
(HTTP payload), as defined in sub-clause 9.3.7.2. If the client receives a 200
OK response with fewer than all the quantity of requested symbols it shall
assume that the file repair server wishes the missing symbols to be requested
again (due to its choice or inability to deliver those symbols with this HTTP
response).
For a redirect case the file repair server uses the HTTP response status code
302 (Found - Redirection) to indicate to the UE that the resource (file repair
data) is temporarily available via a different URI. The temporary URI is given
by the Location field in the HTTP response. In the case of a redirect to
another file repair server, this temporary URI shall be the URL of that repair
server.
In the case of a redirect to a broadcast/multicast delivery, the temporary URI
shall be the URI of the Session Description (SDP file) of the
broadcast/multicast (repair) session as described in sub-clause 9.3.5.3.Other
HTTP status codes (RFC 2616 [18]) shall be used to support other cases. Other
cases may include server errors, client errors (in the file repair request
message) and server overload.
In case the file repair server does not find the requested file (file with
given fileURI is found), the server shall respond with "400 Bad Request" and
optionally with "0001 File not found" in the response body. As a result, the
MBMS UE may choose another file repair server as defined in clause 9.3.5.
In case the file repair server does not find the requested version of the
requested file (file with given fileURI is found but Content-MD5 is not
found), the server shall respond with "400 Bad Request" and optionally with
"0002 Content-MD5 not valid" in the response body. As a result, the MBMS UE
may chose another file repair server as defined in clause 9.3.5. Or the MBMS
UE may request the latest version of the file and discard the previously
received chunks of the file. Note, the MBMS UE can request the latest version
of a file by using only the fileURI argument in the file repair request.
Note. In case of repetitive server errors, the client is not expected to go
through the complete list of available file repair servers, and may abandon
after a limited number of attempts.
In case the file repair server does not find any of the requested SBN or ESI
values, it shall respond with the "400 Bad Request" and optionally with "0003
SBN or ESI out of range" in the respon se body. As a result, the UE should
discard all received chunks of the file and request the entire file from the
file repair server.
In case the file repair server receives unknown query line arguments, it shall
respond with "501 Not Implemented". The server should add the HTTP1.1 "Server"
header with the value "MBMS/6". As a result, the client should try to fetch
the entire file from the file repair server. Note, this behaviour is intended
to make the file repair service forward compatible and allow addition of new
function in later releases.
In case the file repair server does not find the requested serviceId value, it
shall respond with the "400 Bad Request" and optionally with "0004 ServiceId
not found" in the response body. As a result, the UE should request the needed
file separately using the fileURI query line argument.
In case the file repair server does not find the requested fdtInstanceId
value, it shall respond with the "400 Bad Request" and optionally with "0005
fdtInstanceId not found" in the response body. As a result, the UE should
request the needed file separately using the fileURI query line argument.
In case the file repair server does not find the requested fdtGroupId value,
it shall respond with the "400 Bad Request" and optionally with "0006
fdtGroupId not found" in the response body. As a result, the UE should request
the needed file separately using the fileURI query line argument.
HTTP responds error messages may contain a message body, which gives a more
detailed error message. The MIME type of such message body shall be in
text/plain. The syntax of the HTTP error message body is defined in ABNF [23]
as follows:
http-error-body = error-code (SP / HTAB) error-description CRLF
error-code = 4DIGIT
error-description = 1*(SP / VCHAR)
Note that the following error messages MAY be used in the message body of the
HTTP response error messages.
0001 File not found
0002 Content-MD5 not valid
0003 SBN or ESI out of range
0004 ServiceId not found
0005 fdtInstanceId not found
0006 fdtGroupId not found
#### 9.3.7.2 File Repair Response Message Format for HTTP Carriage of Repair
Data
The file repair response message consists of HTTP header and file repair
response payload (HTTP payload).
The HTTP header shall provide:
  * HTTP status code, set to 200 OK for the case of a successful > request.
  * Content type of the HTTP payload (see below).
NOTE: Other HTTP headers (RFC 2616 [18]) may also be used but are not mandated
by this mechanism.
The Content-Type shall be set to \"application/simpleSymbolContainer\", which
denotes that the message body is a simple container of encoding symbols as
described below.
This header is as follows:
  * HTTP/1.1 200 OK
  * Content-Type: application/simpleSymbolContainer
NOTE: Other HTTP headers (RFC 2616 [18]) may also be used but are not mandated
by this mechanism.
Encoding symbols are included in the response in groups. Each group is
preceded by an indication of the number of symbols within the group and an FEC
Payload ID coded according to the FEC scheme used for the original file
delivery session. The FEC Payload ID identifies all the symbols in the group
in the same way that the FEC Payload ID of an FEC source or repair packet
identifies all the symbols in the packet. The file repair response payload is
constructed by including each FEC Payload ID and Encoding Symbol group one
after another (these are already byte aligned). The order of these pairs in
the repair response payload may be in order of increasing SBN, and then
increasing ESI, value; however no particular order is mandated.
A single HTTP repair response message shall contain, at the most, the same
number of symbols as requested by the respective HTTP repair request message.
The UE and file repair server already have sufficient information to calculate
the length of each encoding symbol and each FEC Payload ID. All encoding
symbols are the same length; with the possible exception of the last source
encoding symbol in the repair response. All FEC Payload IDs are the same
length for one file repair request-response as a single FEC Scheme is used for
a single file.
Figure 17: deleted
Figure 18 illustrates the complete file repair response message format (box
sizes are not indicative of the relative lengths of the labelled entities).
* * *
HTTP Header  
Length Indicator FEC Payload ID Encoding Symbols Length Indicator FEC Payload
ID Encoding Symbols
Length Indicator FEC Payload ID Encoding Symbols
* * *
**Length Indicator** (2 bytes): indicates the number of encoding symbols in
the group (in network byte order, i.e. high order byte first)
**FEC Payload ID** : indicates which encoding symbols are included in the
group. The format and interpretation of the FEC Payload ID are dependent on
the FEC Scheme in use.
**Encoding Symbols** : contain the encoding symbols. All the symbols shall be
the same length.
Figure 18: File Repair Response Message Format
#### 9.3.7.3 File Repair Response for Broadcast/Multicast of Repair Data
Details of how a file repair server decides, or is instructed, to use
broadcast/multicast repair instead of point-to-point over HTTP are
implementation specific and beyond the scope of the present document.
Prior to the decision to use broadcast/multicast repair, each repair response
shall be provided by HTTP according to sub-clause 9.3.7.2.
The file repair server uses the HTTP response status code 302 (Found -
Redirection) to indicate to the UE that the resource (file repair data) is
temporarily available via a different URI. The temporary URI is given by the
Location field in the HTTP response and is the URI of the Session Description
(SDP file) of the broadcast/multicast repair session.
Where feasible, it is recommended that the same download session that
delivered the original data be used for the broadcast/multicast repair. If
this conflicts with the session end time limit of the Session Description then
a new version of the Session Description shall be sent with an updated
(extended) session end time. This shall be sent in-band of that download
session.
In some cases this may not be feasible and a different (possibly new) download
session may be defined for the repair.
The SDP file for broadcast/multicast repair session may be carried as payload
(entity-body) in the HTTP response - which is especially useful if the
broadcast/multicast repair session is a new (or recently end time modified)
FLUTE download session and other means of service announcement prior to this
were not feasible.
The delivery method\'s associatedDeliveryProcedureDescription may be updated
and the new version transmitted in-band with the download session so that
currently active client back-off timers are reset, thus minimizing additional
client requests until after the broadcast/multicast repair session. The server
shall be prepared for additional requests in any case as successful reception
of the updated associatedDeliveryProcedureDescription can not be assured in
all cases.
The existence of a broadcast/multicast file repair session is signalled by the
inclusion of the optional _bmFileRepair_ procedure in the updated Associated
Delivery procedure description. This is signalled by the _bmFileRepair_
element with a single \"sessionDescriptionURI\" attribute of type
\"xs:anyURI\" which specifies the URI of the broadcast/multicast file repair
session\'s session description.
In the cases where the same IP addressing is used for the broadcast/multicast
repair session as the original download session, the UE simply shall not leave
the group. Otherwise, the UE shall join to the MBMS bearer for the repair
session as it would for any MBMS session.
A broadcast/multicast file repair session behaves just as an MBMS download
session, and the determination of end of files and session, and use of further
associated delivery procedures uses the same techniques as specified for the
MBMS download delivery method.
#### 9.3.7.4 File Repair Response Message Format for HTTP carriage of Complete
Files
The file repair response message consists of HTTP header and one or more
complete files.
The HTTP header shall provide:
  * HTTP status code, set to 200 OK for the case of a successful response.
  * Content type shall be set to multipart/related
NOTE: Other HTTP headers (RFC 2616 [18]) may also be used but are not mandated
by this mechanism.
The server shall encapsulate the requested files into a multipart mime
container. Each part of the multipart mime shall contain at least the Content-
Location of the embedded files.
### 9.3.8 Server Not Responding Error Case
In the error case where a UE determines that the its selected file repair
server is not responding it shall return to the serverURI list of repair
servers and uniformly randomly select another server from the list, excluding
any servers it has determined are not responding. All the repair requests
message(s) from that UE shall then be immediately sent to the newly selected
file repair server.
If all of the repair servers from the serverURI list are determined to be not
responding, the UE may attempt an HTTP GET to retrieve a, potentially new,
instance of the session\'s Associated Procedure Description; otherwise UE
behaviour in this case is unspecified.
A UE determines that a file repair server is not responding if any of these
conditions apply:
1\. The UE is unable to establish a TCP connection to the server.
2\. The server does not respond to any of the HTTP repair requests that have
been sent by the UE (it is possible that second and subsequent repair requests
are sent before the first repair request is determined to be
not‑responded‑to).
3\. The server returns an unrecognized message (not a recognizable HTTP
response).
4\. The server returns an HTTP server error status code (in the range 500 to
505).
## 9.4 The Reception Reporting Procedure
Following successful reception of content whether through point-to-multipoint
MBMS bearers only, unicast bearers only, or using both point-to-multipoint and
point-to-point bearers, a reception reporting procedure can be initiated by
the MBMS Receiver (UE) to the BM-SC.
For MBMS Download Delivery method, the reception reporting procedure is used
to report the complete reception of one or more files. For MBMS Streaming
Delivery method, the reception reporting procedure is used to report
statistics on the stream.
If the BM-SC provided parameters requiring reception reporting confirmation
then the MBMS Receiver shall confirm the content reception.
If reception reporting is requested for statistical purposes the BM-SC may
specify the percentage subset of MBMS receivers it would like to perform
reception reporting.
Transport errors can prevent an MBMS Receiver from deterministically
discovering whether the reception reporting associated delivery procedure is
described for a session, and even if this is successful whether a sample
percentage is described. An MBMS Receiver shall behave according to the
information it has even when it is aware that this may be incomplete.
The MBMS Receiver:
1\. Identifies the complete reception of a content item (e.g. a file). See
sub-clauses 9.4.1and 9.4.2.
2\. Determines the need to report reception. See sub-clause 9.4.3.
3\. Selects a time (Request time) at which a reception report request will be
sent and selects a server from a list - both randomly and uniformly
distributed. See sub-clauses 9.4.4 and 9.4.5.
4\. Sends a _reception report request_ message to the selected server at the
selected time. See sub-clause 9.4.6.
Then the server:
1\. Responds with a _reception report response_ message either describing a
success or an error case. See sub-clause 9.4.7.
### 9.4.1 Identifying Complete File Reception from MBMS Download
A file is determined to be completely downloaded when it is fully received and
reconstructed by MBMS reception with FEC decoding (if FEC is actually used)
and/or a subsequent File Repair Procedure (sub-clause 9.3). The purpose of
determining file download completeness is to determine when it is feasible for
a UE to compile the RAck reception report for that file.
### 9.4.2 Identifying Complete MBMS Delivery Session Reception
Delivery sessions (download and streaming) are considered complete when the
\"time to\" value of the session description (from \"t=\" in SDP) is reached.
Where the end time is unbounded (time to = 0) then this parameter is not used
for identifying completed sessions.
Delivery sessions are also considered complete when the UE decides to exit the
session - where no further data from that session will be received. In this
case the UE may or may not deactivate the MBMS bearer(s).
For MBMS download sessions, FLUTE provides a \"Close session flag\" (see sub-
clause 7.2.7) which, when used, indicates to the UE that the session is
complete.
### 9.4.3 Determining Whether a Reception Report Is Required
Upon full reception of a content item or when a session is complete, the MBMS
Receiver must determine whether a reception report is required. An Associated
Delivery Procedure Description indicates the parameters of a reception
reporting procedure (which is transported using the same methods as the ones
that describe File Repair).
A delivery method may associate zero or one associated delivery procedure
descriptions with an MBMS delivery session. Where an associated delivery
procedure description is associated with a session, and the description
includes a _postReceptionReport_ element, the UE shall initiate a reception
reporting procedure. Reception reporting behaviour depends on the parameters
given in the description as explained below.
The Reception Reporting Procedure is initiated if:
a. A _postReceptionReport_ element is present in the associated procedure
description instance.
One of the following will determine the UE behaviour:
_b. reportType_ is set to RAck (Reception Acknowledgement). Only successful
file reception is reported without reception details.
_c. reportType_ is set to StaR (Statistical Reporting for successful
reception). Successful file reception is reported (as with RAck) with
reception details for statistical analysis in the network.
_d. reportType_ is set to StaR-all (Statistical Reporting for all content
reception). The same as StaR with the addition that failed reception is also
reported. StaR-all is relevant to both streaming and download delivery.
The _reportType_ attribute is optional and behaviour shall default to RAck
when it is not present.
The _samplePercentage_ attribute can be used to set a percentage sample of
receivers which should report reception. This can be useful for statistical
data analysis of large populations while increasing scalability due to reduced
total uplink signalling. The _samplePercentage_ takes on a value between 0 and
100, including the use of decimals. It is recommended that no more than 3
digits follow a decimal point (e.g. 67.323 is sufficient precision).
The _samplePercentage_ attribute is optional and behaviour shall default to
100 (%) when it is not present. The _samplePercentage_ attribute may be used
with StaR and StaR-all, but shall not be used with RAck.
When the _samplePercentage_ is not present or its value is 100 each UE which
entered the associated session shall send a reception report. If the
_samplePercentage_ were provided for reportType StaR and StaR-all and the
value is less than 100, the UE generates a random number which is uniformly
distributed in the range of 0 to100. The UE sends the reception report when
the generated random number is of a lower value than the _samplePercentage_
value.
### 9.4.4 Request Time Selection
The MBMS receiver selects a time at which it is to issue a delivery
confirmation request. The default start time for the reception reporting
procedure is defined in clause 9.3.2.
Back-off timing is used to spread the load of delivery confirmation requests
and responses over time.
Back-off timing is performed according to the procedure described in sub-
clause 9.3.4. The _offsetTime_ and _randomTimePeriod_ used for delivery
confirmation may have different values from those used for file-repair and are
signalled separately in the reception reporting description of the associated
delivery procedure description instance.
In general, reception reporting procedures may be less time critical than file
repair procedures. Thus, if a postFileRepair timer may expire earlier than a
postReceptionReport, radio and signalling resources may be saved by using the
file repair point-to-point PDP context (and radio bearer) activate period also
for reception reporting (to remove the delay and signalling of multiple
activations and deactivations over time)
The default behaviour is that a UE shall stop its postReceptionReport timers
which are active when a postFileRepair timer expires, which results in the
successful initiation of point-to-point communications between UE and BM-SC.
In some circumstances, the system bottleneck may be in the server handling of
reception reporting. In this case the _forceTimeIndependence_ attribute may be
used and set to true. (false is the default case and would be a redundant use
of this optional attribute). When _forceTimeIndependence_ is true the UE shall
not use file repair point-to-point connections to send reception reporting
messages. Instead it will allow the timers to expire and initiate point-to-
point connections dedicated to reception report messaging.
For StaR and StaR-all, session completeness - according to sub-clause 9.4.2 -
shall determine the back-off timer initialization time.
For RAck, the complete download session - according to sub-clause 9.4.2 \- as
well as completing any associated file repair delivery procedure shall
determine the back-off timer initialization time. RAcks shall be only sent for
completely received files.
### 9.4.5 Reception Report Server Selection
Reception report server selection is performed according to the procedure
described in sub-clause 9.3.5.2.
### 9.4.6 Reception Report Message
Once the need for reception reporting has been established, the MBMS receiver
sends one or more Reception Report messages to the BM-SC. All Reception Report
requests and responses for a particular MBMS transmission should take place in
a single TCP session using the HTTP protocol (RFC 2616 [18]).
The Reception Report request shall include the URI of the file for which
delivery is being confirmed. URI is required to uniquely identify the file
(resource).
The client shall make a Reception Report request using the HTTP (RFC 2616
[18]) POST request carrying XML formatted metadata for each reported received
content (file). An HTTP session shall be used to confirm the successful
delivery of a single file. If more than one file were downloaded in a
particular MBMS download multiple reception reports shall be added in a single
POST request.
Each Reception Report is formatted in XML according the following XML schema
(sub-clause 9.5.3). An informative example of a single reception report XML
object is also given (sub-clause 9.5.3.2).
Multipart MIME (multipart/mixed) may be used to aggregate several small XML
files of reception reports to a larger object.
For Reception Acknowledgement (RAck) a receptionAcknowledgement element shall
provide the relevant data.
For Statistical Reporting (StaR) a statisticalReporting element shall provide
the relevant data.
For both RAck and StaR/StaR-all (mandatory):
  * For download, one or more _fileURI_ elements shall specify the list > of files which are reported. If the Content-MD5 value of the file > is present in the FDT, it shall be provided in the Content-MD5 > attribute in the reception report. Note, this allows unambigous > identification of the files.
For only StaR/StaR-all (all optional):
  * Each _fileURI_ element has an optional _receptionSuccess_ status > code attribute which defaults to \"true\" (\"1\") when not used. > This attribute shall be used for StaR-all reports. This attribute > shall not be used for StaR reports.
  * Each QoE Metrics element has a set of attributes and any number of > media level QoE Metrics elements. All attributes are defined in > sub-clause 9.5.3 and correspond to the QoE metrics listed in > sub-clause 8.4.2. Individual metrics, both at session and at media > level can be selected via SDP as described in sub-clause 8.3.2.1.
  * The _sessionID_ attribute identifies the delivery session. If the > sessionType is \"download\", _sessionID_ is of the format > source_IP_address + \":\" + FLUTE_TSI. If the _sessionType_ is > \"streaming\", _sessionID_ is of the format source_IP_address + > \":\" + RTP_destination_port.
```{=html}
``` \- The _sessionStartTime_ and _sessionStopTime_ attributes identifies >
the NTP time when the session was started and stopped.
```{=html}
``` \- The _sessionType_ attribute defines the basic delivery method > session
type used = \"download\" \|\| \"streaming\".
  * The _serviceId_ attribute is value and format is taken from the > respective userServiceDescription serviceID definition.
  * The _clientId_ attribute is unique identifier for the receiver, e.g. > an MSISDN of the UE as defined in [77].
  * The _serviceURI_ attribute value and format is taken from the > respective associatedDeliveryProcedureDescription serviceURI, > which was selected by the UE for the current report. This > attribute expresses the reception report server to which the > reception report is addressed.
### 9.4.7 Reception Report Response Message
An HTTP response is used as the Reception Report response message.
The HTTP header shall use a status code of 200 OK to signal successful
processing of a Reception Report. Other status codes may be used in error
cases as defined in RFC 2616 [18].
## 9.5 XML-Schema for Associated Delivery Procedures
### 9.5.1 Generic Associated Delivery Procedure Description
Below is the formal XML syntax of associated delivery procedure description
instances. Documents following this schema can be identifed with the MIME type
\"application/mbms‑associated-procedure-description+xml\" defined in Annex
C.7.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\"reportType\" value = \"RAck\" \|\| \"StaR\" \|\| \"StaR-all\"
### 9.5.2 Example Associated Delivery Procedure Description Instance
Below is an example of an associated delivery procedure description for
reception reporting.
\
\
\
\http://mbmsrepair0.example.com/path/repair_script\
\http://mbmsrepair1.example.com/path1/repair_script\
\http://mbmsrepair2.example.com/path2/repair_script\
\
\
\
\http://mbmsreport.example.com/path/report_script\
\
\
### 9.5.3 XML Syntax for a Reception Report Request
Below is the formal XML syntax of reception report request instances.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\ \
\
\
\
\
\
\
#### 9.5.3.1 Use of Specific Values
Void
#### 9.5.3.2 Example XML for the Reception Report Request
\
\
\
\http://www.example.com/mbms-files/file1.3gp\
\http://www.example.com/mbms-files/file2.3gp\
\http://www.example.com/mbms-files/file4.3gp\
\
\
A second example shows a statistical report for a streaming session.
\
\
\
\
\
\
\
\
# 10 Media codecs and formats
## 10.1 General
The set of media decoders that are supported by the MBMS Client to support a
particular media type are defined below. Speech, Audio, Video, Timed Text and
Scene description media decoders are relevant for both MBMS Download and
Streaming delivery. Other media decoders are only relevant for MBMS Download
delivery.
## 10.2 Speech
If speech is supported, the AMR decoder, as specified in 3GPP TS 26.071 [48],
3GPP TS 26.090 [49], 3GPP TS 26.073 [50] and 3GPP TS 26.107 [51], shall be
supported for narrow-band speech. The AMR wideband speech decoder, 3GPP TS
26.171 [52], 3GPP TS 26.190 [53], 3GPP TS 26.173 [54] and 3GPP TS 26.204 [55],
shall be supported when wideband speech working at 16 kHz sampling frequency
is supported.
## 10.3 Audio
If audio is supported, then the following two audio decoders should be
supported:
  * Enhanced aacPlus, as specified in 3GPP TS 26.401 [28], 3GPP TS > 26.410 [29] and 3GPP TS 26.411 [30].
  * Extended AMR-WB, as specified in 3GPP TS 26.290 [24], 3GPP TS > 26.304 [25] and 3GPP TS 26.273 [26].
Specifically, based on the audio codec selection test results, Extended AMR-WB
is strong for the scenarios marked with blue, Enhanced aacPlus is strong for
the scenarios marked with orange, and both are strong for the scenarios marked
with green colour in table 1.
Table 1
+----------------+-------+-------------------+----------------------+--------+ | Content type | Music | Speech over Music | Speech between Music | Speech | | | | | | | | Bit rate | | | | | +----------------+-------+-------------------+----------------------+--------+ | 14 kbps mono | | | | | +----------------+-------+-------------------+----------------------+--------+ | 18 kbps stereo | | | | | +----------------+-------+-------------------+----------------------+--------+ | 24 kbps stereo | | | | | +----------------+-------+-------------------+----------------------+--------+ | 24 kbps mono | | | | | +----------------+-------+-------------------+----------------------+--------+ | 32 kbps stereo | | | | | +----------------+-------+-------------------+----------------------+--------+ | 48 kbps stereo | | | | | +----------------+-------+-------------------+----------------------+--------+
More recent information on the performance of the codecs based on more recent
versions of the codecs can be found in TR 26.936 [86].
## 10.4 Synthetic audio
If synthetic audio is supported, the Scalable Polyphony MIDI (SP-MIDI) content
format defined in Scalable Polyphony MIDI Specification [56] and the device
requirements defined in Scalable Polyphony MIDI Device 5-to-24 Note Profile
for 3GPP [57] should be supported.
SP-MIDI content is delivered in the structure specified in Standard MIDI Files
1.0 [58], either in format 0 or format 1.
In addition the Mobile DLS instrument format defined in [59] and the Mobile
XMF content format defined in [60] should be supported.
A PSS client supporting Mobile DLS shall meet the minimum device requirements
defined in [59] in section 1.3 and the requirements for the common part of the
synthesizer voice as defined in ISO/IEC 10646-1 [70] in section 1.2.1.2. If
Mobile DLS is supported, wavetables encoded with the G.711 A-law codec
(wFormatTag value 0x0006, as defined in [59]) shall also be supported. The
optional group of processing blocks as defined in [59] may be supported.
Mobile DLS resources are delivered either in the file format defined in
ISO/IEC 10646-1 [70], or within Mobile XMF as defined in [60]. For Mobile DLS
files delivered outside of Mobile XMF, the loading application should unload
Mobile DLS instruments so that the sound bank required by the SP-MIDI profile
[57] is not persistently altered by temporary loadings of Mobile DLS files.
Content that pairs Mobile DLS and SP-MIDI resources is delivered in the
structure specified in Mobile XMF [60]. As defined in [60], a Mobile XMF file
shall contain one SP-MIDI SMF file and no more than one Mobile DLS file. PSS
clients supporting Mobile XMF must not support any other resource types in the
Mobile XMF file. Media handling behaviours for the SP-MIDI SMF and Mobile DLS
resources contained within Mobile XMF are defined in [60].
## 10.5 Video
If video is supported, H.264 (AVC) Baseline Profile Level 1.2 decoder (ITU-T
Recommendation H.264\| ISO/IEC 14496-10 [43]) with constraint_set1_flag=1 and
without requirements on output timing conformance (annex C of [43]) should be
supported.
Note that MBMS does not offer dynamic negotiation of media codecs. To ensure
the maximum level of interoperability, H.264 (AVC) is the only video decoder
recommended for MBMS. However, it is to be noted that ITU-T Recommendation
H.263 profile 0 level 45 decoder (ITU-T Recommendation H.263 [45] and H.263
annex X [46]) shall be supported for PSS (3GPP TS 26.234 [47]) and hence may
be used for MBMS User Service.
When H.264 (AVC) is in use in the MBMS streaming delivery method, it is
recommended to transmit H.264 (AVC) parameter sets within the SDP description
of a stream (using sprop-parameter-sets MIME/SDP parameter - RFC3984 [35]),
and it is not recommended to transmit parameter sets within the RTP stream.
Moreover, it is not recommended to reuse any parameter set identifier value
that appeared previously in the SDP description or in the RTP stream. However,
if a sequence parameter set is taken into use or updated within the RTP
stream, it shall be contained at least in each IDR access unit and each access
unit including a recovery point SEI message in which the sequence parameter
set is used in the decoding process. If a picture parameter set is taken into
use or updated within the RTP stream, it shall be contained at the latest in
the first such access unit in each entry sequence that uses the picture
parameter set in the decoding process, in which an entry sequence is defined
as the access units between an IDR access unit or an access unit containing a
recovery point SEI message, inclusive, and the next access unit, exclusive, in
decoding order, which is either an IDR access unit or contains a recovery
point SEI message.
There are no requirements on output timing conformance (annex C of ITU-T
Recommendation H.264 [43]) for MBMS clients.
The H.264 (AVC) decoder in an MBMS client shall start decoding immediately
when it receives data (even if the stream does not start with an IDR access
unit) or alternatively no later than it receives the next IDR access unit or
the next recovery point SEI message, whichever is earlier in decoding order.
Note that when the interleaved packetization mode of H.264 (AVC) is in use,
de-interleaving is normally done before starting the decoding process. The
decoding process for a stream not starting with an IDR access unit shall be
the same as for a valid H.264 (AVC) bitstream. However, the client shall be
aware that such a stream may contain references to pictures not available in
the decoded picture buffer.
## 10.6 Still images
If still images are supported, ISO/IEC JPEG [61] together with JFIF [62]
decoders shall be supported. The support for ISO/IEC JPEG only applies to the
following two modes:
  * baseline DCT, non-differential, Huffman coding, as defined in table > B.1, symbol \'SOF0\' in 3GPP TS 26.273 [26];
  * progressive DCT, non-differential, Huffman coding, as defined in > table B.1, symbol \'SOF2\' 3GPP TS 26.273 [26].
## 10.7 Bitmap graphics
If bitmap graphics is supported, the following bitmap graphics decoders should
be supported:
  * GIF87a, [63];
  * GIF89a, [64];
  * PNG, [65].
## 10.8 Vector graphics
If vector graphics is supported, SVG Tiny 1.2 [66], [67] and ECMAScript [68]
shall be supported.
NOTE 1: The compression format for SVG content is GZIP [42], in accordance
with the SVG specification [66].
NOTE 2 Content creators of SVG Tiny 1.2 are strongly recommended to follow the
content creation guidelines provided in annex L of 3GPP TS 26.234 [47].
NOTE 3: A DIMS client is capable of processing SVG Tiny 1.2 data..
## 10.9 Text
The text decoder is intended to enable formatted text in a SMIL presentation.
If text is supported, a MBMS client shall support
  * text formatted according to XHTML Mobile Profile [69];
  * rendering a SMIL presentation where text is referenced with the SMIL > 2.0 \"text\" element together with the SMIL 2.0 \"src\" attribute.
If text is supported, the following character coding formats shall be
supported:
  * UTF-8, [71];
  * UCS-2, [70].
NOTE: Since both SMIL and XHTML are XML based languages it would be possible
to define a SMIL plus XHTML profile. In contrast to the presently defined SMIL
Language Profile that only contain SMIL modules, such a profile would also
contain XHTML modules. No combined SMIL and XHTML profile is specified for
MBMS. Rendering of such documents is out of the scope of the present document.
## 10.10 Timed text
If timed text is supported, MBMS clients shall support 3GPP TS 26.245 [72].
Timed text may be transported over RTP or downloaded contained in 3GP files
using Basic profile.
NOTE: When a MBMS client supports timed text it needs to be able to receive
and parse 3GP files containing the text streams. This does not imply a
requirement on MBMS clients to be able to render other continuous media types
contained in 3GP files, e.g. AMR, if such media types are included in a
presentation together with timed text. Audio and video are instead streamed to
the client using RTP.
## 10.11 3GPP file format
An MBMS client shall support the Basic profile and the Extended presentation
profile of the 3GPP file format 3GPP TS 26.244 [32].
## 10.12 Scene Description
If scene description is supported, MBMS clients shall support 3GPP DIMS TS
26.142 [89].
# 11 MBMS Metadata
## 11.1 The MBMS Metadata Envelope
### 11.1.1 Supported Metadata Syntaxes
The MBMS metadata syntax supports the following set of features:
  * Support of carriage of SDP descriptions, and SDP is expected to > sufficiently describe at least: MBMS Streaming sessions and, MBMS > download sessions.
  * Support for multiple metadata syntaxes, such that the delivery and > use of more than one metadata syntax is possible.
  * Consistency control of metadata versions, between senders and > receivers, independent of the transport and bearer use for > delivery.
  * Metadata fragments are identified, versioned and time-limited > (expiry described) in a metadata fragment syntax-independent > manner (which is a consequence of the previous two features).
### 11.1.2 Consistency Control and Syntax Independence
The _Metadata Envelope_ provides information to identify, version and expire
metadata fragments. This is specified to be independent of metadata fragments
syntax and of transport method (thus enabling the use of more than one
syntaxes and enable delivery over more than a single transport and bearer).
A metadata envelope may update the time validity of its metadata fragment
without changing version if the metadata fragment itself has not changed. A
newer version (higher version number) of a metadata envelope shall
automatically expire the earlier version. If the content type (metadata
fragment syntax) is recognized and valid, the UE shall use the new metadata
fragment description. However, if the content type is not recognized or valid,
the UE may maintain the expired version data until the newer version is
correctly received.
Service announcement senders shall increment the version by one for each
subsequent transported version of a metadata fragment. However, a UE shall
also accept versions with an increment greater than one (so that they do not
fail in the case that an intermediate version was not successfully
transported).
### 11.1.3 Metadata Envelope Definition
The attributes for a metadata envelope and their description is as follows.
These attributes shall be supported:
  * _metadataURI_ : A URI providing a unique identifier for the metadata > fragment. The _metadataURI_ attribute shall be present.
  * _version_ : The version number of the associated instance of the > metadata fragment. The version number should be initialized to > one. The version number shall be increased by one whenever the > metadata fragment is updated. The _version_ attribute shall be > present.
  * _validFrom_ : The date and time from which the metadata fragment file > is valid. The _validFrom_ attribute may or not be present. If not > present, the UE should assume the metadata fragment version is > valid immediately.
  * _validUntil_ : The date and time when the metadata fragment file > expires. The _validUntil_ attribute may or not be present. If not > present the UE should assume the associated metadata fragment is > valid for all time, or until it receives a newer metadata envelope > for the same metadata fragment describing a validUntil value.
  * _contentType_ : The MIME type of the metadata fragment which shall be > used as defined for \"Content-Type\" in RFC 2616 [18]. The > _contentType_ attribute shall be present for embedding metadata > envelopes. The _contentType_ attribute may be present for > referencing metadata envelopes.
The metadata envelope is instantiated using an XML structure. This XML
contains a URI referencing the associated metadata fragment. The formal schema
for the metadata envelope is defined as an XML Schema as follows.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
The _metadataFragment_ element shall be encapsulated in the metadata envelope
for embedded metadata fragments, and shall not be encapsulated where the
metadata fragment is not embedded. In the embedded case, the
_metadataFragment_ element shall contain exactly one embedded metadata
fragment as specified by the metadata envelope syntax and only one instance of
the envelope element shall be used for encapsulating envelopes.
An embedded metadata fragment (in the _metadataFragment_ element) shall be
escaped. Generally, an embedded metadata fragment should be escaped by placing
inside a CDATA section [31]. Everything starting after \"\\" string would be ignored by the XML envelope parser
(quotes not included). Thus, the embedded parts would appear as \"\\". In this case, the complete metadata envelope
with embedded metadata fragment shall not violate the rules of CDATA section
usage [31].
In case the embedded metadata fragment is an XML document and include a CDATA
section , the embedded metadata fragment may be escaped by replacing illegal
characters with their ampersand-escaped equivalents [31] (instead of
encapsulating the whole fragment in a CDATA section). For instance \"\ envelope.
  * Referenced: The metadata fragment is referenced from the metadata > envelope.
The MBMS UE must know the MIME Type of each metadata fragment.
In the embedded case, the envelope and fragment are, by definition,
transported together and in-band of one another. In the referenced case, the
envelope and fragment shall be transported together in-band of the same
transport session.
MBMS Service Announcement transports shall support delivery of the metadata
envelope as a discrete object (XML document) for the referenced case. In the
referenced case, the MIME type of the metadata fragment should be provided by
the transport protocol (e.g. as a Content-Type text string). In both cases,
the MIME type of the metadata envelope should be provided by the transport
protocol.
The Metadata Envelope includes a reference (_metadataURI_) to the associated
metadata fragment using the same URI as the fragment file is identified by in
the Service Announcement. Thus, Metadata Envelope can be mapped to its
associated metadata fragment.
## 11.2 MBMS User Service Description Metadata Fragment
### 11.2.1 Definition of the MBMS User Service Bundle Description
#### 11.2.1.1 Initial Definition
The root element of the MBMS User Service Bundle description is the
_bundleDescription_ element. The element is of the _bundleDescriptionType_.
The _bundleDescription_ contains one or several _userServiceDescription_
elements and optionally a reference to the FEC repair stream description.
Each _userServiceDescription_ [ ]{.underline} element shall have a unique
identifier. The unique identifier shall be offered as _serviceId_ attribute
within the _userServiceDescription_ element and shall be of URN format.
The _userServiceDescription_ [ ]{.underline} element may contain one or more
_name_ elements. The intention of a _name_ element is to offer a title of the
user service. For each name elements, the language shall be specified
according to XML datatypes (XML Schema Part 2 [22]).
The _userServiceDescription_ [ ]{.underline} element may contain one or more
_serviceLanguage_ elements. Each _serviceLanguage_ element represents the
available languages of the user services. The language shall be specified
according to XML datatypes (XML Schema Part 2 [22]).
The _userServiceDescription_ [ ]{.underline} element may contain an
_accessPointName_ attribute. The _accessPointName_ attribute is optional and
gives an Access Point Name (APN) as defined in [77]. When this attribute is
present, the MBMS UE shall use the given APN for MBMS UE to network
interactions like File Repair and/or security registration. If this attribute
is not present, the MBMS UE shall use a default PDP context for network
interactions.
Each _userServiceDescription_ [ ]{.underline} element shall contain at least
one _deliveryMethod_ element. The _deliveryMethod_ element contains the
description of one delivery method. The element shall contain one reference to
a session description and may contain references to one associated delivery
procedure and/or one service protection descriptions. The session description
is further specified in sub-clause 5.2.2.2.
A _requiredCapabilities_ element gives a list of features, which are required
for the consumption of the related MBMS user service. The list of features
that are currently defined is included in section 11.9. The value of the
_feature_ element indicates the required feature. Note that the BM-SC can also
determine the terminal capabilities from the terminal identification during
the security registration. If the registering terminal does not have the
required capabilities, the BM-SC can reject the security registration.
The _deliveryMethod_ element may contain a reference to an associated delivery
procedure description. The description and configuration of associated
delivery procedures is specified in sub-clause 5.2.2.3.
The _deliveryMethod_ element may contain a reference to a service protection
description. The service protection description is specified in sub-clause
5.2.2.4.
A _userServiceDescription_ element contains zero or more _accessGroup_
elements. An _accessGroup_ element defines a list of access networks and is
uniquely identified by its id attribute. An _accessGroup_ element describes
whether separate access systems for the same MBMS user service are used (see
sub-clause 5.1.5.2 of [4]) by including one or more _accessBearer_ elements,
each describing one of those access systems and no two describing the same.
Possible _accessBearer_ values are "3GPP.R6.UTRAN", "3GPP.R6.GERAN",
"3GPP.R7.MBSFN-FDD", "3GPP.R7.MBSFN-TDD" and "3GPP.R8.MBSFN-IMB" which
indicate transport by 3GPP MBMS bearers according to the specification in
[4][5].
For forward compatibility, other _accessBearer_ values are allowed but their
definition and use are out of scope of this specification and a 3GPP UE may
silently ignore other values.
Each _deliveryMethod_ element contains at most one _accessGroupId_ attribute.
One specific _accessGroupId_ value maps to one specific _accessGroup_ element
id value. For each unique _accessGroupId_ attribute value presented in a
_deliveryMethod_ element of a _userServiceDescription_ instance, exactly one
associated _accessGroup_ element shall be present and the id attribute of the
_accessGroup_ element and the _accessGroupId_ attribute shall have the same
value. For each _deliveryMethod_ element without an _accessGroupId_ attribute,
the UE should assume that the delivery method is offered through all available
MBMS access systems.
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
#### 11.2.1.2 Extensions to the User Service Bundle Description
The MBMS Release 7 schema defined in this clause extends the MBMS Release 6
schema of clause 11.2.1.1. An MBMS Release 7 User Service Description fragment
shall use the MBMS Release 6 and the MBMS Release 7 schema definitions.
An _initiationRandomization_ element and _terminationRandomization_ element
carries the parameters to be used by the MBMS UE to randomize their initiation
and/or termination operations over time. If the _initiationRandomization_
element is present, all MBMS UEs shall randomize the inititation time as
defined by the attributes of the elements. If the _terminationRandomization_
element is present, all MBMS UEs shall randomize the termination time as
defined by the attributes of the elements.
The _initiationRandomization_ and/or _terminationRandomization_ element may be
part of:
  * a bundleDescription, where it applies to all services in the service bundle
  * a userServiceDescription, where it applies to all MBMS bearer services of a single service. If present, this overrides the element in bundleDescription
If the _initiationRandomization_ element is not present, the MBMS UE does not
randomize the User Service Initiation procedure over time. The MBMS UE should
then perform the operation immediately when it is triggered.
If the _terminationRandomization_ element is not present, the MBMS UE does not
randomize the User Service Termination procedure over time. The MBMS UE should
then perform the operation immediately when it is triggered.
An _initiationRandomization_ element may contain the _initiationStartTime_
attribute, which defines the start time for the initiation procedure
randomization period. The value of the data field represents the 32 most
significant bits of a 64 bit Network Time Protocol (NTP) [78] time value. If
the _initiationStartTime_ attribute is not present, the MBMS UE shall use the
reception time of the User Service Discovery / Announcement information as
_initiationStartTime._
The _initiationRandomization_ element shall contain the _protectionPeriod_
attribute. The _protectionPeriod_ attribute expresses the length of the
protection period in seconds. The initiation procedure shall be randomly
deferred during protection period.
The _initiationRandomization_ element shall contain the _randomTimePeriod_
attribute. The _randomTimePeriod_ attribute expresses the length of a time
interval (in seconds) over which requests are deferred. The MBMS UE shall
calculate a random time for the execution of the initiation procedure. The
method provides for statistically uniform distribution over a relevant period
of time.
The _terminationRandomization_ element shall contain the _protectionPeriod_
attribute. The _protectionPeriod_ attribute expresses the length of the
protection period in seconds. The termination procedure execution shall be
randomly deferred during protection period.
The _terminationRandomization_ element shall contain the _randomTimePeriod_
attribute. The _randomTimePeriod_ attribute expresses the length of a time
interval (in seconds) over which the operations are deferred. The MBMS UE
shall calculate a random time for the execution of the termination procedure.
The method provides for statistically uniform distribution over a relevant
period of time.
If the MBMS UE is switched off during the termination randomization, the MBMS
UE shall cancel the termination randomization.
The _alternativeAccessDelivery_ element shall extend the list of elements of
the MBMS _deliveryMethod_ element. Whenever present, it shall contain at least
one unicastAccessURI element. If the alternativeAccessDelivery element is
available then the UE shall select one of the unicastAccessURI elements
included.The timeShiftingBuffer attribute may be used to indicate the minimal
size of the time shifting buffer that will be provided for the current service
by the PSS servers that are referenced in the list. The actual size of the
timeshifting buffer of the selected server is returned in the SETUP response
from the PSS Server.
The _serviceClass_ attribute, if present, shall extend the list of attributes
of the MBMS Release 6 _userServiceDescription_ [ ]{.underline} element. The
_serviceClass_ attribute is optional and contains the service class identifier
for the delivered service according to the syntax defined in clause E.1.2 of
[90]. Note that Annex E of [90] also foresees the registration of service
class identifiers with the Open Mobile Naming Authority. The service class
identifier is similar to MIME types and provides an unique identity to
services. A MBMS UE may determine the receiving application instance out of
the service class identifier.
A user service description may belong to a group of user service descriptions,
which represent alternative configurations of the same user service. An
example is an MBMS user service that is delivered over non-MBSFN bearer with a
low bitrate and over MBSFN bearer with a high bitrate. In such a case, the UE
is only expected to consume one variant of the service. The UE recognizes that
a set of user service descriptions apply to one user service based on the
_serviceGroup_ element.
The MBMS User Service Description may include a _Registration_ element. If
present, then the UE shall send the registration and deregistration to the
given URI. In such a case, the User Service Description fragment may not be
complete in the service announcement. Instead, it may contain references to
metadata fragments (e.g. the session description) that are not embedded in the
service announcement. When registration is requested, the
userServiceDescription element shall contain a Registration element that
describes the requested registration procedure. The registrationURL indicates
the URL to the server with whom the registration procedure shall be performed.
In case more than one registrationURI is indicated, the UE shall select one
randomly. The registrationThreshold is a number that indicates the percentage
of UEs that are requested to register. The UE shall randomly select a number
between 0 and 100 and compare it against the threshold. In case the selected
number is lower than the indicated threshold, the UE should perform
registration. The threshold value \"100\" indicatess that the UE shall perform
registration, which is e.g. necessary when the USD is not complete.
Extensions for the User Service Description schema are defined as follows
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
The following schema defines extensions to the User Service Description
introduced in Release 8:
\
\
\
\
\
> \
>
> \ use=\"optional\" default=\"0\"/>
\
> \
>
> \
>
> \
>
> \ maxOccurs=\"unbounded\"/>
>
> \
>
> \ use=\"optional\" default=\"100\"/>
>
> \
\
\
### 11.2.2 Example MBMS User Service Description Instances
The following User Service Bundle Description instance is an example of a
simple fragment. This fragment includes only the mandatory elements.
\
\
\
\
\
\
The following User Service Description instance is an example of a fuller
fragment.
\
\
\
\Welcome\
\Willkommen\
\Bienvenue\
\Tervetuloa\
\EN\
\DE\
\
\0\"\
\
\
\
\
\
\
\3GPP.R6.GERAN\
\3GPP.R6.UTRAN\
\
\
\3GPP.R6.UTRAN\
\
\
\
The following User Service Description instance is an example of a Release 7
fragment.
\
\
\
\Welcome\
\Willkommen\
\Bienvenue\
\Tervetuloa\
\EN\
\DE\
\
\
\
\
\
\3GPP.R6.GERAN\
\3GPP.R6.UTRAN\
\
\
\3GPP.R6.UTRAN\
\
\
\
\
\
\
The following example User Service Description instance adds an RTSP URI for
alternative access to the delivery method.
\
\
xmlns:r8=\"urn:3GPP:metadata:2007:MBMS:userServiceDescription\">
\
> \ http://www.example.com/3gpp/mbms/channel1.sdp**\"** >
>
> \
>
> **\ rtsp://www.example.com/3gpp/mbms/channel1_pss.sdp
>
> \
>
> \
\
\
\
The following example User Service Description instance indicates that a
registration procedure is requested for 50% of the UEs before the consumption
of the MBMS User Service.
\
\
\
> \ http://www.example.com/3gpp/mbms/channel1.sdp**\"** > **\  registrationThreshold=**\"50\"** >
>
> \
> http://www.example.com/3gpp/mbms/register.php\
>
> \
\
\
\
## 11.3 Service Protection Description Metadata Fragment
### 11.3.1 Definition of the Protection Description
The security description is referenced by the _protectionDescriptionURI_ of a
deliveryMethod element. The security description fragment shall be identified
by the MIME type \"application/mbms protection-description+xml\" as defined in
Annex C.6.
The root element of the security description is the _securityDescription_
element. It contains three different elements, the _keyId_ element identities
the key(s) for each media flow, the _keyManagemen_ element the keymanagement
servers that the load is distributed over and the parameters in use, and the
_fecProtection_ element that configures the FEC protection of the point to
multi-point distributed key flows.
The _keyManagement_ element defines the list of key management servers (i.e.
BM-SC). The MBMS UE must register with a key management server to receive key
material. A receiver shall select a key managment server following the same
procedure defined for selecting a file repair server defined in sub-clause
9.3.5.
The attribute _uiccKeyManagement_ defines whether UICC based key management is
required for the present MBMS User Service.
The _offsetTime_ and _randomTimePeriod_ attributes define the back off
behavior of the UE when requesting MSKs. This uses the procedure defined in
sub-clause 9.3.4 where _offsetTime_ specifies the offset time defined in sub-
clause 9.3.4.1 and _randomTimePeriod_ the length of the random window in
accordance with sub-clause 9.3.4.2. The units for both attributes are in
seconds.
The element _keyId_ contains a list of media flows for which keys are
required. For each media flow a key identifier is provide in addition to that
media flows additional security parameters. The media flow is identified by a
destination tuple providing an address followed by a port number separated by
a \"/\", i.e. \/\. The port number
is for RTP session the RTP port number, and not RTCP\'s. Additional security
parameters are _srtpAuthenticationTagLength_ and _srtpMKILength_ that are only
applicable for RTP sessions that uses SRTP. The _MSK_ element identifies the
key uniquely by specifying both the _keyDomainID_ and the _MSKID_ as defined
in sub-clause 6.3.2.1 of 3GPP TS 33.246 [20]. The _MSKID_ is 4 bytes long
binary with byte 3 and 4 equal to 0x00, i.e. the current key that are base64
[82] when written into the element. The _keyDomainID_ is a 3 byte long binary
value as specified in sub-clause 6.3.2.1 of [20] and shall also be base64
encoded when written in the XML document.
The attribute _srtpAuthenticationTagLength_ defines the length of SRTP
authentication tag in bytes. It has a default value of 10 bytes. For media
flows using SRTP the attribute must be used to specify any value other than
the default one.
The attribute _srtpMKILength_ defines the length of SRTP MKI field in bytes.
The default value is 2 bytes. For media flows using SRTP the attribute must be
used to specify any value other than the default one.
The presence of the _fecProtection_ element indicates that any MIKEY packet
with an multicast destination IP address equal to any of the used destination
address in the User Service Bundle Description instance's delivery methods,
are FEC protected and encapsulated in FEC source packets, see sub-clause
8.2.2.4. The attributes _fecEncodingId_ , _fecInstanceID_ , and
_fecOtiExtension_ specify the FEC payload ID used in the source packet. All
service protection descriptions referenced by a User Service Bundle
Description instance shall use the same FEC parameters.
XML schema for Security Description:
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
### 11.3.2 Example of a Security Description:
\
\
\
\http://register.operator.umts/\
\http://register2.operator.umts/\
\
\
\
\
\aMoM\
\aMoAAA==\
\
\
\
\
\GM8M\
\aMkAAA==\
\
\
\
\
\
## 11.4 Service Protection Registration Format
### 11.4.1 Data Format
The below XML schema defines a format used to register to the keymanagement
servers according to the procedure in TS 33.246. The MIME type for this format
is defined in appendix C.9. The _serviceID_ element identifies the service
uniquely and is the same _serviceID_ used in the userServiceDescription format
defined in sub-clause 11.2.1.
\
\
\
\
\MBMS Security Registration according to TS
33.246\
\
\
\
\
\
\
\
\
\
\
### 11.4.2 Example
The below example is used to register to a service identifed by the serviceID
\" urn:3gpp:mbms:example:serivce:identification:123456789abcdef\".
\
\
\urn:3gpp:mbms:example:serivce:identification:123456789abcdef\
\
## 11.5 Service Protection De-Registration Format
### 11.5.1 Data Format
This format is used to de-register from the keymanagement server(s) according
to the procedure in TS 33.246. The MIME type for this format is defined in
appendix C.10. The _serviceID_ element is defined exactly as in sub-clause
11.4.1.
\
\
\
\
\MBMS Security Deregistration according to TS
33.246\
\
\
\
\
\
\
\
\
\
\
### 11.5.2 Example
The below example is used to de-register from the services identifed by the
serviceID \" urn:3gpp:mbms:example:serivce:identification:123456789abcdef\".
\
\
\urn:3gpp:mbms:example:serivce:identification:123456789abcdef\
\
## 11.6 Service Protection MSK Request Format
### 11.6.1 Data Format
This format is used to request from the keymanagement server(s) the delivery
of one or more MSK identities as defined in sub-clause 11.3.1. The MIME type
for this format is defined in appendix C.8.
\
\
\
\
\
MBMS MSK Request as defined by 3GPP TS 26.346 and 3GPP TS 33.246
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
### 11.6.2 Example
The below example is used to request a single MSK with keyDomainID \"uHCd\"
and a MSK ID part \"aMkAAA==\".
\
\
\
\uHCd\
\aMkAAA==\
\
\
## 11.7 Service Protection Registration and De-Registration Response Format
### 11.7.1 Data Format
This format is used in the response of the keymanagement server(s) to a
Service Protection Registration or De-Registration message. Service Protection
Registration message format is defined in clause 11.4 and the Service
Protection De-Registration message format in clause 11.5. The format of the
response codes are defined in 3GPP TS 33.246 [20]. The MIME Media type for
this format is defined in appendix C.13.
\
\
\
\
\MBMS Security Registration Response according to TS
33.246\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
### 11.7.2 Example
\
\
\
\urn:3gpp:mbms:example:service:identification:123456789abcdef\
\200 OK\
\
\
\urn:3gpp:mbms:example:service:identification:fedcba987654321\
\200 OK\
\
\
## 11.8 Service Protection MSK Response Format
### 11.8.1 Data Format
This format is used in the response of the keymanagement server(s) to an MSK
Request message. The MSK Request message format is defined in clause 11.6. The
format of the response codes are defined in 3GPP TS 33.246 [20]. The MIME
Media type for this format is defined in appendix C.12.
\
\
\
\
\MBMS Security MSK Request Response according to TS
33.246\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
### 11.8.2 Example
\
\
\
\
\uHCd\
\aMkAAA==\
\
\200 OK\
\
\
\
\uHCd\
\JMtEAA==\
\
\200 OK\
\
\
### 11.9 MBMS Feature Requirements
MBMS features enable the BM-SC to signal to the UE the set of capabilities
that are required for the consumption of the MBMS user service. The required
capability list is indicated in the MBMS User Service Description of the
corresponding MBMS user service as defined in section 11.2.1.
The MBMS UE shall not attempt to receive the service if it detects that at
least one required capability, indicated in the USD, is not supported or not
understood. The introduction of new features is possible and assumes that
unidentified features shall be interpreted by the UE as a requirement that
cannot be fulfilled.
The following list of features is currently identified:
Table 2 - MBMS Feature Requirement List
* * *
Service Capability References Recognized Feature Values (Integer) Speech as
defined in clause 10.2 0 AMR-WB as defined in clause 10.2 1 Enhanced aacPlus
as defined in clause 10.3 2 Extended AMR-WB as defined in clause 10.3 3
Synthetic audio as defined in clause 10.4 4 H.263 as mentioned in clause 10.5
5 H.264 Level 1b as defined in clause 10.5 (of Release 6) 6 Still images as
defined in clause 10.6 7 Bitmap graphics as defined in clause 10.7 8 Vector
graphics as defined in clause 10.8 9 Text as defined in clause 10.9 10 Timed
text as defined in clause 10.10 11 3GPP file format as defined in clause 10.11
12 H.264 Level 1.2 as defined in clause 10.5 (of Release 7) 13 Scene
Description as defined in clause 10.12 14 MBSFN mode in UTRAN as defined in
3GPP TS 25.346 (of Release 7) 15
* * *
The list of features may be extended in the future.
###### ## Annex A (normative): FLUTE Support Requirements
This clause provides a table representation of the requirement levels for
different features in FLUTE. Table A.1 includes requirements for an MBMS
client and an MBMS server for FLUTE support as well as the requirements for a
FLUTE client and a FLUTE server according to the FLUTE protocol (RFC 3926
[9]). The terms used in table A.1 are described underneath.
Table A.1: Overview of the FLUTE support requirements in MBMS servers and
clients
+-------------+-------------+-------------+-------------+-------------+ | | FLUTE | MBMS FLUTE | FLUTE | MBMS FLUTE | | | Client | Client | Server use | Server use | | | support | support | requirement | requirement | | | requirement | requirement | as per | as per | | | as per | as per | [9] | present | | | [9] | present | | document | | | | document | | | +-------------+-------------+-------------+-------------+-------------+ | FLUTE | Required | Required | Strongly | Required | | Blocking | | | recommended | | | Algorithm | | | | | +-------------+-------------+-------------+-------------+-------------+ | Symbol | Compact | Compact | Compact | Compact | | Encoding | No-Code | No-Code | No-Code | No-Code | | Algorithm | algorithm | algorithm | algorithm | algorithm | | | required. | required. | is the | is the | | | | | default | default | | | Other FEC | MBMS | option. | option. | | | building | Forward | | | | | blocks are | Error | Other FEC | MBMS | | | undefined | Correction | building | Forward | | | optional | required | blocks are | Error | | | plug-ins. | | undefined | Correction. | | | | | optional | | | | | | plug-ins. | | +-------------+-------------+-------------+-------------+-------------+ | Congestion | Congestion | Single | Single | Single | | Control | Control | channel | channel | channel | | Building | building | support | without | support | | Block | blocks | required | additional | required | | (CCBB) / | undefined. | | CCBB given | | | Algorithm | | | for the | | | | | | controlled | | | | | | network | | | | | | scenario. | | +-------------+-------------+-------------+-------------+-------------+ | Content | Optional | Optional | Optional | Shall not | | Encoding | | | | be used | | for FDT | | | | | | Instances | | | | | +-------------+-------------+-------------+-------------+-------------+ | Content | Optional | Required | Optional | Optional | | Encoding | | | | | | for any | | | | | | other file | | | | | | than FDT | | | | | | Instances | | | | | +-------------+-------------+-------------+-------------+-------------+ | A flag | Required | Required | Optional | Not | | active | | | | recommended | | (header) | | | | to use | +-------------+-------------+-------------+-------------+-------------+ | B flag | Required | Required | Optional | Not | | active | | | | recommended | | (header) | | | | to use | +-------------+-------------+-------------+-------------+-------------+ | T flag | Optional | Optional | Optional | Set to zero | | active and | | | | | | SCT field | | | | | | (header) | | | | | +-------------+-------------+-------------+-------------+-------------+ | R flag | Optional | Optional | Optional | Set to zero | | active and | | | | | | ERT field | | | | | | (header) | | | | | +-------------+-------------+-------------+-------------+-------------+ | Conte | Required | Required | Required | Required | | nt-Location | | | | | | attribute | | | | | | (FDT) | | | | | +-------------+-------------+-------------+-------------+-------------+ | TOI (FDT) | Required | Required | Required | Required | +-------------+-------------+-------------+-------------+-------------+ | FDT Expires | Required | Required | Required | Required | | attribute | | | | | | (FDT) | | | | | +-------------+-------------+-------------+-------------+-------------+ | Complete | Required | Required | Optional | Optional | | attribute | | | | | | (FDT) | | | | | +-------------+-------------+-------------+-------------+-------------+ | FE | Required | Required | Required | Required | | C-OTI-Maxim | | | | | | um-Source-B | | | | | | lock-Length | | | | | +-------------+-------------+-------------+-------------+-------------+ | FEC-OTI- | Required | Required | Required | Required | | Encoding-Sy | | | | | | mbol-Length | | | | | +-------------+-------------+-------------+-------------+-------------+ | FEC-OT | Required | Required | Required | Required | | I-Max-Numbe | | | | | | r-of-Encodi | | | | | | ng-Symbols. | | | | | +-------------+-------------+-------------+-------------+-------------+ | F | Required | Optional | Required | Optional | | EC-OTI-FEC- | | | | | | Instance-ID | | | | | +-------------+-------------+-------------+-------------+-------------+ | FEC-OT | n/a | Required | n/a | Required if | | I-Scheme-Sp | | | | MBMS FEC | | ecific-Info | | | | used | +-------------+-------------+-------------+-------------+-------------+
The following are descriptions of the above terms:
  * **Blocking algorithm:** The blocking algorithms is used for the > fragmentation of files. It calculates the source blocks from the > source files.
  * **Symbol Encoding algorithm:** The symbol encoding algorithm is used > for the fragmentation of files. It calculates encoding symbols > from source blocks for Compact No-Code FEC. It may also be used > for other FEC schemes.
  * **Congestion Control Building Block:** A building block used to > limit congestion by using congestion feedback, rate regulation and > receiver controls (RFC 3048 [17]).
  * **Content Encoding for FDT Instances:** FDT Instance may be content > encoded for more efficient transport, e.g. using GZIP.
  * **Content Encoding for any other file than FDT Instances:** Files > may be content encoded for more efficient transport, e.g. using > GZIP.
  * **A flag:** The Close Session flag for indicating the end of a > session to the receiver in the ALC/LCT header.
  * **B flag:** The Close Object flag is for indicating the end of an > object to the receiver in the ALC/LCT header.
  * **T flag:** The T flag is used to indicate the use of the optional > \"Sender Current Time (SCT)\" field (when T=1) in the ALC/LCT > header.
  * **R flag:** The R flag is used to indicate the use of the optional > \"Expected Residual Time (ERT) field in the ALC/LCT header.
  * **Content Location attribute:** This attribute provides a URI for > the location where a certain piece of content (or file) being > transmitted in a FLUTE session is located.
  * **Transport Object Identifier (TOI):** The TOI uniquely identifies > the object within the session from which the data in the packet > was generated.
  * **FDT Expires attribute:** Indicates to the receiver the time until > which the information in the FDT is valid.
  * **Complete attribute:** This may be used to signal that the given > FDT Instance is the last FDT Instance to be expected on this file > delivery session.
  * **FEC-OTI-Maximum-Source-Block-Length:** This parameter indicates > the maximum number of source symbols per source block.
  * **FEC-OTI-Encoding-Symbol-Length:** This parameter indicates the > length of the Encoding Symbol in bytes.
  * **FEC-OTI-Max-Number-of-Encoding-Symbols:** This parameter indicates > the maximum number of Encoding Symbols that can be generated for a > source block.
  * **FEC-OTI-FEC-Instance-ID:** This field is used to indicate the FEC > Instance ID, if a FEC scheme is used.
  * FEC-OTI-Scheme-Specific-Info: Carries Object Transmission > Information which is specific to the FEC scheme in use.
###### ## Annex B (normative): FEC encoder specification
This Annex specifies the systematic Raptor forward error correction code and
its application to MBMS [7]. Raptor is a fountain code, i.e., as many encoding
symbols as needed can be generated by the encoder on-the-fly from the source
symbols of a block. The decoder is able to recover the source block from any
set of encoding symbols only slightly more in number than the number of source
symbols.
The code described in this document is a Systematic code, that is, the
original source symbols are sent unmodified from sender to receiver, as well
as a number of repair symbols.
# B.1 Definitions, Symbols and Abbreviations
## B.1.1 Definitions
For the purposes of this Annex, the following terms and definitions apply.
**Source block** : a block of _K_ source symbols which are considered together
for Raptor encoding purposes.
**Source symbol** : the smallest unit of data used during the encoding
process. All source symbols within a source block have the same size.
**Encoding symbol** : a symbol that is included in a data packet. The encoding
symbols consist of the source symbols and the repair symbols. Repair symbols
generated from a source block have the same size as the source symbols of that
source block.
**Systematic code:** a code in which the source symbols are included as part
of the encoding symbols sent for a source block.
**Repair symbol** : the encoding symbols sent for a source block that are not
the source symbols. The repair symbols are generated based on the source
symbols.
**Intermediate symbols:** symbols generated from the source symbols using an
inverse encoding process . The repair symbols are then generated directly from
the intermediate symbols. The encoding symbols do not include the intermediate
symbols, i.e., intermediate symbols are not included in data packets.
**Symbol** : a unit of data. The size, in bytes, of a symbol is known as the
symbol size.
**Encoding symbol group** : a group of encoding symbols that are sent
together, i.e., within the same packet whose relationship to the source
symbols can be derived from a single Encoding Symbol ID.
**Encoding Symbol ID** : information that defines the relationship between the
symbols of an encoding symbol group and the source symbols.
**Encoding packet:** data packets that contain encoding symbols
**Sub-block** : a source block is sometime broken into sub-blocks, each of
which is sufficiently small to be decoded in working memory. For a source
block consisting of _K_ source symbols, each sub-block consists of _K_ sub-
symbols, each symbol of the source block being composed of one sub-symbol from
each sub-block.
**Sub-symbol** : part of a symbol. Each source symbol is composed of as many
sub-symbols as there are sub-blocks in the source block.
**Source packet:** data packets that contain source symbols.
**Repair packet:** data packets that contain repair symbols.
## B.1.2 Symbols
_i_ , _j_ , _x_ , _h_ , _a_ , _b_ , _d_ , _v, m_ represent positive integers
ceil(_x_) denotes the smallest positive integer which is greater than or equal
to _x_
choose(_i_ ,_j_) denotes the number of ways _j_ objects can be chosen from
among _i_ objects without repetition
floor(_x_) denotes the largest positive integer which is less than or equal to
_x_
_i_ % _j_ denotes _i_ modulo _j_
_X_ \^ _Y_ denotes, for equal-length bit strings _X_ and _Y,_ the bitwise
exclusive-or of _X_ and _Y_
_A_ denote a symbol alignment parameter. Symbol and sub-symbol sizes are
restricted to be multiples of _A_.
**A** ^T^ denotes the transposed matrix of matrix **A**
**A** ^-1^ denotes the inverse matrix of matrix **A**
_K_ denotes the number of symbols in a single source block
_K~MAX~_ denotes the maximum number of source symbols that can be in a single
source block. Set to 8192.
_L_ denotes the number of pre-coding symbols for a single source block
_S_ denotes the number of LDPC symbols for a single source block
_H_ denotes the number of Half symbols for a single source block
**C** denotes an array of intermediate symbols, _C_[0], _C_[1], _C_[2],...,
_C_[_L_ -1]
**C** ' denotes an array of source symbols, _C'_[0], _C'_[1], _C'_[2],..., _C_
'[_K_ -1]
_X_ a non-negative integer value
_V_ ~0~, _V_ ~1~ two arrays of 4-byte integers, _V_ ~0~[0], _V_ ~0~[1],...,
_V_ ~0~[255] and _V_ ~1~[0], _V_ ~1~[1],..., _V_ ~1~[255]
Rand[_X_ , _i_ , _m_] a pseudo-random number generator
Deg[_v_] a degree generator
LTEnc[_K_ , **C** _,_(_d_ , _a_ , _b_)] a LT encoding symbol generator
Trip[_K, X_] a triple generator function
_G_ the number of symbols within an encoding symbol group
_N_ the number of sub-blocks within a source block
_T_ the symbol size in bytes. If the source block is partitioned into sub-
blocks, then _T_ = _T'∙N_.
_T'_ the sub-symbol size, in bytes. If the source block is not partitioned
into sub-blocks then _T'_ is not relevant.
_F_ the file size, for file download, in bytes
_I_ the sub-block size in bytes
_P_ for file download, the payload size of each packet, in bytes, that is used
in the recommended derivation of the file download transport parameters. For
streaming, the payload size of each repair packet, in bytes, that is used in
the recommended derivation of the streaming transport parameters.
_Q Q_ = 65521, i.e., _Q_ is the largest prime smaller than 2^16^
_Z_ the number of source blocks, for file download
_J(K)_ the systematic index associated with _K_
**G** denotes any generator matrix
**I** _~S~_ denotes the _S_ x _S_ identity matrix
**0** ~_S_ x _H_ ~ denotes the _S_ x _H_ zero matrix
## B.1.3 Abbreviations
For the purposes of the present document, the following abbreviations apply:
ESI Encoding Symbol ID
LDPC Low Density Parity Check
LT Luby Transform
SBN Source Block Number
SBL Source Block Length (in units of symbols)
# B.2 Overview
The Raptor forward error correction code can be applied to both the MBMS file
delivery and MBMS streaming applications described in the main body of this
document. Raptor code aspects which are specific to each of these applications
are discussed in sub-clauses B.3 and B.4 of this document.
The principle component of the systematic Raptor code is the basic encoder
described in sub-clause B.5. First, it is described how to derive values for a
set of intermediate symbols from the original source symbols such that
knowledge of the intermediate symbols is sufficient to reconstruct the source
symbols. Secondly, the encoder produces repair symbols which are each the
exclusive OR of a number of the intermediate symbols. The encoding symbols are
the combination of the source and repair symbols. The repair symbols are
produced in such a way that the intermediate symbols and therefore also the
source symbols can be recovered from any sufficiently large set of encoding
symbols.
This document defines the systematic Raptor code encoder. A number of possible
decoding algorithms are possible. An efficient decoding algorithm is provided
in [91] section 5.5.
The construction of the intermediate and repair symbols is based in part on a
pseudo-random number generator described in sub-clause B.5. This generator is
based on a fixed set of 512 random numbers which must be available to both
sender and receiver. These are provided in sub-clause B.7.
Finally, the construction of the intermediate symbols from the source symbols
is governed by a 'systematic index', values of which are provided in sub-
clause B.6 for source block sizes from 4 source symbols to K~MAX~ = 8192
source symbols.
# B.3 File download
## B.3.1 Void
## B.3.2 Void
## B.3.3 Void
## B.3.4 Example parameters
### B.3.4.1 Parameter derivation algorithm
This sub-clause provides recommendations for the derivation of the four
transport parameters, _A_ , _T_ , _Z_ and _N_. This recommendation is based on
the following input parameters:
\- _F_ the file size, in bytes
\- _W_ a target on the sub-block size, in bytes
\- _P_ the maximum packet payload size, in bytes, which is assumed to be a
multiple of _A_
\- _A_ the symbol alignment factor, in bytes
\- _K~MAX~_ the maximum number of source symbols per source block.
\- _K~MIN~_ a minimum target on the number of symbols per source block
\- _G~MAX~_ a maximum target number of symbols per packet
Based on the above inputs, the transport parameters _T_ , _Z_ and _N_ are
calculated as follows:
Let,
_G_ = min{ceil(_P_ · _K~MIN~_ /_F_), _P_ /_A_ , _G~MAX~_} - the approximate
number of symbols per packet
_T =_ floor(_P_ /(_A_ · _G_))· _A_
_K~t~_ = ceil(_F_ /_T_) - the total number of symbols in the file
_Z_ = ceil(_K~t~_ /_K~MAX~_)
_N_ = min{ceil(ceil( _K~t~_ /_Z_)· _T_ /_W_ ), _T_ /_A_}
The values of _G_ and _N_ derived above should be considered as lower bounds.
It may be advantageous to increase these values, for example to the nearest
power of two. In particular, the above algorithm does not guarantee that the
symbol size, _T_ , divides the maximum packet size, _P_ , and so it may not be
possible to use the packets of size exactly _P_. If, instead, _G_ is chosen to
be a value which divides _P_ /_A_ , then the symbol size, _T_ , will be a
divisor of _P_ and packets of size _P_ can be used.
Recommended settings for the input parameters, _W_ , _A_ , _K~MIN~_ and
_G~MAX~_ are as follows:
_W_ = 256 KB _A_ = 4 _K~MIN~_ = 1024 _G~MAX~_ = 10
### B.3.4.2 Examples
The above algorithm leads to transport parameters as shown in Table B.3.4.2-1
below, assuming the recommended values for _W_ , _A_ , _K~MIN~_ and _G~MAX~_
and _P_ = 512:
Table B.3.4.2-1
* * *
**File size _F_** **_G_** **Symbol size _T_** **_G_ **T** __**K~t~**___Source
blocks_ Z** ___Sub-blocks_ N** __**K** ~L~__**K~S~**__**T~L\ ~**_∙_**A**
__**T~S\ ~**_∙_**A** * 100 KB 6 84 504 1,220 1 1 1,220 1,220 N/A N/A 100 KB 8
64 512 1,600 1 1 1,600 1,600 N/A N/A 300 KB 2 256 512 1,200 1 2 1,200 1,200
128 128 1,000 KB 1 512 512 2,000 1 5 2,000 2,000 104 100 3,000 KB 1 512 512
6,000 1 12 6,000 6,000 44 40 10,000 KB 1 512 512 20,000 3 14 6,666 6,667 40 36
* * *
# B.4 Streaming
## B.4.1 Source block construction
A source block is constructed by the transport protocol, for example as
defined in this document, making use of the Systematic Raptor Forward Error
Correction code. The symbol size, _T_ , to be used for source block
construction and the repair symbol construction are provided by the transport
protocol. The parameter _T_ shall be set so that the number of source symbols
in any source block is at most _K~MAX~_.
Recommended parameters are presented in sub-clause B.4.4.
## B.4.2 Encoding packet construction
As described in sub-clause B.4.3., each repair packet contains the following
information:
> \- Source Block Number (SBN)
>
> \- Encoding Symbol ID (ESI)
>
> \- Source Block Length (SBL)
\- repair symbol(s)
The number of repair symbols contained within a repair packet is computed from
the packet length. The ESI values placed into the repair packets and the
repair symbol triples used to generate the repair symbols are computed as
described in sub-clause B.3.2.2.
## B.4.3 Transport
This sub-clause describes the information exchange between the Raptor
encoder/decoder and any transport protocol making use of Raptor forward error
correction for streaming.
The Raptor encoder for streaming requires the following information from the
transport protocol for each source block:
\- The symbol size, _T,_ in bytes
\- The number of symbols in the source block, _K_
\- The Source Block Number (SBN)
\- The source symbols to be encoded, _K_ ∙ _T_ bytes
The Raptor encoder supplies the transport protocol with encoding packet
information consisting, for each repair packet, of:
\- Source Block Number (SBN)
\- Encoding Symbol ID (ESI)
\- Source Block Length (SBL)
\- repair symbol(s)
The transport protocol shall communicate this information transparently to the
Raptor decoder.
A suitable transport protocol is defined in this specification.
## B.4.4 Example parameters
### B.4.4.1 Parameter derivation algorithm
This sub-clause provides recommendations for the derivation of the transport
parameter _T_. This recommendation is based on the following input parameters:
\- _B_ the maximum source block size, in bytes
\- _P_ the maximum repair packet payload size, in bytes, which is a multiple
of _A_
\- _A_ the symbol alignment factor, in bytes
\- _K~MAX~_ the maximum number of source symbols per source block.
\- _K~MIN~_ a minimum target on the number of symbols per source block
\- _G~MAX~_ a maximum target number of symbols per repair packet
A requirement on these inputs is that ceil(_B_ /_P_) ≤ _K~MAX~_. Based on the
above inputs, the transport parameter _T_ is calculated as follows:
Let,
_G_ = min{ceil(_P_ · _K~MIN~_ /_B_), _P_ /_A_ , _G~MAX~_} - the approximate
number of symbols per packet
_T =_ floor(_P_ /(_A_ · _G_))· _A_
The value of _T_ derived above should be considered as a guide to the actual
value of _T_ used. It may be advantageous to ensure that _T_ divides into _P_
, or it may be advantageous to set the value of _T_ smaller to minimize
wastage when full size repair symbols are used to recover partial source
symbols at the end of lost source packets (as long as the maximum number of
source symbols in a source block does not exceed _K~MAX~_). Furthermore, the
choice of _T_ may depend on the source packet size distribution, e.g., if all
source packets are the same size then it is advantageous to choose _T_ so that
the actual payload size of a repair packet _P'_ , where _P'_ is a multiple of
_T_ , is equal to (or as few bytes as possible larger than) the number of
bytes each source packet occupies in the source block.
Recommended settings for the input parameters, _A_ , _K~MIN~_ and _G~MAX~_ are
as follows:
_A_ = 4 _K~MIN~_ = 1024 _G~MAX~_ = 10
### B.4.4.2 Examples
The above algorithm leads to transport parameters as shown in Table B.4.4.2-1
below, assuming the recommended values for _A_ , _K~MIN~_ and _G~MAX~_ and _P_
= 512:
Table B.4.4.2-1
* * *
**Max source block size _B_** **_G_** **Symbol size _T_** **_G∙T_** 40 KB 10
48 480 160 KB 4 128 512 640 KB 1 512 512
* * *
# B.5 Systematic Raptor encoder
## B.5.1 Encoding overview
The systematic Raptor encoder is used to generate _repair symbols_ from a
source block that consists of _K_ _source symbols_.
Symbols are the fundamental data units of the encoding and decoding process.
For each source block (sub-block) all symbols (sub-symbols) are the same size.
The atomic operation performed on symbols (sub-symbols) for both encoding and
decoding is the exclusive-or operation.
Let _C'_[0],..., _C'_[_K_ -1] denote the _K_ source symbols.
Let _C_[0],..., _C_[_L_ -1] denote _L_ intermediate symbols.
The first step of encoding is to generate a number, _L_ > _K_ , of
intermediate symbols from the _K_ source symbols. In this step, _K_ source
triples (_d_[0], _a_[0], _b_[0]), ..., (_d_[_K_ -1], _a_[_K_ -1], _b_[_K_ -1])
are generated using the Trip[] generator as described in sub-clause B.5.4.4.
The _K_ source triples are associated with the _K_ source symbols and are then
used to determine the _L_ intermediate symbols _C_[0],..., _C_[_L_ -1] from
the source symbols using an inverse encoding process. This process can be can
be realized by a Raptor decoding process.
Certain "pre-coding relationships" must hold within the _L_ intermediate
symbols. Sub-clause B.5.2 describes these relationships and how the
intermediate symbols are generated from the source symbols.
Once the intermediate symbols have been generated, repair symbols are produced
and one or more repair symbols are placed as a group into a single data
packet. Each repair symbol group is associated with an Encoding Symbol ID
(ESI) and a number, _G_ , of encoding symbols. The ESI is used to generate a
triple of three integers, (_d_ , _a,_ _b)_ [for each repair
symbol,]{.underline} again using the Trip[] generator as described in sub-
clause B.5.4.4. This is done as described in sub-clauses B.3 and B.4 using the
generators described in sub-clause B.5.4 . Then, each (_d_ ,_a_ ,_b_)-triple
is used to generate the corresponding repair symbol from the intermediate
symbols using the LTEnc[_K_ , _C_[0],..., _C_[_L_ -1], (_d_ ,_a_ ,_b_)]
generator described in sub-clause B.5.4.3.
## B.5.2 First encoding step: Intermediate symbol Generation
### B.5.2.1 General
The first encoding step is a pre-coding step to generate the _L_ intermediate
symbols _C_[0], ..., C[_L_ -1] from the source symbols _C_ '[0], ..., C'[_K_
-1]. The intermediate symbols are uniquely defined by two sets of constraints:
1\. The intermediate symbols are related to the source symbols by a set of
_source symbol triples._ The generation of the source symbol triples is
defined in sub-clause B.5.2.2 using the the Trip[] generator as described in
sub-clause B.5.4.4.
2\. A set of pre-coding relationships hold within the intermediate symbols
themselves. These are defined in sub-clause B.5.2.3.
The generation of the _L_ intermediate symbols is then defined in sub-clause
5.2.4.
### B.5.2.2 Source symbol triples
Each of the _K_ source symbols is associated with a triple (_d_[_i_],
_a_[_i_], _b_[_i_]) for 0 ≤ _i_ \ (_d_[_i_], _a_[_i_], _b_[_i_]) = Trip[_K, i_]
### B.5.2.3 Pre-coding relationships
The pre-coding relationships amongst the _L_ intermediate symbols are defined
by expressing the last _L_ -_K_ intermediate symbols in terms of the first _K_
intermediate symbols.
The last _L_ -_K_ intermediate symbols _C_[_K_],...,C[_L_ -1] consist of _S_
_LDPC symbols_ and _H_ _Half symbols_ The values of _S_ and _H_ are determined
from _K_ as described below. Then _L= K+S+H_.
Let
_X_ be the smallest positive integer such that _X·_(_X_ \--1) >= 2· _K_.
_S_ be the smallest prime integer such that _S_ ≥ ceil(0.01 _·K_) + _X_
_H_ be the smallest integer such that choose(_H,_ ceil _(H/2)_) ≥ _K_ \+ _S_
_H'_ = ceil(_H_ /2)
_L_ = _K_ +_S_ +_H_
_C_[_0_],..., C[_K_ -1] denote the first _K_ intermediate symbols
_C_[_K_],..., C[_K_ +_S_ -1] denote the _S_ LDPC symbols, initialised to zero
_C_[_K_ +_S_],..., C[_L_ -1] denote the _H_ Half symbols, initialised to zero
The _S_ LDPC symbols are defined to be the values of _C_[_K_],..., C[_K_ +_S_
-1] at the end of the following process:
For _i_ = 0,...,_K_ -1 do
_a_ = 1 + (floor(_i_ /_S_) % (_S_ -1))
_b_ = _i_ % _S_
_C_[_K_ \+ _b_] = _C_[_K_ \+ _b_] \^ _C_[_i_]
_b_ = (_b_ \+ _a_) % _S_
_C_[_K_ \+ _b_] = _C_[_K_ \+ _b_] \^ _C_[_i_]
_b_ = (_b_ \+ _a_) % _S_
_C_[_K_ \+ _b_] = _C_[_K_ \+ _b_] \^ _C_[_i_]
The _H_ Half symbols are defined as follows:
Let
_g_[_i_] = _i_ \^ (floor(_i_ /2)) for all positive integers _i_
Note: _g_[_i_] is the Gray sequence, in which each element differs from the
previous one in a single bit position
g[_j_ ,_k_] denote the _j_ ^th^ element, _j_ =0, 1, 2, ..., of the subsequence
of _g_[_i_] whose elements have exactly _k_ non-zero bits in their binary
representation
Then, the Half symbols are defined as the values of _C_[_K_ +_S_],..., C[_L_
-1] after the following process:
For _h_ = 0,...,_H_ -1 do
For _j_ = 0,...,_K_ +_S_ -1 do
If bit _h_ of _g_[_j_ ,_H'_] is equal to 1 then _C_[_h_ +_K_ +_S_] = _C_[_h_
+_K_ +_S_] \^ _C_[_j_].
### B.5.2.4 Intermediate symbols
#### B.5.2.4.1 Definition
Given the _K_ source symbols _C'_[0], _C'_[1],..., _C'_[_K_ -1] the _L_
intermediate symbols _C_[0], _C_[1],..., _C_[_L_ -1] are the uniquely defined
symbol values that satisfy the following conditions:
1\. The _K_ source symbols _C'_[0], _C'_[1],..., _C'_[_K_ -1] satisfy the _K_
constraints
> _C'_[_i_] ≡ LTEnc[_K_ , (_C_[0],..., _C_[_L_ -1]), (_d_[_i_], _a_[_i_],
> _b_[_i_])], for all _i_ , 0 ≤ _i_ \ **G** ~LDPC~ _·_ (_C_[0], ..., _C_[_K_ -1])^T^ = (_C_[_K_], ..., C[_K_ +_S_
> -1])^T^
**G** ~Half~ be the _H_ x (_K_ +_S_) generator matrix of the Half symbols, So,
> **G** ~Half~ _·_ (_C_[0], ..., _C_[_S_ +_K_ -1])^T^ = (C[_K_ +_S_], ...,
> _C_[_K_ +_S_ +_H_ -1])^T^
>
> **I** _~S~_ be the _S_ x _S_ identity matrix
>
> **I** _~H~_ be the _H_ x _H_ identity matrix
**0** ~_S_ x _H_ ~ be the _S_ x _H_ zero matrix
**G** ~LT~ be the _K_ x _L_ generator matrix of the encoding symbols generated
by the LT Encoder.
So,
> **G** ~LT~ _·_ (_C_[0], ..., _C_[_L_ -1])^T^ = (_C'_[0], _C'_[1],...,
> _C'_[_K_ -1] )^T^
>
> i.e. **G** ~LT _i_ ,_j_ ~ = 1 if and only if _C_[_j_] is included in the
> symbols which are XORed to produce LTEnc[_K_ , (_C_[0], ..., _C_[_L_ -1]),
> (_d_[_i_], _a_[_i_], _b_[_i_])].
Then:
The first _S_ rows of **A** are equal to **G** ~LDPC~ \| **I** _~S~_ \|**Z**
~_S_ x _H_**.** ~
The next _H_ rows of **A** are equal to **G** ~Half~ \| **I** ~_H_**.** ~
The remaining _K_ rows of **A** are equal to **G** ~LT~.
The matrix **A** is depicted in the figure below:
* * *
        *K*           *S*          *H*
_S_ **G** ~LDPC~ **I** _~S~_ **Z** ~_S_ x _H_ ~ _H_ **G** ~Half~ **I** _~H~_  
_K_ **G** ~LT~
* * *
Figure B.5.2.5.2-1: The matrix A
The intermediate symbols can then be calculated as:
**C** = **A** ^-1^_·_**D**
The source triples are generated such that for any _K_ matrix **A** has full
rank and is therefore invertible. This calculation can be realized by applying
a Raptor decoding process to the _K_ source symbols _C'_[0], _C'_[1],...,
_C'_[_K_ -1] to produce the _L_ intermediate symbols _C_[0], _C_[1],...,
_C_[_L_ -1].
To efficiently generate the intermediate symbols from the source symbols, it
is recommended that an efficient decoder implementation such as that described
in [91] section 5.5 be used. The source symbol triples are designed to
facilitate efficient decoding of the source symbols using that algorithm.
## B.5.3 Second encoding step: LT encoding
In the second encoding step, the repair symbol with ESI _X_ is generated by
applying the generator LTEnc[_K_ , (_C_[0], _C_[1],..., _C_[_L_ -1]), (_d_ ,
_a_ , _b)_] defined in sub-clause B.5.4 to the _L_ intermediate symbols
_C_[0], _C_[1],..., _C_[_L_ -1] using the triple (_d_ , _a_ , _b)=_
Trip[_K,X_] generated according to sub-clauses B.3.2.2 and B.4.2.
## B.5.4 Generators
### B.5.4.1 Random Generator
The random number generator Rand[_X_ , _i_ , _m_] is defined as follows, where
_X_ is a non-negative integer, _i_ is a non-negative integer and _m_ is a
positive integer and the value produced is an integer between 0 and _m_ -1.
Let _V­_ ~0~­­ and _V­_ ~1~­­ be arrays of 256 entries each, where each entry
is a 4-byte unsigned integer. These arrays are provided in sub-clause B.7.
Then,
Rand[_X_ , _i_ , _m_] = (_V­_ ~0~[(_X_ \+ _i_) % 256] \^ _V­_ ~1~[(floor(_X_
/256)+ _i_) % 256]) % _m_
### B.5.4.2 Degree Generator
The degree generator Deg[_v_] is defined as follows, where _v_ is an integer
that is at least 0 and less than 2^20^ = 1048576.
In Table B.5.4.2-1, find the index _j_ such that _f_[_j_ -1] ≤ _v_ \ _d_ is an integer denoting an encoding symbol degree
>
> _a_ is an integer between 1 and _L'_ -1 inclusive
>
> _b_ is an integer between 0 and _L'_ -1 inclusive
The encoding symbol generator produces a single encoding symbol as output,
according to the following algorithm:
While (_b_ ≥ _L_) do _b_ = (_b_ \+ _a_) % _L'_
Let _result_ = _C_[_b_].
For _j_ = 1,...,min(_d_ -1,_L_ -1) do
_b_ = (_b_ \+ _a_) % _L'_
While (_b_ ≥ _L_) do _b_ = (_b_ \+ _a_) % _L'_
_result_ = _result_ \^ _C_[_b_]
> Return _result_
### B.5.4.4 Triple generator
The triple generator Trip[_K_ ,_X_] takes the following inputs:
_K_ The number of source symbols
_X_ An encoding symbol ID
Let
_L_ be determined from _K_ as described in sub-clause B.5.2
_L'_ be the smallest prime that is greater than or equal to _L_
_Q_ = 65521, the largest prime smaller than 2^16^.
_J(K)_ be the systematic index associated with _K_ , as defined in sub-clause
B.7
The output of the triple generator is a triples, (_d_ , _a_ , _b_) determined
as follows:
_1._ _A_ _=_ (53591 + _J_(_K_)∙997) % Q
_2_. _B_ = 10267∙(_J_(_K_)+1) % _Q_
_3\. Y_ = (_B_ \+ _X_ · _A_) % _Q_
_4\. v = Rand[Y, 0, 2^20^]_
_5\. d = Deg[v]_
_6\. a = 1 + Rand[Y, 1, L'-1]_
_7\. b = Rand[Y, 2, L']_
# B.6 Systematic Indices J(_K_))
The J(K) indices are defined in [91], clause 5.7
# B.7 Random Numbers
The two tables _V_ ~0~ and _V_ ~1~ are defined in [91], clause 5.6.1 and 5.6.2
respectively.
# B.8 Void
###### ## Annex C (informative): IANA registration
This annex provides the required IANA registration.
# C.1 Registration of SDP Protocol Identifiers for Source packet
This specification defines two new SDP protocol identificators for source
packets. As the registration rules requires these to be registered by an RFC,
there will be an RFC referencing the definitions here.
Protocol identifier "UDP/MBMS-FEC/RTP/AVP" identifies a protocol combination
of UDP[7], FEC source packets (see sub-clause 8.2.2.4), RTP [6] using the AVP
profile [78]. This protocol identifier shall use the FMT space rules that are
used for RTP/AVP.
Protocol identifier "UDP/MBMS-FEC/RTP/SAVP" identifies a protocol combination
of UDP [7], FEC source packets (see sub-clause 8.2.2.4), and RTP [6] using the
SAVP profile [77]. This protocol identifier shall use the FMT space rules that
are used for RTP/AVP.
# C.2 Registration of SDP Protocol identifier for repair packets
This specification defines one new SDP protocol identificator for FEC repair
packets. As the registration rules requires these to be registered by an RFC,
there will be an RFC referencing the definitions within this specification.
Protocol identifier "UDP/MBMS-REPAIR" identifies a protocol combination of UDP
[7], FEC repair packets (see sub-clause 8.2.2.4). The FMT string is not used
and shall be set to "*".
# C.3 Registration of MIME type \"application/simpleSymbolContainer\"
The MIME Type \"application/simpleSymbolContainer\" denotes that the message
body is a simple container of encoding symbols for the file repair procedure
(clause 9.3.5.2 - File Repair Response Message Format for HTTP Carriage of
Repair Data).
Type name: application
Subtype name: simpleSymbolContainer
Required parameters:
> None
Optional parameters:
> None
Encoding considerations:
> The content is binary and if transported in a protocol not capable of
> handling binary content then the object must be encoded, for example using
> base64 [82].
Security considerations:
> The content of this media type are either source or repair symbols part of a
> binary file object. Thus it security considerations depends on the security
> requirements on the file object. As modification of the response message may
> corrupt the complete file object due to the FEC repair operations, integrity
> protection is recommended. Source authentication is also recommended to
> prevent man in the middle or spoofing attacks resulting in erronous repair
> symbols.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.4 Registration of MIME type \"application/mbms-user-service-
description+xml \"
The MIME Type \"application/mbms-user-service-description+xml\" denotes that
the message body is a user service description instance in accordance with the
XML schema \"urn:3GPP:metadata:2005:MBMS:userServiceDescription\" (see sub-
clause 11.2.1).
Type name: application
Subtype name: mbms-user-service-description+xml
Required parameters:
None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> This media format is used to configure the receiver on how to participate in
> a service. This format is highly suspectible to manipulation or spoofing for
> attacks desring to misslead a receiver about a session. Both integrity
> protection and source authentication is recommended to prevent missleading
> of the receiver.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage: None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.5 Registration of MIME type \"application/mbms‑envelope+xml \"
The MIME Type \"application/mbms-envelope+xml\" denotes that the message body
is a metadata envelope according to the XML schema
\"urn:3gpp:metadata:2005:MBMS:envelope\" (see sub-clause 11.1.3).
Type name: application
Subtype name: mbms‑envelope+xml
Required parameters:
> None
Optional parameters:
> embedded: Declares if all objects described in this envelope instance are
> embedded within the this envelope instance. The value is either 0 (false) or
> 1 (true) and when this parameter is omitted the value defaults to 0 (false).
>
> referenced: Declares if all objects described in this envelope instance are
> referenced, none is embedded within the envelope. The value is either 0
> (false) or 1 (true) and when this parameter is omitted the value defaults to
> 0 (false).
>
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> This media format contains information about versioning and validity of
> files, telling the receiver if it should invalidate already received files
> or replace previously received files with new version contained or
> referenced within this format. Thus modifying or spoofing an envelope is a
> simple way of making denial of service attack. Thus source authentication
> and integrity protection of the files are recommended.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.6 Registration of MIME type \"application/mbms‑protection-description+xml
\"
The MIME-Type \"application/mbms-protection-description+xml\" denotes that the
message body is an MBMS protection description XML document according to the
scheme identified as \"urn:3GPP:metadata:2005:MBMS:securityDescription\" (see
sub-clause 11.3.1).
Type name: application
Subtype name: mbms‑protection-description+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The media format is used to configure the security functions of the MBMS
> delivery. Thus a target for any attacker that would like modify a receivers
> understanding of the security functions, either for a denial of service
> attack or a session replacement attack. However the format contains no
> seceret information that may not be shared openly. All security keys are
> handled using other mechanisms. Source authentication and integrity
> protection is recommended.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.7 Registration of MIME type \"application/mbms‑associated-procedure-
description+xml\"
The MIME-Type \"application/mbms-associated-procedure-description+xml\"
denotes that the message body contains the associated procedure description in
XML following the schema \"urn:3gpp:metadata:2005:MBMS:associatedProcedure\"
(see sub-clause 9.5.1).
Type name: application
Subtype name: mbms‑associated-procedure-description+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The information present in this media format is used to configure the
> receiving application. Thus the usage of the fomat is vulnerable to attacks
> modifying or spoofing the content of this format. It is recommended to use
> source authentication and integrity protection.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.8 Registration of MIME type \"application/mbms-msk+xml\"
The MIME-Type \"application/ mbms-msk+xml\" denotes that the message body
contains the MSK request parameters in accordance with the XML scheme
\"urn:3GPP:metadata:2005:MBMS:mskRequest\" (see sub-clause 11.6 and 3GPP TS
33.246 [20]).
Type name: application
Subtype name: application/mbms-msk+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The usage of the format is to identify one or more MSK that the requesting
> entity desires to receive. Modification or changes to this format thus only
> result in a denial of service attack. Integrity protection would protect
> against such modifications.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.9 Registration of MIME type \"application/mbms-register+xml\"
The MIME-Type \"application/mbms-register+xml\" denotes that the message body
contains the MBMS User Service Registration parameters in accordance with the
XML schema \"urn:3GPP:metadata:2005:MBMS:securityRegistration\" (see sub-
clause 11.4 and 3GPP TS 33.246 [20]).
Type name: application
Subtype name: mbms-register+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The content of this format identifies a user service that the document
> creator desires to register to. Any modificatons of this document would
> allow an attacker to change to what services the creator registers to. To
> prevent this integrity protection is necessary. There is also necessary to
> authenticate the entity performing the registration to know who is the one
> performing the registration request. In MBMS this is accomplished using
> procedures described in 3GPP TS 33.246.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.10 Registration of MIME type \"application/mbms-deregister+xml\"
The MIME-Type \"application/mbms-deregister+xml\" denotes that the message
body contains the MBMS User Service Deregistration parameters in accordance
with the XML schema \"urn:3GPP:metadata:2005:MBMS:securityDeregistration\"
(see sub-clause 11.5 of 3GPP TS 26.346 and 3GPP TS 33.246 [20]).
Type name: application
Subtype name: mbms-deregister+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The content of this format identifies a user service that the document
> creator desires to register to. Any modificatons of this document would
> allow an attacker to change to what services the creator registers to. To
> prevent this integrity protection is necessary. There is also necessary to
> authenticate the entity performing the registration to know who is the one
> performing the registration request. In MBMS this is accomplished using
> procedures described in 3GPP TS 33.246.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.11 Registration of MIME type \"application/mbms-reception-report+xml\"
> The MIME-type registration for \"application/mbms-reception-report+xml\"
> that identifies XML documents that follows the schema
> \"urn:3gpp:metadata:2005:MBMS:receptionreport\" defined in clause 9.5.3.
Type name: application
Subtype name: mbms-reception-report+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The reception report XML document instances contain information about what
> services and files that a particular receiver has received. Thus to prevent
> manipulation of that information it would need to be integrity protected.
> The information also has privacy relevance as it reveals what a specific
> receiver, which usually can be connected to a specific user, has received.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
> None
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.12 Registration of MIME type \"application/mbms-msk-response+xml\"
The MIME Media Type \"application/ mbms-msk-response+xml\" denotes that the
message body contains the response codes to MSK request procedure in
accordance with the XML scheme \"urn:3GPP:metadata:2005:MBMS:mskResponse\"
(see sub-clause 11.8 and 3GPP TS 33.246 [20]).
Type name: application
Subtype name: mbms-msk-response+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The usage of the format is to identify one or more response codes of MSK
> requests procedures. Modification or changes to this format thus only result
> in a denial of service attack. Integrity protection would protect against
> such modifications. In MBMS this is accomplished using procedures described
> in 3GPP TS 33.246.
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
# C.13 Registration of MIME type \"application/mbms-register-response+xml\"
The MIME Media Type \"application/mbms-register-response+xml\" denotes that
the message body contains the response codes to an MBMS User Service
Registration or MBMS User Service De-Register procedure in accordance with the
XML schema \"urn:3GPP:metadata:2005:MBMS:securityRegistrationResponse\" (see
sub-clause 11.7 and 3GPP TS 33.246 [20]).
Type name: application
Subtype name: mbms-register-response+xml
Required parameters:
> None
Optional parameters:
> charset: As specified in RFC 3023 [83] for media type application/xml.
Encoding considerations:
> This is an XML document and the encoding considerations are the same as for
> media type \"application/xml\" defined in RFC 3023 [83].
Security considerations:
> The usage of the format is to identify one or more response codes of
> registration or deregistration procedures. Modification or changes to this
> format thus only result in a denial of service attack. Integrity protection
> would protect against such modifications. In MBMS this is accomplished using
> procedures described in 3GPP TS 33.246
Interoperability considerations:
> None
Published specification:
> 3GPP TS 26.346
Applications which use this media type:
> 3GPP MBMS based applications
Additional information:
Magic number(s): None
File extension(s):
Macintosh file type code(s):
Person & email address to contact for further information:
> Magnus Westerlund (magnus.westerlund\@ericsson.com)\ 3GPP TSG SA WG4
Intended usage: COMMON
Restrictions on usage:
> None
Author:
> 3GPP TSG SA WG4
Change controller:
> 3GPP TSG SA WG4
###### ## Annex D (informative): RTP packetization guidelines
This annex provides guidelines for MBMS senders to minimize initial buffering
delay between starting of the reception and starting of rendering of media
data in MBMS receivers.
When H.264 (AVC) video is in use, an MBMS sender should form FEC source blocks
in which the first H.264 (AVC) access unit in decoding order is an IDR access
unit.
MBMS senders should transmit all application data units for a given H.264
(AVC) access unit, or audio frame within one FEC source block.
MBMS senders should set the min-buffer-time MIME/SDP parameter and the minimum
buffering delay elements included in FEC source blocks to values that are
sufficient to cover any required de-interleaving of application data units,
such as H.264 (AVC) NAL units and coded audio frames, from their transmission
order to decoding order.
When RTP timestamps are converted to the wallclock time of the MBMS receiver,
the smallest RTP timestamp among the FEC source packets of a FEC source block
of a stream should be equal or close to the smallest RTP timestamp among the
FEC source packets of a FEC source block of any other stream of the same MBMS
streaming session.
When RTP timestamps are converted to the wallclock time of the MBMS receiver,
the greatest RTP timestamp among the FEC source packets of a FEC source block
of a stream should be equal or close to the greatest RTP timestamp among the
FEC source packets of a FEC source block of any other stream of the same MBMS
streaming session.
When DIMS content is used, suitable media level recovery (a random access
point such as a replacement scene, redundant scene, etc.) should be present at
the beginning of each FEC source block. This facilitates immediate rendering
of the DIMS content after FEC decoding, thus reducing tune-in latency.
###### ## Annex E (informative): Void
###### ## Annex F (informative): Hybrid Streaming Delivery
# F.1 Introduction
In hybrid streaming delivery scenarios it is assumed that a set of streaming
services is available over MBMS and a set of streaming services is available
over PSS. MBMS services may not be available in some service areas, in which
cases those services might be alternatively provided via PSS.
Different switching cases between PSS and MBMS and vice versa may occur in
these scenarios, including user-initiated content switching with access change
as well as application-initiated access change. The latter can occur when a
service is available over MBMS in some service areas but not available over
MBMS in other service areas, assuming that the service is provided over PSS as
a fall-back.
This annex describes some methods to improve switching times in such hybrid
streaming delivery scenarios.
# F.2 Switching between MBMS and PSS Access
## F.2.1 Synchronization of Flows
For switching between MBMS and PSS access while receiving the same service,
comparing the SSRC values of the PSS and MBMS flows gives the UE an advantage
for synchronization onto the flows as described in sub-clause 8.5.
In order to allow for an as interruption-free access switch as possible, the
time offset between MBMS packet reception and PSS packet reception (including
MBMS FEC buffering and PSS retransmission delays) should be as small as
possible.
It is advantageous (but not always possible) that the same set of codecs is
used for representing the same service over both accesses. If the same media
bit rates are provided over both accesses, then at best the same media flows
(identical media encoding) are used for both accesses. This gives the UE an
advantage of being able to continuously using decoding buffers thus
simplifying seamless access switching. In case the codecs or codec
level/profiles change upon access switching, the UE needs to prepare a new set
of decoders and possibly having them run in parallel for a short period of
time.
## F.2.2 Switching from MBMS to PSS Access
Switching from MBMS to PSS can happen in two cases, user-initiated content
switch with access change and application-initiated access change.
  * User-initiated content switch with access change: The user requests reception of a service other than the one currently received over MBMS, and the new service is only available over PSS.
  * Application-initiated switch of access: The MBMS coverage is lost and alternative reception of the same service is possible over PSS.
The latter case may occur suddenly and without warning when the available
signal strength is no longer good enough for the MBMS reception. The UE may
identify the loss of MBMS access by signal strength measurements, detection of
packet losses exceeding a certain threshold, or that RTP reception has stopped
completely. As a result the UE may terminate the MBMS session and initiate
service reception over PSS instead.
In case MBMS coverage is lost and the corresponding PSS session is requested,
the UE may use PSS time-shifting (as defined in TS 26.234 [47]) for signalling
a PSS play-out start corresponding to the time instant the MBMS access was
lost, giving the advantage of synchronization of the received flows.
## F.2.3 Switching from PSS to MBMS Access
Switching from PSS to MBMS can happen in two cases, user-initiated content
switch with access change and application-initiated access change.
  * User-initiated content switch with access change: The user requests reception of a service other than the one currently received over PSS, and the new service is available over MBMS.
  * Application-initiated switch of access: The UE recognizes that MBMS reception of that service is alternatively possible (e.g. because MBMS reception was re-gained), such that the UE may terminate the PSS session and initiate reception over MBMS.
If the UE can receive both PSS and MBMS flows at the same time, and the time
offset between MBMS packet reception and PSS packet reception (including MBMS
FEC buffering and PSS retransmission delays) is small, and identical media
encoding is used, then application-initated access change from PSS to MBMS
without service change is possible to be made in such a way that it is
seamless.
###### ## Annex G (informative): Guidelines for Channel Tune-in and Switch
Time Reduction
This Annex describes some methods to improve channel tune-in and switching
times for MBMS Streaming when using the FEC framework. It presents means for
MBMS senders and receivers to minimize delay from a channel switch and initial
tune-in time. Fast startup improvements for the layers below IP are not
described here.
# G.1 Interleaving for Tune-in Time Reduction of FEC protected MBMS Services
Interleaving may be applied to source blocks before FEC encoding to re-arrange
the order of transmission of the UDP packets. The target of the interleaving
is to provide high priority and correctly decodeable media units in a way that
maximizes the resulting media duration at the receivers that tune in at that
specific source block. The interleaver may operate at two different levels:
  * Inter-stream interleaving: prioritize the media streams and arrange their transmission order according to the ascending order of priorities. In other words high priority data, e.g. audio data, is transmitted towards the end of the source block.
  * Intra-stream interleaving: high priority media data units such as Random Access Points of a video stream are transmitted towards the end of a source block.
The interleaving procedure enables receivers to reliably decode and present
media data that has been received from a fraction of the tune-in source block.
Interleaving is transparent to legacy receivers.
## G.1.1 Timestamp Offsets
The timestamp offset field may be used to signal a timestamp offset for the
received media units in the FEC block as specified in 8.2.3.2.
The timestamp offsets may be used to reconstruct the presentation time line at
the UE. They may also be used to reduce the out time caused by the reception
of a partially received interleaved FEC source block as shown in figure G.1.
{width="6.002083333333333in" height="2.765277777777778in"}
Figure G.1: Early tune-in using variable timestamps
## G.1.2 Early Playout
A UE that desires to make use of the interleaving to reduce the tune-in time
may start the playout earlier than dictated by the min-buffer-time value.
Instead, the UE may schedule the first media unit of the succeeding source
block to be played out after the min-buffer-time. It may then estimate the
appropriate time for starting early playout based on the amount of media
duration that was received from the current block, the playout time of the
earliest media unit of the next source block, and the highest presentation
time of the media units of the current source block.
The early playout behavior is depicted by the following figure.
Figure G.2: Early play out of interleaved media data of a FEC protected MBMS
service
# G.2 FEC Stream & Channel Bundling
## G.2.1 Introduction
FEC Stream bundling is a method of improving the FEC efficiency and also to
improve channel switching times. Several flows of one or more user services
are "bundled" to form the source blocks for the FEC calculations. . This
means, that all flows must be received for potential FEC recovery.
If flows from more than one user service are bundled (i.e. Channel Bundling),
then the receiver discards other services after FEC processing. When a switch
is performed, media inside the same bundle is immediately available. Stream
Bundling can be performed on whole channels, parts of channels, or not at all.
Note: FEC Bundling does not improve start-up times.
### G.2.1.1 Full Channel Bundling (All flows of several user services)
When full bundling is used, more than one complete channel is bundled. A
channel switch inside the bundle does not require rebuffering and can
therefore be near instantaneous. However, full bundling requires the
processing of all packets. In other words, at a single time instance all video
streams and all audio streams are received and processed. Also, the number of
channels possible is limited by the fixed bearer bandwidth.
### G.2.1.2 No Bundling
When no bundling is used, each channel is protected separately. In a channel
switch the new channel needs to be buffered for the full min-buffer-time. At a
single time instant one video stream and one audio stream is received and
processed.
### G.2.1.3 Partial Channel Bundling (Some flows of several user services)
Partial bundling may be used to combine some of the benefits of full bundling
and no bundling. In this case more than one parital channel is bundled. This
may be used to reduce the processing required on the terminal while retaining
fast channel switching between parts of the media.
Partial bundling may be used to bundle only the audio part of channels. In
other words, at a single time instance one video stream and all audio streams
are received. When a switch occurs the audio is switched instantaneously as it
does not need to be rebuffered. The complexity of this case is substantially
lower than full bundling and the number of channels which can be bundled given
a fixed bearer bandwidth is substantially increased. This is due to the fact
that the audio uses a substantially lower percentage of the bitrate compared
to video.
### G.2.1.3 Stream Bundling (All flows of a single user services)
When stream bundling is used, all flows of a single channel are bundled. The
FEC source block is formed using audio, video and security data.
#
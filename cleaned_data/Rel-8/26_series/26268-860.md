# Foreword
The present document has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
The present document contains an electronic copy of the ANSI‑C code for the
eCall in-band modem solution for reliable transmission of MSD data from IVS to
PSAP via the speech channel of cellular networks. The ANSI‑C code is necessary
for a bit exact implementation of the IVS modem and PSAP modem described in
3GPP TS 26.267 [1].
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
  * References are either specific (identified by date of publication, > edition number, version number, etc.) or non‑specific.
  * For a specific reference, subsequent revisions do not apply.
  * For a non-specific reference, the latest version applies. In the > case of a reference to a 3GPP document (including a GSM document), > a non-specific reference implicitly refers to the latest version > of that document _in the same Release as the present document_.
[1] 3GPP TS 26.267: \"eCall Data Transfer; In-band modem solution; General
description\".
See also the references in 3GPP TS 26.267 [1].
# 3 Abbreviations
For the purpose of the present document, the following abbreviations apply:
ACK Acknowledgement
ANSI American National Standards Institute
CRC Cyclic Redundancy Check
FEC Forward Error Correction
GSM Global System for Mobile communications
HARQ Hybrid Automatic Repeat-reQuest
I/O Input/Output
IVS In-Vehicle System
MSD Minimum Set of Data
NACK Negative Acknowledgement
PCM Pulse Code Modulation
PSAP Public Safety Answering Point
RAM Random Access Memory
ROM Read Only Memory
RX Receive
TX Transmit
# 4 C code structure
This clause gives an overview of the structure of the bit‑exact C code and
provides an overview of the contents and organization of the C code attached
to the present document.
The C code has been verified on the following systems:
  * Windows XP SP2 and Microsoft Visual Studio V8.0;
  * Linux (Suse Linux) using the gcc v3.4.2 and v4.1.2 compilers.
## 4.1 Contents of the C source code
The distributed files with suffix \"c\" contain the source code and the files
with suffix \"h\" are the header files.
Further explanation on the files is given in the Readme.txt file, which is
reproduced in part here:
Package Contents
\----------------
folder \'ecall\':
Contains the complete eCall ANSI C fixed-point reference source code.
modem_ivs.c : top-level modem implementation for IVS
modem_psap.c : top-level modem implementation for PSAP
modemx.h : header file for both modem_ivs.c and modem_psap.c
ecall_defines.h : compile time options and preprocessor constants
ecall_control.h : header file control message handling
ecall_fec.h : header file FEC encoder and decoder
ecall_modem.h : header file modulator and demodulator
ecall_sync.h : header file synchronization
ecall_rom.h : header file ROM data
ecall_control.c : control message handling
ecall_fec.c : FEC encoder and decoder
ecall_modem.c : modulator and demodulator
ecall_sync.c : synchronization
ecall_rom.c : ROM data
folder \'test_setup\':
Contains the eCall software simulation framework, to be compiled
and run on MS Windows systems.
folder \'test_vec\':
Contains binary PCM data (104 files) and receiver/transmitter port logs
in ASCII format (104 files) to test the eCall IVS and PSAP modems.
The PCM format is 16 bit signed, little endian, at 8 kHz sampling rate.
The data files reflect 26 test cases and were generated from the eCall
simulation framework.
campaign_short.txt : configuration file for the 26 test cases
pcmdlout\.pcm : output PCM data of DL vocoder = input to IVS
pcmulout\.pcm : output PCM data of UL vocoder = input to PSAP
pcmdlin\.pcm : test vectors for PSAP modem output
pcmulin\.pcm : test vectors for IVS modem output
portivsrx\.txt : test vectors for IVS port logs (receiver)
portivstx\.txt : test vectors for IVS port logs (transmitter)
portpsaprx\.txt : test vectors for PSAP port logs (receiver)
portpsaptx\.txt : test vectors for PSAP port logs (transmitter)
standalone.c
main() wrapper to run the IVS or PSAP modem on prestored PCM files or
receiver/transmitter port logs. To get a list of command-line options,
invoke the corresponding executable with option \'-h\' (help).
standalone.h
header file for standalone.c
Makefile.win
NMAKE Makefile for Microsoft Visual Studio 2005 and above:
Builds \'standalone.exe\' from standalone.c and the eCall sources,
build options are RELEASE and DEBUG.
Makefile.glx
GNU Linux Makefile using gcc
Builds \'standalone\' from standalone.c and the eCall sources,
build options are RELEASE and DEBUG.
verify.bat
Windows batch file
Runs \'standalone.exe\' in six different modem modes on the 26 test cases
contained in folder \'test_vec\' and performs a test vector comparison to
the respective output PCM and port log data.
verify.sh
Linux shell script
Runs \'standalone\' in mode \'-m ivs\' and \'-m psap\' on 26 test cases
(folder \'pcm\') and performs a test vector comparison to the respective
modem output PCM data.
## 4.2 Program execution
An explanation on code compilation and execution is given in the readme.txt
file, which is reproduced in part here:
Getting Started
\---------------
3GPP TS 26.268 provides the eCall modem source code, a software simulation
framework, and a standalone wrapper that allows to run the IVS or PSAP modem
on prestored reference data.
The following functions represent the eCall modem interface and invoke the
respective receiver and transmitter implementation of each modem:
* void IvsReset(const Ord8 *msd, int length);
* void IvsProcess(Int16 *pcm);
* void IvsSendStart(void);
* void PsapReset(void);
* void PsapProcess(Int16 *pcm);
* void PsapSendStart(void);
* void PsapSendHlack(const Ord8 data);
The external application must in addition implement the callback functions:
* void IvsCatchEvent(IvsEvent ie);
* void IvsReceiveAck(void);
* void IvsReceiveHlack(const Ord8 data);
* void PsapCatchEvent(PsapEvent pe);
* void PsapReceiveMsd(const Ord8 *msd, int length);
* void Abort(const char *format, ...);
* void LogInfo(const char *format, ...);
IvsCatchEvent and PsapCatchEvent inform about relevant modem events and can
be used to perform actions such as muting or unmuting of the voice channel.
The other callback functions indicate...
* IvsReceiveAck : reception of the lower-layer ACK,
* IvsReceiveHlack : reception of the HLACK message,
* PsapReceiveMsd : successful MSD reception.
Abort and LogInfo should implement a variadic error and printlog handler,
respectively. See standalone.c for sample implementations of all callback
functions.
For a real-time simulation over 3GPP FR and AMR vocoders and to log PCM data
as input to the standalone wrapper, the eCall sources have to be integrated
into a simulation framework; folder \'test_setup\' contains the one as used in
the 3GPP selection tests.
In order to compile and run the eCall modem code, follow the instructions
given below. For code testing, two batch files have been provided:
* verify.bat : MS Windows systems
* verify.sh : Linux systems
For each of the 26 test cases of campaign_short.txt in folder \'test_vec\',
they run the standalone wrapper in six different modem modes (three IVS and
three PSAP modes). The resulting PCM and port log files in folder \'out\' are
finally compared to the test vectors in folder \'test_vec\'.
In modes \'psap\' and \'psaprx\', you should see an MSD success message at the
end of each test case.
Code Compilation
\----------------
MS Windows systems
Compilation assumes an installation of MS Visual Studio 2005 or above.
To set the environment variables for building, run \'vcvars32.bat\' which
should be contained in the \'bin\' subfolder of your VC installation.
To build standalone.exe from standalone.c and the eCall sources (or to
perform cleanup), run
nmake /f Makefile.win
nmake /f Makefile.win clean
The source code should compile without any errors or warnings.
Run \'verify.bat\' to verify the executable against the test vectors.
GNU Linux systems
Compilation under Linux has been tested with
* GNU Make version 3.81
* gcc version 4.1.3 and 4.2.4
For building the executable \'standalone\' and cleanup, use
make -f Makefile.glx
make -f Makefile.glx clean
On the platforms tested, the code compiled without errors or warnings.
Run \'verify.sh\' to verify the executable against the test vectors.
Simulation Framework
\--------------------
The eCall software simulation framework is provided in folder \'test_setup\'.
Important remarks:
* See LICENSE.TXT and README.TXT for terms of usage!
* The G.711 software is part of ITU-T Rec. G.191, (C) ITU 2000.
Distributed with the authorization of ITU as part of the test setup
software for 3GPP TS 26.268.
* The framework must be compiled and run on MS Windows systems, as the
FR and AMR vocoders are attached to it in form of Windows executables
and via Windows specific API functions.
To build (or clean) the framework together with the eCall IVS and PSAP,
change to subfolder \'c\' of \'test_setup\' and run (remember
\'vcvars32.bat\')
nmake /f makefile_ecall
nmake /f makefile_ecall clean
The framework has the five callback functions of above already implemented.
By default, the binaries (*.exe *.lib) are generated in the \'bin\' subfolder.
You can use the following two batch files to run the executables:
demosim.bat : runs testsim_demo.exe
demosock.bat : runs testlab.exe and modem_demo.exe in socket mode
## 4.3 Variables, constants and tables
### 4.3.1 Description of constants used in the C-code
This clause contains a listing of all global constants defined in
ecall_defines.h., together with some explanatory comments.
**Constant Value Description**
#define MAX(a,b) ((a)>(b) ? (a) : (b))
#define MIN(a,b) ((a)\ MSD to be transmitted */
/* int length -> MSD length (equal to MSD_MAX_LENGTH) */
/*----------------------------------------------------------------------------*/
void IvsReset(const Ord8 *msd, int length)
void IvsRxReset(void)
void IvsTxReset(const Ord8 *msd, int length)
/*============================================================================*/
/* IVS implementation: IvsProcess */
/*----------------------------------------------------------------------------*/
/* Description: IVS modem function that processes the PCM data */
/* */
/* InOut: Int16* pcm \ input and output frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void IvsProcess(Int16 *pcm)
void IvsRxProcess(const Int16 *pcm)
void IvsTxProcess(Int16 *pcm)
/*============================================================================*/
/* IVS implementation: IvsSendStart */
/*----------------------------------------------------------------------------*/
/* Description: Initiates IVS to trigger the transmission of SEND messages */
/*----------------------------------------------------------------------------*/
void IvsSendStart(void);
/*============================================================================*/
/* IVS implementation: IvsReceiveAck */
/*----------------------------------------------------------------------------*/
/* Description: callback function indicating a received ACK message */
/*----------------------------------------------------------------------------*/
void IvsReceiveAck(void);
/*============================================================================*/
/* IVS implementation: IvsReceiveHlack */
/*----------------------------------------------------------------------------*/
/* Description: callback function indicating a received higher layer messages
*/
/* */
/* In: const Ord8 data -> data symbol identifierer */
/*----------------------------------------------------------------------------*/
void IvsReceiveHlack(const Ord8 data);
/*============================================================================*/
/* PSAP implementation: PsapSendStart */
/*----------------------------------------------------------------------------*/
/* Description: Initiates PSAP to trigger the transmission of an MSD */
/*----------------------------------------------------------------------------*/
void PsapSendStart(void)
/*============================================================================*/
/* PSAP implementation: PsapSendHlack */
/*----------------------------------------------------------------------------*/
/* Description: Initiates PSAP to send the higher layer messages */
/* */
/* In: const Ord8 data -> data symbol identifierer */
/*----------------------------------------------------------------------------*/
void PsapSendHlack(const Ord8 data);
/*============================================================================*/
/* PSAP implementation: PsapReset */
/*----------------------------------------------------------------------------*/
/* Description: Reset of PSAP before the reception of a new MSD */
/*----------------------------------------------------------------------------*/
void PsapReset(void)
void PsapRxReset(void)
void PsapTxReset(void)
/*============================================================================*/
/* PSAP implementation: PsapProcess */
/*----------------------------------------------------------------------------*/
/* Description: PSAP modem function that processes the PCM data */
/* */
/* InOut: Int16* pcm \ input and output frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void PsapProcess(Int16 *pcm)
void PsapRxProcess(const Int16 *pcm)
void PsapTxProcess(Int16 *pcm)
### 4.4.2 IVS transmitter functions
/*============================================================================*/
/* IVS FUNCTION: IvsTransmitter */
/*----------------------------------------------------------------------------*/
/* Description: IVS transmitter function */
/* */
/* In: const ModState* ms -> modulator struct */
/* const Ord1* buffer -> code bit buffer */
/* Int16 rv -> redundancy version */
/* Int16 index -> position within uplink frame */
/* Out: Int16* pcm \ new control message symbol */
/* Int16 metric -> receiver metric (-1: ignore symbol) */
/* Bool syncLock -> indicates sync lock of control receiver */
/*----------------------------------------------------------------------------*/
void IvsTxState(Int16 msg, Int16 metric, Bool syncLock)
/*============================================================================*/
/* IVS FUNCTION: SymbolMod */
/*----------------------------------------------------------------------------*/
/* Description: symbol modulator */
/* */
/* In: const ModState* ms -> modulator struct */
/* Int16 symbol -> symbol index */
/* Out: Int16* mPulse \ vector of input bytes */
/* Int16 length -> length of input */
/* Out: Ord1* out \ takes info bits and returns coded bits */
/*----------------------------------------------------------------------------*/
void FecEncode(Ord1 *buffer)
/*============================================================================*/
/* ENCODER FUNCTION: AttachCrc */
/*----------------------------------------------------------------------------*/
/* Description: attaches CRC bits */
/* */
/* In: const Ord1* infoBits -> input information bits */
/* Out: Ord1* infoWithCrc \ non scrambled input bit sequence */
/* Out: Ord1* out \ scrambled bits to coded bits */
/*----------------------------------------------------------------------------*/
void EncodeTwo(Ord1 *codedBits)
/*============================================================================*/
/* ENCODER FUNCTION: EncodeOne */
/*----------------------------------------------------------------------------*/
/* Description: convolutional encoding of each component */
/* */
/* In: Int16 encNr -> component number */
/* InOut: Ord1* codedBits \ bits to be encoded */
/*----------------------------------------------------------------------------*/
void EncodeOne(Ord1 *codedBits, Int16 encNr)
### 4.4.3 PSAP receiver functions
/*============================================================================*/
/* UTILITY FUNCTION: PsapRxUplink */
/*----------------------------------------------------------------------------*/
/* Description: PSAP UL state machine, determines PSAP receiver operation */
/* according to the state */
/* */
/* In: const Int16* pcm -> input frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void PsapRxUplink(const Int16 *pcm)
/*============================================================================*/
/* UTILITY FUNCTION: PsapRxDownlink */
/*----------------------------------------------------------------------------*/
/* Description: PSAP DL state machine, determines PSAP transmitter operation
*/
/* according to the state */
/*----------------------------------------------------------------------------*/
void PsapRxDownlink(void)
/*============================================================================*/
/* PSAP FUNCTION: PsapReceiver */
/*----------------------------------------------------------------------------*/
/* Description: PSAP receiver function (decoding is done outside) */
/* */
/* In: const ModState* ms -> modulator struct */
/* const Int16* pcm -> input data for demodulation */
/* Out: IntLLR* softBits \ modulator struct */
/* const Int16* mPulse -> received pulse train */
/* Out: IntLLR* softBits \ vector of input bits */
/* Int16 length -> length of output */
/* Out: Ord8* out \ 32bit number */
/* Int16 var16 -> 16bit number */
/* Return: Int32 \ received soft bits */
/* Int16 rv -> redundancy version */
/* Out: Ord1* out \ received soft bits */
/* Int16 rv -> redundancy version */
/* InOut: IntLLR* chLLRbuffer \ decoder buffer */
/*----------------------------------------------------------------------------*/
void UpdateBuffer(IntLLR *chLLRbuffer, const IntLLR *softInBits, Int16 rv)
/*============================================================================*/
/* DECODER FUNCTION: DecodeBuffer */
/*----------------------------------------------------------------------------*/
/* Description: decoding of LLR buffer */
/* */
/* In: const IntLLR* syst1 -> RX systematic soft bits */
/* const IntLLR* syst2 -> interleaved RX systematic tail bits */
/* const IntLLR* parity1 -> RX parity soft bits */
/* const IntLLR* parity2 -> interleaved RX parity soft bits */
/* Out: Ord1* decBits \ received parity soft bits */
/* InOut: IntLLR* extrinsic \ extrinsic information */
/*----------------------------------------------------------------------------*/
void Bcjr(const IntLLR *parity, IntLLR *extrinsic)
/*============================================================================*/
/* DECODER FUNCTION: Interleave */
/*----------------------------------------------------------------------------*/
/* Description: Turbo code interleaver */
/* */
/* In: const IntLLR* in -> input sequence */
/* Out: IntLLR* out \ input and deinterleaved output sequence */
/*----------------------------------------------------------------------------*/
void Deinterleave(IntLLR *inout)
/*============================================================================*/
/* DECODER FUNCTION: Descramble */
/*----------------------------------------------------------------------------*/
/* Description: descrambles decoded bits */
/* */
/* InOut: Ord1* inout \ input and output bit sequence */
/*----------------------------------------------------------------------------*/
void Descramble(Ord1 *inout)
/*============================================================================*/
/* DECODER FUNCTION: DecodeCrc */
/*----------------------------------------------------------------------------*/
/* Description: check CRC of decoded bits */
/* */
/* In: const Ord1* codedBits -> decoded bit sequence to be checked */
/* Return: Bool \ bit position */
/* Int16 l -> state */
/* const IntLLR* parity -> received parity bits */
/* const IntLLR* extrinsic -> sum of extrinsic and systematic bits */
/* Return: IntLLR \ value one */
/* IntLLR b -> value two */
/* Return: IntLLR \ sync struct */
/* In: const Int16* pcm -> input frame */
/* const char* caller -> modem identification */
/* Bool invert -> port inversion flag */
/*----------------------------------------------------------------------------*/
void Sync(SyncState *sync, const Int16 *pcm, const char *caller, Bool invert)
/*============================================================================*/
/* UTILITY FUNCTION: CtrlSync */
/*----------------------------------------------------------------------------*/
/* Description: control message sync function */
/* */
/* InOut: CtrlRxData* control \ control struct */
/* In: const Int16* pcm -> input frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void CtrlSync(CtrlRxData *control, const Int16 *pcm)
/*============================================================================*/
/* UTILITY FUNCTION: SyncSubPut, SyncSubGet, SyncSubCpy */
/*----------------------------------------------------------------------------*/
/* InOut: SyncState* sync \ sync struct */
/* InOut: SyncSub* ssub \ sync subsystem */
/*----------------------------------------------------------------------------*/
void SyncSubPut(SyncState *sync, SyncSub *ssub)
void SyncSubGet(SyncState *sync, SyncSub *ssub)
void SyncSubCpy(const SyncSub *ssubIn, SyncSub *ssubOut)
/*============================================================================*/
/* UTILITY FUNCTION: SyncSubRun */
/*----------------------------------------------------------------------------*/
/* Description: sync peak evaluation */
/* */
/* InOut: SyncSub* ssub \ sync subsystem */
/* In: const char* caller -> modem identification */
/* const Int32* pPos -> positive peaks positions */
/* const Int32* pCorr -> positive peaks correlation values */
/* const Int32* nPos -> negative peaks positions */
/* const Int32* nCorr -> negative peaks correlation values */
/*----------------------------------------------------------------------------*/
void SyncSubRun(SyncSub *ssub, const char *caller,
const Int32 *pPos, const Int32 *pCorr,
const Int32 *nPos, const Int32 *nCorr)
/*============================================================================*/
/* IVS FUNCTION: SyncCheck */
/*----------------------------------------------------------------------------*/
/* Description: check whether locked sync is still valid */
/* */
/* InOut: SyncState* sync \ sync struct */
/* In: const Int16* pcm -> input frame */
/* const char* caller -> modem identification */
/*----------------------------------------------------------------------------*/
void SyncCheck(SyncState *sync, const Int16 *pcm, const char *caller)
/*============================================================================*/
/* IVS FUNCTION: SyncTrack */
/*----------------------------------------------------------------------------*/
/* Description: uplink sync tracker */
/* */
/* InOut: SyncState* sync \ sync struct */
/* In: Bool invert -> port inversion flag */
/*----------------------------------------------------------------------------*/
void SyncTrack(SyncState *sync, Bool invert)
/*============================================================================*/
/* FUNCTION: SyncFilter */
/*----------------------------------------------------------------------------*/
/* Description: sync filter implementation */
/* */
/* InOut: SyncState* sync \ sync struct */
/* In: const Int16* pcm -> input frame */
/* Bool invert -> port inversion flag */
/*----------------------------------------------------------------------------*/
void SyncFilter(SyncState *sync, const Int16 *pcm, Bool invert)
/*============================================================================*/
/* UTILITY FUNCTION: ToneDetect */
/*----------------------------------------------------------------------------*/
/* Description: tone detection at 500 Hz or 800 Hz */
/* */
/* InOut: SyncState* sync \ sync struct */
/* In: const Int16* pcm -> input frame */
/*----------------------------------------------------------------------------*/
void ToneDetect(SyncState *sync, const Int16 *pcm)
/*============================================================================*/
/* UTILITY FUNCTION: PeakUpdate */
/*----------------------------------------------------------------------------*/
/* Description: update sync peak position */
/* */
/* In: const Int32* pos -> vector of positions */
/* const Int32* corr -> vector of correlation values */
/* Int16 dist -> distance to be checked */
/* Return: Int16 \ sync subsystem */
/* In: const char* caller -> modem identification */
/* const Bool* pdet -> vector of peak detection flags */
/* const Int16* p -> vector of frame numbers */
/* const Int32* corr(X) -> vector of correlation values */
/* Int16 pos1 -> peak position 1 */
/* Int16 pos2 -> peak position 2 */
/* Int16 npeaks -> number of detected peaks */
/* Int16 delay -> target delay if sync successful */
/*----------------------------------------------------------------------------*/
void PeakCheck(SyncSub *ssub,
const char *caller, const Bool *pdet, const Int16 *p,
const Int32 *corrP, const Int32 *corrN, const Int32 *corr,
Int16 pos1, Int16 pos2, Int16 npeaks, Int16 delay)
/*============================================================================*/
/* UTILITY FUNCTION: SyncSubChk */
/*----------------------------------------------------------------------------*/
/* Description: sync peak evaluation for sync check */
/* */
/* InOut: SyncSub* ssub \ sync subsystem */
/* In: const char* caller -> modem identification */
/* const Int32* posP -> positive peaks positions */
/* const Int32* corrP -> positive peaks correlation values */
/* const Int32* posN -> negative peaks positions */
/* const Int32* corrN -> negative peaks correlation values */
/* Int16 delay -> reference delay */
/*----------------------------------------------------------------------------*/
void SyncSubChk(SyncSub *ssub, const char *caller,
const Int32 *posP, const Int32 *corrP,
const Int32 *posN, const Int32 *corrN, Int16 delay)
/*============================================================================*/
/* UTILITY FUNCTION: SyncReset */
/*----------------------------------------------------------------------------*/
/* InOut: SyncState* sync \ sync struct */
/* In: Int32* mem -> pointer to sync memory */
/* Int32* memWakeup -> pointer to sync wakeup memory */
/*----------------------------------------------------------------------------*/
void SyncReset(SyncState *sync, Int32 *mem, Int32 *memWakeup)
/*============================================================================*/
/* UTILITY FUNCTION: SyncSubReset */
/*----------------------------------------------------------------------------*/
/* InOut: SyncSub* ssub \ sync subsystem */
/*----------------------------------------------------------------------------*/
void SyncSubReset(SyncSub *ssub)
### 4.4.7 Control link functions
/*============================================================================*/
/* UTILITY FUNCTION: CtrlPortName */
/*----------------------------------------------------------------------------*/
/* Description: converter for log output */
/* */
/* In: PortOwner owner -> modem identification */
/* Return: const char* \ control struct */
/* Int16* pcm \ frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void CtrlTxProcess(CtrlTxData *control, Int16 *pcm)
/*============================================================================*/
/* UTILITY FUNCTION: CtrlTxMod */
/*----------------------------------------------------------------------------*/
/* Description: control message transmitter using prestored sequences */
/* */
/* In: Int16 symbol -> lower-layer or higher-layer message symbol */
/* Int16 index -> position within message frame */
/* Out: Int16* pcm \ control struct */
/* In: const Int16* pcm -> input frame of 16bit PCM samples */
/*----------------------------------------------------------------------------*/
void CtrlRxProcess(CtrlRxData *control, const Int16 *pcm)
/*============================================================================*/
/* UTILITY FUNCTION: CtrlRxDemod */
/*----------------------------------------------------------------------------*/
/* Description: control message receiver */
/* */
/* In: const Int16* pcm -> input PCM buffer */
/* Out: Int16* metric \ control struct */
/* In: const char* owner -> modem identification */
/*----------------------------------------------------------------------------*/
void CtrlTxReset(CtrlTxData *control, const char *owner)
/*============================================================================*/
/* CONTROL FUNCTION: CtrlRxReset */
/*----------------------------------------------------------------------------*/
/* Description: reset function control receiver */
/* */
/* InOut: CtrlRxData* control \ control struct */
/* In: const char* owner -> modem identification */
/* SyncState* sync -> pointer to sync struct */
/* Int16* buffer -> pointer to control receiver buffer */
/* Int16 syncLock -> number of sync events required */
/*----------------------------------------------------------------------------*/
void CtrlRxReset(CtrlRxData *control, const char *owner,
SyncState *sync, Int16 *buffer, Int16 syncLock)
### 4.4.8 Other utility functions (IVS and PSAP)
/*============================================================================*/
/* UTILITY FUNCTION: SetModState */
/*----------------------------------------------------------------------------*/
/* Description: set the modulator state */
/* */
/* In: Int16 modType -> type of modulator to use */
/* InOut: ModState* ms \ modulator struct */
/*----------------------------------------------------------------------------*/
void SetModState(ModState *ms, ModType modType)
#
# Foreword
This Technical Report has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
At the 3GPP TSG RAN#75 meeting, the Study Item Description on \"Study on UL
data compression in LTE\" has been approved RP-162541[2]. This study item
covers evaluation of the data compression schemes to improve uplink capacity
in E-UTRA.
# 1 Scope
The present document is related to the study item \"Study on UL data
compression in LTE\" [2]. This Technical Report constitutes performance
evaluation of potential data compression schemes to support increased uplink
capacity for E-UTRA.
This document captures descriptions related to the evaluation methodology used
technical outcomes of the study, analysis of potential UL data compression
solutions and a conclusion on the way forward.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or nonâ€‘specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TSG-RAN RP-162541: \"New SI proposal: Study on UL data compression in
LTE\", RAN#74, June.2016.
[3] IETF RFC 3095, \"RObust Header Compression (ROHC): Framework and four
profiles: RTP, UDP, ESP and uncompressed\".
[4] IETF RFC 1950, \"ZLIB Compressed Data Format Specification version 3.3\".
[5] IETF RFC 1951,\"DEFLATE Compressed Data Format Specification version 1.3\"
[6] Usage of HTTP/2 for websites,  _World Wide Web Technology Surveys_.
W3Techs. Dec 2, 2016.
[7] https://www.google.com/transparencyreport/https/metrics/?hl=en#contry
[8] 3GPP TSG-RAN WG2 Meeting #99 R2-1709024: \"APDC compressor source code\",
ftp://ftp.3gpp.org/tsg_ran/WG2_RL2/TSGR2_99/Docs/R2-1709024.zip, Qualcomm
Incorporated, August 2017.
[9] 3GPP TSG-RAN WG2 Meeting #98 R2-1705615: \"Details on APDC decompression
algorithm\", ftp://ftp.3gpp.org/tsg_ran/WG2_RL2/TSGR2_98/Docs/R2-1705615.zip,
Qualcomm Incorporated, May 2017.
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
TR 21.905 [1] and the following apply.\ A term defined in the present document
takes precedence over the definition of the same term, if any, in TR 21.905
[1].
Compression efficiency 1 -- (output compressed data size / input uncompressed
data size)
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in TR 21.905
[1] and the following apply.\ An abbreviation defined in the present document
takes precedence over the definition of the same abbreviation, if any, in TR
21.905 [1].
UDC Uplink Data Compression
APDC Adaptive Packet Data Compression
# 4 Requirements on UL data compression
The shortage of uplink resource becomes a concern in the network due to the
following factors:
\- More and more mobile internet users are becoming content producers.
\- Increasing of downlink traffic when using CA leads to more uplink traffic.
However UE operates with few uplink carriers, typically only one. This is to
satisfy requirements on UE battery consumption and reduce UE complexity.
\- Typical UL/DL configuration in TD-LTE network is configuration 2, i.e. 3DL:
1UL. It is quite often that uplink becomes bottleneck in case of, e.g. file
uploading.
Thus uplink capacity improvement is becoming an urgent requirement to address
the increase amount of UL traffic in the network. Another concern on uplink is
transmission vulnerability to poor radio condition.
\- As the number of LTE subscribers increases, the uplink interference level
reaches 5\~10 dB in a typical network, making uplink transportation in poor
radio condition difficult.
\- Due to power limitation, RLC segmentation is a common way to extend uplink
coverage. However, it is not a preferred solution in some cases, e.g. VoLTE
call setup where long call setup latency is an issue.
\- Size of SIP message used in VoLTE call setup is about 2KB. When UE is in
poor radio condition (e.g. RSRP \ For fair comparison of different UDC solutions, the solutions are to be
> evaluated using a common traffic profile. Traffic traces where data traffic
> captured from live systems are expected to be used in the evaluation.
> Traffic generated based on synthetic models or statistical models are not
> used. The data file format is ".pcap" which only includes UL packets (DL
> packets are removed).
Evaluation model
> The aim of the simulation is to evaluate the compression algorithms in terms
> of compression efficiency, impacts to the existing protocol and
> specification efforts. Thus detail channel model and radio channel
> simulation are not seen essential for the evaluation of compression
> algorithms. To emulate the unreliability of radio channel and data loss if
> considered necessary, a suitable simplified radio channel based on packet
> loss rate and random packet discard to be used.
>
> A simplified evaluation model without packet loss rate is considered and
> scenarios with packet loss rate are considered with low priority.
Protocol unit
> UL data compression algorithm is considered to be located in PDCP layer in
> the evaluation.
## 6.2 Simulation Assumptions
\- UDC aims to design a compression solution for the UL user plane (DRB) data
received from higher layer, e.g. HTTP data, SIP signalling, TCP ACK for DL
traffic, etc. Therefore, only User Plane (DRB) data is considered in
simulation of different UDC solutions.
\- The amount of buffered data which are used in compressing current packet
could have an effect on the achieved compression ratio. For the simulation and
comparison of different solutions 8K and 32K buffer size are considered, and
64K can be optionally selected.
\- RLC-AM is considered in UDC evaluation.
\- UL data compression is applied for both header and payload in evaluation of
different solutions.
\- The case of combination of UDC and RoHC on the same DRB is not evaluated.
\- UDC solutions should be agnostic to packet header format.
## 6.3 Performance Metrics
The aim of UDC study is to identify compression algorithms and/or compressed
data formats which could be used in RAN to fulfil the objectives of UDC (e.g.
controllability of UDC on service basis by operator). The following Figure
illustrates a block diagram of UDC operation. The UDC entity processes the
input data and generates the output compressed data.
Figure 6.3-1: Block diagram of UDC operation
Compression efficiency as per the following formulation is considered for
performance metric in evaluation of different UL data compression solutions.
Compression efficiency = 1 -- (output data size / input data size)
High computation complexity of compression algorithm degrades usefulness of
UDC even if the resulted compression efficiency is significant. Additionally,
required memory for compression/ decompression also has impacts on the overall
performance of UL data compression algorithms. Therefore, not only the
compression efficiency but also processing complexity of compressor/ de-
compressor and memory requirements are agreed as the criteria for performance
evaluation. Even though it may not be possible to quantify the processing
complexity, qualitative analysis of complexity is expected in the performance
evaluation. In addition, the evaluation criteria of a compression solution
shall take into account the byte alignment and reliability.
# 7 UL data compression solutions
## 7.1 Existing data compression methods and encryption trend
Compression is commonly used when storing and transmitting data and several
applications exist in different layers of the network, as illustrated in
Figure 7.1-1. Application layer file formats, such as MPEG-4 and JPEG use
compression in generating encoded outputs.
{width="6.690277777777778in" height="3.5694444444444446in"}
Figure 7.1-1: OSI/RAN Level architecture and location of existing algorithms
Application layer compression algorithms have been standardized in IETF and
3GPP SA4. Such application layer algorithms include:
\- HTTP-2 is an updated version of HTTP. An advantage of HTTP-2 over previous
HTTP version is that it decreases latency to improve page load speed in web
browsers by considering data compression of HTTP headers.
\- QUIC (Quick UDP Internet Connections) aims to provide faster and
secured/encrypted web browsing experience.
\- SigComp is a solution for compressing messages generated by application
protocols with primary driver to compress SIP message.
In addition, Data Compression Proxies can provide data compression.
The UDC gain depends on whether the data is encrypted and/or compressed by the
application layer. HTTP-2 is known to perform encryption of HTTP payload and
compression of HTTP header. But it should be considered that some of popular
websites still use HTTP protocol like HTTP or HTTP-1.1.The web technology
report [6] shows that 14.2 % of all the website use HTTP-2 (on 23^th^ May
2017). This means that most of the websites are currently using legacy HTTP
protocol. It is also shown in [6] that HTTP-2 is gaining popularity.
### 7.1.2 Traffic Encryption Trend
Figure 7.1.2-1 illustrates the encrypted traffic trend based on google
transparency report [7]. While Figure 7.1.2-1 (a) shows the percentage of
pages loaded over HTTPS per operating system Figure 7.1.2-1 (b) shows the
regional distribution of the usage of HTTPS. The frequency of HTTPS is higher
when using Chrome OS and least when using Android however both follow an
increasing trend of usage of.The statistics are taken from 9 countries. Note
that China is not among the listed countries. The usage of HTTPS is increasing
and is above 50 % in the middle of April 2017 for the listed countries except
for Japan where the ratio of encrypted traffic is lower and is around 35 % in
the middle of April 2017.
{width="6.534027777777778in" height="2.095138888888889in"}
(a) Percentage of pages loaded over HTTPS per operating system
{width="6.540972222222222in" height="1.613888888888889in"}
(b) Regional distribution of (a) slide 1
{width="6.461805555555555in" height="1.5347222222222223in"}
(c) Regional distribution of (a) slide 2 highlighting the USA trend
Figure 7.1.2-1: percentage of encrypted traffic as per google transparency
report [7]
## 7.2 Solutions for RAN level UL data compression
A number of different UL data compression solutions have been simulated with
the following input traffic scenarios. These traffic profiles are generated
with neither application layer compression nor application layer encryption.
Table 7.2-1: Traffic profiles
* * *
PCAP File # PCAP File Name Note 1 FTP data-CMCC(UL-client)  
2 FTP data-CMCC(UL-server)  
3 SIP signalling-CMCC 01(UL)  
4 SIP signalling-CMCC 02(UL)  
5 SIP signalling-CMCC 03(UL)  
6 Video data-CMCC(UL) duration: \~6s 7 web surfing-CMCC(UL)  
8 long period Video data-CMCC(UL) duration: \~6min 9 Video data-MTK duration:
\~1hr 10 Long period ftp-MTK  
11 Multiple IP flows-Qualcomm
* * *
### 7.2.1 Solution 1: UL RoHC
#### 7.2.1.1 Solution description
RoHC (Robust Header Compression) is a method to compress the IP, UDP, RTP and
TCP headers of internet traffic [3]. Several compression profiles are
available, including e.g. IP-only, IP/UDP and IP/TCP. In Rel-14, uplink-only
RoHC operation was introduced (UL RoHC for short). For UL RoHC, profile 0x0006
has been standardized (the usage is TCP/IP). UL RoHC implies compression is
applied only in UL and compression is disabled in the downlink. The payload of
the packets is not targeted for compression. The RoHC protocol exploits
redundancies in the headers, so that redundant information is only transmitted
in the first packet. The following packets contain only dynamic information,
such as identifiers and sequence numbers. To enhance performance, the packets
are classified into different streams which are compressed according to the
best fitting compression profile available.
The RoHC algorithm can operate in several different modes and states. The
modes define if there is a reliable feedback link or not, while the states
define the level of compression performed by the algorithm. In the
Initialization and Refresh (IR), packet headers are sent uncompressed and are
used when the compressor has just been created or has been reset. In First
(FO) and Second (SO) order states compression is performed in a way that
reflects an increasing level of confidence about the correctness of the
information available in the decompression side. The RoHC implementation
should strive to get the compressor into SO state, where the highest
compression efficiency is achieved, but the ROHC compressor will typically
transit between states depending on the variability of the header to compress,
decompression errors, or if there for other reasons is a need to refresh the
decompression context.
#### 7.2.1.2 Simulation results
Table 7.2.1.2-1 shows the simulation results. It can be found that UL RoHC-
based method provides good compression efficiency in FTP and long video data
scenarios. In long video data scenario, most of the uplink packets are for TCP
ACKs, which makes UL-only RoHC highly efficient. Note that the simulation
results consider the overhead from the RoHC headers.
Table 7.2.1.2-1: Compression efficiency for UL RoHC
* * *
Input file UL RoHC Ratio of TCP/IP headers  
Input traffic1: FTP data-client-CMCC 73.3% 90.8%  
Input traffic2: FTP data-server-CMCC 59.7% 73.4%  
Input traffic 3: SIP signalling-CMCC #01 5.4% 7.5% Input traffic4: SIP
signalling-CMCC #02 5.1% 7.1% Input traffic5: SIP signalling-CMCC #03 4.4%
6.2% Input traffic6: Video data-CMCC (duration: \~6s) 21.7% 29.1%  
Input traffic 7: Web surfing-CMCC 23.1% 31.3%  
Input traffic8: Long period Video data-CMCC (duration: \~6min) 45.1% 58.1%  
Input traffic9: Video data-MTK (duration: \~1hr) 80.7% 95.9%  
Input traffic 10: Long period ftp-MTK 83.4% 99.96%  
Input traffic 8 + 10: 39.3%
* * *
### 7.2.2 Solution 2: UDC solution based on RFC 1950: Zlib-based
#### 7.2.2.1 Solution description
The concept of Zlib-based UDC is shown in Figure 7.2.2.1-1 below. To perform
cross-packet checking to find repeated pattern, each source packet is stored
in the configurable buffer after being compressed. And, the compressed data
format for Zlib [4] is given in Figure 7.2.2.1-2. The definitions of Zlib
headers are:
CMF: compression window length
FLG: flag to indicate if preset dictionary is applied
DICTID: preset dictionary ID
Note that, pre-defined dictionary is not used in this evaluation. For the
detail descriptions of Zlib algorithm and compressed data format can be found
in [4].
Figure 7.2.2.1-1: Illustrative compression flow with Zlib
{width="4.211805555555555in" height="0.4638888888888889in"}
Figure 7.2.2.1-2: Zlib-based compressed data format
#### 7.2.2.2 Simulation results
Zlib v1.2.11 is used in this evaluation. The compressed packets are byte-
aligned, and ended with no tail-byte. The simulation results are shown in
Table 7.2.2.2-1. The results show that larger window size provides slightly
better compression efficiency though it is not significant. Input traffic 6 is
an exception, where 8Kbyte window size configuration is better than 32Kbyte
window size configuration. It is because the repeated pattern can be found by
short distance in the window. Larger window size configuration provides no
additional gain in terms of compression efficiency, but introduces longer
header length. Note that the simulation results consider all the overhead from
the UDC header as specified in Section 7.2.2.1.To carefully evaluate the
performances of Zlib, cross-checking was conducted using the same
configuration. Similar compression efficiency is achieved by different
companies.
Table 7.2.2.2-1: Compression efficiency for Zlib
* * *
Input file **Zlib-based UDC (8K)** **Zlib-based UDC (32K)**  
Input traffic 1: FTP data-client-CMCC **50.5%** **50.5%**  
Input traffic 2: FTP data-server-CMCC **45.1%** **45.1%**  
Input traffic 3: SIP signalling-CMCC #01 **86.7%** **88.1%** Input traffic 4:
SIP signalling-CMCC #02 **84.2%** **85.3%** Input traffic 5: SIP signalling-
CMCC #03 **87.2%** **88.5%** Input traffic 6: Video data-CMCC (duration: \~6s)
**65.1%** **65.1%**  
Input traffic 7: Web surfing-CMCC **66.3%** **70.1%**  
Input traffic 8: Long period Video data-CMCC (duration: \~6min) **72.9%**
**73.9%**  
Input traffic 9: Video data-MTK (duration: \~1hr) **60.7%** **59.1%**  
Input traffic 10: Long period ftp-MTK **63.6%** **60.0%**  
Input traffic 8 + 10: **65.6%** **67.4%**
* * *
### 7.2.3 Solution 3: UDC solution based on RFC 1951: DEFLATE- based
#### 7.2.3.1 Solution description
RFC 1951 (DEFLATE Compressed Data Format Specification) [5] is broadly used
with fewest overhead (e.g. compare to RFC 1950, reduced with header and tail
bytes.Deflate is a lossless data compression algorithm and associated file
format (specified in [5]) that uses a combination of the LZ77 algorithm and
Huffman coding.
LZ77 compression works by finding sequences of data that are repeated. A
sliding window is used to find the match characters in previous data. An
8K/32K sliding window means that the compressor (and de-compressor) has a
record of what the last 8192 or 32768 characters were. When the next sequence
of characters to be compressed is identical to one that can be found within
the sliding window, the sequence of characters is replaced by two numbers: a
"distance", representing how far back into the window the sequence starts, and
a "length", representing the number of characters for which the sequence is
identical. And then, the string pair (length, distance) is used to replace the
current matched characters. Lazy-match is considered in the simulation to
finding the longest matching part in the buffer. The un-matched characters are
noted as "literal".
(a) Before compression
(b) After compression
Figure 7.2.3.1-1: Illustration of data format before and after compression
using RFC 1951 (LZ77 compression)
In Figure 7.2.3.1-1, the buffer size is 8 bytes. When a new packet which has
content of "bcd" coming, a cross-packet match can be identify in the buffer,
with the previous position 6, length 3. The new packet which original length
is 3 byte can be compressed to 6 bits (i.e. 3 bits to identify 8 positions in
the buffer, and 3 bits for length). After compression, the new packet is
inserted in the buffer.
After compressed by LZ77, Huffman coding is used to encode the "literal",
"length" and "distance" by replacing frequently used codes with shorter
representations and infrequently used codes with longer representations.
Adaptive selection of static Huffman coding and dynamic Huffman coding is
enabled to achieve maximum compression efficiency in the simulation.
The Huffman codes used for each alphabet (e.g. literal/length alphabet and
distance alphabet) in the "deflate" format have two additional rules: 1) All
codes of a given bit-length have lexicographically consecutive values, in the
same order as the symbols they represent; 2) Shorter codes lexicographically
precede longer codes (details can be seen in RFC1951 [5]).
The Huffman codes for the two alphabets appear in the block immediately after
the header bits and before the actual compressed data, first the
literal/length code and then the distance code. Each code is defined by a
sequence of Huffman code lengths. For even higher compression ratio, the code
length sequences themselves are compressed using a Huffman code.
In our UDC solution, the following compression block format is used
respectively for static Huffman coding and dynamic Huffman coding.
Figure 7.2.3.1-2: Compression block by using static Huffman tree
{width="6.302777777777778in" height="1.7319444444444445in"}
Figure 7.2.3.1-3: Compression block by using dynamic Huffman tree
Where, dynamic/Static flag: indicating whether static Huffman or dynamic
Huffman is used
00- No compression
01 - Compressed with fixed Huffman codes
10 - Compressed with dynamic Huffman codes
11 - Reserved (error)
HLIT - Number of Literal/Length (257 - 286) codes minus 257
HDIST - Number of Distance codes (1 - 32) minus 1
HCLEN - Number of Code Length codes (4 - 19) minus 4
END - The literal/length symbol 256 (end of data)
LAST - Reserved, can be used to indicating whether this is the last block for
a file
**Proposed UDC format for Solution 3**
Checksum mechanism could be used to resolve synchronisation miss-match (if
any) between compression buffer and de-compression buffer. This means,
compressor calculate a checksum value by using the data in buffer, and the de-
compressor can validate the buffer content by the checksum value.
Additionally, multiple IP flow in one ratio bearer using various profile
should be considered when design UDC solution, where some data packet in the
bearer need to be compressed by UDC entity, while others need not. Thus
whether the current received packet is processed by UDC entity or not could be
included in the UDC header. Considering these two aspects, one byte UDC header
is introduced. Whether the current PDCP SDU is compressed/processed by UDC
entity is indicated by 1 bit in the UDC header, and 4\~6 bits allocated for
the checksum (note that the checksum is calculated by the data in buffer,
excluding the current packet).
Example UDC header format is shown in Figure 7.2.3.1-4. The detail of the UDC
header format can be further discussed in WI phase.
Figure 7.2.3.1-4: An example of UDC header format
The reserved bits can be used to indicate whether to reset the buffer and
whether to copy this packet data into the de-compression buffer. Thus could
assist to improve efficiency of compression/de-compressor buffer utilisation.
#### 7.2.3.2 Simulation results
The simulation results of RFC 1951 for 8Kbyte and 32Kbyte buffer are shown in
this section . To carefully evaluate the performances of solution 3, cross-
checking was conducted using the same configuration. The Deflate configuration
for the results in this subsection is: the _source library_ version is v1.2.8,
_compress level_ is Z_DEFAULT_COMPRESSION and Z_BEST_COMPRESSION, and the
_compress strategy_ is Z_DEFAULT_STRATEGY (adaptive Huffman coding). Note URL
of source code can be found in [5]. Similar compression efficiency is achieved
by different companies.
Table 7.2.3.2-1 shows the simulation results of RFC 1951 with adaptive Huffman
encoding and without UDC header.
Table 7.2.3.2-1: Simulation results with RFC 1951 (adaptive Huffman encoding
without 1 byte UDC header)
* * *
Input file **[8Kbyte buffer]{.underline}** **[32Kbyte buffer]{.underline}**  
Original Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression Efficiency Original
Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression Efficiency Input traffic 1: FTP
data-client-CMCC 1211 585 51.69% 1211 585 51.69% Input traffic 2: FTP data-
server-CMCC 1782 962 46.02% 1782 962 46.02% Input traffic 3: SIP signalling-
CMCC UE 1 51020 6639 86.99% 51020 5997 88.25% Input traffic 4: SIP signalling-
CMCC 32680 4921 84.94% 32680 4791 85.34% Input traffic 5: SIP signalling-CMCC
46688 5927 87.31% 46688 5313 88.62% Input traffic 6: Video data-CMCC
(duration: \~6s) 13450 4632 65.56% 13450 4633 65.55% Input traffic 7: Web
surfing-CMCC 2381720 786295 66.99% 2381720 689638 71.04% Input traffic 8: Long
period Video data-CMCC (duration: \~6min) 1371861 365346 73.37% 1371861 337360
75.41% Input traffic 9: Video data-MTK (duration: \~1hr) 2453749 950644 61.26%
2453749 983524 59.92% Input traffic 10: Long period ftp-MTK 879630 317485
63.91% 879630 347815 60.46% Input traffic 11: Multiple IP flows-QC 5319100
1434672 73.03% 5319100 1336519 74.87% Input traffic 7+8:average mixed 3753581
1220693 67.48% 3753581 1071819 71.45% Input traffic 7+8:one inserted in
another one 3753581 1151601 69.32% 3753581 1026762 72.65% Input traffic
7+8:random mixed 3753581 1220407 67.49% 3753581 1067292 71.57%
* * *
Table 7.2.3.2-2 shows the simulation results of RFC 1951 with adaptive Huffman
encoding and 1 byte UDC header.
Table 7.2.3.2-2: Simulation results with RFC 1951 (adaptive Huffman encoding
with 1 byte UDC header)
* * *
Input file [8Kbyte buffer]{.underline} [32Kbyte buffer]{.underline}  
[]{.underline} Original Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression
Efficiency Original Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression Efficiency
Input traffic 1: FTP data-client-CMCC 1211 606 49.96% 1211 606 49.96% Input
traffic 2: FTP data-server-CMCC 1782 987 44.61% 1782 987 44.61% Input traffic
3: SIP signalling-CMCC UE 1 51020 6700 86.87% 51020 6058 88.13% Input traffic
4: SIP signalling-CMCC 32680 4958 84.83% 32680 4828 85.23% Input traffic 5:
SIP signalling-CMCC 46688 5976 87.20% 46688 5362 88.52% Input traffic 6: Video
data-CMCC (duration: \~6s) 13450 4717 64.93% 13450 4718 64.92% Input traffic
7: Web surfing-CMCC 2381720 804504 66.22% 2381720 707847 70.28% Input traffic
8: Long period Video data-CMCC (duration: \~6min) 1371861 385106 71.93%
1371861 357120 73.97% Input traffic 9: Video data-MTK (duration: \~1hr)
2453749 996099 59.41% 2453749 1028979 58.07% Input traffic 10: Long period
ftp-MTK 879630 334174 62.01% 879630 364504 58.56% Input traffic 11: Multiple
IP flows-QC 5319100 1485336 72.08% 5319100 1387183 73.92% Input traffic
7+8:average mixed 3753581 1258662 66.47% 3753581 1109788 70.43% Input traffic
7+8:one inserted in another one 3753581 1189297 68.32% 3753581 1064458 71.64%
Input traffic 7+8:random mixed 3753581 1258376 66.48% 3753581 1105261 70.55%
* * *
The compressor can always use static (fixed) Huffman encoding during the
compression. Static Huffman tree is defined in RFC 1951, and both compressor
and decompressor use the same Huffman tree. Table 7.2.3.2-3 shows the
simulation results of RFC 1951 with static Huffman encoding and 1 byte UDC
header. Compare with above simulation configuration, the difference is the
_compress strategy_ is Z_FIXED (fixed Huffman coding).
Table 7.2.3.2-3: Simulation results with RFC 1951 (static Huffman encoding
with 1 byte UDC header)
* * *
Input file [8Kbyte buffer]{.underline} [32Kbyte buffer]{.underline}  
[]{.underline} Original Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression
Efficiency Original Sizeï¼ˆByteï¼‰ Compressed Sizeï¼ˆByteï¼‰ Compression Efficiency
Input traffic 1: FTP data-client-CMCC 1211 606 49.96% 1211 606 49.96% Input
traffic 2: FTP data-server-CMCC 1782 987 44.61% 1782 987 44.61% Input traffic
3: SIP signalling-CMCC UE 1 51020 6888 86.50% 51020 6149 87.95% Input traffic
4: SIP signalling-CMCC 32680 5298 83.79% 32680 4943 84.87% Input traffic 5:
SIP signalling-CMCC 46688 6139 86.85% 46688 5487 88.25% Input traffic 6: Video
data-CMCC (duration: \~6s) 13450 4979 62.98% 13450 4978 62.99% Input traffic
7: Web surfing-CMCC 2381720 828805 65.20% 2381720 713901 70.03% Input traffic
8: Long period Video data-CMCC (duration: \~6min) 1371861 394337 71.26%
1371861 360064 73.75% Input traffic 9: Video data-MTK (duration: \~1hr)
2453749 1004068 59.08% 2453749 1032588 57.92% Input traffic 10: Long period
ftp-MTK 879630 334169 62.01% 879630 364504 58.56% Input traffic 11: Multiple
IP flows-QC 5319100 1508809 71.63% 5319100 1393884 73.79% Input traffic
7+8:average mixed 3753581 1302194 65.31% 3753581 1121805 70.11% Input traffic
7+8:one inserted in another one 3753581 1223095 67.42% 3753581 1073699 71.40%
Input traffic 7+8:random mixed 3753581 1302491 65.30% 3753581 1117187 70.24%
* * *
### 7.2.4 Solution 4: Adaptive Packet Data Compression (APDC)
#### 7.2.4.1 Solution description
##### 7.2.4.1.1 Overview
Both UE and eNB maintains APDC Compression Memory to remember uncompressed
contents of previous packets. When a new packet arrives, the UE tries to match
(partially or fully) with the stored packets. If a match is found, then the UE
sends pointers (addresses/locations of matched data block in both the
compression memory and the packet) instead of the actual data bytes, to the
eNB. The decompression algorithm is similar to the famous C language library
function "_memcpy(srcaddr, destaddr, length)_ " which simply copies the
pointed data from the compression memory to the current packet, to recover the
original packet. So the compressed data format mainly contains the following
parameters.
\- "srcaddr": the address in compression memory [called "Lookback Length" in
this solution]
\- "destaddr": the address in the current packet [called "Distance to pointer"
in this solution]
\- "length": the length of the data bytes that was replaced by the compressor
[called "size" in this solution]
**APDC header memory**
Sometimes the APDC headers of two packets can be the same, in this case, the
compressor does not have to send the APDC header, instead, the compressor can
inform the decompressor to use the APDC header of the previous compressed
packet. To enable such mechanism, a separate APDC header memory of
_APDCHeaderMemorySize_ (=32 bytes) is set apart at both the compressor and
decompressor for saving the APDC header from the latest compressions.
The APDC header memory is used for previous packet compression context
reference (PPCR), which is a packet action that indicates the decompressor to
use the full APDC header from a previous packet. To achieve this, both the
compressor and decompressor push the APDC header in a packet to APDC header
memory. The compression/decompression mechanism using this method is referred
to as PPCR. The PPCR is indicated by setting the field "Packet action" of APDC
common header to '100'.
For _packet actions_ 011 and 010, the entire APDC header shall be pushed to
the APDC header memory. If there are more than _APDCHeaderMemorySize_ bytes of
APDC header in any packet, then that header is not pushed. The APDC header is
always copied to the beginning of the APDC header memory, overwriting any
contents before.
**Compression memory**
The compression memory is first in first out (FIFO) queue and illustrated in
the figure below. New contents are pushed into the memory from the one end of
the queue, as illustrated by Table 7.2.4.1.1-1 below. When a DRB is configured
with APDC or when APDC compression memory is reset, every octet in the
compression memory is reset to 0x00 in both compressor and decompressor.
Packets stored in APDC compression memory are word-aligned (4 byte aligned).
The beginning of each packet pushed to APDC compression memory starts from the
next word (4 byte aligned) boundary. APDC compression memory is padded with
zeros to fill the space between the last byte of the packet to the next word
boundary.
Table 7.2.4.1.1-1: Compression memory illustration
* * *
Memory Address Memory Content Note 0x0000 zeros Unused Memory 0x0001 zeros
Unused Memory 0x0002 oldest content 0x0003  
**...**  
maxMemEndAddr newest content
* * *
##### 7.2.4.1.2 Detailed Compressed Data Format Description
The compressed packet is preceded by the APDC header, which dictates how the
decompression can be performed. As shown in Figure 7.2.4.1.2-1, the APDC
header format consists of one APDC common header, (zero or one) PMCR header(s)
and (zero or one) CPCR header(s). One PMCR header can have multiple PMCR
metadata. Similarly, one CPCR header can have multiple CPCR metadata. The PMCR
header is present if the "E" bit in the APDC common header is set to 1;
otherwise, PMCR header is not present. If present, the PMCR header in a
compressed packet is always ahead of the CPCR header. This implies that a
section of the data packet is decompressed using the PMCR header and the
remaining section of the packet is decompressed using the CPCR header.
**\- Current Packet Compression Reference (CPCR):** The
compression/decompression mechanism, which indicates individual matches from
APDC compression memory, is referred to as CPCR and this header is called the
CPCR header. This header refers to matches in APDC compression memory using
CPCR header metadata each of which points to a block of prior memory that
needs to be copied to create the decompressed packet.
**\- Packet Match Compressed Reference (PMCR)** : This header refers a prior
block of data from APDC compression memory and indicates the mismatches in the
current packet with respect to the prior block in APDC Compression memory. The
compression/decompression mechanism using this PMCR header is referred to as
PMCR.The PMCR header may be optionally present, which is indicated by the "E"
bit set to 1 in the APDC common header.
Figure 7.2.4.1.2-1: Compressed data format
The PMCR header in a compressed packet is always ahead of the CPCR header.
This implies that a section of the data packet is decompressed using the PMCR
header and the remaining section of the packet is decompressed using the CPCR
header.
Packets stored in APDC compression memory are word-aligned (4 byte aligned).
The beginning of each packet pushed to APDC compression memory starts from the
next word (4 byte aligned) boundary. APDC compression memory is padded with
zeros to fill the space between the last byte of the packet to the next word
boundary.
**APDC common header (the first octet in Figure 7.2.4.1.2-1)**
Packet action (upper 3 bits)
\- 011 -- Decompression shall be performed as indicated by the APDC header
that follows the first octet. The entire packet (decompressed) shall be pushed
to UL compression memory. The APDC header shall be pushed to APDC header
memory if the APDC header length is less than or equal to APDC
_HeaderMemorySize_.
\- 010 -- The compression shall be performed only for the first
_APDCHeaderLength_ octets of the original packet; the rest portion of the
packet shall not be compressed. This mode is referred as header-only
compression mode in this solution. The compression and decompression
algorithms in header-only compression mode are the same as those in the full-
packet compression mode, respectively. No deep packet inspection (DPI) is
performed in header-only compression mode. The only difference between header-
only and full-packet modes is that the compressor skips compression on the
portion of a packet beyond the first _APDCHeaderLength_ octets in header-only
mode, to reduce processing. Decompression shall be performed as indicated by
the APDC header that follows the first octet. The packet header (of the
decompressed packet), as indicated by APDC _HeaderLength,_ shall be pushed to
UL compression memory. The APDC header shall be pushed to APDC header memory
if the APDC header length is less than or equal to APDC _HeaderMemorySize._
\- 001 -- For this packet action, there is no following header and no
decompression needs to be performed. The entire packet shall be pushed to UL
compression memory. The APDC header shall not be pushed to APDC header memory.
\- 000 -- For this packet action, there is no following header and no
decompression needs to be performed. The packet shall not be pushed to APDC
compression memory. The APDC header shall not be pushed to APDC header memory.
\- 100 -- This is an exact match of the APDC header with the contents of APDC
header memory. This is the signaling for the PPCR method that is described in
Section 7.2.4.1.1. Decompression shall be performed, as indicated by the
previous APDC header, as contained in APDC header memory. The entire packet or
packet header only shall be pushed to APDC compression memory, depending on
the _packet action_ in the previous packet (011 or 010 respectively). The APDC
header shall not be pushed to APDC header memory.
\- 101 -- Reset APDC compression memory to all zeros. For this _packet action_
, there are no following header and no decompression needs to be performed.
The entire packet shall be pushed to APDC compression memory. The APDC header
shall not be pushed to APDC header memory.
Checksum (next 4 bits) -- The checksum is used by the decompressor to detect
APDC compression memory out-of-sync conditions between the compressor and
decompressor.
Extension (E) (next 1 bit) -- Set to 1 if, and only if, a PMCR header follows;
set to 0 otherwise. For _packet actions_ 011 and 010, an E bit set to 0 means
the CPCR header follows and an E bit set to 1 means the PMCR header follows.
For all other _packet actions_ , the E bit is set to 0.
**Checksum computation**
The checksum is computed based on the _packet action_.
For _packet actions_ 011 and 010, the checksum contents depend on the presence
of the PMCR header.
\- No PMCR header -- Checksum contains the sum of the first 5 bytes of the
first match in this packet.
\- PMCR header is present -- Checksum contains the sum of the 5 bytes starting
from the location pointed to by the _lookback length_ minus 8. See the PMCR
header format for the processing of _lookback length_.
For _packet action_ 001, the checksum contains the sum of the last 5 bytes in
APDC compression memory before the packet that includes the checksum is pushed
into APDC compression memory.
For _packet action_ 000, the checksum bits are invalid and shall not be
checked.
For _packet action_ 101, the checksum bits shall be set to all zeros.
For _packet action_ 100, the checksum contents depend on the presence of the
PMCR header in the APDC header memory.
\- No PMCR header -- The checksum contains the sum of the first 5 bytes of the
first match in this packet.
\- PMCR header is present -- The checksum contains the sum of the 5 bytes
starting from the location pointed to by the _lookback length_ minus 8. See
the PMCR header format for the processing of _lookback length_.
**CPCR Header**
{width="6.666666666666667in" height="2.998611111111111in"}
Figure 7.2.4.1.2-2: CPCR Header format
The CPCR header consists of the following two parts:
\- CPCR common header -- The first byte gives the decompressor the _Number of
matches_ in the packet.
\- CPCR header metadata -- 4 bytes of metadata for each matched block of data
indicating _Distance to pointer_ , _Lookback length,_ and _length_. There are
as many metadata as there are _Number of matches_.
**CPCR common header**
\- Number of matches (1 byte) -- The number of matches indicates the number of
CPCR header metadata present in the packet. No more than 255 compressed blocks
can be present in a single compressed packet.
**CPCR header metadata (4 bytes)**
Each CPCR header metadata identifies a compressed block within the packet.
\- Distance to pointer (11 bits) -- Length in bytes of the uncompressed block
before this compressed block. It can cover a packet size up to 2048 bytes. The
range is 0 to 2047, with a value of 0 indicating that there are no
uncompressed bytes that precede this compressed block.
\- Lookback length (14 bits) -- Distance in bytes to look back in APDC
compression memory from the current end of APDC compression memory to find the
replacement for the compressed block; it can reference a APDC compression
memory capacity up to 16 kB. Valid values for this field range from 4 to
16383, for example, a value of 4 means that the match occurred with the last 5
bytes in APDC compression memory.
\- Length (7 bits) -- Number of bytes to copy from APDC compression memory;
match length is interpreted as Length + Minimum match length (5). Number of
bytes to be copied can be as large as 132 bytes (2^7^ + 5).
**PMCR Header**
{width="6.686111111111111in" height="1.96875in"}
Figure 7.2.4.1.2-3: PMCR Header format
The PMCR header consists of the following two parts:
\- PMCR common header -- The first 3 bytes give the decompressor the location
and length of the block to be copied from APDC compression memory (_Lookback
length_ and _Length_ respectively) and the _Number of mismatches_ within that
copied block.
\- PMCR header metadata -- 1 byte of metadata for each mismatched block of
data in the copied section indicating _Match length_ and _Mismatch length_.
There are as many metadata bytes as there are _Number of mismatches_.
**PMCR common header**
\- Option (2 bits) -- Set to 01; indicates that this is a PMCR header.
\- Extension (1 bit) -- Set to 1 if the CPCR header follows. Set to 0 if no
CPCR header follows.
\- Lookback length (10 bits) -- Distance in words to look back in APDC
compression memory from the current end of APDC compression memory to find the
block to be copied. Distance in bytes = (_Lookback length_ \+ 1) * 4 -- 1.
Valid values for this field range from 0 to 1023.
\- Number of mismatches (4 bits) -- Number of the PMCR header metadata present
in the packet. Valid values for this field range from 0 to 15. No more than 15
mismatched blocks can be present in the copied block. A value of 0 indicates
that there are no mismatches in the copied block.
\- Length (7 bits) -- Number of bytes to copy from APDC compression memory.
Valid values for this field range from 1 to 127. The number of bytes to be
copied can be as large as 127 bytes.
\- Note that the PMCR header can be used only when the compressor compresses
the consecutive data block(s) that start from the first byte of the
uncompressed packet.
**PMCR header metadata (1 byte)**
Each PMCR header metadata identifies a mismatched block within the copied
block.
\- Match length (5 bits) -- Length in bytes of the matched block. This length
is counted from the end of the previous mismatched block or the start of the
packet (for the first metadata). The range is 0 to 31, with a value of 0
indicating that there are no matched bytes that precede the mismatched block.
Mismatch length (3 bits) -- Length in bytes of the mismatched block. This
length is counted from the end of the matched block. The range is 0 to 7, with
a value of 0 indicating that there are no mismatched bytes that follow the
matched block. This block of bytes (as many as _Mismatch Length_) is found in
the uncompressed bytes following the APDC header. Note that the mismatched
block indicated by this field is found before the uncompressed bytes indicated
by the CPCR header, if any.
Example compressor and decompressor algorithms are provided in Annex A.
**Packet checksum failure**
Figure 7.2.4.1.2-4 illustrates the behavior on checksum failure. See the text
above for details of the checksum computation and packet action. Note that the
decompressor continues to discard any compressed packets after the first
checksum failure is observed until the packet with _packet action_ = 101
(reset compression memory) is received.
If the packet with _packet action_ = 101 is not received by the decompressor
for some time (recommended value = 5 seconds) after the RRC Connection
Reconfiguration Complete is received, then the decompressor should release
APDC by sending RRC Connection Reconfiguration with APDC release.
If decompressor has sent two reset messages but encounters another checksum
failure within a short time (e.g., one minute), the decompressor should
release the APDC by sending RRC Connection Reconfiguration with APDC release.
Figure 7.2.4.1.2-4: Call flow on checksum failure
#### 7.2.4.2 Simulation results
The compression memory is filled with all zeros in the beginning of the
simulation. For APDC, at most 16Kbyte buffer is supported due to the valid
value range for _Lookback length_ (14bit) of CPCR header field is from 4 to
16383. Note that the simulation results consider all the overhead from the
APDC header as specified in Section 7.2.4.1. The simulation results by using
the disclosed example source code in [8][9] with 8Kbytes buffer and 16Kbytes
buffer are shown in below. To carefully evaluate the performances of solution
4, cross-checking was conducted using the disclosed example source code.
Similar compression efficiency by using the disclosed example source code is
achieved by different companies.
Table 7.2.4.2-1: Simulation results
* * *
PCAP File # PCAP File Original simulation results Simulation results with
disclosed example source code  
Original Size (Bytes) Compressed Size (Bytes) Compression Efficiency (8KB)
Compression Efficiency (8KB) Compression Efficiency (16KB) 1 FTP- Client
(CMCC) 1211 548 54.74% 54.34% 54.34% 2 FTP- Server (CMCC) 1782 884 50.39%
50.34% 50.34% 3 Online video (CMCC) 13450 5105 62.04% 61.00% 61.04% 4 Long
period video (CMCC) 1371861 295658 78.44% 76.67% 78.13% 5 SIP UE1(CMCC) 51020
7337 85.61% 83.91% 85.18% 6 SIP UE2 (CMCC) 32680 5827 82.16% 80.62% 81.78% 7
SIP UE3 (CMCC) 46688 6561 85.94% 84.20% 85.67% 8 Web surfing (CMCC) 2381720
767990 67.75% 64.24% 66.87% 9 Video data (MediaTek) 2453749 638347 73.98%
73.47% 73.9% 10 Long duration FTP (MediaTek) 879630 216910 75.34% 75.34%
75.30% 11 Multiple IP flows (Qualcomm) 5319100 1312299 75.32% 73.35% 74.68%
* * *
### 7.2.5 Compression Gain Enhancement Technique
#### 7.2.5.1 Pre-defined dictionary
For SIP signalling case, the initial IMS registration related SIPs are not
compressed in application layer and the first message of a VoLTE session only
could be compressed partially if there is no data receive before. And in UDC
solutions 2, 3, 4, cross-packets compressions (dynamic dictionary) are used
which the first packet could not be compressed since there is no data for
reference as a dictionary. To compress the initial IMS registration related
SIPs and the first message of a VoLTE session, the pre-defined dictionary can
potentially be used. Specification defined static dictionary (e.g. static
dictionary defined in RFC 3485) or the third party pre-defined dictionary
(e.g. operator defined dictionary) can be used in UDC.
The following is an example of specification defined static dictionary. In the
Appendix A section in RFC 3485, it lists the SIP input strings that were used
in generating the dictionary, as well as a priority value, the offset of the
string in the generated dictionary, and the length of the string. The
following is part of the static dictionary defined in RFC 3485:
Table 7.2.5.1-1: part of static dictionary defined in RFC 3485
* * *
String Pr Off Len  
\"sip:\" 1 0CDD 0004  
\"sips:\" 3 08AC 0005  
\"tel:\" 3 08BD 0004  
\"SIP/2.0\" 1 0CB9 0007  
\"SIP/2.0/UDP \" 1 0CFE 000C  
......
* * *
While use pre-defined dictionary, the compressor/de-compressor should copy the
dictionary into the compression/decompression buffer and then start to
compress/decompress data. It means the pre-defined data is just the initial
data in the buffer, and new data in the packets would enter the buffer after
compression/decompression.
Corresponding signalling procedure to support pre-defined dictionary can be
discussed in next phase.
Pre-defined dictionary can potentially be used complementary to solution 2, 3
and 4.
## 7.3 Comparison of UL data compression solutions
The results from UDC solutions 2 to 4 show a similar trend in terms of the
compression efficiency for simulated uplink input traffic. Wherein, about 40%
to 50% compression efficiency is shown for FTP traffic, over 80% of
compression efficiency is shown for SIP signalling and about 60% to 75%
compression efficiency is shown for video traffic. Similarly, over 60% of
compression efficiency can be obtained with web surfing data.
Simulation results are shown considering 8KBytes and 32KBytes buffer sizes
except solution 4 which considering 8KBytes and 16KBytes buffer size. The
buffer size has not shown a significant factor to the simulation results in
terms of compression efficiency, although the performance with 32KBytes buffer
shows a slight increase of gain compared to that of 8KBytes buffer case in UDC
solution 2 and solution 3 and the performance with 16Kbytes buffer shows a
slight increase of gain compared to that of 8Kbytes buffer case in UDC
solution 4.
Significant compression efficiency is shown with all UDC solutions when
applying on mixed traffic profile. Simulation results for mixed traffic were
derived based on combination of input traffic profiles as well as mixed
traffic profile captured in a practical system. It can be observed that the
compression efficiency of mixed traffic is between the compression
efficiencies resulted from individual traffic profiles.
Compression efficiency of SIP signalling achieved with UL RoHC is around 5%
while compression efficiency is achieved in the order of 50 to 80% on other
traffic. It was noted that the compression efficiency by UL RoHC has
correlation to the size of TCP/IP header ratio. If the TCP/IP header ratio is
high, the compression efficiency achieved with RoHC is also high as expected
from a header compression scheme.
Pre-defined dictionary can be used to compress the initial IMS registration
related SIPs and the first message of a VoLTE session. Specification defined
static dictionary (e.g. static dictionary defined in RFC 3485) or the third
party pre-defined dictionary (e.g. operator defined dictionary) can be used in
UDC.
A summary of the proposed UDC solutions (solution 2, 3 and 4) is below. Step 1
is the same for the three solutions. The main difference is in Steps 2 and 3.
Solution 3 (Deflate) and solution 2 (Zlib) require Huffman encoding in Step 2,
while solution 4 (APDC) mainly writes the matching and mismatching information
into UDC headers and copy mismatched bytes to the compressed packet.
Table 7.3-1 Comparison of Compressor Side Computation Complexity
* * *
                       Step 1                                                              Step 2                                                                                                                                 Step 3
Deflate (RFC 1951) Search for repeated strings from compression memory (e.g.,
LZ77). Huffman encoding.  
Zlib (RFC 1950) Huffman encoding. Add Zlib header; compute checksum for
decompressor to verify decompression result. APDC Write the matching and
mismatching information (like pointers) into APDC headers and copy mismatched
bytes to the compressed packet. Compute checksum for decompressor to verify
decompression result.
* * *
Table 7.3-2 Comparison: Decompressor side Computation complexity
* * *
                       Step 1              Step 2                                                                                 Step 3
Deflate (RFC 1951) Huffman decoding. Copy matched bytes from compression
memory to the decompressed packet (memory copy).  
Zlib (RFC 1950) Huffman decoding. Compute checksum to verify decompression
result. APDC [Nothing] Compute checksum to verify decompression result.
* * *
The following remarks can be made based on the simulations:
**Remarks on solutions:**
\- Compression efficiency of UL RoHC depends on the size of TCP/IP header
ratio and depending on the traffic input, RoHC could achieve significant
compression efficiency up to 80%. For SIP signalling the compression
efficiency of RoHC is around 5%.
\- RoHC is designed to fully exploit packet header format and would need to be
updated should a new type of internet header emerge.
\- Solution 2 (Zlib) is an abstraction of solution 3 (Deflate) algorithm where
a header and trailer bytes are added to the raw DEFLATE data.
\- Solution 2 (Zlib) adds some extra overhead to solution 3 (Deflate) protocol
as header and trailer bytes are added to the raw DEFLATE data.
\- The possibility to manage the compression context memory as proposed in
APDC could be expected to increase compression efficiency as packets with no
or low level of redundancy could be excluded from the buffer.
\- Pre-defined dictionary could be used for SIP signalling compression in UDC.
Potential gain of using pre-defined dictionary for SIP signalling compression
is expected. However, impact of buffer and authentication when using pre-
defined dictionary have not been investigated. Pre-defined dictionary can
potentially be used complementary to solution 2, 3 and 4.
**Remarks on comparisons of solutions:**
\- A significant compression performance can be achieved with UDC solutions in
UL for all types of traffic including FTP, SIP, video and web surfing in case
1 and case 2 type traffic scenarios.
\- Mixed traffic representing a nature of traffic in a practical system could
also be compressed using UDC solution and significant compression efficiency
can be achieved.
\- For the cases that RoHC does not achieve high compression efficiencies, all
other UDC solutions provide compression efficiencies in the range from
60%-88%.
\- Among the simulated traffic types, solution 3 outperforms other solutions
in terms of compression efficiencies in some cases while in some other cases
solution 4 outperforms other solutions.
\- Solution 3 (Deflate) shows the best compression efficiencies for SIP
signalling.
\- Solution 2 (Zlib) and solution 3 (Deflate) can be consolidated as a DEFLATE
based solution.
\- For Zlib/DEFLATE based compression solutions (solution 2 and solution 3),
multiple companies achieve consistent compression performance with the same
configuration.
# 8 Conclusions
Four different solutions were studied in this study item for UDC.
Solution 1 is based on UL RoHC with TCP/IP profile has been standardized in
rel-14 for LTE. RoHC is designed to fully exploit the packet header formats
and the RoHC compression/decompression algorithms need to be updated should a
new type of internet header emerge. Compression efficiency of UL RoHC depends
on the size of TCP/IP header ratio. Depending on the input traffic types, RoHC
could achieve significant compression efficiency up to 80%. For SIP signalling
the compression efficiency of RoHC is around 5%.
Cross-checking was conducted for solution 2 and 3 and similar UDC results can
be achieved by different vendors for the same configuration. Solution 2 and
solution 3 can be consolidated to a DEFLATE based solution considering the
commonality of the two solutions. The consolidated solution is based on the
compression algorithm, DEFLATE [5].
Solution 4 (APDC) is based on a new compression algorithm named APDC which is
described in section 7.2.4 and details of compressor and decompressor are
defined in Annex A. Cross-checking was conducted for solution 4 and similar
UDC results can be achieved by different vendors with the disclosed example
source code.
Pre-defined dictionary could be used for SIP signalling compression in UDC.
Potential gain of using pre-defined dictionary for SIP signalling compression
is expected. However impact of buffer and authentication when using pre-
defined dictionary have not been investigated. Pre-defined dictionary can be
used complimentarily to solution 2, 3 and 4.
The simulation results of UDC solution based on DEFLATE (solution 3) and
Solution 4 (APDC) have shown a similar trend in terms of the compression
efficiency for uplink on various input traffic profiles simulated including
FTP, SIP signalling, video and web surfing in case 1 and case 2 type traffic
scenarios. Wherein, about 40% to 50% compression efficiency is shown for FTP
traffic, over 80% of compression efficiency is shown for SIP signalling and
about 60% to 75% compression efficiency is shown for video traffic. Similarly,
over 60% of compression efficiency can be obtained with web surfing data. From
technical point of view, solution based on DEFLATE and solution based on APDC
have shown significant and similar compression efficiency.
Both solutions based on DEFLATE and APDC are candidates for a UL data
compression solution. However RAN2 recommends only one solution to be selected
for specification in a potential Work Item (WI).
###### ### Annex A: Void
#
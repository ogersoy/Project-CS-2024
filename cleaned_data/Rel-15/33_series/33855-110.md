# Foreword
This Technical Report has been produced by the 3rd Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
3GPP TS 23.501 [2] defines 5G services with a new service based architecture
(SBA) approach. The present document reviews the interactions in this new
architecture, determines key issues and
# 1 Scope
3GPP TS 23.501 [2] defines 5G services with a new service based architecture
(SBA) approach.
The present document reviews the interactions in this new architecture,
determines key issues relating to the security of SBA elements and interfaces,
details potential solutions and recommends normative work for releases 15 and
16.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or nonâ€‘specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 23.501: \"System Architecture for the 5G System\".
[3] 3GPP TS 23.502: \"Procedures for the 5G System\".
[4] JSON Object Signing and Encryption
([https://datatracker.ietf.org/wg/jose/charter]{.underline}).
[5] IETF RFC 7515: \"JSON Web Signature\"
([https://tools.ietf.org/html/rfc7515]{.underline}).
[6] IETF RFC 7516: \"JSON Web Encryption\"
([https://tools.ietf.org/html/rfc7516]{.underline}).
[7] IETF RFC 7518: \"JSON Web Algorithms\"
(https://tools.ietf.org/html/rfc7518).
[8] V. Goyal, O. Pandey, Amit Sahai, and B. Waters, \"Attribute-based
encryption for fine-grained access control of encrypted data,\" in Proc. CCS
\'06, New York, 2006, pp. 89-98.
[9] J. Bethencourt, A. Sahai, and B. Waters, \"Ciphertext-Policy Attribute-
Based Encryption\" in Proc. SP \'07, 2007, pp. 321-334.
[10] C. Chen, J. Chen, H.-W. Lim, Z. Zhang, D. Feng, \"Combined Public-Key
Schemes: The Case of ABE and ABS\" in Proc. Provable Security \'12, Lecture
Notes in Computer Science, vol. 7496, 2012, pp. 53-69.
[11] 3GPP TS 33.501: \"Security architecture and procedures for 5G System\".
[13] S3-181481 Prevent fraudulent Registration Request attack
[14] S3-181480 N32 message anti-spoofing within the SEPP
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply. An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
# 4 Key Issues
## 4.1 General SBA Key Issues
### 4.1.1 Key Issue #1: Confidentiality protection of signalling messages
#### 4.1.1.1 Issue description
Confidentiality protection of (some information elements in) signalling
messages transferred between NFs ensures that third parties are unable to
extract any relevant information from the communication. Failing to provide
such protection for signalling traffic between any two NFs by means of
ciphering can be considered a key issue for both security and user privacy.
In inter-PLMN communication, IPX providers offer valuable services to
operators that may require them to access certain information contained in the
transferred signalling messages. Thus, protecting the confidentiality of every
single information element might not be desirable.
In particular, leaking the IMSI, cryptographic material and location data may
constitute a breach of user's privacy and may lead to fraud towards the
operator.
#### 4.1.1.2 Threat description
A lack of confidentiality protection for 5GC signalling messages may lead to
the following security threats:
\- Leakage of sensitive information about mobile customers, such as SUPI
and/or location data
\- Leakage of potentially sensitive information about the PLMN itself
\- Theft of service, if authentication information/authorization credentials
are transferred unciphered
#### 4.1.1.3 Potential security requirements
Relevant IEs in 5GC signalling messages exchanged via intra-PLMN communication
shall be confidentiality protected.
As for inter-PLMN communication, certain sensitive information elements shall
always be confidentiality protected:
\- Authentication Vectors
\- Cryptographic Material
\- Location Data
As per agreement between operators, certain sensitive information elements
shall be confidentiality protected:
\- Identifiers such as IMSI, SUPI, NAI, PEI and/or IMEI;
Additionally, it is recommended to cipher the remaining information elements
as well, unless agreed otherwise with the roaming partner or IPX provider.
### 4.1.2 Key Issue #2: Integrity protection of signalling messages while
allowing for modifications
#### 4.1.2.1 Issue description
Integrity protection ensures that signalling messages transferred between NFs
cannot be modified without the receiving party noticing that such modification
occurred. In combination with authenticity, integrity is an essential
guarantee for the correctness and validity of messages.
In inter-PLMN communication, however, IPX providers offer valuable services to
opeartors that may require them to modify certain information contained in the
transferred signalling messages. Thus, it might be desireable to allow for
certain modifications by authorized intermediates on N32 even if the messages
are integrity protected.
#### 4.1.2.2 Threat description
The lack of integrity protection for 5GC signalling messages may lead to the
following security threats:
\- Man in the Middle attacks that actively modify signalling messages between
NFs
\- Lack of availability caused by malformed messages due to unnoticed
modifications during transfer
\- Theft and fraud towards an operator
#### 4.1.2.3 Potential security requirements
5GC signalling messages in both intra- and inter-PLMN communication shall be
integrity protected.
In intra-PLMN communications, intermediaries shall be able to apply
modifications without breaking the integrity protection.
A receiving PLMN shall be able to identify the intermediary that applied
modifications and verify that this was authorized.
### 4.1.3 Key Issue #3: Replay protection of signalling messages
#### 4.1.3.1 Issue description
Replay protection of signalling messages transferred between NFs ensures that
it is not possible to successfully gain service from an NF by recording
genuine messages and re-sending them at a later point in time.
#### 4.1.3.2 Threat description
The lack of replay protection for 5GC signalling messages may lead to the
following security threats:
\- Theft of service
\- Leakage of potentially sensitive information about mobile customers and the
network itself
\- Loss of control, in case authorization credentials are replayed
#### 4.1.3.3 Potential security requirements
5GC signalling messages in both intra- and inter-PLMN communication shall be
replay protected.
### 4.1.4 Key Issue #4: NF-NF Authentication
#### 4.1.4.1 Issue description
Authentication ensures that an attribute claimed by a given entity is actually
correct. In the context of communication and NF-NF signalling in particular,
authenticating the communication peer's identity is a key objective in order
to guarantee the validity of transferred messages. Authentication is also a
prerequisite for conducting authorization which itself is another key issue
for 5GC signalling. already mentioned in TS 23.501 [2].
#### 4.1.4.2 Threat description
Not mutually authenticating two NFs that is not mutually authenticated could
potentially allow attackers to perform the following types of attacks:
\- Operating malicious NFs claiming to be genuine peers in order to request
certain services (theft of service) or information (data leakage)
\- Man in the Middle attacks between any genuine NFs of a given PLMN
#### 4.1.4.3 Potential security requirements
NFs shall be able to mutually authenticate each other.
### 4.1.5 Key Issue #5: NF-NF Authorization
#### 4.1.5.1 Issue description
Authorization comprises the definition and enforcement of access rights or
privileges to certain resources or services. TS 23.501 [2] outlines a high-
level NF service authorization framework, in which the consuming and producing
NF both play a key role. After the Consumer NF has been successfully
authorized by the NRF, it may subsequently be subject to another authorization
procedure conducted by the Producer NF, which decides whether a certain
service request is allowed based on information on "request type granularity".
#### 4.1.5.2 Threat description
If an NF does not authorize incoming requests from other NFs in the same PLMN,
attackers would potentially be able to perform the following types of attacks:
\- Requesting and successfully obtaining services from the NF that are not
allowed for third parties, e.g. in order to extract potentially sensitive
information about the network
\- Causing a Denial of Service situation by successfully forcing the NF to
perform resource-demanding operations
#### 4.1.5.3 Potential security requirements
An NF shall validate whether a requesting NF is authorized to request a given
service(s).
### 4.1.6 Key Issue #6: NF-NRF Authentication
#### 4.1.6.1 Issue description
Since the NRF comprises the central repository of registered NFs and available
NF services in a 5GC, there are several key message exchanges between NRF and
its peer NFs that require secure communication. Therefore, just as in NF-NF
signalling, authentication of the message source in any communication between
NF and NRF is crucial. Furthermore, authentication between NF and NRF is also
a prerequisite for conducting authorization which itself is another key issue
for 5GC signalling and already mentioned in TS 23.501 [2].
#### 4.1.6.2 Threat description
Communication between NF and NRF that is not mutually authenticated could
potentially allow attackers to perform the following types of attacks:
\- Performing Man in the Middle attacks between any genuine NFs and NRFs of a
given PLMN
\- Registering a malicious NF with the genuine NRF of a given PLMN
\- Operating a malicious NRF in order to trick genuine NFs not to register
with the genuine NRF of a given PLMN
#### 4.1.6.3 Potential security requirements
Communication between NF and NRF shall be mutually authenticated.
### 4.1.7 Key Issue #7: NF-NRF Authorization
#### 4.1.7.1 Issue description
Authorization comprises the definition and enforcement of access rights or
privileges to certain resources or services. TS 23.501 [2] outlines a high-
level NF service authorization framework, in which both the consuming NF and
NRF play a key role. In particular, the NRF checks whether the Consumer NF is
allowed to discover Producer NF instances of the requested services: "This is
performed on a per NF granularity by NRF".
#### 4.1.7.2 Threat description
If an NRF does not authorize incoming requests from NFs in its PLMN, attackers
would potentially be able to perform the following types of attacks:
\- Sending registration requests from malicious NFs which are controlled by
the attacker
\- Requesting services from the NRF that third parties are not allowed to
consume, e.g. in order to gain information about the PLMN (potentially
considered secret)
\- Flooding the NRF with resource-demanding operations that may lead to a
Denial of Service situation
#### 4.1.7.3 Potential security requirements
An NRF shall validate whether a given NF is authorized to register with or
request certain services -- such as NF service discovery -- from the NRF.
### 4.1.8 Key Issue #8: NRF-NRF Authentication
#### 4.1.8.1 Issue description
For any NF service discovery that is carried out in inter-PLMN communication,
the initial discovery request will be transferred from the NRF in the Consumer
NF's PLMN to the NRF in the Producer NF's PLMN. The same applies to the
response, potentially containing information about how to address the Producer
NF and a token for authorization purposes. In order to ensure that NF service
discovery is perfomed by valid peers, communication between two NRFs relies on
mutual authentication.
#### 4.1.8.2 Threat description
Communication between NRFs across different PLMNs that is not mutually
authenticated could potentially allow attackers to perform the following types
of attacks:
\- Performing Man in the Middle attacks between the local NRF and an NRF of a
genuine roaming partner
\- Querying of address information from an NRF, thereby leaking potentially
secret data about the PLMN
#### 4.1.8.3 Potential security requirements
Communication between NRFs shall be mutually authenticated.
### 4.1.9 Key Issue #9: NRF-NRF Authorization
#### 4.1.9.1 Issue description
As described in Key Issue #8, communication between two NRFs precedes every
service discovery an NF may send to a foreign PLMN. Being exposed to such
external requests, the NRF is a valuable target for attackers that may try to
send malicious requests in order to obtain illegitimate service or
information. Therefore, the NRF is a key element in the 5GC NF service
authorization framework and needs to ensure its communication peers are
authorized to request a certain service.
#### 4.1.9.2 Threat description
If an NRF does not authorize incoming requests from NRFs in other PLMN,
attackers would potentially be able to perform the following types of attacks:
\- Sending discovery requests from malicious NRF which are controlled by the
attacker
\- Requesting services from the NRF that third parties are not allowed to
consume, e.g. in order to gain information about the PLMN (potentially
considered secret)
#### 4.1.9.3 Potential security requirements
An NRF shall validate whether a requesting NRF is authorized to request the
given service(s).
## 4.2 SEPP-/N32-specific Key Issues
### 4.2.1 Key Issue #10: Termination points of N32 security
#### 4.2.1.1 Issue description
#### 4.2.1.2 Threat description
#### 4.2.1.3 Potential security requirements
### 4.2.2 Key Issue #11: Local provisioning of SEPP protection policies
#### 4.2.2.1 Issue description
When a SEPP receives a message to be sent out to a different PLMN via N32, it
applies certain protection measures to it. In order to allow for a uniform
protection of any given information element, independent of the sending NF,
the SEPP needs to be able to detect what data-types are contained in a
received message and by what means to protect them. This information is
contained in a Protection Policy Suite, comprised of Data-type Encryption
Policy and Data-type Modification Policy and the related attribute mappings
that describe what data-types (e.g. subscription identifier or location data)
are contained in the individual information elements. Thus, there needs to be
a standard format for these policies as well as a standard way of locally
provisioning them to the SEPP.
#### 4.2.2.2 Threat description
If there is no standard format for such Protection Policy Suites, ensuring a
uniform protection of all outgoing messages on N32 will be next to impossible.
Furthermore, since the Protection Policies Suites will also be exchanged
between roaming partners, a standard format is a fundamental prerequisite for
ensuring interoperability between different SEPPs. Failing to provide such may
impede working inter-PLMN signalling.
#### 4.2.2.3 Potential security requirements
There shall be a standard format for Protection Policy Suites, comprised of
Data-type Encryption Policy and Data-type Modification Policy and the related
attribute mappings.
A SEPP shall apply confidentiality and integrity protection to outgoing N32
messages according to its local Protection Policy Suite.
A receiving SEPP shall enforce modifications to incoming N32 messages
according to the sender's Modification Policy.
### 4.2.3 Key Issue #12: Provisioning of SEPP protection policies over N32
#### 4.2.3.1 Issue description
In order to correctly interpret incoming messages on N32, a SEPP needs to know
which attributes are protected in what way (i.e. only integrity protected or
ciphered). While the ciphering information in form of thr Data-type Encryption
Policy is likely to be agreed by both roaming partners in advance as part of
their business agreement, there is merit in validating that both SEPPs are
configured with the same policy during the initial handshake.
As for the second part of the Protection Policy Suite, it is crucial that the
SEPP of a roaming partner is provided with the Data-Type Modification Policy,
thereby enabling it to verify the validity of modifications performed by
intermediates.
#### 4.2.3.2 Threat description
If two SEPPs are unable to agree on a Protection Policy Suite, there is a
possibility of ambiguous states when rewriting messages or misaligned
protection measures at both ends of the communication, thereby rendering N32
communication faulty or even completely defective.
Furthermore, if a SEPP does not provide its local Data-type Modification
Policy to its peer SEPP, the latter is unable to verify whether the
intermediate IPX provider it does not have a business agreement with only made
modifications in adherence to the policy.
#### 4.2.3.3 Potential security requirements
The Data-type Encryption Policy shall be negotiated during the initial SEPP
handshake.
A SEPP shall be able to negotiate Data-type Encryption Policies with its peer
SEPPs via N32-c. This includes the respective attribute mapping necessary for
correctly interpreting a message. Both information shall be transferred
confidentiality, integrity and replay-protected.
The Data-type Modification Policy should be exchanged during the initial SEPP
handshake.
A SEPP shall be able to exchange Data-type Modification Policies with its peer
SEPPs via N32-c. This includes the respective attribute mapping necessary for
correctly interpreting a message. Both information shall be transferred
confidentiality, integrity and replay-protected.
### 4.2.4 Key Issue #13: SEPP session setup
#### 4.2.4.1 Issue description
In order to apply the required protection mechanisms to outgoing messages as
well as verifying and rewriting incoming messages on the N32 interface, two
peer SEPPs need to agree on some principles of communication first. This
comprises the following information:
\- Type of N32 Protection, i.e. TLS or ALS
\- Cipher Suites for ALS
\- ALS keys for confidentiality protection
\- ALS keys for integrity protection
\- ALS key expiry
The exchange of above information can be summarized as SEPP session setup,
which needs to be performed whenever two SEPPs start to exchange messages.
#### 4.2.4.2 Threat description
If there is no standard way of exchanging the information outlined in the
previous subsection, two SEPPs may not be able to successfully establish a
secure N32 connection, thereby impeding inter-PLMN communication and roaming
for customers from/to the related PLMNs.
#### 4.2.4.3 Potential security requirements
There shall be a standard session setup procedure performed by the SEPP in
order to agree on core principles required for secure message transfer over
N32.
### 4.2.5 Key Issue #14: Application of ciphering and integrity protection to
JSON object using JOSE
#### 4.2.5.1 Issue description
In order to protect all parts of an outgoing messageon N32, including HTTP
Request Line and potential HTTP headers, the SEPP will have to rewrite every
message into a defined JSON structure before applying JOSE protection
mechanisms to it.
#### 4.2.5.2 Threat description
If a SEPP is unable to correctly re-write N32 messages or apply JOSE
algoritms, there is no way to ensure the protection of confidentiality or
integrity for messages on the N32 interface.
Furthermore, ambiguities in the application of rewriting rules and protection
measures are to be avoided for interoperability reasons. If there is no
standard way of conducting these message transformations, a SEPP may not be
able to re-build the original HTTP message from protected one received on N32,
thereby impeding roaming traffic between two operators.
#### 4.2.5.3 Potential security requirements
There shall be a standard way of re-writing messages and applying JOSE
protection measures for integrity and confidentialy on N32.
A SEPP shall verify the integrity of all incoming N32 messages. Messages with
fail this integrity check shall be descarded.
A SEPP shall verify whether intermediates that performed changes on incoming
N32 messages are authorized to do so according to the contained signature and
the related Data-Type Modification Policy.
### 4.2.6 Key Issue #15: Malicious messages received on the N32 interface
#### 4.2.6.1 Issue description
In order to properly analyse the potential impact of malicious messages on the
N32 interfaces and how to mitigate their security risk, we structure our
analysis into three different parts. Specifically, we differentiate between
possible message origins, destinations, as well as threat categories, as
outlined below.
**A. Message origin -** Any incoming message received by the SEPP on N32
originates from one of the following groups:
  1. Genuine roaming partners
  2. IPX providers
  3. Other parties in the IPX network
**B. Message destination -** Messages received by the SEPP on N32 can have one
of the following destinations:
  1. The SEPP itself (i.e. SEPP-to-SEPP signalling)
  2. Network Functions within one's own PLMN
  3. Others (incl. Network Functions in PLMNs of 3rd parties, invalid addresses, etc.)
**C. Threat category --** Expected message types on N32 can be broadly grouped
into the following categories:
  1. 3GPP application signaling (Session management, Mobility management, etc. -- known from previous Releases)
  2. SBA specific signaling (Service Registration, Service Discovery, Service Access, Service Subscription)
  3. SEPP-to-SEPP signaling
Using this model, we are able to take into account every possible attack
vector of malicious messages by exhaustively combining all the categories
above, i.e. each origin with each destination, with each threat. Note that
some of the combinations can be ruled out definitively by considering the
basic, already agreed SEPP functionalities.
**Observation 1: During the initial N32-c handshake the SEPP shall
authenticate any peer SEPP that it receives messages from based on the other
party's root certificate, which has been exchanged previously via out-of-band
measures. Incoming N32-c messages from SEPPs that cannot be authenticated by a
root certificate shall be discarded.**
**Observation 2: An N32-f connection utilizes encryption and integrity keys
that are derived during the initial N32-c session. Incoming N32-f messages
that do not belong to an active N32-f connection with a valid set of
cryptographic keys shall be discarded by the SEPP.**
Based on Observation 1 and 2, we can exclude message origin A.2 and A3 from
further analysis. It is fair to assume that IPX providers will not operate
their own SEPP in order to act as an individual PLMN. While some operators may
very well choose to outsource their SEPP to an IPX provider, the messages
originiating from their PLMNs would still be authenticated on the basis of the
operator's own root certificate, not that of the IPX provider.\ However,
operators will most certainly have to exchange root certificates with IPX
providers to authenticate intermediate IPX providers that perform message
modifications. Therefore, it needs to be ensured that an IPX provider is not
able to pose as an individual roaming partner, i.e. a genuine source of N32
signaling on the basis of these certificates. In order to clearly
differentiate between certificates that are used to authenticate roaming
partners and certificates that are used to authenticate message modifications
by intermediates, the SEPP will have to support separate certificate storages.
**Potential security requirement 1: The SEPP shall be able to clearly
differentiate between certificates used for authentication of peer SEPPs and
certificates used for authentication of intermediates performing message
modifications, e.g. by implementing separate certificate storages.**
If above Potential security requirement 1 is realized, the authentication of
messages from all other parties in the IPX network is bound to fail, since the
SEPP's certificate storage for authentication is only provisioned with root
certificates of genuine roaming partners. This leaves us with only genuine
roaming partners (A.1) as a source for malicious messages. The possible
message origins types are shown in the figure below.
{width="4.756944444444445in" height="1.9527777777777777in"}
**Figure 1: Potential N32 message types originating in PLMNs of genuine
roaming partners**
As for the SEPP as the final destination of messages (B.1), it can be safely
assumed that a hardened SEPP will only accept SEPP-to-SEPP signaling which is
needed to authenticate peers, negotiate N32 session keys, etc. Any other form
of Control Plane traffic, i.e. 3GPP application (C.1) and SBA-specific
signaling (C.2), will usually not terminate in the SEPP. If the SEPP does
receive N32 messages that it is unable to understand anyway, these messages
must, of course, be discarded.
**Potential security requirement 2: The SEPP shall discard malformed N32
signaling messages.**
Thus, only the combination of B.1/C.3 is worth analyzing further. We already
established that the SEPP will authenticate incoming SEPP-to-SEPP signaling
and will discard malformed messages. Another potential threat on N32 is
excessive SEPP-to-SEPP signaling, e.g. key re-negationation requests, in order
to cause a denial of service on the receiver's side. Thus, an additional
protection mechanism that is necessary on N32 is rate limitation.
**Potential security requirement 3: The SEPP shall impement rate-limiting
functionalities to defend itself and subsequent Network Functions against
excessive Control Plane signaling. This includes SEPP-to-SEPP signaling
messages.**
Control Plane signaling by successfully authenticated roaming partners and
with valid source/destination addresses will eventually be routed by the SEPP
to the receiving NF. However, this does not rule out malicious contents
completely. As [13] points out, a genuine roaming partner could e.g. still
send fraudulent messages that may result in a denial of service for a user
connected to a differernt PLMN as well as additional cost for the HPLMN.\ Up
till now, most kinds of malicious messages discussed in this document were
related to unauthenticated or unauthorized parties trying to send messages to
a certain PLMN -- an issue that is best prevented at the foremost edge of the
network, i.e. by the SEPP. To counter the problem of fraudulent 3GPP
application signaling (e.g. session management, mobility management, etc.),
the NFs themselves need to implement certain security functionalities as well.
Detailed measures depend on Stage 3 message contents, but they will be similar
to measures performed for legacy protocols by SS7 firewalls and Diameter Edge
Agents.
**Potential security requirement 4: Each network function shall implement
anti-spoofing measures by validating every incoming message for plausibility
and against its internal state machine. Messages that are not valid according
to the protocol specification and network state shall be discarded by the
NF.**
Incoming messages on N32 may also contain spoofed destination addresses or
alternatively, valid addresses that do not belong to the SEPP's own PLMN
(B.3). Whether or not this is due to any malicious intent or caused by a
misconfiguration, and regardless of the message type (C.1/C.2/C.3), the SEPP
shall never accept or forward such messages. Similarly, anti-spoofing checks
must be applied for origin identities on different protocol layers that should
belong to the same origin, e.g. source addresses, FQDNs, PLMN IDs. This is an
addition to the SEPP's anti-spoofing mechanisms already captured in the living
document on SBA security [14]. Again, detailed measures depend on Stage 3
message contents.
**Potential security requirement 5: The SEPP shall implement anti-spoofing
mechanisms that enable cross-layer validation of source and destination
address and identifiers (e.g. FQDNs or PLMN IDs). If there is a mismatch
between different layers of the message or the destination address does not
belong to the SEPP's own PLMN, the message shall be discarded.**
#### 4.2.6.2 Threat description
As the primary element of filter and policy enforcement functionality for
inter-PLMN signalling, it is one of the main tasks of a SEPP to protect the NF
of its own PLMN from malicious traffic. If it fails to do so, attackers might
be able to abuse the roaming interface to perform various types of fraud,
cause leakage of information or induce Denial of Service situations, thereby
preventing genuine customers or roaming partners from being served.
#### 4.2.6.3 Potential security requirements
The receiving SEPP shall be able to verify whether the sending SEPP is
authorized to use the PLMN ID in the received N32 message.
The SEPP shall be able to clearly differentiate between certificates used for
authentication of peer SEPPs and certificates used for authentication of
intermediates performing message modifications.
The SEPP shall discard malformed N32 signaling messages.
The SEPP shall impement rate-limiting functionalities to defend itself and
subsequent NFs against excessive CP signaling. This includes SEPP-to-SEPP
signaling messages.
The SEPP shall implement anti-spoofing mechanisms that enable cross-layer
validation of source and destination address and identifiers (e.g. FQDNs or
PLMN IDs).
### 4.2.7 Key Issue #16: N32 error signalling
#### 4.2.7.1 Issue description
#### 4.2.7.2 Threat description
#### 4.2.7.3 Potential security requirements
# 5\. General Requirements
Editor\'s note: this clause details security requirements that are not part of
a key issue such as performance requirements.
# 6 Solutions
## 6.1 Solution #1: Authorization of NF service access
### 6.1.1 Introduction
This clause specifies authorization procedures for authorizing NF service
consumer to access services provided by NF service producer.
Granularity of authorization is per service based. In the case of
authorization by NRF, prior to accessing a service defined in TS 23.502 [3],
the NF service consumer requests a token from NRF. The token records and
proves that NF service consumer is permitted to access the service provided by
the service producer. The NF service producer verifies the token before
executing the requested service. The authorization token can be reused to
avoid requesting authorization for every service access.
Editor\'s Note: It is assumed that NRF authenticates the NF service consumer
before authorization. The authentication method is FFS.
### 6.1.2 Solution details
#### 6.1.2.1 Service authorization procedure for non-roaming scenarios
Figure 6.1.2.1-1: Service authorization procedure for non-roaming scenario
1) NF service consumer to NRF: Service Authorization Request (NF type and NF
instance ID of service consumer, NF type and NF instance ID of service
producer, NF service name). Service Authorization Request is included in
Nnrf_NFDiscovery_Request [3] if the NF Service Consumer requests service
authorization along with NF service discovery request.
2) NRF to NF Service Consumer: Authorization Result (Token).
NRF checks whether the access can be permitted according to the maintained
authorization information. If the service can be authorized, NRF sends the
result along with a token that proves this authorization. The token should
include the NF type and NF instance ID of NF service consumer, the NF type and
NF instance ID of NF service producer, the NF service name that will be
accessed, and a credential such as MAC (Message Authentication Code) or
digital signature. If the token can be reused within a period of time, the
expiration date should also be included. If Service Authorization Request is
included in Nnrf_NFDiscovery_Request, NF service producer should include
Authorization Result in Nnrf_NFDiscovery_Request Response [3] which will be
sent to the NF Service Consumer.
3) NF service consumer to NF service producer: NF Service Request (NF type and
NF instance ID of service consumer, NF service name, Token).
4) NF service producer to NRF: Token Verification Request (Token).
If NF service producer is able to verify the token, step 4 and step 5 are
skipped. Otherwise, NF service producer requests NRF to verify the token
through Token Verification Request.
5) NRF to NF service producer: Token Verification Response.
NRF informs NF service producer the verification result. Token Verification
Request and Response could introduce much overhead, thus it is recommended to
verify the token by NF service producer itself.
6) NF service producer to NF service consumer: NF Service Response.
If the token is valid and the NF service Request is consistent with the
information in the token, NF service producer executes the requested service
and response to NF service consumer.
Editor\'s Note: Parameters of the messages and parameters in the token are
FFS.
Editor\'s Note: How to compute and verify the credential included in the token
is FFS.
#### 6.1.2.2 Authorization of NF service access for roaming scenario
Figure 6.1.2.2-1: Authorization of NF service access for roaming scenario
1) NF service consumer to NF service producer: NF Service Request (NF type and
NF instance ID of service consumer, NF type and NF instance ID of service
producer, NF service name).
2) NF service producer to NRF in Home PLMN: Authorization Request (NF type and
NF instance ID of service consumer, NF type and NF instance ID of service
producer, NF service name).
3) NRF in Home PLMN to NF service producer:
NRF in Home PLMN checks whether the access can be permitted according to the
maintained authorization information (static policies). If the service can be
authorized, NRF in Home PLMN sends the Authorization Response to the NF
service producer.
4) NF service producer to NF service consumer:
If authorized, NF service producer executes the requested service and response
to NF service consumer.
Editor\'s Note: The authentication mechanisms between different PLMNs is FFS.
### 6.1.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.2 Solution #2: Application layer protection based on JSON Object Signing
and Encryption (JOSE)
### 6.2.1 General
Following aspects are considered when designing a solution for e2e protection
of application layer information in the HTTP payload:
\- Which protocol to use to secure JSON content
\- Where to implement e2e security in the network
\- Which JSON information elements to protect and what kind of protection is
required
\- Algorithms to use for protection and their negotiation between two Edge
Proxy end points
\- Key management aspects including key distribution to the Edge Proxies
\- Protection mechanism that allows selective protection of the payload while
allowing other unprotected payload to be modified by the intermediaries
### 6.2.2 Application layer protection based on JOSE
JOSE [4] provides a set of specifications to protect JSON based data
structures. These include standards for:
\- representation of integrity-protect JSON data based on public-key digital
signatures as well as symmetric-key MACs using JSON Web Signing (JWS) [5],
\- representation of encrypted data using JSON Web Encryption [6],
\- specifying how to encode public keys as JSON-structured objects,
\- specifying algorithms and algorithm identifiers using JSON Web Algorithm
[7],
\- specifying a means to protect private and symmetric keys via encryption.
JOSE is used to protect JSON based application content in SBA.
#### 6.2.2.1 JSON based IEs that require protection (WHAT)
JOSE framework will be used to integrity protect all the JSON IEs in the HTTP
message payload. The JSON Web Signature [5] applies integrity protection
either based on digital signatures (asymmetric protection) or Message
Authentication Codes (symmetric protection). The resulting data structure is
of JSON type and contains JWS Signature representing a digitally signed or
MACed message payload.
JOSE framework will be used to confidentiality protect Authentication Vector
(AVs), cryptographic keys, SUPI and Location data (e.g. Cell ID and Physical
Cell ID) contained in the HTTP message. The JSON Web Encryption [6] is based
on the use of Authenticated Encryption with Associated Data (AEAD) based
encryption algorithms. Hence it applies both confidentiality protection and
integrity protection on the Authentication Vectors.
Editor\'s Note: This clause shall be revisited again in Phase 2 if any change
is identified in the list of IEs identified in this clause for protection in
Phase 1.
#### 6.2.2.2 Integrity and Confidentiality protection schemes (HOW)
Editor\'s Note: This clause shall include the following aspects - whether
Confidentiality protection and Integrity protection is based on Asymmetric
encryption or Symmetric encryption, protection schemes needed to allow
intermediate nodes to modify application layer information, if required.
##### 6.2.2.2.1 Integrity protection based on JSON patch
There is a requirement for \"e2e\" integrity protection in conjunction with
requirement for intermediaries to be able to modify the message in a
verifiable way.
Figure 6.2.2.2-1: Message flow across N32 interface
1\. The vSEPP receives an HTTP request.
2\. The vSEPP encapsulates the HTTP request into a JSON object
encapsulatedRequest consisting of three JSON objects:
\- the request lines is put into an element called requestLine containing an
element each for the method, the URI, and the protocol of the request received
in step 1.
\- the header of the request received in step 1 is put in into an element
called httpHeaders, with one element per header of the original request.
\- the body of the request received in step 1 is put into an element called
http body.
Editor\'s note: how to deal with multipart messages is FFS.
The vSEPP includes its own identity and the encapsulatedRequest into a JSON
object called partRequest as well to allow the hSEPP to identify the
originator.
Editor\'s note: it is FFS whether: The vSEPP shall include the first
intermediary\'s ID in the partRequest. This authorizes the first intermediary
to perform modifications.
Editor\'s Note: Only authorized intermediaries are allowed to perform
modifications. Authorization mechanism is FFS
Editor\'s note: whether the hSEPP should include a policy which elements are
allowed to be changed by the first intermediary is FFS.
The vSEPP integrity protects the complete partRequest using JWS.
The integrity protected partRequest is put into an array.
3\. The vSEPP uses HTTP POST to send the encapsulated request to the first
intermediary (visited network\'s IPX provider).
4\. The first intermediary (e.g. visited network\'s IPX provider) checks the
integrity and authenticity of the encapsulated request. It parses the
encapsulated request and determine which changes are required. The first
intermediary creates a JSON element called operations, taking the syntax and
semantic from RFC 6902, that, when applied as a JSON patch to the encapsulated
request, will result in the desired request. If no patch is required, the
operations element is empty.
Editor\'s note: error handling in case of failed integrity check is FFS.
The first intermediary creates a JSON element called partRequest that includes
the intermediary\'s identity, and integrity protect the partRequest in a JWS.
Editor\'s note: whether the part Request includes the hSEPP ID or the next
intermediaries\' ID to authorize further changes is FFS. Inclusion of a policy
is not required, because this would be under the home networks remit.
The integrity protected partRequest is appended to the array inside the
encapsulated request created in step 2.
5\. The first intermediary sends the encapsulated request to the second
intermediary (home network\'s IPX) as in step 3.
6\. The second intermediary checks the integrity and authenticity of the
encapsulated request and the partRequest. It parses the encapsulated request,
apply the modifications described in the partRequest and determine further
modifications required to result in the desired request. These modifications
are recorded as a further patch request. Further processing is like in step 4
(create a pertRequest and integrity protect).
Editor\'s note: it is FFS, if a policy is included in step 2, how and whether
the second intermediary can check that the first intermediary only changed
allowable elements.
7\. The second intermediary sends the encapsulated request to the hSEPP as in
step 3.
Note: The behaviour of the intermediaries is not normative, but the hSEPP
assumes that behaviour for processing the resulting request.
8\. The hSEPP checks the integrity and authenticity of the encapsulated
request and the partRequests. The hSEPP checks whether the modifications
performed by the intermediaries were permitted by policy. The hSEPP
decapsulates the encapsulated request, verify signatures, apply the patches in
the partRequests in order, perform filtering on the resulting request, and
create a new HTTP request according to the \"patched\" encapsulatedRequest.
Editor\'s note: which signatures the hSEPP needs to verify is FFS
9\. The hSEPP sends the HTTP request resulting from step 8 to the home
network\'s NF.
10.-18. These steps are analogous to steps 1.-9., but treating the HTTP
response like the HTTP request.
Below is an example to illustrate the elements in the JSON:
partRequest created by vSEPP
{
\"partRequest\": {
\"previousSignature\": \"\",
\"originatorIdentity\": \"some MNO\'s SEPP\",
\"encapsulatedRequest\": {
\"requestLine\": {
\"method\": \"POST\",
\"URI\": \"APIroot/nausf_auth/v1/ue_authentications\",
\"protocol\": \"HTTP/2\"
},
\"httpHeader\": {
\"Accept: application/json\",\ \"Content-Type: application/json\",
\"host: \": \"hplmn.f.q.dn\",
\"content-length: \": 100
},
\"body\": {
\"UE-id\": \"maguro_suci\",\ \"Serving network name\": \"some_VPLMN\",\
\"access_type\": \"5G\" }
},
\"nextHopIdentity\": \"next intermediaries name\"
}
}
partRequest created by Intermediary
{
\"partRequest\": {
\"previous\": \"\\",
\"next\": \"\\",
\"originator\": \"intermediary name\",
\"operations\": [
{
\"op\": \"replace\",
\"path\": \"/HTTP-headers/Host\",
\"value\": \"HPLMN2.com\"
},
{
\"op\": \"replace\",
\"path\": \"/HTTP-headers/Content-Length\",
\"value\": \"131\"
},
{
\"op\": \"add\",
\"path\": \"/HTTP-body/new_element\",
\"value\": \"value1\"
}
]
}
}
The complete request with change history as will arrive at the hSEPP
{
\"requestHistory\": [
{
\"integrityProtectedPartRequest\":
\"protectedHeader.protectedPayloadIsPartRequestFromVSEPP.signature\"
},
{
\"integrityProtectedPartRequests\":
\"protectedHeader.protectedPayloadIsPartRequestFromFirstIntermediary.signature\"
},
{
\"integrityProtectedPartRequests\":
\"protectedHeader.protectedPayloadIsPartRequestFromFirstIntermediary.signature\"
}
]
}
##### 6.2.2.2.2 Authorization of modifications based on JSON patch
The receiving SEPP requires a policy S which elements may be changed by the
first IPX provider and a policy R which elements may be changed by the second
IPX provider.
The sending SEPP informs the receiving SEPP of policy S either out of band or
by including the policy (or link thereto) in the message itself. The receiving
SEPP applies the policy that policies cannot be modified by intermediate IPX
providers. Policy R is local to the receiving SEPP.
Each policy consists of a list of paths with the allowed operations. Below is
an example:
\"allowed-operations\": [
{
\"op\": \"replace\",
\"path\": \"/HTTP-headers/Host\"
},
{
\"op\": \"replace\",
\"path\": \"/HTTP-headers/Content-Length\"
},
{
\"op\": \"add\",
\"path\": \"/HTTP-body/new_element\"
}
]
The receiving SEPP verifies the modifications proposed by the first IPX in the
incoming message against policy S. If a policy violation occurred, the
receiving SEPP informs the sending SEPP of the policy violation in an error
message with the appropriate HTTP error code and enough information for the
sending SEPP to pinpoint the policy violation. The receiving SEPP discards the
incoming message. The SEPP sending the original message (i.e. the one
receiving the error message) applies the policy that policy violation messages
cannot be modified by intermediate IPX providers.
The receiving SEPP verifies the modifications proposed by the second IPX in
the incoming message against policy R. If a policy violation occurred, the
receiving SEPP informs the second IPX provider out of band. The receiving SEPP
also informs the sending SEPP of the fact that a policy violation occurred in
an error message with the appropriate HTTP error code, and discard the
incoming message. The SEPP sending the original message (i.e. receiving the
error message) applies the policy that policy violation messages cannot be
modified by intermediate IPX providers.
Editor\'s Note: what the sending SEPP will do when receiving an error code is
FFS.
##### 6.2.2.2.3 Authentication of intermediaries
Each intermediary has its own certificate infrastructure. The sending SEPP
includes the root CA of the first IPX intermediary in its policy. The sending
SEPP signs its policy.
##### 6.2.2.2.4 Rewriting of HTTP message into JSON-object
The solution \"Integrity protection based on JSON patch\" described in clause
6.2.2.2.1 also contains a solution for rewriting the HTTP message into a JSON
object. Once the HTTP message has been rewritten in this way, it becomes more
straight-forward to apply JOSE protection to selected elements of the message.
Hence the rewriting process is of importance even for a solution without
standardized modifications of intermediaries.
It thus seems reasonable to consider the following steps as a separate
solution:
**Rewriting of HTTP-message into JSON-object:**
The vSEPP encapsulates the HTTP request into a JSON object encapsulatedRequest
consisting of three JSON objects:
\- the request line is put into an element called requestLine containing an
element each for the method, the URI, and the protocol of the request received
in step 1.
\- the header of the request received in step 1 is put in into an element
called httpHeaders, with one element per header of the original request.
\- the body of the request received in step 1 is put into an element called
http body.
Editor\'s Note: It is for further study, whether including the identity of the
vSEPP in the JSON-object is necessary.
#### 6.2.2.3 Key management aspects
Editors\' Note: This clause shall include the following aspects - whether
Confidentiality protection and Integrity protection is based on Asymmetric
encryption or Symmetric encryption, how to establish the required keys for
Integrity and Confidentiality protection.
### 6.2.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.3 Solution #3: NF service registration process
### 6.3.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.3.2 Solution Details
During initial provisioning and configuration of NF, NRF is configured with
NF\'s public key and other information. And NF is configured with public key
of NRF and other information.
Figure 6.3.1-1 Authentication of NF service registration
1) NF service consumer sends Nnrf_NFManagement_NFRegister Request message to
NRF, signed by NF\'s private key and encrypted using public key of NRF.
Registration request includes a nonce for replay protection.
2) NRF sends Registration response signed by NRF private key. Registration
response includes NF certificate and other parameters.
3) Upon receipt if registration response, NF service consumer checks the
integrity the Nnrf_NFRegister_Response by using public key of NRF decrypts the
payload by NF Service consumer\'s private key.
### 6.3.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.4 Solution #4: Authorization of NF service access
### 6.4.1 Introduction
During initial provisioning and configuration of NF, NRF is configured with
NF\'s public key and other information. And NF is configured with public key
of NRF and other information. During service registration, NF obtains
certificate from NRF for its public key.
Service request and response uses TLS to establish a secure session between NF
Service Consumer and NF Service Producer using their corresponding
certificates. Upon successful Service request and response, a secure
association is established between NF service consumer and NF service producer
which provides secure session between the two.
Service request and response can function within same PLMN or across PLMNs.
Subsequent sections describe the detailed flow for each case.
### 6.4.2 Solution details
#### 6.4.2.1 Authorization of NF service access in the same PLMN
Figure 6.4.2.1-1: Authorization of NF service request in the same PLMN
1\. The NF Consumer sends an NF Service request to NF producer. It contains a
self-signed client ID. Service request also includes a client TLS
[client_hello] message for the NF Producer. The contents of TLS client_hello
are defined in the TLS specification.
> 2.
a. The NF Producer forwards the Signed Client ID as a payload to IsAuthorized
message to NRF.
b. NRF verifies client ID signature. If the NF Consumer ID is successfully
verified, NRF checks the stored NF profile information to determine whether
the access can be permitted. If the service can be provided, NRF sends the
verification result back to NF Service Producer. If verification is
unsuccessful, NF Service producer does not proceed.
Editor\'s Note: IsAuthorized Request and response messages and
VerifyCertificate message need to be defined. Its format and parameters are
FFS.
> 3\. The NF Producer replies to the NF Consumer with TLS[server_hello], which
> further includes information elements such as server_hello,
> NF_P_Certificate, server_key_exchange, certificate_request,
> server_hello_done. These information elements are defined in the RFCs for
> the TLS.
>
> 4\. Upon receiving the TLS[server_hello] message NF consumer forwards the
> message to its NRF through VerifyCertificate message. NRF verifies the NF
> Producer certificate received in TLS [server_hello].
>
> 5\. Upon successful verification of NF producer certificate, NF Consumer
> replies with TLS [client key exchange], which further contains information
> element such as client_certificate (NF_C_Certificate), client_key_exchange,
> client_certificate_verify, change_cipher_spec, client_finished, etc.
>
> 6\. After receiving the TLS [client_certificate] message NF consumer
> forwards the message to its NRF through VerifyCertificate message. NRF
> verifies the NF Consumer certificate received in TLS [client_certificate] by
> NRF\'s public key.
>
> 7\. NF producer sends Nrf_Nf_Service Response with TLS [Server_finished]
> with change_cipher_spec to the NF Consumer.
>
> 8\. Session Key (K~SESSION_C_P~) is used to secure further communication
> between NF consumer and producer.
#### 6.4.2.2 Authorization of NF service access in different PLMNs
Figure 6.4.2.2-1: Authorization of NF service access across PLMNs
1\. The NF Consumer sends an NF Service request to NF producer in the home
PLMN. It contains a self-signed client ID. Service request also includes a
client TLS [client_hello] message for the NF Producer. The contents of TLS
client_hello are defined in the TLS specification.
2\. The NF Producer forwards the Signed Client ID as a payload to IsAuthorized
message to NRF in home PLMN. hNRF acts proxy for NRF in serving PLMN and
forwards the signed payload to it. Serving NRF verifies the Client ID
signature. If the NF Consumer ID is successfully verified, NRF checks the
stored NF profile information to determine whether the access can be
permitted. If the service can be provided, NRF sends the verification result
back to NF Service Produce through hNRF proxy. If verification is
unsuccessful, NF Service producer does not proceed.
Editor\'s Note: IsAuthorized Request and response messages need to be defined.
Its format and parameters are FFS.
3\. The NF Producer replies to the NF Consumer with TLS[server_hello], which
further includes information elements such as server_hello, NF_P_Certificate,
server_key_exchange, certificate_request, server_hello_done. These information
elements are defined in the RFCs for the TLS.
4\. NF Service producer\'s certificate is sent to NRF in HPLMN for
verification through the VerifyCertificate message. Serving NRF acts as a
proxy and just transfer the payload to Home NRF. The NRF in HPLMN verifies the
NF producer\'s certificate received in TLS [server_hello].
5\. NF Consumer replies with TLS [client key exchange], which further contains
information element such as client_certificate (NF_C_Certificate),
client_key_exchange, client_certificate_verify, change_cipher_spec,
client_finished etc.
6\. NF Service consumer certificate is sent to NRF in SPLMN for verification
through the VerifyCertificate message. HPLMN NRF acts as a proxy and just
transfer the payload to Serving NRF. The NRF in Serving PLMN verifies the NF
Consumers certificate received in TLS [client_certificate].
7\. NF producer sends Nrf_Nf_Service Response with TLS [Server_finished] with
change_cipher_spec to the NF Consumer.
8\. Session Key (K~SESSION_C_P~) is used to secure further communication
between NF consumer and producer.
### 6.4.1 Evaluation
Editor\'s note: The evaluation is FFS
## 6.5 Solution #5: Using mediation services with end-to-end encryption
### 6.5.1 Generic
The scenario that is depicted in the figure below is a scenario with two MNOs,
MNO A and MNO B and two IPX providers, IPX A and IPX B. The IPX provider A
provides mediation services for MNO A and IPX provider B provides mediation
services for MNO B. Both MNOs have one network function (NF), which is left
unnamed. This solution provides two possible implementations, one where two
SEPPs communicate securely with each other via HTTPS or TLS, and one where
JOSE is used for the protection of the messages between two SEPPs.
### 6.5.2 End-to-end encryption using HTTPS or TLS
In this version of the solution, it is assumed that the SEPPs themselves use
HTTPS for providing end-to-end security. In this case, the solution works as
follows:
1\. The SEPP A receives a HTTP(S) Request from NF A as usual.
2\. In case this request contains sensitive information according to clause
9.1.3.3, the SEPP A performs an action to hide these fields for the mediation
service. This action is not to be standardized. Some examples are:
a. Replacing the values of these with some other values, e.g. a hash of the
value. The SEPP A stores the hash of the value and the corresponding value
temporarily.
b. Entirely removing the fields from the message and storing bot the header
and the value temporarily.
c. Encrypting the fields using some proprietary mechanism.
3\. The SEPP A invokes the Mediate service running at the IPX A by sending a
MediateAndReturn Request message to the IPX provider. The MediateAndReturn
Request contains the message that was received from the NF A and has its
sensitive information removed or hidden according to step 2.
4\. The Mediation services performs its mediation
5\. The mediation service sends the MediateAndReturn Response message, which
contains the mediated message, to the SEPP A.
6\. Upon reception, the SEPP A reinserts the sensitive information. This
action depends on how the SEPP A has removed or hidden the sensitive
information and can be entirely proprietary.
7\. The SEPP A then sends the mediated version of the original NF A\'s request
to the SEPP B over HTTPS. So the request would look like a request that came
from NF A apart from the mediated fields.
8\. The SEPP B receives the request, and if mediation is deemed necessary, the
SEPP B also removes or hides the sensitive fields from the message.
9\. The SEPP B then invokes the Mediate service running on IPX B by sending a
MediateAndReturn Request message to IPX B.
10\. The mediation service performs its mediation.
11\. The mediation service sends the MediateAndReturn Response message, which
contains the mediated message.
12\. The SEPP B re-inserts the sensitive information.
13\. And finally, SEPP B sends the request to NF B.
In short, the solution relies on standard HTTP and HTTPS. In between the steps
2 and 6, the SEPP A will either have to keep state or use an encryption /
decryption mechanism. In between the steps 8 and 12, the SEPP B has a similar
task. In case IPX provider hosts the SEPP (e.g. for small operators), the
steps 2-6 would probably be left out altogether.
{width="6.688888888888889in" height="3.6395833333333334in"}
Figure 6.5.2-1: Mediation service using HTTPS
### 6.5.3 End-to-end security using JOSE
In this version of the solution, it is assumed that the SEPPs themselves use
HTTP request with an encrypted JOSE payload for providing end-to-end security.
In this case, the solution works as follows:
1\. The SEPP A receives a HTTP(S) Request from NF A as usual.
2\. The SEPP A takes the request and wraps the whole request into a JSON
format. So, the request headers go into a field called \'HTTPRequestHeader\',
a binary blob goes into a field called \'BinaryBlob\' and the session cookie
goes into a field called \'SessionCookie\'. Then, the SEPP determines whether
the message contains sensitive information according to clause 9.1.3.3 and
performs an action to hide these fields for the mediation service. This action
is not to be standardized. Some examples are:
a. Replacing the values of these with some other values, e.g. a hash of the
value. The SEPP A stores the hash of the value and the corresponding value
temporarily.
b. Entirely removing the fields from the message and storing bot the header
and the value temporarily.
c. Encrypting the fields using some proprietary mechanism.
3\. The SEPP A invokes the Mediate service running at the IPX A by sending a
MediateAndReturn Request message to the IPX provider. The MediateAndReturn
Request contains the message that was received from the NF A and has its
sensitive information removed or hidden according to step 2.
4\. The Mediation services performs its mediation
5\. The mediation service sends the MediateAndReturn Response message, which
contains the mediated message, to the SEPP A.
6\. Upon reception, the SEPP A reinserts the sensitive information. This
action depends on how the SEPP A has removed or hidden the sensitive
information and can be entirely proprietary. The SEPP A encrypts the message
using standard JOSE using the target SEPP\'s public key.
7\. The SEPP A then sends the mediated version of the original NF A\'s request
to the SEPP B over HTTP.
8\. The SEPP B receives the request, decrypts the request, and if mediation is
deemed necessary, the SEPP B also removes or hides the sensitive fields from
the message.
9\. The SEPP B then invokes the Mediate service running on IPX B by sending a
MediateAndReturn Request message to IPX B.
10\. The mediation service performs its mediation.
11\. The mediation service sends the MediateAndReturn Response message, which
contains the mediated message.
12\. The SEPP B re-inserts the sensitive information.
13\. And finally, SEPP B reconstructs the HTTP Request from the JSON fields
and sends the HTTP Request to the NF B.
In short, the solution relies on standard HTTP and JOSE. A complicating factor
is that the SEPPs will have to convert the **entire** HTTP Request into a JSON
object, which in itself will be contained in another HTTP request. The
receiving SEPP will have to do the reverse conversion. Like in the solution
based on HTTPS, in between the steps 2 and 6, the SEPP A will either have to
keep state or use an encryption / decryption mechanism. In between the steps 8
and 12, the SEPP B has a similar task. In case IPX provider hosts the SEPP
(e.g. for small operators), the steps 2-6 would probably be left out
altogether.
{width="6.701388888888889in" height="3.6395833333333334in"}
Figure 6.5.3-1: Mediation service using JOSE end-to-end encryption
### 6.5.4 Migration paths after accepting this solution
One possible drawback of the solution is that it will \'stick\' even past its
due date. The solution provides therefore proposes to name the mediation
service in 3GPP specs. By standardizing a name, it becomes possible to migrate
to a newer service by using a service under the newer name and migration
remains under control of 3GPP. Investments in existing services and SEPPs will
not be affected and IPX providers can distinguish themselves by operating the
newer service.
### 6.5.5 Possible deployments
In this solution, it is always assumed that the SEPP is located in the MNO
domain and the mediation service is located in the IPX domain. As a drawback,
there is an additional message exchange between the SEPP in the MNO domain and
the mediation service in the IPX domain. There are two possible deployments
that alleviate this problem:
\- Colocation of the SEPP in the IPX domain: This is a likely deployment
scenario for smaller operators, but should not be the standard preferred
option.
\- Colocation of the mediation service in the MNO domain: In this deployment,
the mediation service is run as a service on premise for the MNO. This is a
deployment scenario for larger operators, but will depend on the willingness
of IPX providers to run their service offsite.
### 6.5.6 Evaluation
This solution has a number of drawbacks:
\- It introduces additional messages (in total 4 if mediation is used twice);
\- The SEPP needs to either keep state for removing / reinserting the
sensitive fields;
\- TLS handshake for HTTP request will take time and messages;
\- MNO needs to operate both a connection to IPX Mediation Service and a
\'direct\' connection to MNO peers (both can be over the same IPX network, but
doesn\'t have to go there).
On the other hand:
\- It mostly reuses standard HTTP, etc. making it relatively easy to
implement;
\- Works with end-to-end security, also if different from what is presented
here;
\- Offers a migration path;
\- Does not expose the sensitive information to the IPX provider, while making
mediation services possible;
\- Can be specified within the timeframe available;
\- Allows IPX providers to continue to offer their services, even if end-to-
end security is used.
## 6.6 Solution #6: Policies for protection on the N32 interface
### 6.6.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.6.2 Solution details
Editor\'s Note: This section has multiple options for provisioning of
protection policy in the SEPP. Formatting of this clause is needed to list out
the options in a readable way.
A message protection policy determines which part of a certain message is
integrity protected, which part of a certain message is confidentiality
protected, and which part of a certain message is modifiable by IPX providers.
For application layer protection of messages on the N32 interface, the SEPP
applies message protection policies.
Editor\'s Note: The specification of the protection policy is in scope of CT4.
SA3 requires that the granularity is at service level or more fine-grained.
Whether \'per subscription\' is relevant, is to be discussed between SA3 and
CT4. Other details are for CT4 to decide.
If the SEPP neither has nor obtains a policy applicable for a specific
message, the SEPP applies a default policy.
Editor\'s Note: Which IEs are protected according to the default policy is for
further study.
For the protection of a specific message, an NF may include a message
protection policy applicable for that specific message into the message.
The SEPP retrieves a message protection policy from the NRF, if operator
configuration requires, e.g. when the SEPP has no message protection policy
available for a message to be sent on N32.
Editor\'s Note: It is for further study whether the procedure is a service
offered by the NRF.
The SEPP also supports local configuration of message protection policy, e.g.,
by OA&M system. Configuration may occur during initial provisioning of SEPP or
through dynamic updates any time the policy needs an update e.g., due to
network configuration change.
The SEPP sends message protection policy error messages to NFs or the NRF if
operator configuration requires, e.g. for the case that the SEPP has no policy
applicable for a specific message.
It is up to operator configuration how the SEPP behaves if more than one
policy applicable for a specific message are available to the SEPP.
### 6.6.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.7 Solution #7: Signaling based provisioning of message protection policy
in partner SEPPs
### 6.7.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.7.2 Solution details
The signaling based provisioning and update of the message protection policy
in a roaming partner SEPP allow the two SEPPs to share each other network\'s
protection policy information.
This scheme is useful in scenarios where a local SEPP obtains its message
protection policy information through an out of band mechanism such as via the
OA&M interface or from a central repository, and not via in-band scheme such
as for e.g. embedded in HTTP messages from Network functions themselves.
When the local SEPP in a network gets its initial copy of the message
protection policy or if there is an update in the network that resulted in an
update to its copy of the message protection policy the local SEPP initiates a
handshake with each of its remote partner SEPPs in different networks. It
provides its version of the protection policy to each of them. In the
response, the SEPPs in the remote network may decide to provide the latest
version of its message protection policy.
A mutually authenticated TLS connection is used for protecting SEPP to SEPP
signaling messages over N32. TLS is e2e between two SEPPs with no
intermediaries in between.
In the following illustration, Registration Request message flow from clause
13.5 in TS 33.501 is reused.
Figure 6.7-1: Signaling based provisioning of message protection policy in
partner SEPPs
1\. The SEPP which initiated the TLS connection sends a Registration Request
message to the responding SEPP including the its message protection policy for
protecting the NF service messages belonging to its network.
2\. The responding SEPP stores the received message protection policy for
network A.
3\. The responding SEPP sends a Registration Response message to initiating
SEPP including its message protection selected security mechanism for
protecting the NF service messages belonging to its network.
4\. The initiating SEPP stores the message protection policy for network B.
### 6.7.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.8 Solution #8: Inter PLMN routing and TLS: Solution Options
### 6.8.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.8.2 Bump in the TLS
In this solution option, TLS seems to be end-to-end from an NF point of view,
but is forced to be terminated in the SEPPs instead. This is made possible by
providing the SEPPs with certificates representing the remote PLMN, signed by
their own CA. This either requires a large number of pre-provisioned
certificates, certificate creation on the fly, multilevel wild card
certificates or the certificates would have to include the actual IP of SEPP.
**Pros:** No changes to current specifications.
**Cons:** Unorthodox solution, should work technically but may introduce
implementation issues. The solution needs to be repeated for possible SEPP-
IPX, IPX-IPX TLS usage.
### 6.8.3 TLS tunnel or VPN from NF to SEPP
In this solution, the inter-PLMN service request would be in http plain text
but sent to the SEPP over TLS (stunnel, etc.).
Alternatively, the transport layer protection does not need to be a TLS tunnel
but could be any \"VPN\" connection that can be authenticated and that
provides sufficient security.
**Pros:** Solves TLS issues in SEPP, same approach could be used between PLMN
and IPX.
**Cons:** Adds requirements for NFs as a separate setup for the NF-SEPP tunnel
is needed. It would not work if QUIC is introduced in a future release.
### 6.8.4 Using local SEPP FQDN in request URI
In this solution option, the URI would always point to the next-hop and hence
TLS could be terminated in an ordinary way. The actual target NF FQDN could be
carried in some other place in the header or body of the message.
{width="6.6875in" height="2.9791666666666665in"}
Figure 6.8.4-1: Message routing in roaming scenarios
NOTE: IPXs not depicted for the sake of clarity.
The message flow for this solution is the following, see also Figure 6.8.4-1:
1) The consumer NF initiates the service request towards the local vSEPP URL,
target PLMN FQDN is carried in message header or body.
2) The vSEPP forwards the service request towards the next-hop URL. The next-
hop URL may be either an IPX proxy or the SEPP of the roaming partner.
3) The hSEPP forwards the service request to the URL of the target producer
NF.
4) The producer NF sends the response back to the URL of the local hSEPP.
5) The local hSEPP forwards the service request towards the next-hop URL. The
next-hop URL may be either an IPX proxy or the SEPP of the roaming partner.
6) The vSEPP forwards the response to the consumer NF
**Pros:** Solves TLS termination issues.
**Cons** : Requires changes to current SA2 and CT4 specifications.
### 6.8.5 Evaluation
For Key issue #2: Inter-PLMN routing and TLS, solution option \"Using local
SEPP FQDN in request URI\" of Solution #8 is SA3\'s recommendation for
normative work.
## 6.9 Solution #9: N32 message anti-spoofing within the SEPP
### 6.9.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.9.2 Solution Details
As the first point of contact for incoming signalling messages on N32, it is
the responsibility of the Security Edge Protection Proxy to protect the PLMN
and its NFs from malicious messages. Such messages might contain spoofed JSON
content within the HTTP body in order to obtain unauthorized service access or
obtain information about the topology of a given PLMN. Therefore, SEPP is able
to perform anti-spoofing on incoming messages, enforcing the following
plausibility checks:
\- Matching of MNC and MCC: If MCC and MNC or PLMN-ID is contained in an
incoming message on N32, the receiving SEPP verifies that the combination of
MCC and MNC is valid.
\- Validation of the originating SEPP\'s certificate: The receiving SEPP
validates the TLS certificate of the originating SEPP. This includes matching
of the originating FQDN with the one that the certificate was issues for.
\- Matching of MNC and MCC and SEPP FQDN: If MCC and MNC or PLMN-ID is
contained in an incoming message on N32, the receiving SEPP verifies that the
originating SEPP\'s FQDN matches the one expected for the contained PLMN-ID.
\- Matching of SUPI and expected SUPI-range: If the SUPI is contained in an
incoming message on N32, the receiving SEPP verifies that it is either within
the operators own SUPI-range or the pre-configured SUPI-range of an associated
roaming partner.
In case any of the above-mentioned checks fail, the SEPP discards the incoming
message.
### 6.9.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.10 Solution #10: Mitigation against fraudulent registration attack
between SEPPs
### 6.10.1 Introduction
This solution addresses Key Issue #3: Fraudulent registration message over N32
interface.
### 6.10.2 Solution Details
To mitigate this attack, the VSEPP generates a secret based on the certificate
which negotiated between SEPPs and the PLMN ID (MCC and MNC in NF ID), or the
VSEPP generates a signature by using the PLMN ID and its private key. The
VSEPP sends the secret or signature together with the PLMN ID to the HSEPP
through the N32 message. The HSEPP verifies the secret based on the
certificate and the PLMN ID, or verify the signature based on the serving
network\'s public key and the PLMN ID. The HSEPP sends a response to the VSEPP
through the N32 message.
### 6.10.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.11 Solution #11: Security policy provisioning for SEPP
### 6.11.1 Introduction
Editor\'s note: Each solution should list the key issues that it addresses.
There may be references to the key issues different from \'X\' (when
addressing more than one key issues).
### 6.11.2 Solution Details
Figure 4.3.X-1: Security policy provisioning for SEPP
1\. The cSEPP (the SEPP in the consumer PLMN) sends a service discovery
request to the pSEPP (the SEPP in the producer PLMN). The service discovery
request message includes the name of the required service (service 1) and the
PLMN-ID of the producer PLMN.
2\. The pSEPP sends the discovery request message to the pNRF. The pNRF
generates the authorization token of the service 1, and send it to the pSEPP.
3\. The pSEPP sends a security policy request message to the pPCF. The pPCF
returns the security policy of the service 1 and the security policy of
service authorization to the pSEPP.
4\. The pSEPP sends the security policy of service 1, the security policy of
service authorization and the protected (e.g. encrypted) token in the service
discovery response message. The pSEPP protects the token based on the security
policy of service authorization.
4a. Upon receipt of the service discovery response message from the pSEPP, the
cSEPP verifies the token in the response message based on the security policy
of service authorization. In addition, the cSEPP may send a security policy
notification message based on its own configuration, which includes cSEPP-
supported security policies.
### 6.11.3 Evaluation
Editor\'s note: The evaluation is FFS
## 6.12 Solution #12: End-to-end data protection in hop-by-hop network
communication links
> Editor\'s Note:
\- Entities generating and distributing the public/private keys mentioned in
this solution need to be clarified;
\- For the proposed solution Call Flows need to be added.
### 6.12.1 Introduction
Consider a hop-by-hop network communication link, e.g., in a 5G or 4G IPX
network, whose nodes correspond to IPX entities. In particular, such a link
corresponds to N32 interface in 5G. Assume that data is arranged in a
signaling message as a sequence of information elements (IEs), e.g., as a
sequence of AVPs in the 4G Diameter protocol. For example, IEs can be
implemented as JSON elements.
Signaling messages go from source to destination via specified intermediate
peers which can be authorized to read or modify (change or delete) the IEs or
can add the new ones. The communication links thus have an intrinsic hop-by-
hop nature and, as such, can be protected in the hop-by-hop manner (e.g., by
TLS tunnels over http in 5G or by IPSec tunnels in 4G). However, such hop-by-
hop protection does not ensure end-to-end integrity protection with non-
repudiation and traceability of changes. Neither does it ensure that only
authorized nodes should perform changes in a signaling message. Neither does
it ensure that only authorized nodes should have read access to sensitive IEs.
### 6.12.2 Integrity protection with non-repudiation and traceability of
changes
The solution described in this clause ensures end-to-end integrity protection
with non-repudiation by using hash functions and digital signatures. Each node
receives only the last signaling message meant to be received by that node,
after all the changes performed by previous nodes along the link, along with
some auxiliary information.
The signaling message received by any node along the link is verified as
authentic if and only if all included digital signatures are verified as
valid. In that case, the receiving node also learns and verifies as authentic
all the change operations performed by previous nodes in the respective
received signaling messages. It also verifies as authentic any information
about the nodes (e.g., their identity attributes) associated with the
respective digital signatures. Non-repudiation is ensured by digital
signatures, with respect to this associated information. Digital signatures
are performed only by the nodes adding or modifying the IEs in a signaling
message.
The solution is defined as follows:
1\. If a node adds a new IE to the sequence, then it associates to it an index
that is different from the indexes of other IEs in the sequence, before
sending the new IE to the next node. In particular, this relates to the source
node.
2\. If a node modifies a received IE, by changing or deleting its value, then
it associates to the modified IE a hash0 value of its original value, without
modifying its index, before sending it to the next node. Here, the hash0
function must be collision-resistant, e.g., a cryptographic hash function, or,
if IE is very short, an identity function, which is not one-way.
3\. If a node does not modify a received IE, then it forwards it to the next
node in the same form.
4\. If a node neither adds new IEs nor modifies the existing IEs in a received
signaling message, then it forwards the received signaling message as a whole
to the next node.
5\. If a node adds or modifies at least one IE in a signaling message, then it
computes a hash value of the concatenation of the hash0 values of all added or
modified IEs including their indexes. Then, it computes a digital signature on
the resulting hash value, by applying the respective private key, and adds a
new IE containing the digital signature together with the indexes of the added
or modified IEs. Here, the hash function must be a cryptographic hash
function, which is both collision-resistant and one-way.
6\. Each computed digital signature should include anti-replay protection
mechanisms (e.g., based on nonces).
7\. Upon receiving a signaling message, each receiving node verifies all the
digital signatures included in the signaling message, by iteratively
exploiting the associated hash0 values of the original values of modified IEs
and by applying the respective public keys for verification.
8\. The method can be applied to all or to only selected IEs in a signaling
message, where the selection should be performed by the nodes adding new IEs.
### 6.12.3 Integrity protection with non-repudiation, traceability of changes,
and authorization
In the solution described in clause 4.3.x.2, each receiving node can locally
store the authorizations of all previous nodes for performing the changes in a
signaling message and can then verify the consistency of the traced operations
by comparing them with the stored authorizations. However, the local storage
and update of authorizations can be impractical, especially if nodes belong to
different domains. If classical digital signatures are used, then an inter-
operator public-key infrastructure (PKI) is required, which may be
impractical.
A more effective and efficient method, using attribute-based cryptosystems is
described in the following:
\- Authorization rights of a node for performing the changes in a signaling
message are expressed by an access policy in terms of the node attributes
(e.g., their identity or domain attributes).
\- Such an access policy is (dynamically) embedded in a digital signature of a
node by using attribute-based signatures (ABS) or identity-based signatures
(IBS) [3]. The node attributes are embedded in the node private key for
signing.
\- In ABS, there is a common public key for signature verification and a
multiplicity of private signing keys.
\- An ABS signature can be verified as valid if and only if the embedded node
attributes satisfy the embedded access policy and the signed information is
authentic.
\- Such write authorization rights are then verified by verifying a digital
signature and by checking if the access policy embedded in the digital
signature is compliant with the write access policy associated with an IE
(e.g., as an integral part of IE value).
### 6.12.4 Confidentiality protection with authorization
Confidentiality of sensitive IEs can be protected by using encryption. The
objective is that the source node, or any intermediate node adding new
sensitive IEs to a signaling message, should encrypt these IEs in such a way
that only the further nodes along the link that are authorized to read these
IEs (including the destination node) are in possession of the respective
private decryption key. Classical solutions are not satisfactory due to
impractical key management.
A more effective and efficient method, using attribute-based cryptosystems is
described in the following:
\- Confidentiality of selected IEs with authorized access to decryption keys
is achieved by applying attribute-based encryption (ABE) or identity-based
encryption (IBE), where the relevant read access policy is (dynamically)
embedded in ciphertext and the node attributes in its decryption key
(ciphertext-policy ABE -- CP-ABE) [9]. Preferably, both CP-ABE and ABS should
use the same public and private keys (ABES) [10]. Alternatively, the relevant
node attributes is embedded in ciphertext and the access policy in the node
decryption key (key-policy ABE -- KP-ABE) [8].
\- In ABE, there is a common public key used for encryption and a multiplicity
of private decryption keys.
\- In ABE, the decryption can work if and only if the embedded node attributes
satisfy the embedded access policy. This means that the read authorization
rights are thus ensured automatically.
\- ABE should be used for establishing a common shared key for a symmetric-key
encryption/decryption. The same key is automatically shared by the encryption
node all authorized decryption nodes. Moreover, this key can be used as
static, together with a key-derivation function in order to generate dynamic
session keys for encryption.
\- The integrity protection of modified and re-encrypted IEs should be
performed on ciphertexts, in order to enable for the nodes that are not
authorized to decrypt/read encrypted IEs to verify the integrity of these IEs.
## 6.13 Solution #13: Content and structure of protection policies
### 6.13.1 Introduction
A protection policy determines which part of a certain message is integrity
protected, which part of a certain message is confidentiality protected, and
which part of a certain message is modifiable by IPX providers. For
application layer protection of messages on the N32 interface, the SEPP
applies message protection policies.
In this solution, the following protection policies are introduced:
\- Data-type encryption policy that specifies which data types need to be
confidentiality protected;
\- A modification policy that specifies which IEs are modifiable by
intermediaries.
In addition, there is a mapping between the data-types in the data-type
encryption policy and the IEs in NF API descriptions which is given in a NF-
API data-type placement mapping. For each message, the resulting policy is the
combination of the data-type protection policy with the date-type mapping and
the data field modification policy. The resulting policy applies to the
message after rewriting by the SEPP.
In this solution, it is not specified how the data-type mapping gets to the
SEPP.
### 6.13.2 Data-type encryption policy
The SEPP contains an operator controlled protection policy that specifies
which types of data is encrypted. The data-types defined at this moment are
the following:
\- Data of the type \'SUPI\'
\- Data of the type \'location data\'
\- Data of the type \'key material\'
\- Data of the type \'authentication token\'
\- Data of the type \'other data requiring encryption\'
This policy is on a per roaming partner basis.
The policy contains an identifier that identifies the policy.
### 6.13.3 NF API data-type placement mapping
Each NF API data-type placement mapping contains the following:
\- Which IEs contain data of the type \'SUPI\'
\- Which IEs contain data of the type \'location data\'
\- Which IEs contain data of the type \'key material\'
\- Which IEs contain data of the type \'other data requiring encryption\'
Where the location of the IEs refers to the location of the IEs after the SEPP
has rewritten the message for transmission over N32.
An NF API data-type placement mapping furthermore contains data that
identifies the NF API, namely:
\- The name of the NF
\- The version
\- An identifier
NOTE: Larger networks can contain multiple NFs with the same API, e.g. three
AMFs. The NF API policy applies to all NFs with the same API.
The NF API data-type placement mapping resides in the SEPP.
### 6.13.4 Modification policy
The modification policy specifies which IEs can be modified by an IPX provider
of the sending SEPP. The IEs refer to the IEs after the SEPP has rewritten the
policy.
This policy is specific per roaming partner and per IPX provider that is used
for the specific roaming partner.
This policy resides at the SEPP.
### 6.13.5 Evaluation
This solution achieves the following:
\- The ability to configure the usage of encryption by the operator; and
A mechanism to activate and deactivate NF policies in the SEPP.
## 6.14 Solution #14: Provisioning and negotiation of protection policies
### 6.14.1 Introduction
In order for the SEPP to apply the protection policies, it needs to be
provisioned with the:
\- Data-type encryption policy;
\- NF API Data-type placement mapping;
\- The modification policy.
This solution proposes to manually configure the SEPP.
### 6.14.2 Provisioning of the policies in the SEPP
The SEPP contains an interface that the operator can use to manually configure
the protection policies in the SEPP.
The SEPP is able to store and process the following policies for outgoing
messages:
\- A generic data-type encryption policy;
\- Roaming partner specific encryption policies that will take precedence over
a generic data-type encryption policy if present;
\- One NF API Data-type placement mapping;
\- Multiple modification policies, to handle modifications that are specific
per IPX provider and modification policies that are specific per IPX provider
and roaming partner.
The SEPP is also able to store and process the following policies for incoming
messages:
\- Roaming partner specific encryption policies;
\- A modification policies per roaming partner that specifies which fields can
be modified by which IPX providers.
### 6.14.3 Negotiation of protection policies
In addition to statically configuring the protection policies between roaming
partners, two SEPPs can also exchange their modification policies in the
initial handshake. In that case, both SEPPs include their modification
policies in the initial handshake and store the received policies.
### 6.14.4 Evaluation
This solution describes how the protection policies are provisioned in the
SEPP.
## 6.x Solution #x: \
### 6.x.1 Introduction
### 6.x.2 Solution Description
### 6.x.3 Solution Evaluation
# 7 Conclusions
Editor\'s note: this section will have conclusions based on the key issues and
the proposed solutions
# 8 Recommendations
## 8.1 Recommendations for Release 15 normative work
Editor\'s note: this section will have recommendations for normative work in
Rel.15
## 8.2 Recommendations for Release 16 normative work
Editor\'s note: this section will have recommendations for normative work in
Rel.16
###### ### Annex A: Working Agreements
Editor\'s note: this section will be removed as the TR is completed.
# SBA Offline Session -- 21^st^ May 2018
**Symmetric vs. asymmetric cryptography**
\- Agreement: always use AEAD for SEPP-to-SEPP protection and signatures for
data that may require modifications by IPX providers.
\- Nokia to prepare a new CR for the TS based on S3-181948.
**Session negotiation**
\- Agreement: use TLS key exporter to derive keys directly from TLS session.
\- Agreement: same procedure to be run again (i.e. set up TLS tunnel, utilize
TLS key exporter) for key refreshment.
\- Agreement: no dedicated session keys for operator-to-IPX signaling (i.e.
data that may require modifications by IPX providers), because JWS will use
asymmetric keys that will be exchanged out of band.
\- To be captured by KPN in SBA TR (or TS directly).
**Initial handshake**
\- Agreement: Information that may be negotiated during initial handshake:
cipher suites, protection policies.
\- Nokia to prepare a new CR for the TS based on S3-181922.
**Application of ciphering/integrity protection to JSON using JOSE**
\- Message protection using JOSE is agreed and to be captured in S3-181948
(revision of S3-181890, S3-181823)
\- Way of documenting JOSE profiles still uncertain, to be discussed in
plenary session.
\- TS 33.210 seems like a good fit, but contains only TLS profiles up till
now.
\- Ericsson to prepare the final CR based on S3-181824.
**Provisioning of protection policies for the local SEPP**
\- Agreement: Manual provisioning mandatory in Rel-15, dynamic procedure ruled
out (may be added in Rel-16).
\- KPN to rephrase their discussion document (S3-181732) into a CR against the
SBA TR.
**Provisioning of protection policies for the remote SEPP over N32**
\- Agreement: Manual provisioning mandatory in Rel-15 (e.g. part of roaming
agreement), optional dynamic procedure to be defined as well by CT4.
\- KPN to rephrase their discussion document (S3-181732) into a CR against the
SBA TR.
# SBA Offline Session -- 22^nd^ May 2018
**Format of protection policies**
\- Question: Whether and how to split work on format details between SA3 and
CT4?
\- Agreement: SA3 to define the format of both policy files (for encryption
and integrity protection).
\- Protection Policy for Encryption:
\- Agreement: Protection policy for encryption is local to SEPP, i.e. not
exchanged over N32 in Rel-15 (possible exchange of policies in Rel-16 may be
defined by CT4).
\- Agreement: SEPP will be configured with \"data location information\" per
NF-type, describing where to find a certain high-level data type (SUPI,
location info, etc.) in the message, and \"data protection policy\" per
roaming partner, describing how to protect these high-level data types.
\- KPN to prepare a CR for the SBA TR.
\- Protection Policy for Integrity:
\- Agreement: Generally, same structure as Protection Policies for Encryption
(\"data location information\" + \"data protection policy\", which will
contain data that may be modified by IPX providers).
\- Agreement: Format of integrity policy to be specified by SA3, contents to
be defined by CT4. Policies will be based on re-written messages.
\- Agreement: Protection Policy for Integrity may optionally be exchanged over
N32 in Rel-15. Details are to be defined by CT4.
\- Ericsson/Docomo/KPN to prepare a CR for the SBA TR.
**Message re-writing**
\- General structure of the re-written message is agreed.
\- Unclear whether CT4 will agree to all the details. May have comments
regarding the performance of re-writing operation.
\- Nokia to prepare a CR based on S3-181908 as proposal to CT4, asking them
for feedback.
**TLS issues relating to inter-PLMN routing**
\- Resolved, taken care of in S3-181957.
**Malicious messages**
\- Agreed requirements for SEPP and NFs during SA3#91Bis in S3-181955.
\- More time needed to derive solutions.
**NF to NF authorization in inter-PLMN communication**
\- Issue is still open. Some companies questioned the use of Oauth in roaming
scenarios.
**IPX message modifications**
\- Issue is still open.
**Error handling**
\- Issue is still open.
###### ### Annex B: Options for integrity protection on the N32 interface
The JSON framework offers three cryptographic mechanisms for integrity
protection: keyed MACs, digital signatures and authenticated encryption with
additional data (AEAD). Keyed MACs and AEAD are symmetric mechanisms while
digital signatures are asymmetric.
JSON Web Signatures (JWS) [11] provide integrity protection for arbitrary data
using MACs or digital signatures. JSON Web Encryption (JWE) [2] represents
encrypted content using JSON-based data structures. All content encryption
algorithms in JWE are authenticated encryption algorithms, meaning that these
algorithms provide integrity protection of the data, as well as
confidentiality protection. All content encryption algorithms in JWE permit
the inclusion of Additional Authenticated Data (AAD). This is data which is
integrity protected but not encrypted. Therefore, JWE can be used when
confidentiality protection is only required for certain IEs. Whether JWE can
be used when no encryption is required is undefined.
Table B-1: Comparison of options for integrity protection on N32 interface
+----------------+----------------+----------------+----------------+ | | MAC | Digital | Authenticated | | | | signature | encryption | +----------------+----------------+----------------+----------------+ | C | Yes -- JWE | Yes -- JWE | Yes -- JWE | | onfidentiality | encapsulating | encapsulating | only | | and integrity | JWS or JWS | JWS or JWS | | | protection | including JWE | including JWE | | | achievable | | | | | within JOSE | | | | | framework | | | | +----------------+----------------+----------------+----------------+ | Allows | Yes | Yes | Undefined | | integrity | | | | | protection | | | | | only | | | | +----------------+----------------+----------------+----------------+ | Signature/MAC | JWS: 256 bits | JWS: 512 bits | JWE: 128 bits | | size(s) | -- 512 bits | -- 2048 bits | | | | | | | | | JWE: 128 bits | JWE: 128 bits | | +----------------+----------------+----------------+----------------+ | N | No | Yes | No | | on-repudiation | | | | +----------------+----------------+----------------+----------------+ | C | Yes | Yes | Yes | | onfidentiality | | | | | protection for | | | | | specific IEs | | | | +----------------+----------------+----------------+----------------+ | Separate keys | Yes | Yes | Maybe | | for integrity | | | (algorithm | | protection and | | | dependent) | | encryption | | | | +----------------+----------------+----------------+----------------+ | Allows IPX | Maybe -- | Yes - IPXs | Maybe -- | | modifications | Different keys | need own | Different keys | | | for endpoints | certificates | for endpoints | | | and IPXs | for signing | and IPXs | | | preferred. | message | required. | | | | changes. | | | | | Multiple | | | | | signatures can | | | | | be added to | | | | | one message. | | +----------------+----------------+----------------+----------------+
When both encryption and integrity protection are required the simplest
mechanism for integrity protection for SEPP-SEPP communications is
authenticated encryption, which is provided by all JWE encryption algorithms.
This requires the least overhead of all options, both in terms of bandwidth
and processing. Using an authenticated encryption mechanism reduces
complexity, making it less likely that mistakes will be made in securing
messages. Authenticated encryption algorithms also reduce the possibility of
combining integrity and encryption algorithms in an insecure manner.
When integrity protection alone is required the behaviour of JWE is undefined,
so JWS is a more appropriate mechanism for messages which require no
encryption. MACs are preferable to signatures in this scenario due to their
reduced overhead. Alternatively, JWE could be used, with a defined \"null\"
value for the JWE plaintext.
_An IPX might not have a relationship with every operator to whom it routes a
message, hence agreeing shared keys might be difficult. Therefore, digital
signatures are the most appropriate integrity protection mechanism for IPX
modifications. The disadvantage of using digital signatures is that they add
an overhead to communications in terms of bandwidth and a cryptographic
overhead for signing and verification. Therefore, addition of digital
signatures to every modified message could significantly increase the IPX\'s
processing requirements._
#
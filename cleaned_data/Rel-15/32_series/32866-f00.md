# Foreword
This Technical Report has been produced by the 3rd Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
The IRP methodology clearly separates between requirements, the protocol
neutral Information Service (IS) and the protocol specification called
Solution Set (SS). One of the main targets when designing this architecture
was to decouple IS and SS as it was assumed that an IS stays stable over a
very long period of time whereas Solution Sets have a shorter life time since
protocol technologies change more frequently as IT technology advances.
CORBA IDL and SOAP WSDL are used as Solution Set technologies.
The REST architectural style is very prominent for API design. The protocol of
choice for implementing REST APIs became HTTP. JSON is replacing XML as data
interchange format.
# 1 Scope
The present document evaluates REST, HTTP and JSON for their applicability to
design and implement management interfaces. It provides also best practices
and guidelines for designing management interfaces with REST, HTTP and JSON.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 32.111-2: \"Telecommunication management; Fault Management; Part
2: Alarm Integration Reference Point (IRP): Information Service (IS)\".
[3] 3GPP TS 32.300: \"Name convention for managed objects\".
[4] 3GPP TS 32.602: \"Telecommunication management; Configuration Management
(CM); Basic CM Integration Reference Point (IRP); Information Service (IS)\".
[5] ETSI GS NFV SOL 17: \"SOL REST API convention collection living document
(2017-01-30)\".
[6] ETSI GS NFV SOL 003: \"Network Functions Virtualisation (NFV) Release 2;
Protocols and Data Models; RESTful protocols specification for the Or-Vnfm
Reference Point\".
[7] ETSI GS MEC 009: \"Mobile Edge Computing (MEC); General principles for
Mobile Edge Service APIs\".
[8] IETF RFC 3986: \"Uniform Resource Identifier (URI): Generic Syntax\"
(https://www.ietf.org/rfc/rfc3986.txt).
[9] IETF RFC 6570: \"URI Template\" (https://www.ietf.org/rfc/rfc6570.txt).
[10] IETF RFC 7230: \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax
and Routing\" (https://www.ietf.org/rfc/rfc7230.txt).
[11] IETF RFC 7231: \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and
Content\" (https://www.ietf.org/rfc/rfc7231.txt).
[12] IETF RFC 7232: \"Hypertext Transfer Protocol (HTTP/1.1): Conditional
Requests\" (https://www.ietf.org/rfc/rfc7232.txt).
[13] IETF RFC 7233: \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\"
(https://www.ietf.org/rfc/rfc7233.txt).
[14] IETF RFC 5789: \"PATCH Method for HTTP\"
(https://www.ietf.org/rfc/rfc5789.txt).
[15] IETF RFC 7159: \" The JavaScript Object Notation (JSON) Data Interchange
Format\" (https://www.ietf.org/rfc/rfc7159.txt).
[16] IETF RFC 7396: \"JSON Merge Patch\"
(https://www.ietf.org/rfc/rfc7396.txt).
[17] IETF RFC 6902: \"JavaScript Object Notation (JSON) Patch\"
(https://www.ietf.org/rfc/rfc7232.txt).
[18] IETF RFC 6901: \"JavaScript Object Notation (JSON) Pointer\"
(https://www.ietf.org/rfc/rfc6901.txt).
[19] IETF RFC 6421: \"Network Configuration Protocol (NETCONF)\"
(https://www.ietf.org/rfc/rfc6241.txt).
[20] IETF RFC 8040: \"RESTCONF Protocol\"
(https://www.ietf.org/rfc/rfc8040.txt).
[21] https://martinfowler.com/articles/richardsonMaturityModel.html
[22] IETF Internet-Draft: \"JSON Schema: A Media Type for Describing JSON
Documents\" (https://tools.ietf.org/html/draft-wright-json-schema-01).
[23] IETF Internet-Draft: \"JSON Schema Validation: A Vocabulary for
Structural Validation of JSON\" (https://tools.ietf.org/html/draft-wright-
json-schema-validation-01).
[24] IETF Internet-Draft: \"JSON Hyper-Schema: A Vocabulary for Hypermedia
Annotation of JSON\" (https://tools.ietf.org/html/draft-wright-json-schema-
hyperschema-01).
[25] Fielding, Roy Thomas (2000). \"Architectural Styles and the Design of
Network-based Software Architectures\". Dissertation. University of
California, Irvine.
(https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
[26] OpenAPI Specification Version 2.0\
[(]{.underline}https://github.com/OAI/OpenAPI-
Specification/blob/master/versions/2.0.md[)]{.underline}
[27] IETF RFC 8288: \" Web Linking \" (https://www.ietf.org/rfc/rfc8288.txt).
[28] IETF Internet-Draft: \"JSON Hypertext Application Language\"
(https://tools.ietf.org/html/draft-kelly-json-hal-08).
[29] ETSI GS NFV SOL 002: \"Network Functions Virtualisation (NFV) Release 2;
Protocols and Data Models; RESTful protocols specification for the Ve-Vnfm
Reference Point\".
[30] ETSI GS NFV SOL 005: \"Network Functions Virtualisation (NFV) Release 2;
Protocols and Data Models; RESTful protocols specification for the Os-Ma-nfvo
Reference Point\".
# 3 Definitions, and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply.\ An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
CMIP Common Management Information Protocol
CORBA Common Object Request Broker Architecture
GDMO Guidelines for the Definition of Managed Objects
HAL Hypertext Application Language
HTTP Hypertext Transfer Protocol (HTTP)
IS Information Service
JSON JavaScript Object Notation
REST REpresentational State Transfer
SOAP Simple Object Access Protocol
SS Solution Set
WSDL Web Services Description Language
# 4 IRP design principles
The IRP specification process separates between requirements, protocol neutral
definitions named Information Service (IS) and protocol dependent definitions
named Solution Set (SS). This clear distinction allows to continue using
requirements and IS whilst just changing the protocol definitions in the SS.
# 5 Overview of existing Solution Sets (SS)
Since its creation 3GPP has used the following protocols: CMIP GDMO, CORBA IDL
and SOAP WSDL.
CMIP was specified by the ITU-T and geared towards the management of
telecommunication networks. It was very powerful but suffered from the lack of
tool and product support. CMIP was soon replaced by CORBA. CORBA was widely
used in the IT industry and the telecom world hoped to overcome the CMIP
issues with it. But CORBA became more complex over time, developers complained
about expensive CORBA-ORBs and problems with firewalls since tunnelling
through port 80 is not easily feasible. At the same time the World Wide Web
and its technologies saw an impressive rise and CORBA was more and more used.
Soon developers hoped for the better by using the technologies of the World
Wide Web, namely HTTP and XML and SOAP was born. SOAP is basically RPC where
the operations are described with XML and HTTP POST is used as transport. In a
way this was also a step backwards since CORBA and CMIP were object oriented
approaches with operations being invoked on the objects and not against
service endpoints. That CORBA was not used by 3GPP in this way because so
called facade objects (only real CORBA objects with IOR) were introduced as
service endpoints for scalability reasons is another story.
As with CORBA, SOAP required extensive software support on the client and
server. XML was soon considered complicated and running XML instance documents
through parsers even more complicated. Developers started to prefer JSON and
HTTP that is readily available on many servers and clients. In 2000 Roy
Fielding published in [25] with REST (**RE** presentational **S** tate **T**
ransfer) a new architectural style for designing interfaces with strict focus
on resources and not operations. HTTP and JSON can be used for implementing
REST. More and more developers adopt RESTful HTTP based interfaces.
# 6 Alternative Solution Sets (SS)
## 6.1 RESTful HTTP-based Solution Set (SS)
### 6.1.1 REST API specification in ETSI NFV SOL 17 [5]
#### 6.1.1.1 API patterns
ETSI NFV SOL 17 [5] collects all agreed REST API conventions to be applied to
the SOL REST APIs (SOL002 [29], SOL003 [6] and SOL005 at the time of writing).
In clause 5 of this document, the following two patterns are described:
\- Subscribe-Notify
\- Links
#### 6.1.1.2 Example specifications
IN ETSI NFV ISG, REST API specifications are specified, e.g. for the Or-Vnfm
reference point (see [6]).
### 6.1.2 RESTCONF Protocol in IETF RFC 8040 [20]
IETF has specified in RFC 6421 [19] a configuration management protocol
(NETCONF). A RESTified version (RESTCONF) is available in RFC 8040 [20].
### 6.1.3 Mobile Edge Service APIs in ETSI MEC 009 [7]
ETSI GS MEC 009 [7] defines RESTful mobile edge service APIs. The APIs in ETSI
MEC are developed based on these common principles and design patterns. The
document provides a rich source for the development of own guidelines.
# 7 Common principles and design patterns for a RESTful HTTP-based Solution
Set (SS)
## 7.1 Input material
As described earlier there are already numerous SDO/fora using RESTful HTTP-
based solution sets. 3GPP should consider this material as input for its work
and study possible alignment options.
## 7.2 Short review of REST
### 7.2.1 REST design principles
REST stands for **RE** presentational **S** tate **T** ransfer. It is an
architectural style defined by the following principles:
**Client-server** **architecture**
REST follows a client-server architecture. Client and server are linked by the
uniform interface. The server is concerned with data storage. The client
manipulates this data with create, read, update and delete (CRUD) operations.
This architecture allows the client and server to evolve independently.
**Stateless servers**
REST servers are stateless, meaning that no client context is stored on the
server. It is the client holding the session state. Each request from a client
contains all the information required to service the request.
**Cacheability**
REST is cacheable. The client and any intermediary can cache responses,
helping to improve system scalability and performance.
**Layered System**
REST is a **layered system**. A client cannot know if it is interacting with
the end server or an intermediate server on the way to the end server. Each
component has only knowledge about the component it is interacting with. All
components are independent and easily replaceable or extendable. This improves
system scalability and enables load-balancing.
**Code on demand**
Code on demand is an optional REST feature. It allows servers to transfer
executable code to the client, thereby extending the functionality of the
client.
**Uniform interface**
The uniform interface is the most important aspect of REST. Client and server
communicate via the uniform interface. It is characterized by the following:
> **Resource identification:** The key concept is to abstract information into
> resources. These resources have a unique resource identification. Requests
> are directed towards resources.
>
> **Resource representation:** Each resource has one or multiple
> representations. Representations can be in e.g. XML, JSON or HTML. Resource
> representations are exchanged over the wire together with any representation
> metadata. The metadata provides information about the representation, such
> as its media type, the date of last modification, or even a checksum.
>
> **Self-descriptive messages:** Messages need to be be self-descriptive. All
> the information required to process the message is included in the message.
>
> **Hypermedia as the engine of application state (HATEOAS):** This refers to
> the capability of the server to send hyperlinks to the client allowing the
> client to traverse and dynamically discover resources without referring to
> external documentation.
These principles were first described in [25].
### 7.2.2 Richardson Maturity Model
There are four levels in the Richardson Maturity Model [21].
Level 0 -- The Swamp of POX (**P** lain **O** ld **X** ML): At this level HTTP
methods are used as tunnelling mechanism for remote interaction mechanisms,
typically Remote Procedure Calls (RPCs). The HTTP POST request is sent to a
service endpoint exposed by the server. Different services may have different
endpoints but resources behind the service are not individually addressable.
This level is primarily action based.
Level 1 - Resources: At this level resources are introduced as addressable
units. HTTP requests are directed directly to these resources and not to a few
service endpoints. As in level 0, HTTP is used as tunnelling mechanism for
operations described in the message body. This level is still pretty much
action based even though actions are addressed to individual resources.
Level 2 - HTTP Verbs: At this level HTTP methods are used for their real
purpose and not just as tunnelling mechanism. This means that the type of
action the server performs is conveyed by the HTTP verb and not by operation
names in the message body. There is a clear distinction between the safe
(read-only) actions and the unsafe (read-write) actions on the resources.
Level 3 - Hypermedia Controls: At this level, the resource is completely
described in the hypermedia documents that are transported over the interface.
This is known as Hypermedia As The Engine Of Application State (HATEOAS). The
interface is self-documenting and discoverable. This creates a very dynamic
interface which has no centralized pre-defined specification. The client has
no pre-defined knowledge about the capabilities of the server. This style of
interface is well-suited to a DevOps environment where there are frequent
changes to the capabilities and structure of the interface.
It is recommended IRP REST Solution Sets comply at least with level 2. The use
of hyperlinks (level 3 feature) should also be considered when specifying REST
Solution Sets.
### 7.2.3 REST and HTTP
REST is an architectural style and not tied to any protocol. In practice,
however, REST APIs always use HTTP. As already suggested by the title of this
study, this document focuses only on an HTTP based solution.
## 7.3 Short review of HTTP
### 7.3.1 Message Format
In RFC 7230 [10] the general format of a message is given by:
HTTP-message = start-line
*( header-field CRLF )
CRLF
[ message-body ]
with:
start-line = request-line / status-line
request-line = method SP request-target SP HTTP-version CRLF
method = token
token = 1*tchar
tchar = \"!\" / \"#\" / \"\$\" / \"%\" / \"&\" / \"\'\" / \"*\" / \"+\" /
\"-\" / \".\" /
\"\^\" / \"_\" / \"'\" / \"\|\" / \"˜\" / DIGIT / ALPHA
request-target = origin-form
/ absolute-form
/ authority-form
/ asterisk-form
HTTP-name = %x48.54.54.50 ; HTTP
HTTP-version = HTTP-name \"/\" DIGIT \".\" DIGIT
status-line = HTTP-version SP status-code SP reason-phrase CRLF
status-code = 3DIGIT
reason-phrase = *( HTAB / SP / VCHAR / obs-text )
header-field = field-name \":\" OWS field-value OWS
field-name = token
field-value = *( field-content / obs-fold )
field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar = VCHAR / obs-text
obs-fold = CRLF 1*( SP / HTAB )
; obsolete line folding
; see Section 3.2.4
message-body = *OCTET
### 7.3.2 HTTP methods
#### 7.3.2.1 HTTP GET method
The HTTP GET method requests a representation of the resource specified by the
URI. It is used to retrieve one or multiple resources from the server. The
query component of the URI can be used for filtering purposes in case more
than one resource is scoped by the path-abempty part of the URI. Only those
resources passing the filtering criteria are returned.
#### 7.3.2.2 HTTP HEAD method
The HTTP HEAD method returns only the headers that are returned with a HTTP
GET method together with the message body, except for the payload header
fields.
#### 7.3.2.3 HTTP POST method
The POST method sends data in the message body to the server. In contrast to
HTTP PUT, replacing the resource representation, it requests the target
resource to process the representation enclosed in the request according to
the resource\'s own specific semantics. With this method, it is possible to
create a new resource.
When a new resource is created, 201 (Created) is returned. The returned
Location header carries the URI of the created resource. The URI of the new
resource is created by the server. The response message body contains a
representation of the created resource.
#### 7.3.2.4 HTTP PUT method
The HTTP PUT method requests that the resource representation of the target
resource be created or replaced with the representation enclosed in the
request message payload. This method replaces always the complete resource
representation. Partial resource modifications are not possible. If a resource
at the URI specified in the request does not exist yet, the server creates a
new resource at this URI.
Conditional requests (RFC 7232 [12]) using e.g. the entity tag (ETag) can be
used to prevent accidentally overwriting modifications made to a resource by
another client (\"lost update problem\").
#### 7.3.2.5 HTTP DELETE method
The DELETE method requests that the origin server deletes the resource
identified by the Request-URI. This does not imply that the underlying
information is deleted as well.
#### 7.3.2.6 HTTP CONNECT method
This method allows a client to establish a HTTP tunnel between a (first) HTTP
proxy server and a destination server, possibly involving more proxies between
the aforementioned peers. The tunnel is typically used for secured
connections.
#### 7.3.2.7 HTTP OPTIONS method
The HTTP OPTIONS method allows clients to discover the communication options
available for the target resource, namely the HTTP methods supported by the
target resource. The returned information is contained in the response header
fields and the message body. A representation for the response message body is
not defined in RFC 7231 [11].
#### 7.3.2.8 HTTP TRACE method
HTTP TRACE allows clients to request a recipient server to mirror back the
received request message in the message body of the response. This can be used
for testing and diagnostic purposes since clients can see what is received by
the recipient. The recipient is either the final server or any proxy server
before, as specified by the Max-Forwards request header value.
#### 7.3.2.9 HTTP PATCH method
The HTTP PUT method only allows a complete resource replacement. For this
reason, a new method, HTTP PATCH, has been defined by IETF in RFC 5789 [14]
for partial resource modifications. The set of changes to be applied is
described in the request message body.
RFC 7396 [16] specifies a simple method in JSON (JSON Merge Patch) allowing to
describe a set of modifications to be applied to the target resource\'s
content. JSON Merge Patch works at the level of JSON objects. An _object_ is
an unordered set of name/value pairs.
Three types of patches are described in RFC 7396 [16]:
1) Replacing the value of an already existing name/value pair by a new value.
2) Adding a new name/value pair.
3) Removing an existing name/value pair.
It is not possible to append e.g. a value to an array other than replacing the
complete object.
A more sophisticated method for describing partial resource updates, JSON
Patch, is specified in RFC 6902 [17]. This feature works with operations
(test, remove, add, replace, move, copy). The location within the target
document where the operation is performed is indicated by a JSON-Pointer value
(RFC 6901 [18]). Compared to JSON Merge Patch, this method is more powerful.
Besides partial modification of resources, it is also possible to create
multiple resources with a single HTTP PATCH request.
Conditional requests (RFC 7232 [12]) can be used also with the HTTP PATCH
method.
### 7.3.3 HTTP resources
HTTP methods act on resources identified by a Uniform Resource Identifier
(URI)..
### 7.3.4 Uniform Resource Identifiers (URIs)
URIs are used in HTTP as a means for identifying resources. The generic URI is
defined in RFC 3986 [8] by:
URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]
hier-part = \"//\" authority path-abempty
/ path-absolute
/ path-rootless
/ path-empty
HTTP uses a subset of the generic URI scheme defined in RFC 7230 [10] as:
http-URI = \"http:\" \"//\" authority path-abempty [ \"?\" query ]
[ \"#\" fragment ]
where:
authority = \
path-abempty = \
query = \
fragment = \
and:
authority = [ userinfo \"@\" ] host [ \":\" port ]
path-abempty = *( \"/\" segment )
query = *( pchar / \"/\" / \"?\" )
fragment = *( pchar / \"/\" / \"?\" )
and:
segment = *pchar
pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"
unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"˜\"
pct-encoded = \"%\" HEXDIGHEXDIG
sub-delims = \"!\" / \"\$\" / \"&\" / \"\'\" / \"(\" / \")\"
/ \"*\" / \"+\" / \",\" / \";\" / \"=\"
**Example:**
foo://example.com:8042/over/there?name=ferret#nose
\\_/ \\________________/ \\________/ \\_________/ \\__/
\| \| \| \| \|
scheme authority path query fragment
A more readable form is as follows:
http://host:port/path?queryString#fragment
### 7.3.5 URI Templates
URI Templates [9] allow to specify a range of URIs with parameters that need
to be substituted (expanded) with values for constructing the concrete URI
reference. The variable part is enclosed by curly brackets {}.
URI Templates can be used for interactions on the wire but also for specifying
interfaces.
**Example:**
http://www.example.com/api/post/{id}
With id=5 this gives
http://www.example.com/api/post/5
## 7.4 Usage of HTTP
### 7.4.1 URI structure
The URI should follow a common structure. One possibility is to align with
ETSI GS NFV SOL 003 [6]. In this case the URI without the query component
follows the structure:
URI = {URI-prefix}/{resourcepath}
URI-prefix = {irpRoot}/{irpName}/{irpVersion}
where:
{irpRoot} indicates the scheme (\"http\" or \"https\"), the host name and
optional port, and an optional prefix path.
{irpName} indicates the IRP name.
{irpVersion} indicates the version of the IRP.
When comparing this URI scheme to the http-URI you get:
http-URI = \"http:\" \"//\" host [ \":\" port ] path-abempty [ \"?\" query ]
\\____________________________/\\_/\\_/\\_/
\| \| \| \|
irpRoot irpName \| \|
irpVersion \|
resourcepath
The optional userinfo component is not used.
**Example 1:**
This example illustrates the URI for the case of an Interface IRP not
operating on a NRM IRP.
http://example.com:80/optionalPrefixPart/exampleInterfaceIRP/V1/...
**Example 2:**
This example illustrates the URI for the case of an Interface IRP operating on
a NRM IRP. Besides the version of the Interface IRP the version of the NRM IRP
needs to be indicated.
http://example.com:80/optionalPrefixPart/exampleInterfaceIRP/V1/exampleNRMIRP/V7/...
### 7.4.2 Resource identification
TS 32.300 [3] defines the approach for naming a MOI as follows:
\"_ITU-T Recommendation X.500 [2] uses the AttributeType (defined for use as
the first component of the AttributeTypeAndValue of a RDN) to identify one
attribute of the subject MO for naming purpose. This AttributeType is called
the naming attribute to distinguish itself from other attributes that may be
present in the MO._ \"
Based on this definition, the RDN can be defined as:
RDN = \"/\"{namingAttribute} \"/\" {namingAttributeValue}
and the resource path is the concatenation of RDNs separated by \"/\".
resourcePath = *( \"/\" RDN )
The slash \"/\" is used in this approach as delineator between RDN components
and between the naming attribute and the naming attribute value. Another
possibility is to use the equal sign \"=\" as delineator between the naming
attribute and the naming attribute values, making the URI more readable.
RDN = \"/\"{namingAttribute} \"=\" {namingAttributeValue}
As naming attribute the class name can be used.
**Example:**
.../SubNetwork/south/IRPAgent/5/ManagedElement/Berlin6754/ENBFunction/1
.../SubNetwork=south/IRPAgent=5/ManagedElement=Berlin6754/ENBFunction=1
There are two options for identification of resources in a RESTful interface:
**Option 1: Server allocates the resource identifier.**
In this option, the namingAttributeValue is used only in the body of HMTL
messages. The server allocates an identifier to be used in the URI.
The client uses a POST message to create a resource, and the server responds
with the resource identifier.
**Example:**
POST www.example.org/network/utranCell HTTP/1.1
{
\"id\" : \"CityCenterCell17\"
}
HTTP/1.1 201 Created
Location: /network/utranCell/8fbc8f030303cdc1
After the resource is created, all subsequent messages refer to the resource
identifier.
**Example:**
DELETE www.example.org/network/utranCell/8fbc8f030303cdc1 HTTP/1.1
HTTP/1.1 200 OK
**Option 2: Client allocates the resource identifier.**
In this option, the namingAttributeValue is used in the URI.
The client uses a PUT message to add the resource to the list of resources.
The server does not allocate another identifier.
**Example:**
PUT www.example.org/network/utranCell/CityCenterCell17 HTTP/1.1
HTTP/1.1 200 OK
After the resource is created, all subsequent messages use the
namingAttributeValue as the resource identifier.
**Example:**
DELETE www.example.org/network/utranCell/CityCenterCell17 HTTP/1.1
HTTP/1.1 200 OK
### 7.4.3 Metadata language for the message body
#### 7.4.3.1 Data transport language
There are two commonly-used languages used to transport data in a RESTful
message body; JSON and XML.
JSON is optimized for the transport of models, while XML is optimized for the
transport of documents.
Because the communication between IRP Manager and IRP Agent is based on
information models, JSON is recommended as the data transport language.
JSON is defined in RFC 7159 [15] and JSON Schema is defined in [22], [23] and
[24].
#### 7.4.3.2 Specification language
To provide a machine-readable version of an interface specification, 3GPP
publishes a Solution Set document which formally describes the schema for each
interface. A similar formal schema will be needed for each RESTful interface.
For JSON, there are two parts to this formal description:
\- The behaviour of the API may be described according to the OpenAPI
specification [26].
\- The format of the JSON document may be described by a JSON Schema, as
defined in the OpenAPI specification [26].
Open API descriptions and JSON Schemas may be expressed as either JSON
documents or as YAML documents.
#### 7.4.3.3 Support for Network Resource Models
As part of the Solution Set for an Interface IRP, there is a need for a
description of how the Network Resource Model will be transported on the
interface. A placeholder for the Network Resource Model needs to be created.
Figure 7.4.3.3.1 shows an example of how a SOAP Solution Set describes a
placeholder (marked in red) for a managed object.
Figure 7.4.3.3.1: Example of placeholder for Network Resource Model in SOAP
Solution Set
In a RESTful interface, it is possible to transport multiple files in a single
request. This allows the possibility that the Network Resource Model could be
described in a JSON document that is separate from the main body of the
request. This has the advantage that the Network Resource Model descriptor
could be validated in real time, because it is not embedded as part of another
document. Figure 7.4.3.3.2 shows an example of how a JSON Solution Set could
describe an external reference (marked in red) for a managed object.
Figure 7.4.3.3.2: Example of external file for Network Resource Model in JSON
Solution Set
### 7.4.4 Usage of HTTP headers and media types
Media types are used in HTTP headers for the following purposes:
\- The Accept-Type HTTP header in a request indicates which media types the
client supports. This is used for content format negotiation between server
and client.
\- The Content-Type\" HTTP header indicates the media type of the message
body.
Media types that are supported are listed below:
\- application/json (RFC 7159 [15])
\- application/merge-patch+json (RFC 7396 [16])
\- application/json-patch+json (RFC 6902 [17])
## 7.5 Design Patterns
### 7.5.1 Information model for examples
The following class diagram is used for examples in clause 7.5.
{width="1.6979166666666667in" height="3.0416666666666665in"}
Figure 7.5.1.1: Class diagram
The corresponding JSON Schema definitions are given by:
{
\"title\": \"Ensemble class\",
\"description\": \"Ensemble class definition serving as example in 3GPP TR
32.866\",
\"type\": \"object\",
\"properties\": {
\"id\": { \"type\": \"string\" },
\"type\": { \"type\": \"string\" }
}
}
and
{
\"title\": \"Part class\",
\"description\": \"Part class definition serving as example in 3GPP TR
32.866\",
\"type\": \"object\",
\"properties\": {
\"id\": { \"type\": \"string\" },
\"name\": { \"type\": \"string\" },
\"vendor\": { \"type\": \"string\" },
\"size\": { \"type\": \"integer\"}
}
}
Furthermore, the following instances are assumed:
\- There is one instance of the class Ensemble with the id=1.
\- There are three instances of the class Part with id=a, id=b and id=c.
The instances could look like:
{
\"id\": \"z\",
\"type\": \"baseStation\"
}
and
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
Multiple instances of the Part class can be transferred in the message body in
an array containing a Part class instance as JSON object.
[
{
\"id\": \"a\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
},
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
},
{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
]
### 7.5.2 Design pattern for READ operations (scope: one resource)
READ operations for single resources are mapped to the HTTP GET method. The
resource to be retrieved is identified by the URI.
**Example:**
The resource representation of the Part class instance with id=b is to be
read. A GET is invoked on the corresponding URI. In case of success 200 OK is
returned.
GET /Ensemble/1/Part/b HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
It is also possible to return the location of the resource. In this case the
id attribute is not required any more.
HTTP/1.1 200 OK
Content-Type: application/json
{
\"href\": \"/Ensemble/1/Part/b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
### 7.5.3 Design pattern for READ operations (scope: multiple resource)
READ operations for multiple resources are be mapped to the HTTP GET method.
For the selection of multiple resources two approaches are possible:
\- With GET ...{root}/{ClassName} it is possible to retrieve all resources of
type class name below the root resource. Alternatively, a new resource
{ClassName}s can be introduced below the {root} resource. Invoking a GET on
this resource returns also all ClassName instances.
\- Other resource selection mechanisms can be realized with the query part of
the URI, where scoping and filtering constructs can be placed, see clause
7.5.13.
**Example:**
The resource representations of all Part class instances is read.
GET /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
[
{
\"id\": \"a\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
},
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
},
{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
]
**Example:**
The base object and the complete subtree below the base object are retrieved.
In the example response given below the name containment is reflected in the
JSON structure. It is also possible to return a plain list of object instances
where each object contains its own URI.
GET /Ensemble/1?scopeType=BASE_SUBTREE HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
[
{
\"id\":\"z\",
\"type\":\"baseStation\"
},
{
\"Part\":
[
{
\"id\": \"a\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
},
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
},
{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
]
}
]
### 7.5.4 Design pattern for UPDATE operations (complete update)
For updating a complete resource HTTP PUT is used. The resource is updated
with the representation in the request message body.
In case only a part of the resource needs to be updated, the agent can GET the
resource representation, modify it and send the modified complete resource
representation back to the server using PUT. All attributes of the resource
with final values need to be sent in the message body. Missing attributes will
be set by the server to empty or null value. Alternatively, HTTP PATCH can be
used for partial updates.
Multiple resources can be selected for an update with the scoping and
filtering design pattern.
**Example:**
Update the Part class instance with id=b, change the size attribute from \"2\"
to \"5\". Even though the other attributers are not touched, they need to be
present in the request message body.
PUT /Ensemble/1/Part/b HTTP/1.1
Host: example.org
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
### 7.5.5 Design pattern for UPDATE operations (partial update)
HTTP PATCH is used when only a part of the resource needs to be replaced. The
changes to be applied to the target resource are described in the request
message body. RFC 7396 [16] describes a simple method for JSON (JSON Merge
Patch) to describe these modifications. Another, more sophisticated method is
JSON Patch specified in RFC 6902 [17].
The query part of the URI can be used for scoping and filtering multiple
resources.
**Example 1:**
This example demonstrates the use of JSON Merge Patch for changing the size
attribute of the Part class instance identified by id=b from \"2\" to \"5\"..
In contrast to PUT, only the size attribute needs to be present in the request
message body. The unmodified attributes can be omitted.
PATCH /Ensemble/1/Part/b HTTP/1.1
Host: example.org
Content-Type: application/merge-patch+json
{
\"size\": 5
}
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
**Example 2:**
This example shows how the size attribute is modified with JSON Patch.
PATCH /Ensemble/1/Part/b HTTP/1.1
Host: example.org
Content-Type: application/json-patch+json
[
{
\"op\": \"replace\",
\"path\": \"/size\",
\"value\": \"5\"
}
]
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
### 7.5.6 Design pattern for CREATE operations (single resource)
When the identifier of the new resource is to be created by the server, the
HTTP POST method needs to be used for resource creation. In case the
identifier is to be created by the client and used by the server, the HTTP PUT
method needs to be used.
**Example:**
A new Part class instance is created using the POST method. In case of success
\"201 Created\" is returned. The location header value refers to the new
resource. The name of the resource is created by the server.
POST /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": \"5\"
}
HTTP/1.1 201 Created
Location: /Ensemble/1/Part/6384
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
**Example:**
Assume the Part class instance with id=b does not exist yet. A PUT at the
location /Ensemble/1/Part/b creates this resource. In case off success \"201
Created\" is returned. The location header value refers to the new resource.
PUT /Ensemble/1/Part/b HTTP/1.1
Host: example.org
Content-Type: application/json
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
HTTP/1.1 201 Created
Location: /Ensemble/1/Part/b
### 7.5.7 Design pattern for CREATE operations (multiple resources)
The location header can carry only one URI. For this reason, HTTP POST or HTTP
PUT cannot be used for creation of multiple resources, unless the URIs of the
created resources are made known to the server in some other way than in the
location header response. One possibility to do so is to return \"303 See
Other\" and a location header pointing to a resource containing the links of
all created resources.
Another possibility is to use HTTP PATCH with JSON Patch for creation of
multiple resources.
**Example:**
Assume the part class instances with id=b and id=c do not exist yet and are
created with a single HTTP PATCH method invocation. JSON PATCH is used to
describe the resources to be created.
PATCH /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json-patch+json
[
{
\"op\":\"add\",
\"path\":\"/\",
\"value\":{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
}
},
{
\"op\":\"add\",
\"path\":\"/\",
\"value\":{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
}
]
HTTP/1.1 200 OK
Content-Type: application/json
[
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
},
{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
]
### 7.5.8 Design pattern for DELETE operations (single resource)
The HTTP DELETE method is used for deleting single resources.
**Example:**
The Part class instance with id=b is deleted.
DELETE /Ensemble/1/Part/b HTTP/1.1
Host: example.org
HTTP/1.1 204 No content
### 7.5.9 Design pattern for DELETE operations (multiple resources)
HTTP PATCH with JSON Patch is used for deleting multiple resources.
**Example:**
The Part class instances with id=b and id=c are deleted.
DELETE /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json-patch+json
[
{
\"op\":\"remove\",
\"path\":\"/b\",
\"value\":{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
}
},
{
\"op\":\"remove\",
\"path\":\"/c\",
\"value\":{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
}
]
HTTP/1.1 200 OK
Content-Type: application/json
[
{
\"id\": \"a\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
}
]
### 7.5.10 Design pattern for SUBSCRIBE/NOTIFY operations
HTTP is based on requests and responses. There is no built-in support for
notifications and subscriptions to notifications. These mechanisms need to be
modelled. To this end the server exposes a subscription resource. To subscribe
to notifications the subscriber sends a HTTP POST request to this resource
indicating -- in the message body - the subscriber to which notifications are
sent to, and including information about the type of notifications that are
subscribed to. Additional filter information may be included in the message
body as well.
Upon reception of a HTTP POST request the HTTP server creates a dedicated
subscription resource for this specific subscription. To cancel a
subscription, the subscriber deletes this resource with HTTP DELETE. If the
cancellation is successful, the server responds with response code 204 (No
content).
To send a notification on the occurrence of a notifiable event the HTTP server
sends a HTTP POST request to the client identified by HTTP endpoint address.
The actual notification content is included in the message body of the HTTP
POST request. Conceptually this means that the HTTP server contains a reduced
feature HTTP client for sending HTTP POST requests, and vice versa, the HTTP
client contains a reduced feature HTTP server for receiving HTTP POST requests
and sending HTTP POST responses.
The subscriber can retrieve the information about a specific subscription by
sending a HTTP GET request to the URI returned by the server upon creation of
this subscription. Information about all subscriptions of a subscriber can be
read by invoking a HTTP GET on the parent subscription resource whilst
instructing the server, using the query component, to return only the
subscriptions related to the client invoking the request.
**Example:**
This example shows how to subscribe to notifications.
POST /Subscriptions HTTP/1.1
Host: example.org
Content-Type: application/json
{
\"subscriberAddress\": \"http://subscriber.com/SubscriptionX\",
\"subscribedNotificationTypes\": \"all\",
\"notificationFilter\": \"filterValue\"
}
HTTP/1.1 201 Created
Location: /Subscriptions/7324
Content-Type: application/json
{
\"subscriberAddress\": \"http://subscriber.com/SubscriptionX\",
\"subscribedNotificationTypes\": \"all\",
\"notificationFilter\": \"FilterValue\"
}
**Example:**
This example shows how to send a notification.
POST /SubscriptionX HTTP/1.1
Host: subscriber.com
Content-Type: application/json
{
\"notificationType\": \"alarm\",
\"alarmedResource\": \"example.org/Ensemble/1/Part/b \",
\"eventTime\": \"2017-08-09T13:37:27+00:00\"
}
HTTP/1.1 204 No Content
**Example:**
This example shows how to delete a subscription.
DELETE /Subscriptions/7324 HTTP/1.1
Host: example.org
HTTP/1.1 204 No Content
**Example:**
This example shows how to query information about a specific subscription.
GET /Subscriptions/7234 HTTP/1.1
Host: example.org
HTTP/1.1 200 Ok
Content-Type: application/json
{
\"subscriberAddress\": \"http://subscriber.com/SubscriptionX\",
\"subscribedNotificationTypes\": \"all\",
\"notificationFilter\": \"FilterValue\"
}
### 7.5.11 Design pattern for TASK operations
Due to their complexity, some operations cannot be mapped easily into CRUD
operations. For these operations task resources are introduced.
Task resources are created below a parent resource to which the task is
related to. The tasks are invoked by sending a HTTP POST request to the
resource. Input parameters can be specified in the message body of the POST
request. Output parameters can be returned in the message body of the POST
response. The name of the resource should be a verb describing the invoked
action.
.../foo/doSomething
Task resources are created automatically by the HTTP server once the parent
resource is created. The HTTP client does not need to create them.
The RMM level 1 can be obtained with task resources. For this reason the use
of task resources is discouraged.
### 7.5.12 Design pattern for asynchronous operations
Some operations cannot be mapped to synchronous HTTP requests and responses.
For these operations, various options exist to implement asynchronous
operations over a HTTP interface.
**Option 1: Client requests a notification to a callback URI**
In this option, the client submits a callback URI while requesting the
asynchronous operation. This URI is called when the asynchronous operation is
complete.
**_To invoke an operation:_**
> The client sends a GET request to an operation-style URI, for example
> \"/network/utranCell/Cell13784/upgrade\". The request contains a link to a
> callback URI so that the client may be notified when the request is
> completed. If the request is accepted, the server responds with status 200
> (OK). If the request is not accepted, the server responds with status 4xx or
> 5xx.
**_To cancel an ongoing operation:_**
> Cancellation is not possible.
**_To check the status of an operation:_**
> Status check is not possible.
**_Advantages:_**
> This option is very simple to implement.
**_Disadvantages:_**
> This option does not properly use the RESTful nature of HTTP, it only uses
> HTTP as a carrier protocol. The Solution Set needs to describe proprietary
> handling of request state transitions and error handling.
>
> The client and server need to agree in advance which operations will be
> asynchronous.
>
> It is not possible for the client to check the status of the request or to
> cancel the request.
**_Maturity level:_**
> This option is at Richardson Maturity Level 0. The action is described in
> the URI, not in the HTTP verb. The status of the request is not reported to
> the client.
**Option 2: Client creates a resource to represent the operation**
In this option, the client creates and manages a resource to represent the
asynchronous operation. This resource is used to represent the actions on the
operation and the error conditions of the operation.
**_To invoke an operation:_**
> The client POSTs a request to an operation-style URI, for example
> \"/network/utranCell/Cell13784/upgrade\". Optionally, the request may
> contain a link to a callback URI so that the client may be notified when the
> request is completed. If the request is accepted, the server responds with
> status 201 (created) and a link to a status URI (for example \"Location:
> /network/utranCell/Cell13784/upgrade/75CD01A7110C\"). If the request is not
> accepted, the server responds with status 4xx or 5xx.
**_To cancel an ongoing operation:_**
> The client invokes a DELETE operation on the status URI. If the cancellation
> is successful, the server responds with response code 204 (success). If it
> is not possible to cancel the ongoing operation, the server responds with
> response code 405 (method not allowed).
**_To check the status of an operation:_**
> The client invokes a GET operation on the status URI. The server responds
> with response code 200 (OK) and the body of the response describes the
> current status of the operation (for example ongoing/success/failed).
>
> If the operation has finished, the server may remove the status URI after a
> suitable timeout. Any requests to the removed URI should result in response
> code 410 (gone).
**_Advantages:_**
> This option is compatible with existing 3GPP SA5 Information Models.
**_Disadvantages:_**
> This option does not properly use the RESTful nature of HTTP, it only uses
> HTTP as a carrier protocol. The Solution Set needs to describe proprietary
> handling of request state transitions and error handling.
>
> The client and server need to agree in advance which operations will be
> asynchronous.
>
> Every operation is expressed as a POST. This causes misuse of HTTP verbs in
> some cases, for example an asynchronous request to delete a resource needs
> to be encapsulated within a POST request.
**_Maturity level:_**
> This option is at Richardson Maturity Level 1. The action is described in
> the URI, not in the HTTP verb. The status of the request is described in the
> HTTP body, not in the HTTP status code.
**Option 3: Server creates a resource to represent the operation**
In this option, the server creates and manages a resource to represent the
asynchronous operation. HTTP verbs are used to represent the actions on the
operation and HTTP status codes are used to report the error conditions of the
operation.
**_To invoke an operation:_**
> The client sends a request (POST/PUT/DELETE) containing \"Expect:
> 200-ok/201-created/202-accepted\" in the request header.
>
> If the server is able to processes the request synchronously, the server
> responds with code 200 (OK) or 201 (created).
>
> If the server is not able to processes the request synchronously, the server
> responds with status 202 (accepted) and a link to a status URI (for example
> \"Location: /request/9EB50DADABDF\").
>
> If the request is not accepted, the server responds with status 4xx or 5xx.
**_To cancel an ongoing asynchronous operation:_**
> The client invokes a DELETE operation on the status URI. If the cancellation
> is successful, the server responds with response code 204 (success). If it
> is not possible to cancel the ongoing operation, the server responds with
> response code 405 (method not allowed).
**_To check the status of an asynchronous operation:_**
> The client invokes a GET operation on the status URI. If the operation is
> still ongoing, the server responds with response code 200 (OK). If the
> operation is finished and an object exists as a result of the operation, the
> server responds with response code 303 (see other link) and the URI of the
> object. If the operation is finished and no object exists as a result of the
> operation, the server responds with response code 410 (gone).
>
> If the operation has finished, the server may remove the status URI after a
> suitable timeout. Any requests to the removed URI should result in response
> code 410 (gone).
**_Advantages:_**
> This option is compatible with cloud-style interfaces. Standard HTTP verbs
> and HTTP error codes are used properly. Because the behaviour is consistent,
> code may be reused or automatically generated.
**_Disadvantages:_**
> This option is very different to the existing 3GPP SA5 solution sets. A
> typical 3GPP SA5 Information Model defines the behaviour of an asynchronous
> operation, and this behaviour may differ for various managed objects. In
> this option, the behaviour of the asynchronous operation is always the same,
> which may cause a mismatch between the Information Model and the Solution
> Set.
**_Maturity level:_**
> This option is at Richardson Maturity Level 2. The lifecycle of the request
> is controlled by HTTP verbs and is reported by the HTTP status codes.
### 7.5.13 Design pattern for scoping and filtering
The hierarchical path component in the URI serves to identify a resource,
called the base resource. The scope defines the resources below the base
resource or at the same level as the base resource. A subset of the scoped
resources can be selected by applying one or multiple filtering criteria. The
scoped resources that match the filter criteria are those on which the HTTP
operation is being applied to.
The query component in the URI is used for scoping and filtering. The query
component is indicated by the first question mark (\"?\") character and
terminated by a number sign (\"#\") character or by the end of the URI.
In RFC 3986 [8] the query component is defined as:
query = *( pchar / \"/\" / \"?\" )
A filter language is not defined in IETF. In ETSI GS NFV SOL 003 the following
filter language is specified
simpleFilterExpr := \[\".\"\]*\".\"\\"=\"\
filterExpr := \"?\"\[\"&\"\]*
op := \"eq\" \| \"neq\" \| \"gt\" \| \"lt\" \| \"gte\" \| \"lte\" \| \"cont\"
\|\ \"ncont\"
attrName := string
with
* * *
Operator \ Meaning \.eq=\[,\]* Attribute **equal**
to one of the values in the list \.neq=\[,\]*
Attribute **not** **equal** to any of the values in the list
\.gt=\ Attribute **greater than** \
\.gte=\ Attribute **greater than or equal** to \
\.lt=\ Attribute **less than** \
\.lte=\ Attribute **less than or** **equal** to \
\.cont=\[,\]* Attribute **contains** (at least) one of
the values in the list \.ncont=\[,\]* Attribute **does
not** **contain** any of the values in the list
* * *
NOTE: The choice of filtering language and method is not relevant at this
stage and may be subject for discussion in the normative phase.
The scope can be defined as follows:
...?scopeType={scopeTypeValue}&scopeLevel={scopeLevelValue}
scopeTypeValue = \"BASE_ONLY\" / \"BASE_NTH_LEVEL\" / \"BASE_SUBTREE\" /
\"BASE_ALL\"
scopeLevelValue = *DIGIT
The scope types are defined in TS 32.602 [4], and repeated here for
convenience:
\- BASE_ONLY: select the base object, value of Level is ignored
\- BASE_NTH_LEVEL: select all _n_ th level (indicated by the value of Level)
subordinate objects
\- BASE_SUBTREE: select the base object and all of its subordinates down to
and including the _n_ th level
\- BASE_ALL: select the base object and all of its subordinates; value of
Level is ignored
Another simpler but also less rich possibility to select certain resources is
to invoke a HTTP method not on a leaf resource but on a resource before the
leaf object.
**Example 1:**
This URI scopes the leaf resource with the id=c, which is the normal case
where one resource is selected.
.../Ensemble/1/Part/c
**Example 2:**
This URI scopes all three instances of Part with the id=a, id=b and id=c
.../Ensemble/1/Part
**Example 3:**
This URI scopes the instance of Ensemble with id=1
.../Ensemble/1
**Example 4:**
This URI scopes all instances of Ensemble, in this case hence only the
instance with id=1
.../Ensemble
### 7.5.14 Design pattern for attribute selection
This design pattern allows to select the attributes to be returned by the GET
method. This pattern is not applicable to any other HTTP methods.
The attributes to be returned are specified in the query part of the URI with
a key value pair. The key is \"fields\", the value is equal to the attribute
names separated by a comma.
**Example 1:**
In this example only the attributes \"vendor\" and \"size\" are selected to be
returned.
GET /Ensemble/1/Part/b?fields=vendor,size HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
{
\"vendor\": \"XYZ\",
\"size\": 5
}
### 7.5.15 Design pattern for links
Links are used on Level 3 of the Richardson Maturity Model. Links are returned
by the server as part of the resource representation and used by the client to
traverse the resource space and discover features of the resources without the
need to consult external documents. In its most simple form the value of a
link is a URI or a templated URI pointing to another resource (target
resource). This information can be complemented by information about how the
target resource relates to the context resource (link relation type) and
attributes describing the target resource (target attributes).
RFC 8288 [27] describes links to be used in HTTP header fields. The general
mechanisms can be used also for conveying links as part of the resource
representation in the response message body. However, a JSON Schema for
annotating returned resource representations with links would have to be
defined.
The IETF Internet \"Draft JSON Hypertext Application Language\" [28] proposes
a new media type for representing resources and their relations with
hyperlinks. The JSON Hypertext Application Language (HAL) introduces a
\"_links\" property whose property names (keys) are link relation types
defined by RFC 8288 [27]. The property value is a Link Object or an array of
Link Objects. A Link Object represents a hyperlink from the containing
resource to another resource identified by the URI. A link Object has a couple
of properties (key-value pairs):
\- The \"href\" property identifies the other resource and its value is either
a URI or a URI Template.
\- The \"templated\" property specifies if the URI is templated or not. Its
value is boolean (true/false).
\- The \"type\" property indicates the media type of the resource
representation to be expected from the target resource. Its value is a string.
\- The presence of the \"deprecation\" property indicates that the link is to
be deprecated. Its value is a URI pointing to a resource containing more
information about the deprecation.
\- The \"name\" property can be used as secondary key besides the relation
type.
\- The \"profile\" property is a URI pointing to a resource with information
about the profile of the target resource.
\- The \"title\" property is a string and allows to add a human-readable name
for the link.
\- The \"hreflang\" property is a string and indicates the language of the
target resource.
It is recommended that each link object should always contain a link
identifying the resource itself. The link type is the IANA registered
\"self\".
It is not possible to provide in the Link Object information to the client on
which HTTP methods are accepted by the target resource. However, it is
possible to specify a URI in the link relation pointing to a resource
providing documentation about the target resource like the supported HTTP
methods.
HAL features also a \"_embedded\" property. Its name is a link relation type
and its value a resource object or an array of resource objects. Resource
representations are those of the target URI or related to the target URI. The
server decides to include his property in the response. Some REST guidelines
also suggest the usage of an embed query parameter to allow the client to
force the inclusion of the \"_embedded\" property.
Besides HAL there is also the IETF Internet Draft \"JSON Hyper-Schema: A
Vocabulary for Hypermedia Annotation of JSON\" [24] proposing keywords for
defining link description objects. The general approach is the same as for
HAL. Nevertheless, there are differences in syntax and semantics. In HAL, for
example\" the relationship type is carried by the property names of the name-
value pairs included in the \"_links\" object whereas in the JSON Hyper-Schema
a dedicated property (\"rel\") is defined for that purpose. The keyword for
link description objects is \"links\" and not \"_links\". As for HAL many
keywords are defined for specifying properties on link description objects.
This study does not make any recommendation on which hyperlink standards
should be used.
**Example 1:**
This example demonstrates the usage of HAL. A hyperlink to the alarm resource
itself is returned as well as the links to the previous and the next alarm.
The link relation types \"self\", \"next\" and \"prev\" are used to identify
the semantics of the link. They are registered at IANA.
{
\"_links\": {
\"self\": {\"href\": \"http://example.org/AlarmIRP/v1/Alarms/127\"},
\"next\": {\"href\": \"http://example.org/AlarmIRP/v1/Alarms/128\"},
\"prev\": {\"href\": \"http://example.org/AlarmIRP/v1/Alarms/126\"}
}
}
**Example 2:**
This example illustrates the use of a templated URI with Path Segment
Expansion. The client can expand the templated URI with a specific alarm id
and obtains the URI for retrieving the corresponding alarm resource.
{
\"_links\": {
\"find\": {\"href\": \"http://example.org/AlarmIRP/v1/Alarms{/id},
\"templated\": true \"}
}
**Example 3:**
In the following example possible actions on the returned alarm are listed in
the \"_links\" object. This example assumes the presence of task resources.
Note that \"comment\", \"acknowledge\" and \"unacknowledge\" are extension
link relation types not registered with IANA.
{
\"_links\": {
\"comment\": {\"href\":
\"http://example.org/AlarmIRP/v1/Alarms/127/comment\"},
\"acknowledge\": {\"href\":
\"http://example.org/AlarmIRP/v1/Alarms/127/acknowledge\"}
}
}
In case the alarm is already acknowledged the following options are returned.
{
\"_links\": {
\"comment\": {\"href\":
\"http://example.org/AlarmIRP/v1/Alarms/127/comment\"},
\"unacknowledge\": {\"href\":
\"http://example.org/AlarmIRP/v1/Alarms/127/unacknowledge\"}
}
}
**Example 4:**
This example shows how a child resource may be linked. The \"parts\" relation
type is not registered with IANA.
GET /ensembles/1 HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"1\",
\"type\": \"Type1\",
\"_links\":
{
\"self\": { \"href\": \"/ensembles/1\" },
\"parts\": { \"href\": \"/ensembles/1/parts\" }
}
}
**Example 5:**
This example demonstrates the usage of HAL with the \"_embedded\" property.
The inclusion of this property in the return message payload is triggered by
the \"embed\" query parameter.
GET /ensembles/1?embed=parts HTTP/1.1
Host: example.org
Content-Type: application/json
HTTP/1.1 200 OK
Content-Type: application/json
{
\"id\": \"1\",
\"type\": \"Type1\",
\"_links\":
{
\"self\": { \"href\": \"/ensembles/1\" },
\"parts\": { \"href\": \"/ensembles/1/parts\" }
}
\"_embedded\"
{
\"parts\":
[
{
\"id\": \"a\",
\"name\": \"aName\",
\"vendor\": \"ACME\",
\"size\": 10,
\"_links\":
{
\"self\": { \"href\": \"/ensembles/1/parts/a\" }
}
},
{
\"id\": \"b\",
\"name\": \"bName\",
\"vendor\": \"ACME\",
\"size\": 5,
\"_links\":
{
\"self\": { \"href\": \"/ensembles/1/parts/b\" }
}
},
{
\"id\": \"c\",
\"name\": \"cName\",
\"vendor\": \"ACME\",
\"size\": 12,
\"_links\":
{
\"self\": { \"href\": \"/ensembles/1/parts/c\" }
}
}
]
}
}
**Example 6:**
This example illustrates the usage of the JSON Hyper-Schema.
\"links\": [
{
\"rel\": \"self\",
\"href\": \" http://example.org/AlarmIRP/v1/Alarms/127\"
},
{
\"rel\": \"next\",
\"href\": \" http://example.org/AlarmIRP/v1/Alarms/128\"
}
]
### 7.5.16 Design pattern for iterations
#### 7.5.16.1 Iteration methods
Sometimes large portions of data need to be retrieved by a client. In these
cases it is desirable to partition the response and return the data in
multiple subsets. This is often referred to as the client iterating through
the information to be returned. Two methods are commonly used and may be
considered during the normative stage.
#### 7.5.16.2 Iteration using header
RFC 7233 [13] describes range requests that can be used for iterations. A
Range header can be specified in the GET request allowing the client to
specify a subset of the total resource representation. Only the specified
subset is returned in the response. Ranges can be specified either in bytes or
based on other substructures like the number of managed object instances. RFC
7233 [13] defines only requests for byte ranges.
In case of success the server returns the status code 206 (Partial Content)
and the Content-Range and Content-Length response headers. The response
message body contains the partial content. The status code 416 (Range Not
Satisfiable) is returned if the requested range cannot be satisfied by the
server.
The Accept-Ranges header allows a server to indicate support for range
requests for a target resource. The Accept-Ranges header value indicates the
range unit type supported. The client can trigger a response including the
Accept-Ranges header with a HEAD request.
**Example:**
The three Part class instances are read in two steps. The first step returns
the first two instances, and the second step the last instance.
GET /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json
Range: items=0-1
HTTP/1.1 206 Partial Content
Content-Range: 0-1/3
Content-Length: 1
Content-Type: application/json
[
{
\"id\": \"a\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 5
},
{
\"id\": \"b\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 2
}
]
GET /Ensemble/1/Part HTTP/1.1
Host: example.org
Content-Type: application/json
Range: items=2
HTTP/1.1 206 Partial Content
Content-Range: 2/3
Content-Length: 1
Content-Type: application/json
[
{
\"id\": \"c\",
\"name\": \"ABC\",
\"vendor\": \"XYZ\",
\"size\": 53
}
]
The Range request header can specify also a set of ranges within a single
representation (multipart ranges). The response to these requests is in case
of success the 206 (Partial Content) status code and includes a Content-Type
header value of multipart/byteranges together with a boundary parameter
string. The boundary indicates the boundary between the requested parts in the
response message body.
The concept of multipart ranges cannot be used to partition large data sets to
be read into multiple smaller responses. It may be used to scope certain
managed objects in a large resource representation containing multiple managed
objects.
#### 7.5.16.3 Iteration using query parameters
Another method for handling large portions of data need to be retrieved by a
client is the use of query parameters. All URLs which return collections of
resource results (e.g. GET /dc/api/v5/users) follow the same pattern for
paging. When issuing your HTTP request, you can include two parameters which
determine paging behavior:
\- limit:
The _limit_ parameter controls the maximum number of items that may be
returned for a single request. This parameter can be thought of as the page
size. If no limit is specified, the system defaults to a limit of 15 results
per request. The maximum valid limit value is 100.
\- offset:
The **offset** parameter controls the starting point within the collection of
resource results. For example, if you have a collection of 15 items to be
retrieved from a resource and you specify _limit=5_ , you can retrieve the
entire set of results in 3 successive requests by varying the _offset_ value:
_offset=0_ , _offset=5_ , and _offset=10_. Note that the first item in the
collection is retrieved by setting a **zero offset**.
The response to these requests is typically a JSON object with the following
three properties: _results_ , _next_ , and _prev_. The _results_ property is
simply an array of the items returned for your request. If you are paged into
the result set, the _prev_ property will contain a link to the previous page
of results. A _next_ property, if present, will contain a link to the next
page of results based on your current limit and offset values.
**Example**
For this scenario, a request is made to the users\' resource, limiting the
results to three items per page. Notice the next property on the response
object contains a link with an identical URL but with an adjusted offset to
include the next set of items _._
GET /ensembles/?limit=3,offset=5 HTTP/1.1
Host: example.org
Accept: application/json
HTTP/1.1 200 OK
Content-Type: application/json
{
\"ensembles\":
[
{
\"id\": \"5\",
\"type\": \"Type1\"
},
{
\"id\": \"6\",
\"type\": \"Type1\"
},
{
\"id\": \"7\",
\"type\": \"Type1\"
}
],
\"_links\":
{
\"self\": { \"href\": \"/ensembles/?limit=3,offset=5\" },
\"next\": { \"href\": \"/ensembles/?limit=3,offset=8\" }
\"previous\": { \"href\": \"/ensembles/?limit=3,offset=2\" }
}
}
## 7.6 Example mapping of IRPs
### 7.6.1 Mapping of Network Resource Model (NRM) IRPs to resources
Each Managed Object Instance (MOI) is mapped to a HTTP resource.
### 7.6.2 Basic CM IRP
The Information Service of the Basic CM IRP is defined in 3GPP TS 32.602 [4]
and features the following operations:
* * *
IS operation Description createMO Operation allows to create one MOI deleteMO
Operation allows to create one MOI or (through scoping and filtering) multiple
MOIs setMOAttributes Operation allows to set the attributes of one MOI or
(through scoping and filtering) multiple MOIs getMOAttributes Operation allows
to read the attributes of one MOI or (through scoping and filtering) multiple
MOIs getContainment Operation to get the containment starting from the
specified base object cancelOperation Operation to cancel an ongoing Basic CM
operation
* * *
Case 1: The operations relate to one and only one managed object instance
(resource)
In this case the resource is identified by the URI. The scope is the base
object alone. Filter constraints can be specified in the query component.
In this case the IS operations can be mapped directly into HTTP methods as
specified in the following table.
* * *
IS operation HTTP method createMO POST deleteMO DELETE setMOAttributes PATCH
(partial update) / PUT (complete update) getMOAttributes GET cancelOperation
not possible with synchronous methods getContainment relates to multiple
resources
* * *
**Example: Get all attributes of a resource**
Request:
GET .../SubNetwork/south/IRPAgent/5/ManagedElement/6/ENBFunction/Berlin6754
Response:
Returns in the message body the resource instance in JSON.
**Case 2: The operations relate to a scope with more than one managed object
instance (resource)**
* * *
IS operation HTTP method deleteMO DELETE with appropriate identification of
multiple resources to be deleted setMOAttributes PATCH/PUT with appropriate
identification of multiple resources getMOAttributes GET with appropriate
identification of multiple resources cancelOperation not possible with
synchronous methods getContainment GET with appropriate identification of all
resources below base resource
* * *
### 7.6.3 Alarm IRP
#### 7.6.3.1 Introduction
The Information Service of the Alarm IRP is specified in TS 32.111-2 [2]. This
clause will detail some possible mappings based on the Richardson Maturity
Model.
#### 7.6.3.2 Richardson Maturity Model Level 0 (The swamp of POX)
At this level only a service endpoint is exposed as a resource by the server.
{width="1.7979166666666666in" height="0.35in"}
Figure 7.6.3.2.1: Resource URI structure of the Alarm IRP (RMM Level 0)
HTTP POST methods are invoked against this URI. The operation to be performed
is given in the request message body along with the operation input
parameters. The operation output parameters are returned in the response
message body. Below, there is an example for the operation getAlarmList.
POST /AlarmIRP/V1 HTTP/1.1
[REQUEST HEADER]
{
\"getAlarmListRequest\":
{
\"parameterNameA\": \"parameterNameA_value\",
\"parameterNameB\": \"parameterNameB_value\"
}
}
HTTP/1.1 200 OK
[RESPONSE HEADER]
{
\"getAlarmListResponse\":
{
\"parameterNameX\": \"parameterNameX_value\",
\"parameterNameY\": \"parameterNameY_value\"
}
}
#### 7.6.3.3 Richardson Maturity Model Level 1 (Resources)
At this level resources are introduced. The operations getAlarmList and
getAlarmCount target the resource AlarmList. A HTTP POST can be invoked
against AlarmList. The type of operation as well as input and output
parameters are carried in the request and response message bodies in the same
way as for RMM Level 0.
The operations acknowledgeAlarms, unacknowledgeAlarms, setComment and
clearAlarms can target one or multiple alarms identified by a single alarmId
or a list of alarmId. This means that all these operations need to be POSTed
against AlarmList, too. The difference to the solution in the clause above is
only that the HTTP POST is not directed to a service endpoint but to the
AlarmList resource.
{width="2.6881944444444446in" height="0.6048611111111111in"}
Figure 7.6.3.3.1: Resource URI structure of the Alarm IRP (RMM Level 1,
alternative 1)
In case the operations acknowledgeAlarms, unacknowledgeAlarms, setComment and
clearAlarms can target only one alarm, the following resource URI structure
could be used.
{width="3.5729166666666665in" height="0.9895833333333334in"}
Figure 7.6.3.3.2: Resource URI structure of the Alarm IRP (RMM Level 1,
alternative 2)
The operations acknowledgeAlarms, unacknowledgeAlarms, setComment and
clearAlarms are POSTed against the alarmId resource in this case.
Yet another possibility is to use task resources as shown in the following
figure.
{width="3.7597222222222224in" height="2.714583333333333in"}
Figure 7.6.3.3.3: Resource URI structure of the Alarm IRP (RMM Level 1,
alternative 3)
#### 7.6.3.4 Richardson Maturity Model Level 2
At this maturity level resources are used and the HTTP verbs are used as they
are used in HTTP. The following figure shows the resource URI structure.
{width="4.522222222222222in" height="2.542361111111111in"}
Figure 7.6.3.4.1: Resource URI structure of the Alarm IRP (RMM Level 2)
getAlarmList:
GET /AlarmIRP/V1/Alarms HTTP/1.1
acknowledgeAlarms:
PATCH /Alarms?alarmId=5,alarmId=7 HTTP/1.1
[REQUEST HEADER]
{
\"ackUserId\": \"5\"
\"ackSystemId\": \"53\",
\"ackState\": \"acknowledged\"
}
unacknowledgeAlarms:
PATCH /Alarms?alarmId=5,alarmId=7 HTTP/1.1
[REQUEST HEADER]
{
\"ackUserId\": \"5\",
\"ackSystemId\": \"53\",
\"ackState\": \"unacknowledged\"
}
clearAlarms
PATCH /Alarms?alarmId=5,alarmId=7 HTTP/1.1
[REQUEST HEADER]
{
\"clearUserId\": \"5\"
\"clearSystemId\": \"53\"
}
setComment
PUT /AlarmList/1/Comment HTTP/1.1
[REQUEST HEADER]
{
\"commentUserId\": \"5\"
\"commentSystemId\": \"53\",
\"commentText\": \"This is a comment.\"
}
getAlarmCount:
GET /AlarmIRP/V1/Alarms?count HTTP/1.1
## 7.7 Example mapping of solution set
### 7.7.1 Example of defining types
Figure 7.7.1.1 shows an example of how a common type is defined in a SOAP
Solution Set.
Figure 7.7.1.1: Example of common type definition in SOAP Solution Set
Figure 7.7.1.2 shows how this example may be defined in a JSON Solution Set
(expressed in YAML to aid readability).
Figure 7.7.1.2: Example of common type definition in JSON Solution Set
### 7.7.2 Example of defining managed objects
Figure 7.7.2.1 shows an example of how a managed object is defined in a SOAP
Solution Set.
Figure 7.7.2.1: Example of managed object definition in SOAP Solution Set
Figure 7.7.2.2 shows how this example may be defined in a JSON Solution Set
(expressed in YAML to aid readability).
Figure 7.7.2.2: Example of managed object definition in JSON Solution Set
## 7.8 REST SS template
This clause provides the REST SS template.
# 8 Recommendations
The present document provides an overview of the REST architectural style and
HTTP. Design patterns, conforming to the REST style and using HTTP, are
described for functions commonly used for management purposes. Example
mappings of IRPs are provided. This proves that IRPs can be implemented based
on HTTP whilst following REST principles.
It is recommended to introduce new RESTful HTTP based Solution Set
definitions.
###### ### Annex A: About TM Forum REST API specifications
# A.1 REST API design guidelines
## A.1.0 Introduction
This clause provides information regarding the development of TM Forum APIs
using REST. Documents in Annex X provide recommendations and guidelines for
the implementation of Entity CRUD operations and Task operations. They also
provide information on filtering and attribute selection. Finally they provide
information on supporting notification management in REST based systems.
## A.1.1 General concepts
\- A Managed Resource is e.g. a database record or a managed entity. Its
representation includes fields with values and links to related resources.
Client can create, query, update and delete (CRUD) managed resources;
\- A Resource Collection is a server managed collection of resources;
\- Executable functions are of two kinds:
\- CRUD methods;
\- Tasks.
\- REST APIs embrace all aspects of HTTP 1.1, including its requests methods,
response codes and message headers.
## A.1.2 Operations
* * *
Type of operation API operation Description Query managed entities GET
Resource GET is used to retrieve a representation of a resource. Create
managed entity POST Resource POST is used to create a new resource Partial
Update of a managed entity PATCH Resource PATCH is used to partially update a
resource Complete Update of a managed entity PUT Resource PUT is used to
completely update a resource Remove a managed entity DELETE Resource DELETE is
used to delete a resource Execute an Action on a managed entity POST on TASK
Resource POST is used to execute actions other than CRUD.
* * *
## A.1.3 Media types
\- REST methods may be able to transfer data in XML or JSON; each is
represented by its media type
\- REST APIs need to support the JSON media type
\- The default for resource representation is JSON
\- XML and other formats may optionally be supported via content negotiation
between the client and the server.
# A.2 Example TM Forum REST APIs
Here below is an non exhaustive list of REST APIs specified by TM Forum:
\- Trouble Ticket API
\- Customer Management API
\- Product Catalog Management API
\- Product Inventory Management API
\- Performance Management API, etc.
###### ### Annex B: Bibliography
TMF 630 TM Forum REST API Design Guidelines Part 1- Practical guidelines for
RESTful APIs naming, CRUD, filtering, notifications. Release 14.5.1 \-- March
2015
TMF 631 TM Forum REST API Design Guidelines Part 2 -- Advanced guidelines for
RESTful APIs lifecycle management, polymorphism, common tasks. Release 14.5.1
-- March 2015
#
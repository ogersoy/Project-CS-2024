# Foreword
This Technical Report has been produced by the 3rd Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
Refer to actual network operation & maintenance, a subset of IRP requirements
on Itf-N has been described in TR 32.861[2] based on existing TS 32-series
specifications. In order to put it into practice, both functionalities and
solution sets for the simplified Itf-N are urgently needed to be studied. This
document is subsequent study to TR 32.861[2] (Study on Application and
Partitioning of Itf-N), which also takes existing 32-series specifications
into consideration.
This document aims to provide one solution sets for requirements of Itf-N
raised by TR 32.861[2].
# 1 Scope
The present document examines the IRP Information Service (IS) of Itf-N from
existing TS 32-series specifications and identifies one subset of IRP
functionality according to the IRP requirements in TR 32.861[2], also studies
diverse solution sets and compares them between each other on efficiency and
complexity. Finally, this document gives a suggestion of one or more solution
set(s) for above identified IS subset.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TR 32.861: \"Study on Application and Partitioning of Itf-N\".
[3] 3GPP TS 32.111-2：\"Telecommunication management; Fault Management; Part 2:
Alarm Integration Reference Point (IRP): Information Service (IS)\"
[4] 3GPP TS 32.302: \"Telecommunication management; Configuration Management
(CM); Notification Integration Reference Point (IRP); Information Service
(IS)\"
[5] 3GPP TS 32.312: \"Telecommunication management; Generic Integration
Reference Point (IRP) management; Information Service (IS)\"
[6] 3GPP TS 32.342\"Telecommunication management; File Transfer (FT)
Integration Reference Point (IRP); Information Service (IS)\"
[7] 3GPP TS 32.352 \"Telecommunication management; Communication Surveillance
(CS) Integration Reference Point (IRP); Information Service (IS)\"
[8] 3GPP TS 32.412 \"Telecommunication management; Performance Management (PM)
Integration Reference Point (IRP): Information Service (IS)\"
[9] 3GPP TS 32.612 \"Telecommunication management; Configuration Management
(CM); Bulk CM Integration Reference Point (IRP): Information Service (IS)\"
[10] OMG, Common Object Request Broker Architecture (CORBA) Specification,
Part 1 -- Interfaces, Version 3.3,
http://www.omg.org/spec/CORBA/3.3/Interfaces/PDF
[11] W3C, SOAP Version 1.2 Part 0: Primer (Second Edition),
https://www.w3.org/TR/soap12-part0/
[12] 3GPP TR 32.809 v 7.0.0 \"Feasibility Study of XML-based (SOAP/HTTP) IRP
Solution Sets\"
[13] IETF, RFC-147, \"The Definition of a Socket\",
https://tools.ietf.org/html/rfc147
[14] IETF, RFC-6458, \"Sockets API Extensions for the Stream Control
Transmission Protocol (SCTP)\", https://tools.ietf.org/html/rfc6458
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply.\ An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
CM Configuration Management
EMS Element Management System
FM Fault Management
IRP Integration Reference Point
IS Information Service
NMS Network Management System
NRM Network Resource Model
PM Performance Management
SS Solution Set
# 4 Background
In order to keep the stability of Itf-N and improve the efficiency of network
maintenance for operators, a study on partitioning of Itf-N has been carried
out in TR 32.861[2]. The report provides a subset of IRP requirements which
consist of Fault Management (FM), Performance Management (PM) and
Configuration Management (CM). The subset of IRP requirements is listed as
following:
\- FM
\- Real-time forwarding of alarm reports
\- Real-time forwarding of Alarm clearing message
\- Retrieval of current alarm information on NM request
\- PM
\- Transfer of performance measurements
\- CM
\- Transfer of NRM data when needed
Based on above study, IRP requirements are simplified according to actual
practice of operators. To simply Itf-N further, a "better" implementation is
necessary. By examining the exist IRP Information Service, choose the most
appropriate subsets of functionalities which satisfy the all the requirements
in TR 32.861[2]. Then the solution sets should be carefully studied by
analysing the complexity and performance of each interface protocol.
Meanwhile, business consequence will be taken into account when making a
decision of "better" SS.
# 5 Study on grouping IRP functionality for Itf-N
## 5.1 Configuration Management (CM)
According to the subset of requirements of Configuration Management (see TR
32.861 [2], clause 6.3), the IRPAgent should create files containing
configuration data on the demand of the IRPManager or automatically on a
presented schedule. IRPManager and IRPAgent should have an agreement on the
NRMs for the configuration data.
Data files are transferred through file transfer mechanism covered by the File
Transfer IRP IS (see TS 32.342 [6]).
When the files have been prepared, IRPAgent emits the notifyFileReady
notification (see clause 5.4.1) to subscribed IRPManager(s). An IRPManager can
request to transfer the files appropriately according to the file information.
The subscribed IRPManager(s) are notified by notifyFilePreparationError (see
clause 5.4.2) regarding the occurrence of an error during the preparation of
the file.
## 5.2 Performance Management (PM)
According to the subset of requirements of Performance Management (see TR
32.861 [2], clause 6.2), the operations and notifications of PM IRP IS are not
needed. The IRPAgent should create files containing performance measurement
data automatically on a preseted schedule. IRPManager and IRPAgent should have
an agreement on the scope of measurementTypes.
Data files are transferred through file transfer mechanism covered by the File
Transfer IRP IS (see TS 32.342 [6]).
When the files have been prepared, IRPAgent emits the notifyFileReady
notification (see clause 5.4.1) to subscribed IRPManager(s). An IRPManager can
request to transfer the files appropriately according to the file information.
The subscribed IRPManager(s) are notified by notifyFilePreparationError (see
clause 5.4.2) regarding the occurrence of an error during the preparation of
the file.
## 5.3 Fault Management (FM)
### 5.3.1 getAlarmLists
(Quote from TS 32.111-2 [3], version 12.1.0, clause 6.3.2.1)
_\"The IRPManager invokes this operation to request the AlarmIRP to provide
either the complete list of AlarmInformation instances in the AlarmList or
only a part of this list (partial alarm alignment)._
_The parameters baseObjectClass and baseObjectInstance are used to identify
the part of the alarm list to be returned. If they are absent, then the
complete alarm list shall be provided (full alarm alignment). If they identify
a particular class instance, then only a) the AlarmInformation instances
related to this class instance and b) the AlarmInformation instances related
to the subordinate class instances of this class instance shall be provided
(partial alarm alignment). An instance-a is said to be subordinate to
instance-b if the DN of the latter is part of the DN of the former._
_There are two modes of operation. One mode is synchronous. In this mode, the
list of AlarmInformation instances in AlarmList is returned synchronously with
the operation. The other mode is asynchronous. In this mode, the list of
AlarmInformation instances is returned via notifications. In asynchronous mode
of operation, the only information returned synchronously is the status of the
operation. A method allowing to abort an ongoing alarm alignment process shall
be available in the asynchronous mode. The mode of operation to be used is
determined by means outside the scope of specification. To use asynchronous
mode, the IRPManager must have established a subscription with the
NotificationIRP via the subscribe operation specified in 3GPP TS 32.302
[5].\"_
The input parameters are in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.3.2.2.
The output parameters are in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.3.2.3.
The pre-condition is in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.3.2.4.
The post-condition is in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.3.2.5.
The exceptions are in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.3.2.6.
### 5.3.2 notifyNewAlarm
(Quote from TS 32.111-2 [3], version 12.1.0, clause 6.8.1.1)
_\"A new AlarmInformation has been added in the AlarmList. The subscribed
IRPManager instances are notified of this fact if the added AlarmInformation
satisfies the current filter constraint of their subscription._
_There are two tables for Input Parameters. If alarmType parameter indicates
\"Communications Alarm\", \"Processing Error Alarm\", \"Environmental Alarm\".
\"Quality Of Service Alarm\" or \"Equipment Alarm\", the first table (see
clause 6.8.1.2) shall be applicable for this notifyNewAlarm. If alarmType
parameter indicates \"Integrity Violation\", \"Operational Violation\",
\"Physical Violation\", \"Security Service or Mechanism Violation\" or \"Time
Domain Violation\", the second table (see clause 6.8.1.3) shall be
applicable.\"_
The input parameters are in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.8.1.2 and 6.8.1.3.
The trigger event is in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.8.1.4.
### 5.3.3 notifyClearedAlarm
(Quote from TS 32.111-2 [3], version 12.1.0, clause 6.8.3.1)
_\"IRPAgent notifies the subscribed IRPManager of alarm clearing if the
subject AlarmInformation satisfies the optional filter constraint expressed in
the subscribe operation._
_The notification shall contain all parameters that are filterable and are
present in the original (related) notifyNewAlarm notification.\"_
The input parameters are in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.8.3.2.
The trigger event is in compliance with the features specified in 3GPP TS
32.111-2 [3], clause 6.8.3.3.
## 5.4 File Transfer (FT)
### 5.4.1 notifyFileReady
(Quote from TS 32.342 [6], version 12.0.0, clause 6.5.1.1)
_\"After the management data files have been prepared ready in the IRPAgent,
IRPAgent will emit notification to subscribed IRPManager(s) to notify the
availability of the file(s).\"_
The input parameters are in compliance with the features specified in 3GPP TS
32.342 [6], clause 6.5.1.2.
The trigger event is in compliance with the features specified in 3GPP TS
32.342 [6], clause 6.5.1.3.
### 5.4.2 notifyFilePreparationError
(Quote from TS 32.342 [6], version 12.0.0, clause 6.5.2.1)
_\"The subscribed IRPManagers are notified regarding the occurrence of an
error during the preparation of the file. This notification is an event and
will not be treated as alarms defined in Alarm IRP IS (3GPP TS 32.111-2
[3]).\"_
The input parameters are in compliance with the features specified in 3GPP TS
32.342 [6], clause 6.5.2.2.
The trigger event is in compliance with the features specified in 3GPP TS
32.342 [6], clause 6.5.2.3.
# 6 Analysis on diverse solution sets for Itf-N
## 6.0 Overview
Diverse solutions for Itf-N are adopted for the management of actual networks.
Some of the solutions are in the scope of existing specifications, such as
solution sets based on CORBA or SOAP, while others are not. The IRPs'
requirements and information services are well supported by existing solution
sets, but these IRPs do not support some operators' need for a simpler
solution, as stated in the previous study for partitioning of Itf-N [2].
Solutions beyond the scope of existing specifications are adopted to implement
the subset of IRPs.
This section is a technical overview of the protocols of several solution
sets, and provides information for the comparison and recommendations in
following sections.
## 6.1 Definitions
### 6.1.1 CORBA
#### 6.1.1.1 Overview and concepts
Common Object Request Broker Architecture (CORBA) is OMG's vendor-neutral,
open standard for distributed object technology. Since the beginning it has
gone through various improvement and enhancements and the current version is
CORBA 3.3 presented in Nov 2012 [10].
The components of CORBA are Object Management Architecture (OMA), Object
Request Broker (ORB) to support interaction between objects, and object
services, and its main functions include locating objects, communication
between servers and clients. Communication between clients and servers are not
direct, it is always carried out via an Object Request Broker (ORB). Moreover,
ORB objects are accessed through the use of interfaces, defined using
Interface Definition language (IDL).
#### 6.1.1.2 Interoperation
When an object in the client role invokes an operation, the request is
processed by an ORB to identify the server object to perform the request. The
client is not aware of either the location or implementation details of the
server object. The client makes the request using the object reference. An
Interoperable Object Reference (IOR) contains the contact details for all the
protocols that clients can use to communicate with an object in a server.
The ORB is responsible for all of the mechanisms required to find the object
implementation for the request, to prepare the object implementation to
receive the request, and to communicate the data making up the request. The
interface which the client sees is completely independent of where the object
is located, what programming language it is implemented in, or any other
aspect that is not reflected in the interface of the object. In the client-
server model an object plays roles of a client and a server and an object may
assume both client and server roles for different operations.
ORB interoperability specifies a comprehensive, flexible approach to
supporting networks of objects that are distributed across and managed by
multiple, heterogeneous CORBA-compliant ORBs. General Inter-ORB Protocol
(GIOP) is the abstract protocol by which ORBs communicate. This protocol
defines the different message types -- such as request and reply messages --
that can be exchanged between client and server applications and also
specifies a binary format for the on-the-wire representation of IDL types.
The GIOP is specifically built for ORB to ORB interactions and is designed to
work directly over any connection-oriented transport protocol that meets a
minimal set of assumptions. Instead, the choice of transport mechanism is
decided in a specialization of GIOP.
A specialization of GIOP is the Internet Inter-ORB Protocol (IIOP), which is
specified how GIOP messages are exchanged using TCP/IP connections. CORBA uses
IIOP (Internet-Inter ORB Protocol) for interoperability in distributed
heterogeneous environment.
CORBA products are obliged to support IIOP, but they may optionally also
support other GIOP-based protocols or Environment Specific Inter-ORB protocols
(ESIOP).
#### 6.1.1.3 Features
CORBA has many advantages such as it is neither language nor operating system
dependent paradigm, there are many languages supported by various CORBA
providers, the most popular languages are Java and C++. CORBA\'s design is
meant to be OS-independent. CORBA is available in Java (OS-independent), as
well as natively for Linux/Unix, Windows, Solaris, etc. This provides
extensibility to support any future language paradigm and OS.
Moreover, CORBA Server and clients are transparent to implementation and
underlying layers, thus system details are hidden from developer and there is
no need for server and clients to know underlying architecture.
CORBA is a true object-oriented component framework, with CORBA, there is a
tight coupling between the client and the server. First of all, both of them
share the same interface and run an ORB (Object Request Broker) at both ends.
Then, the interaction between the client and the server may be achieved
directly with no need to further intermediation.
In CORBA, the Portable Object Adapter (POA) policies combined with the Fault-
tolerant CORBA features and the Load-balancing CORBA service provide the
desired scalability to CORBA applications.
### 6.1.2 SOAP
#### 6.1.2.1 Overview and concepts
SOAP is a lightweight protocol defined by the w3c organisation [11]. SOAP is
intended to exchange information in decentralized and distributed environment.
It uses XML technologies that allow defining an extensible messaging framework
providing a message construct that can be exchanged over a variety of
underlying protocols. As well, the framework has been designed to be
independent of any particular programming model and other implementations
specific semantics. SOAP does not specify a transport event though it is very
commonly used with HTTP.
#### 6.1.2.2 Interoperation
SOAP provides a distributed processing model that assumes a SOAP message
originates at an initial SOAP sender and is sent to an ultimate SOAP receiver
via a number of SOAP intermediaries.
A SOAP message is specified as an XML message that consists in a SOAP
envelope, a SOAP header and a SOAP body. The SOAP envelope element information
item is embedded within an XML message and specifies that this message is a
SOAP message. It contains a local name (envelope) as well as a namespace and a
number of namespace qualified attribute information items. Therefore it has to
contain a Body element information item and optionally a Header element
information item.
The SOAP header provides a mechanism for extending a SOAP message in a
decentralized and modular way. The SOAP body provides a mechanism to transmit
information to an ultimate SOAP receiver. It is a mandatory field since it
contains the message or payload that is to be processed by the ultimate SOAP
receiver.
While a SOAP receiver processing a message, a SOAP node (identified by an URI)
is said to act in one or more SOAP role, each of which is identified by a URI
known as the SOAP role name. For example, there are three main role names in
the context of SOAP:
> \- Next: Each SOAP intermediary and the ultimate SOAP receiver act in this
> role
>
> \- None: SOAP nodes do NOT act in this role
>
> \- Ultimate Receiver: Only the ultimate receiver acts in this role
A solution set based on SOAP also needs WSDL as a description language and
UDDI as a discovery "layer".
WSDL is a Standard to define Web Services. WSDL is an XML format that allows
Web Services description as a set of endpoints operating on messages
containing either a document oriented or procedure oriented information.
Operations and messages are described at an abstract level and then bound to a
concrete network protocol and message format to define an endpoint. WSDL
describes the format and protocols of a web service in a standardized way.
The Service provider publishes service WSDL description to a UDDI registry.
The service requestor discovers the service by searching the UDDI registry and
then binds the WSDL description to a specific message it uses to access the
service. Finally, the service requestor can use the service.
UDDI allows service providers to publish information about their services. The
requestor can then find these information when looking for a service. This is
done using the UDDI functionalities providing a registry in which information
such as business entity, service provided by this entity and the WSDL
description of those services is stored. UDDI provides as well an interface to
insert information of the registry and possibly search for a service.
#### 6.1.2.3 Features
SOAP version 1.2 is based on the XML Information Set [11]. SOAP 1.2 places no
restriction about how the message is transported. Building on top of the XML
message, the SOAP 1.2 specification defines a binding framework explaining the
responsibility of the mechanism carrying a SOAP message from one SOAP node to
another. This makes SOAP processors underlying protocol agnostics and SOAP
version 1.2 protocol independent. SOAP 1.2 messages can be carried over HTTP,
SMTP or any other protocol for which a binding conforms the binding framework.
SOAP 1.2 defines a web method feature and the SOAP HTTP binding provides
support for both HTTP GET and POST operations. This implies that SOAP gets the
benefits of the web infrastructure such as HTTP caches. Basically, SOAP 1.2
uses existing, established web technologies and it allows achieving better
performance.
The biggest strength of SOAP 1.2 is coming from its extensibility model. SOAP
1.1 model has been reworked and formalized as features and properties that can
be expressed either in the SOAP envelope or via the underlying protocol
binding, making SOAP1.2 very flexible and making it take advantage of any
feature that the underlying protocol would be providing.
### 6.1.3 Protocols based on Socket API
#### 6.1.3.1 Overview and concepts
A Socket defines an endpoint of connection for the communication across
networks for a process, is an abstract reference (or handle) that a local
program can pass to the networking application programming interface (API) to
use the connection. The original definition of Socket is given in IETF RFC 147
[13]. The Socket is designed to implement the client-server model for inter-
process communication where the interface to network protocols needs to
accommodate multiple transport protocols, such as TCP, UDP, and SCTP.
The Socket API, defines interface between application and transport layer, is
usually provided by the operating system, allows application programs to
control and use network sockets. Each transport protocol offers a set of
services, and the Socket API provides the abstraction to access these
services. Operating system maintains information about the Socket and its
connection, and application references the Socket for sends and receives. In
inter-process communication, each end will generally have its own Socket, but
may use different APIs.
Socket APIs are usually based on the Berkeley sockets standard. In the
Berkeley sockets standard, sockets are a form of file descriptor (a file
handle), gives a file system like abstraction to the capabilities of the
network, due to the UNIX philosophy that \"everything is a file\", and the
analogies between sockets and files. The API defines function calls to create,
close, read and write to/from a Socket. Two processes communicate by sending
data into Socket, reading data out of Socket.
There are three types of sockets:
\- Stream sockets allow processes to communicate using TCP. A stream Socket
provides bidirectional, sequenced, and unduplicated flow of data with no
record boundaries. After the connection has been established, data can be read
from and written to these sockets as a byte stream. SCTP may also be used for
stream sockets [14]. Stream sockets are the most commonly used type of Socket.
\- Datagram sockets allow processes to communicate using UDP. A datagram
Socket supports bidirectional flow of messages. A process on a datagram Socket
can receive messages in a different order from the sending sequence and can
receive duplicate messages.
\- Raw sockets provide access to ICMP. Raw sockets are not for most
applications. They are provided to support developing new communication
protocols or for access to more esoteric facilities of an existing protocol.
To specify a protocol of management interface based on Socket, the protocol
stack above transport layer needs to be defined. Many of the application layer
protocols like HTTP, FTP, as well as CORBA and SOAP, make use of sockets to
establish connection between client and server and then for exchanging data.
Each of these protocols defines a set of rules to encapsulate the data payload
or controlling information. They also utilize some other protocols to assist
the interoperation of the interface, such as CORBA objects communicating with
each other via IIOP.
In contrast to above protocols, the protocol to be proposed and analysed in
this study makes a more direct use of Socket. String-based and human-readable
messages are sent and received in form of byte stream via Socket. The protocol
definition focuses on data format of the application layer, including the
structure of messages, message types (request and response of operations,
notification, etc.), parameters, and any other necessary features according to
the management requirements. The interoperation of the protocol is based on
the original functionality of Socket API, e.g. setup and closing connections,
writing and reading messages.
#### 6.1.3.2 Interoperation
Basically two parameters are needed to setup a Socket connection: a Socket
address including IP address and port number, and a transport protocol type
(e.g. TCP). In the Socket API, this information is communicated by binding the
socket.
Computer processes that provide application services are referred to as
servers, and create sockets on start-up that are in listening state. These
sockets are waiting for initiatives from client programs.
For stream socket, a server may serve several clients concurrently, by
creating a child process for each client and establishing a TCP connection
between the child process and the client. Unique dedicated sockets are created
for each connection. These are in established state when a socket-to-socket
virtual connection, also known as a TCP session, is established with the
remote socket, providing a duplex byte stream.
A server may create several concurrently established TCP sockets with the same
local port number and local IP address, each mapped to its own server-child
process, serving its own client process. They are treated as different sockets
by the operating system, since the remote socket address are different.
#### 6.1.3.3 Features
Socket API can be implemented with different language mapping, e.g. C, Java,
Perl and Python. Sockets are low-level interface to network protocols,
therefore a protocol based on Socket API could be highly customized and with
good flexibility, and developers could focus on the key requirements without
taking care of unconcerned details and constraints.
A stream socket provides a connection-oriented flow of data, with well-defined
mechanisms for creating and destroying connections and for detecting errors. A
stream socket transmits data reliably, in order, and with out-of-band
capabilities. Because the stream sockets are implemented on top of TCP, data
of applications can run across any networks using TCP/IP protocol.
The management requirements in actual networks may change due to technology
improvements, modification to the system architecture and increasing scale of
network. The management interface should be able to keep up with the
performance and usability requirements of the management systems and network
elements that it connects. An interface of a customized protocol based on
Socket API could be rapidly developed, quickly deployed and easily upgraded,
when new features are added to existing interface functionalities.
For an interface protocol with messages designed to be string-based, no
special decoder is needed for debugging, and new messages can be added with
minimal effort. In certain scenarios, such as a subset of the IRPs
requirements, such a protocol based on Socket API could be a good option for
the implementation of Itf-N.
## 6.2 Comparative analysis
#### 6.2.1 Overview and concepts
As mentioned above, in fundamental functions, these three recommended
protocols have same abilities and only are differenced in implementation
mechanism. Then the different mechanism defines different complexity and
performance as two key factors in real deployment and runtime environments.
Thus, this section mainly analyses these protocols from complexity and
performance perspectives. To estimate these protocols accurately, quantitative
analysis and qualitative analysis are adopted in the following subsections.
Finally, the result of qualitative analysis is listed based on a number of
results of quantitative analysis.
The estimated indicators which are used in quantitative analysis are as
followings:
* * *
Scope Indicator Definition Complexity Learning cost To evaluate the time cost
of understanding each protocol. Workload(man-hour) To evaluate the time
complexity of a protocol. It represents the time cost of deployment and
maintains of each protocol above. Complexity of building
connection(step/connection) To evaluate the number of steps for building a
connection. It represents the complexity of the operation and maintains.
Performance Parse efficiency(s/MB) To evaluate the parsing efficiency of
information processed by each protocol. Assume that a given size of original
data is encapsulated according to a selected protocol and is prepared for
parsing by a receiver; the indicator is used to measure the parsing efficiency
in the same runtime environment (including hardware, operation system, and
development platform). Latency(ms) To evaluate the processing latency of a
protocol. Assume that a given size of original data is prepared for entering
into Itf-N; the latency is the time cost that the data from inputting into
Itf-N to sending out from Itf-N.
* * *
#### 6.2.2 Complexity
Follow the perspectives of clause 6.2.1, one operator contributed a cluster of
data which covered all of the indicators related the complexity.
In a real network, the process of deployment of a protocol includes these
phases: installation, configuration, inter-operability test, and debug.
Meanwhile, different engineers in different OAM centre bring the different
time cost. Thus, in this section, firstly a cluster of data was collected from
all of OAM centres of an operator. And second, these data are calculated by
arithmetic average. At last, indicator values are the result of arithmetic
average of these data.
These results are followings:
* * *
Indicator Protocol Values Learning cost(days/person) CORBA 30 days/person
Socket 10 days/person SOAP N/A Workload(man-hour) CORBA 56 man-hour Socket 24
man -hour SOAP N/A Complexity of building connection(step/connection) CORBA 6
Socket 3 SOAP N/A
* * *
According to the above tables, compared with CORBA and Socket, SOAP is not
deployed in real operator's network. Thus, it makes sense that SOAP is not
adopted in network commercially. Besides these, in terms of real data of three
dimensions of complexity, CORBA takes more time than Socket in learning cost,
workload and connection respectively. Hence, in complexity, Socket is
recommended.
#### 6.2.3 Performance
In this section, same statistical method is adopted as section 6.2.2. Thus,
this table lists real data from an operator network in performance of each
protocol.
* * *
Performance Analysis  
Scope Indicator Protocol Values Performance Parse efficiency CORBA
10ms/notification Socket 1ms/notification SOAP N/A Latency(ms) CORBA
10000ms/notification Socket 5000ms/notification SOAP N/A
* * *
As sane as the analysis of complexity, SOAP is not used in real networks yet.
And also, the performance of Socket is better than CORBA in efficiency and
latency.
## 6.3 Business consequence
Based on the above analysis in complexity and performance, a general
conclusion is that SOAP is not a commercial protocol in communication network
at least. Thus, the recommended candidates are CORBA and Socket.
Considering that Socket reveals its strengths in efficiency and time cost.
Hence, Socket is the recommended protocol.
# 7 Recommendation for IRP solution sets for Itf-N
The recommended protocol is Socket which provides a simple mechanism for
information exchange. The maintenance and management of Socket can be
implemented in any operating system. Any information can be transferred by
Socket directly regardless of how socket is implemented. Thus, a solution set
for Itf-N based on Socket is proposed in this study. A format should be
defined for parameters transferred between EM and NM. JSON (JavaScript Object
Notation), due to its convenience for humans' reading & writing and machines'
parsing & generating, is here proposed for the data format. The following
figure depicts a protocol stack for the solution set proposed in this study.
Figure 1. Protocol Stack for Solution Set of Itf-N
On the left top of Figure1., Lightweight Itf-N Protocol based on Socket is
proposed for partitioning of Itf-N. For each IRP, a separate solution set is
proposed as follows:
\- Fault management IRP: A Lightweight Itf-N Protocol based on Socket is
implemented to support FM IRP operations (such as getAlarmLists,
notifyNewAlarm, and notifyClearedAlarm), and JSON is used to develop the data
format of the parameters involved (such as new alarm, cleared alarm, alarmlist
request message and response message and etc.);
\- Configuration Management IRP: A Lightweight Itf-N Protocol based on Socket
is implemented to support CM IRP operations (such as notifyFileReady and
notifyFilePreparationError), and JSON is used to develop the data format of
the parameters involved; Meanwhile, FTP is used to transfer CM files which
contain collected configuration data.;
\- Performance Management IRP: A Lightweight Itf-N Protocol based on Socket is
implemented to support PM IRP operations (such as notifyFileReady and
notifyFilePreparationError), and JSON is used to develop the data format of
the parameters involved; Meanwhile, FTP is used to transfer PM files which
contain collected performance measurement data.
# 8 Conclusions
This study analyses essential IRP functions that can be used on Itf-N for
configuration management, performance management and fault management. These
functions consist of real-time management information retrieval, historical
management information retrieval and notifications respectively.
Based on the subset of IRP requirements identified in TR 32.861[2], this study
concentrates on the introduction and analysis of present solution sets for
Itf-N. To the comparison between these solution sets, a set of evaluation
indicators was used. Then a business consequence for different solution sets
was introduced.
Based on this study, a "Lightweight Itf-N" protocol is proposed. However,
different solution sets depend on different operators' requirements. The
proposal suggested in this study just provides an option for implementation of
Itf-N. Efficiency of network operation and maintenance could be improved by
using the Lightweight Itf-N protocol.
#
# Foreword
This Technical Report has been produced by the 3rd Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# 1 Scope
The present document studies and evaluates the enhancements on service layer
to support massive file delivery for IoT devices. An IoT device could be for
instance a NB-IoT device or an eMTC device.
Editor note: Other types of device may be added.
The study considers the enhancements/simplifications in the following areas:
\- Define the requirements and constraints for different IoT device
categories.
\- Review the existing multicast/broadcast service architecture to support
MBMS delivery for IoT devices.
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 26.346: \"Multimedia Broadcast/Multicast Service (MBMS); Protocols
and codecs\".
[3] IETF RFC 3926 (October 2004): \"FLUTE - File Delivery over Unidirectional
Transport\", T. Paila, M. Luby, R. Lehtonen, V. Roca, R. Walsh
[4] 3GPP TS 36.101: \"User Equipment (UE) radio transmission and reception\".
[5] 3GPP TS 36.306: \"User Equipment (UE) radio access capabilities\".
[6] 3GPP TR 22.861: \"FS_SMARTER - massive Internet of Things\".
[7] IETF RFC 7252 (June 2014): \"The Constrained Application Protocol
(CoAP)\", Z. Shelby, K. Hartke, C. Bormann.
[8] IETF RFC 6347 (January 2012): \"Datagram Transport Layer Security Version
1.2\", E. Rescorla, N. Modadugu.
[9] OMA-TS-LightweightM2M-V1_0-20170208-A: \"Lightweight Machine to Machine
Technical Specification\".
**[10] IETF RFC 7228 (May 2014): \"Terminology for Constrained-Node
Networks\", C. Bormann, M. Ersue, A. Keranen.**
**[11]** 3GPP TR 45.820: \"Cellular system support for ultra-low complexity
and low throughput Internet of Things (CIoT)\"
[12] IETF RFC 4919 (August 2007): \"IPv6 over Low-Power Wireless Personal Area
Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals\", N.
Kushalnagar, G. Montenegro, C. Schumacher.
[13] IETF RFC 7959 (August 2006): \"Block-Wise Transfers in the Constrained
Application Protocol (CoAP)\", C. Bormann, Z. Shelby.
[14] https://www.w3.org/XML/EXI/
[15] http://www.xfront.com/EXI/EXI.zip
[16] https://www.itu.int/en/ITU-T/asn1/Pages/asn1_project.aspx
[17] https://thrift.apache.org/
[18] https://github.com/google/protobuf
[19] http://www.oss.com/asn1/resources/asn1-made-simple/encoding-rules.html
[20] N. Gligorić, I. Dejanović and S. Krčo, \"Performance evaluation of
compact binary XML representation for constrained devices,\" 2011
International Conference on Distributed Computing in Sensor Systems and
Workshops (DCOSS), Barcelona, 2011, pp. 1-5.
[21] 3GPP TS 36.331: "Evolved Universal Terrestrial Radio Access (E-UTRA);
Radio Resource Control (RRC); Protocol specification".
[22] https://www.w3.org/TR/2009/WD-exi-evaluation-20090407/
[23] https://www.w3.org/WoT/IG/wiki/images/4/44/2016-04_EXI_for_WoT-1.pdf
[24] Sebastian Bittl, Arturo A. Gonzalez, Michael Spahn, and Wolf A. Heidrich,
"Performance Comparison of Data Serialization Schemes for ETSI ITS Car-to-X
Communication Systems", International Journal on Advances in
Telecommunications, vol 8 no 1 & 2, 2015.
# 3 Definitions, symbols and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR
21.905 [1] and the following apply. An abbreviation defined in the present
document takes precedence over the definition of the same abbreviation, if
any, in 3GPP TR 21.905 [1].
eMBMS Evolved Multimedia Broadcast Multicast Services
eMTC enhanced Machine Type Communication, often referred to as LTE-M
FLUTE File deLivery over Unidirectional Transport
IoT Internet of Things
NB-IoT NarrowBand IoT
RTOS Real-Time Operating System
XML Extensible Markup Language
# 4 Use cases
## 4.0 General
3GPP TR 22.861 [6] identifies the use case families, traffic scenarios and
potential requirements for massive IoT. However, the use case families in 3GPP
TR 22.861 do not address the data delivery from the network to a large amount
of UEs. The following use cases present the data delivery using MBMS User
Services with additional requirements compared to 3GPP TR 22.861.
## 4.1 Use case 1 - Periodic and/or planned data delivery
### 4.1.1 Description
This use case represents a periodic and/or planned file delivery to a large
number of devices. Smart water-metering devices are installed in deep indoor
and wake up once or twice a day to send the consumption reports to the water-
metering network that is regularly extended. The payload size for uplink
transmission is in the range of 12 to 100 bytes. Based on growing amount of
data, the system configuration is adjusted, requiring the delivery of small
configuration updates to all metering devices. Moreover, the water-metering
manufacturer regularly provides non-critical software updates for bug fixes,
performance improvements, or new features/functionalities. For example, the
clause E.2.4 of 3GPP TR 45.820 [11] estimates a periodic inter-arrival time of
180 days between software update events. This frequency is equivalent to twice
per year. Depending on the application, the update frequency can be lower or
higher. These devices require a battery lifetime of approximate 15 years and
are significantly resource-constrained (processing and storage).
### 4.1.2 Recommended Requirements
The following recommended requirements are considered:
\- The 3GPP system supports the reliable delivery and associated procedures to
ensure data integrity.
\- The 3GPP system supports the report on successful delivery.
\- The 3GPP system supports eMBMS delivery mechanisms and procedures for
devices with very limited capabilities (e.g. limited battery life of 15 years,
limited processing and limited storage).
\- The 3GPP system supports a mechanism to inform the scheduled delivery
session to the devices that enables the UE to download the file at the planned
schedule time.- The 3GPP system supports a mechanism to acknowledge a
successful reception and action required (e.g. successful file update).
In addition, the following recommended requirements are not directly related
to 3GPP system but necessary for IoT software update:
\- The update needs to be robust. An update does not make the device unusable.
\- The update needs to be atomic. An update needs to be completely installed
or not at all.
\- The update needs to be fail-safe. There is a fall-back mode if the update
has failed.
## 4.2 Use case 2 -- Initially Unplanned data delivery
### 4.2.1 Description
This use case represents the unplanned data delivery to a large number of
devices. A device manufacturer wants to distribute a software/firmware update
after some bug fixes. These devices may wake up periodically (e.g., every 12
hours to upload measurement data), or dynamically, for instance, when the
buffer which contains measurement data is about to be full. The information
that a new software/firmware update is available is transmitted during these
wake-up periods. The device recommended requirements and constraints are
similar to the use case 1.
### 4.2.2 Recommended requirements
In addition to the recommended requirements in clause 4.1.2, the following
additional recommended requirement is considered:
\- The 3GPP system supports a mechanism to inform the UE during its wake-up
periods about any newly scheduled download delivery sessions.
## 4.3 Use case 3 -- Initially Unplanned data delivery for critical data
### 4.3.1 Description
This use case represents the unplanned critical data delivery to a large
number of devices. A bug in software could be a target for exploitation or is
being exploited by unwanted people to perform a massive attack if the devices
are connected to the Internet. To solve the issue, a device manufacturer wants
to distribute as soon as possible a critical software/firmware update. The
device recommended requirements and constraints are similar to the use case 1.
But in contrast to use case 2, the device manufacturer wants to speed up the
update mechanism such that devices can obtain information on a newly scheduled
download delivery session, as opposed to having to wait until the next wake-up
period to obtain such information.
### 4.3.2 Recommended requirements
In addition to the recommended requirements in clause 4.1.2, the following
additional recommended requirement is considered:
\- The 3GPP system supports a mechanism to page the UE in order to inform the
UE about a newly schedule download delivery session.
# 5 IoT device analysis
## 5.0 General
In IoT devices, there are two separate parts: connectivity and application.
The connectivity part is responsible for the connectivity between the IoT
device and the network (e.g. LTE modem) while the application part is used for
a specific application/use case. Each part may have its own
software/firmware/OS. The clause 5.1 specifies the classes of devices at the
application, the clause 5.2 presents the device categories for LTE
connectivity.
## 5.1 Classes of constrained devices
RFC 7228 [10] defines constrained devices as small devices with limited CPU,
memory, and power resources. The devices are often used as sensors/actuators,
smart objects, or smart devices. RFC 7228 [10] identifies 3 classes of
constrained devices as in table 5.1-1 to provide rough indications of device
capabilities.
Table 5.1-1: Classes of constrained devices (KiB = 1024 bytes) [12]
* * *
Name Data size (e.g. RAM) Code size (e.g. Flash) Class 0, C0 \ **Success codes (2.xx):**
_\- 2.01 Created_ : similar to HTTP 201 \"Created\", but only used in response
to POST and PUT requests. The payload returned with the response, if any, is a
representation of the action result.
_\- 2.02 Deleted_ : similar to HTTP 204 \"No Content\" but only used in
response to a request that causes the resource to be no longer available, such
as DELETE and, in certain circumstances, POST requests.
_\- 2.03 Valid_ : similar to HTTP 304 \"Not Modified\", but is only used to
indicate that the response identified by the entity-tag identified by the
included ETag Option is valid.
_\- 2.04 Changed_ : similar to HTTP 204 \"No Content\" but only used in
response to POST and PUT requests.
_\- 2_._05 Content_ : similar to HTTP 200 \"OK\" but only used in response to
GET requests.
> **Client Error codes (4.xx):**
_\- 4.00 Bad Request_ : Equivalent meaning to HTTP 400 \"Bad Request\".
_\- 4.01 Unauthorized_ : the client is not authorized to perform the requested
action.
_\- 4.02 Bad Option_ : the request could not be understood by the server due
to one or more _unrecognized_ or malformed options.
\- Each of the following error codes _4.03 Forbidden_ , _4.04 Not Found_ ,
_4.05 Method Not Allowed_ , _4.06 Not Acceptable_ , _4.12 Precondition Failed_
, _4.13 Request Entity Too Large_ , and _4.15 Unsupported Content-Format_ has
similar semantics to its HTTP 4.xx error code counterpart with the same \'xx\'
value.
\- Message ID: use for matching response type ACK/RST to request type CON/NON,
as well as for message duplicate detection.
While the CoAP specification [7] itself only defines an upper bound to the
message size. Messages larger than an IP packet would result in undesirable
packet fragmentation. Therefore, [7] recommends that when appropriately
encapsulated, a CoAP message should fit within a single IP packet and which
fits into one UDP packet payload, i.e. within a single IP datagram.
### 7.1.4 Options
Either a request or response message may contain one or more options, a common
set of which is defined in CoAP for both message types:
\- Content-Format
\- ETag
\- Location-Path
\- Location-Query
\- Max-Age
\- Proxy-Uri
\- Proxy-Scheme
\- Uri-Host
\- Uri-Path
\- Uri-Port
\- Uri-Query
\- Accept
\- If-Match
\- If-None-Match
\- Size1
As can be seen, many of these options have the same name and similar semantics
as header fields defined in HTTP. Options belong to one of two classes:
\"critical\" or \"elective\". The difference is how an unrecognizable option
is handled by the message recipient, namely according to the following rules:
\- Unrecognized options of class \"elective\" will be silently ignored;
\- Unrecognized options of class \"critical\" that occur in a CON request will
cause the return of a 4.02 (Bad Option) response;
\- Unrecognized options of class \"critical\" that occur in a CON response, or
piggybacked in an ACK response, will cause the response to be rejected;
\- Unrecognized options of class \"critical\" that occur in a NON message will
cause the message to be rejected.
Additionally, options are also classified based on how a proxy is to deal with
an option it does not recognize it. For this purpose, an option can either be
considered \'Unsafe-to-Forward\' (_UnSafe_ is set to 1) or \'Safe-to-Forward\'
(_UnSafe_ is set to 0).
### 7.1.5 Caching
CoAP endpoints may be able to cache responses to reduce the response time and
network bandwidth consumption on future, equivalent requests. Unlike HTTP, the
cache ability of a CoAP response does not depend on the request method, but
instead on the Response Code. A \"freshness\" mechanism is used for this
purpose by making of the \'Max-Age\' Option code, which indicates the cache
lifetime. The \'ETag\' Option allows for validity checking whereby the payload
of a prior response can be reused to satisfy a new request. RFC 7252 [7]
indicates that Response Codes used to indicate success but are unrecognized by
an endpoint will not be cached.
### 7.1.6 Proxying
As possible in HTTP, CoAP supports the use of proxies which are CoAP devices
typically used by clients to perform requests on their behalf. Both _forward-
proxy_ and _reverse-proxy_ functionality are possible. In the former, the
proxy can be explicitly selected by the client in serving the client\'s
request, whereas in the latter, the proxy serves as stand-in for an origin
server. A proxy can map an incoming CoAP request to an outgoing CoAP request
(CoAP-to-CoAP proxy), or translate from/to a different protocol (\"cross-
proxy\"), for example, between CoAP and HTTP. An instance of such CoAP-to-HTTP
cross proxy is shown in Figure 7.1-1.
### 7.1.7 Security and DTLS
The delivery of CoAP messages can be secured by using DTLS (Datagram Transport
Layer Security) as defined in RFC 6347 [8], in a similar fashion to securing
HTTP over TCP by using TLS. The CoAP protocol stack model with the (optional)
inclusion of DTLS was shown in Figure 7.1.2-1.
### 7.1.8 Block-wise transfers
#### 7.1.8.0 General
The CoAP base protocol works well for small payload. However, in case of
larger payload which exceeds the maximum size for fragmentation at different
layers (e.g. IP, UDP), RFC 7959 [13] extends basic CoAP with a pair of
\"Block\" options for transferring multiple blocks of information from a
resource representation in multiple request-response pairs. RFC 7959 [13]
suggests to limit the size of datagrams in constrained networks:
\- by the maximum datagram size (\~ 64 KiB for UDP)
\- by the desire to avoid IP fragmentation (MTU of 1280 bytes for IPv6)
\- by the desire to avoid adaptation-layer fragmentation (60-80 bytes for
6LoWPAN [12])
NOTE: KiB = 1024 bytes.
The block-wise specification adds a pair of Block options (Block1 and Block2)
to CoAP that can be used for block-wise transfers. Both options can be present
in both the request and response messages. In either case, the Block1 Option
pertains to the request payload, and the Block2 Option pertains to the
response payload. Benefits of using these options include:
\- Transfers larger than what can be accommodated in constrained-network link-
layer packets can be performed in smaller blocks.
\- No hard-to-manage conversation state is created at the adaptation layer or
IP layer for fragmentation.
\- The transfer of each block is acknowledged, enabling individual
retransmission if required. Both sides have a say in the block size that
actually will be used.
\- The resulting exchanges are easy to understand using packet analyser tools,
and thus quite accessible to debugging.
\- If needed, the Block options can also be used (without changes) to provide
random access to power-of-two sized blocks within a resource representation.
#### 7.1.8.1 Structure of a Block Option
Three items of information may need to be transferred in a Block (Block1 or
Block2) option:
\- the size of the block (SZX);
\- whether more blocks are following (M);
\- the relative number of the block (NUM) within a sequence of blocks with the
given size.
The value of the Block option is a variable-size (0 to 3 byte) unsigned
integer. This integer value encodes these three fields, see Figure 7.1.8.1-1.
{width="4.088888888888889in" height="2.7263888888888888in"}
Figure 7.1.8.1-1: Block Option Value
The block size is encoded using a three-bit unsigned integer (0 for 2**4 bytes
to 6 for 2**10 bytes), which we call the \"SZX\" (\"size exponent\"); the
actual block size is then \"2**(SZX + 4)\".
The bit M or \"more\" bit, indicates whether more blocks are following or if
the current block-wise transfer is the last block being transferred.
The option value divided by sixteen (the NUM field) is the sequence number of
the block currently being transferred, starting from zero. The current
transfer is, therefore, about the \"size\" bytes starting at byte \"NUM \ \- The option 2 defines a new CoAP option Range. This solution requires a
> change in the CoAP IETF standard
#### 7.3.1.1 Option 1: use Uri-Query option in CoAP
This alternative relies on the use of Uri-Query option in CoAP to send a byte-
range request message. This solution uses the special defined keywords
\"bytefrom\" and \"byteto\" inside Uri-Query option to indicate the byte-
range.
NOTE 1: The special defined keywords could be different than \"bytefrom\" and
\"byteto\" if this option is adopted.
As an example, the FLUTE receiver partially receives the transport object with
file name \"firmware.bin\" having the \"File-Etag\" attribute set to
\"df69d20220cb1ff4\" in the FDT instance. It issues a repair request to the
host server to fetch the missing bytes. The request message from the CoAP
client is as follows:
Input:
Destination IP Address = 198.51.100.1
Destination UDP Port = 5683
Uri-Host = \"mbmsrepair1.example.com\"
Etag = \"df69d20220cb1ff4\"
Uri-Path = \"path\"
Uri-Path = \"repair_script\"
Uri-Query = \"bytefrom=500;byteto=627\"
Output:
coap://mbmsrepair1.example.com:5683/path/repair_script/?bytefrom=500;byteto=627
NOTE 2: The Etag option does not appear in the CoAP URI but in the CoAP
payload.
Upon reception of the GET request message, the CoAP server parses the special
keywords \"bytefrom\", \"byteto\" to extract the byte-range the CoAP client
wants to fetch. Figure 7.3.1.1-1 shows the request and response CoAP messages.
{width="6.690972222222222in" height="1.7916666666666667in"}
Figure 7.3.1.1-1: Request and response CoAP messages using Uri-Query option
NOTE 3: MID is the message ID in CoAP header.
In 3GPP TS 26.346, multiple byte-ranges or multiple symbols in different block
number can be put in a single HTTP based file repair request message. However,
there is no benefits to combining multiple requests in a single request
message in CoAP since transfer of each block is acknowledged [13]. If the
missing data in a response message is large, or if the CoAP server wants to
use multiple small data payloads in response messages, the block-wise transfer
is used. Table 7.3.1.1-1 shows different cases for byte-range request:
Table 7.3.1.1-1: Different cases for CoAP byte-range request message
+----------------------+----------------------------------------------+ | Single byte-range | Single response CoAP message for file repair | | | if possible | | | | | | Otherwise use block-wise transfer | +----------------------+----------------------------------------------+ | Multiple byte-ranges | Split into multiple of single byte-range | | | requests | +----------------------+----------------------------------------------+
Figure 7.3.1.1-2 shows the case where the CoAP server wants to use block-wise
transfer to deliver the missing bytes.
{width="6.690972222222222in" height="2.9118055555555555in"}
Figure 7.3.1.1-2: Request response CoAP messages using block-wise
NOTE 4: MID is the message ID in CoAP header.
#### 7.3.1.2 Option 2: define a new CoAP option Range
A new CoAP option \"Range\" with a new allocated number 21 is defined in this
solution. Table 7.3.1.2-1 shows an example where the \"Range\" option resides
in the ordered options in CoAP.
Table 7.3.1.2-1: New defined \"Range\" option within **CoAP options**
* * *
No. C U N R Name Format Length Default 1 x x If-Match opaque 0-8 (none) 3 x x
- Uri-Host string 1-255 (see below) 4 x ETag opaque 1-8 (none) 5 x If-None-
Match empty 0 (none) 7 x x - Uri-Port unit 0-2 (see below) 8 x Location-Path
string 0-255 (none) 11 x x - x Uri-Path string 0-255 (none) 12 Content-Format
unit 0-2 (none) 14 x - Max-Age unit 0-4 60 15 x x - x Uri-Query string 0-255
(none) 17 x Accept unit 0-2 (none) 20 x Location-Query string 0-255 (none) 21
x x Range string 0-255 (none) 35 x x - Proxy-Uri string 1-1034 (none) 39 x x -
Proxy-Scheme string 1-255 (none) 60 x Size1 unit 0-4 (none) C=Critical,
U=Unsafe, N=NoCacheKey, R=Repeatable
* * *
NOTE 1: This solution uses the option number 21 to demonstrate the feasibility
of the solution. If this solution using \"Range\" option is adopted as an
extension of CoAP protocol, the allocated number could be different.
With the new defined CoAP option, the query message from the CoAP client is as
follows:
Input:
Destination IP Address = 198.51.100.1
Destination UDP Port = 61616
Uri-Host = \"mbmsrepair1.example.com\"
Etag = \"df69d20220cb1ff4\"
Uri-Path = \"path\"
Uri-Path = \"repair_script\"
Range = \"bytes=500-627\"
Output:
coap://mbmsrepair1.example.com:5683/path/repair_script/
NOTE 2: The Etag and Range options do not appear in the CoAP URI but in the
CoAP payload since these options are not in the process of the clause 6.5 of
RFC 7252.
Figure 7.3.1.2-1 shows the request response CoAP messages using the new
defined \"Range\" option.
{width="6.690972222222222in" height="1.7916666666666667in"}
Figure 7.3.1.2-1: Request and response CoAP messages using defined \"Range\"
option
Similarly, Figure 7.3.1.2-2 shows the case where the CoAP server wants to use
block-wise transfer to deliver the missing bytes.
{width="6.690972222222222in" height="2.9118055555555555in"}
Figure 7.3.1.2-2: Request and response CoAP messages using defined \"Range\"
option and block-wise
### 7.3.2 Block Request based File Repair
Two alternatives for block request based file repair via CoAP are described in
this contribution. They are motivated by and modeled after similar options in
byte-range based file repair, as described in 3GPP TS 26.346, clause 9.3.6.2.
Specifically, they are based on the two options available to the BM-SC for
delivering FEC encoding symbols using the download delivery method:
  * Sending of source symbols followed by repair symbols, and
  * Sending of repair symbols exclusively.
For the sake simplicity in the following examples, it is assumed that sub-
blocking is not used in the broadcast transmission of FEC symbols. Also, it is
assumed that the original file object is stored on a standard CoAP server that
supports file repair, and which is FEC-unaware.
#### 7.3.2.1 Option 3: Block request for repair data after broadcast
transmission of source and repair symbols
In the example as shown below in Figure 7.3.2.1-1, broadcast delivery of the
file object comprises sending of the source symbols followed by repair
symbols. It is assumed that the file object for broadcast delivery to MBMS-
capable IoT devices is a firmware update file whose size is 6.7 Kbytes. The
BM-SC will apply AL-FEC in the transmission of the file object, encoded as
source symbols, along with the repair symbols generated from the file, as a
sequence of ALC/ FLUTE packets, each with payload size of 1024 bytes.
Figure 7.3.2.1-1 -- MBMS download delivery of 6.7-kByte file employing
256-byte FEC symbols carried in FLUTE packets with payload size of 1024 bytes;
sending of source + repair symbols
In FLUTE delivery of the file, an integer number of FEC encoding symbols are
contained in the 1024-byte packet payload -- in this example, four 256-byte
FEC symbols are carried in each FLUTE packet. Loss in reception of any FLUTE
packet, due to for example transmission errors, would result in a loss of four
symbols (for packets not containing padding bytes). The UE will track the
number of symbols it has successfully acquired, and determine the specific
additional symbols needed for successful FEC decoding. As shown in the above
example, FEC symbols which map logically to Blocks 1, 5 and 6 of the source
file (along with some repair symbols) were not received, corresponding to the
loss of source symbols with ESIs (Encoded Symbol IDs) 4-7 and 20-26. Suppose
that in this example, eleven additional symbols are needed to enable full file
recovery. The MBMS client will determine that source symbols with ESIs 4-7,
20-23, and 24-26, corresponding to Blocks 1 and 5, and a portion of Block 6,
will need to be acquired via unicast file repair. Subsequently, the UE will
employ CoAP's Block2 option to request, via the GET method, block-wise
transfer from the server of those symbols, as shown in Figure 2.
Figure 7.3.2.1-2 -- Block-wise transfer request and response for retrieval of
FEC symbols contained in Blocks 1 and 5 at repair server
Note that in the example message flow in Fig. 7.3.2.1-2, and according to the
semantics in RFC 7959 [13], the third line of the request indicates, by 'B2',
the use of the 'Block2' option in the request, and whereby the notation
'1/0/6' correspond to the triplet [NUM/M/SZX]. The NUM field represents the
block number of the payload requested for return in the response ('1', '5' and
'6' in this example), the M bit has no meaning and must be set to zero, and
SZX = 6 is a variable for use in computing the actual block size for use in
block-wise transfer, as given by 2^(SZX\ +\ 4)^, or 1024 bytes. Due to the use
of the Confirmable (CON) message in the request with message ID as shown
inside the bracket [ ], reliability is ensured for the associated UDP
transport by the returned ACK message, with the same Message ID, in which the
requested resource is piggybacked.
#### 7.3.2.2 Option 4: Block request for repair data after broadcast
transmission of only repair symbols
In the example as shown below in Figure 7.3.2.2-1, only repair symbols are
sent in the broadcast delivery of the file object. As in the previous case, a
6.7 Kbyte file is broadcast to (IoT) UEs, the BM-SC applies AL-FEC in the
transmission of the file object, and the encoded repair symbols are sent as a
sequence of ALC/ FLUTE packets, each with payload size of 1024 bytes.
Figure 7.3.2.2-1 -- MBMS download delivery of 6.7-kByte file employing
256-byte FEC symbols carried in FLUTE packets with payload size of 1024 bytes;
sending of repair symbols only
In this example, it can be seen that FEC symbols which map logically to Blocks
1, 5, 6 and 7 were not received, resulting in the loss of repair symbols with
ESIs (Encoded Symbol IDs) 4-7 and 20-31. Similar to the previous example, it
is assumed that eleven additional symbols are needed to enable full file
recovery, but since only repair symbols were transmitted/received, file
recovery can be achieved at the UE by acquiring any eleven source symbols,
ensured to be distinct from the already-received repair symbols. In this case,
it would the simplest for the MBMS client, acting as the CoAP client, to
request the first eleven source symbols, i.e., the initial 2048 bytes of the
file stored in the repair server. In other words, the UE will employ CoAP's
Block2 option to request, via the GET method, block-wise transfer by the
server of the first three 1024-byte blocks (Blocks 0, 1 and 2), from the
repair server, as shown in Figure 7.3.2.2-2.
Figure 7.3.2.2-2 -- Block-wise transfer request and response for retrieval of
FEC symbols contained in Blocks 0, 1 and 2 at repair server
### 7.3.2.3 Comparison of Block Request based File Repair Options
The The Option 3 vs. Option 4 methods for block request based file repair, as
described in Sections 7.3.2.1 and 7.3.2.2, bear resemblance to the broadcast
delivery of source and repair symbols vs. repair symbols only methodologies,
respectively, and associated unicast procedures for byte-range based file
repair as specified in 3GPP TS 26.346. Broadcast transmission of source and
repair symbols is shown below in Fig. 7.3.2.3-1, and broadcast transmission of
only the repair symbols is shown in Fig. 7.3.2.3-2.
{width="3.113888888888889in" height="1.6145833333333333in"}
Figure 7.3.2.3-1 -- Broadcast delivery of source and repair symbols
{width="93.9625in" height="1.5152777777777777in"}
Figure 7.3.2.3-2 -- Broadcast delivery of repair symbols only
The Block options ('Block1' and 'Block2' as defined in RFC 7959 [3][13])
enable the repair server to be stateless, i.e. it does not maintain state on
what the client has previously retrieved, nor is it aware of the status of the
file repair process -- e.g., when the client has finished, whether the client
has decided to abort the file repair procedure (for example, due to change in
the ETag value of the file resource), etc. Complexity of server operation in
support of file repair requests from the UE is the same, regardless of whether
the client is retrieving contiguous or non-contiguous blocks, or the relative
position of the requested repair data within the source file stored at the
server (for example, at the beginning or near the end of the file, or
somewhere in between). The reason being that the server is handling the
request/response for one block at a time, and it maintains no state
information on prior transactions.
On the other hand, broadcast transmission of only repair symbols makes the
MBMS client's processing task a little easier, as it need not track which
source symbols are missing in generating request for that specific set, which
would be required if source symbols were broadcast. However, the client still
has to make two separate CoAP requests, as done in Optoin 3. Another potential
advantage of repair-only broadcast, as compared to broadcast of source
symbols, is the expected better caching efficiency (higher "hit ratio') in
case that proxy caches are employed in the unicast network, since every client
that performs file repair can be designed to request repair data (as
contiguous symbols) starting with the very first CoAP Block of the source
file.
## 7.4 Binary data formats
MBMS protocols, codecs and procedures often use XML as a format for exchanging
metadata (e.g. FDT, service announcement). However, the use of XML stack can
be costly for IoT devices, especially for low-end IoT profile. Binary data
formats may be more appropriate for IoT devices to exchange metadata. One can
define a paritular binary format for each specific purpose (e.g. FDT, service
announcement, reception report). However, it is desirable to have a common
binary format for all procedures, formats in the context of MBMS IoT.
### 7.4.1 Efficient Extensible Interchange or Efficient XML Exchange (EXI)
EXI is a way for one system to send to another system a highly compressed
sequence of parse events. The recipient can build data structures directly
from the parse events without having to reconstitute a textual representation
(such as a JSON file, an XML file, JavaScript, HTML and so forth) [14]. It was
developed by W3C's Efficient Extensible Interchange Working Group. EXI
provides multiple benefits as follows (non exhaustive list):
  * EXI provides better compression than other XML compression techniques, and can deliver compression ratios of up to 100 to 1 (Figure 7.4.5.2-1) [15];
  * Using EXI format reduces the verbosity of XML documents as well as the cost of parsing;
  * When using EXI, XML parsers consume EXI directly. XML applications, such as XML Schema validators and XSLT processors, will process the EXI exactly as they\'ve always processed XML, i.e., no changes to the XML applications are required and XML applications are completely unaware that the format of the data is binary, not text (Figure 7.4.1-2);
  * EXI format specification does not make particular assumption about the platform architecture;
  * EXI was designed to integrate well into the XML stack, neither duplicating nor requiring changes to functionality at other layers in the XML stack.
Figure 7.4.1-1 shows the diagram which uses EXI to exchange data between
sender and receiver.
{width="3.3625in" height="2.5388888888888888in"}
Figure 7.4.1-1: Data exchange using EXI [15]
Figure 7.4.1-2 shows the interaction between EXI, XML parser and XML
application. The parser converts the EXI to an XML infoset and XML
applications operate on the infoset. Thus, the applications are unaware that
EXI is being used.
{width="2.5236111111111112in" height="1.8743055555555554in"}
Figure 7.4.1-2: Interaction between EXI, XML parser and XML application [15]
EXI defines two types of encoding: schema-less and schema-informed. The
schema-less encoding is generated directly from the XML data and can be
decoded by any EXI entity without any prior knowledge about the data. The
schema-informed encoding assumes that the two EXI processors share an XML
Schema before actual encoding and decoding can take place. In schema-informed,
the available schema information is used to improve compactness and
performance.
### 7.4.2 Well-known binary formats
A number of well-known binary formats for representing data are available such
as ASN.1 [16], Thrift [17], Protobuf [18].
The Abstract Syntaxt Notation One (ASN.1) is a well-know binary format used in
many applications, especially in telecommunications (3G, LTE). The notation
describes data structures for representing, encoding, transmitting, and
decoding data. Data structures transfer syntax can be encoded using different
encoding rules, providing schema notation even for representing XML in binary
form - XER (XML Encoding Rules). The standard ASN.1 encoding rules include:
  * Distinguished Encoding Rules (DER)
  * Basic Encoding Rules (BER)
  * Canonical Encoding Rules (CER)
  * XML Encoding Rules (XER)
  * Canonical XML Encoding Rules (CXER)
  * Extended XML Encoding Rules (E-XER)
  * Packed Encoding Rules (PER, unaligned: UPER, canonical: CPER)
  * Octet Encoding Rules (OER, canonical: COER)
  * JSON Encoding Rules (JER)
  * Generic String Encoding Rules (GSER)
Unaligned PER is commonly used in 3GPP cellular technologies such as UMTS (3G)
or LTE (4G) for protocols like RANAP, NBAP or RRC [19].
Thrift is an interface definition language and binary communication protocol
that is used to define and create services for numerous languages. Thrift is
used as a remote procedure call (RPC) framework and was developed at Facebook.
Although developed at Facebook, it is now an open source project in the Apache
Software Foundation.
The Protocol Buffers (Protobuf) is a method of serializing structured data. It
is useful in developing programs to communicate with each other over a wire or
for storing data. Protobuf were initially developed at Google to address the
problem of large number of requests and responses to/from the index server.
This protocol uses binary encoding which makes serialized data more compact.
The design goals for Protobuf emphasized simplicity and performance. In
particular, it was designed to be smaller and faster than XML.
Table 7.4.2-1 shows the comparison between these binary formats [20].
* * *
                           **Binary formats**                                  
                           **ASN.1**                  **Thrift**               **Protobuf**
Licence Open source Open source Open source Language compatibility Java, C++,
C, Python... C++, Java, Python, PHP Java, C++, Python Parsing speed Fast
Medium Fast Memory usage Low Medium Medium Debugging complexity High Low
Medium Implementation Medium Medium Low Documentation Very good Less than good
Very good
* * *
Table 7.4.2-1: Comparison of binary formats
NOTE: The implementation indicates the implementation complexity. ASN.1
demands external (third-party) tool for reading encoded message, and it is
more complex to deploy [20]. Protobuf has some built-in features, i.e.
toString() method that returns human-readable representation of message.
### 7.4.3 Ad-hoc binary format
Besides the well-known binary formats presented in section 7.4.2 (ASN.1,
Thrift, Protobuf), one can define a customized binary format for a given data
structure requirement.
For instance, Figure 7.4.3-1 shows an example of an Ad-hoc binary format for
FDT.
Bits | 
> Number of Octets
|  |  |  |  |  |  |  |   
---|---|---|---|---|---|---|---|---|---  
7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  |   
HET = 194 | 1 | Header part |  |  |  |  |  |  |   
FLUTE Version = 1 | FDT Instance ID | 1 |  |  |  |  |  |  |   
FDT Instance ID continue | 2 |  |  |  |  |  |  |  |   
Binary FDT Version = 1 | Expires | Base-URL-1 | Base-URL-2 | FEC Information bit (NOTE 6) | 1 (NOTE 5) | Binary FDT descriptor |  |  |   
Length of FDT descriptor (NOTE 7) | 2 |  |  |  |  |  |  |  |   
Content-type (NOTE 1) | 1 |  |  |  |  |  |  |  |   
Length of Expires | 2 |  |  |  |  |  |  |  |   
Expires | 0-m |  |  |  |  |  |  |  |   
Length of Base-URL-1 | 2 |  |  |  |  |  |  |  |   
Base-URL-1 | 0-m |  |  |  |  |  |  |  |   
Length of Base-URL-2 | 2 |  |  |  |  |  |  |  |   
Base-URL-2 | 0-m |  |  |  |  |  |  |  |   
FEC-OTI-FEC-Encoding-ID | 1 |  |  |  |  |  |  |  |   
FEC-OTI-Maximum-Source-Block-Length | 2 or 4 (NOTE 2) |  |  |  |  |  |  |  |   
FEC-OTI-Encoding-Symbol-Length | 2 |  |  |  |  |  |  |  |   
Length of FEC-OTI-Scheme-Specific-Info | 2 |  |  |  |  |  |  |  |   
FEC-OTI-Scheme-Specific-Info | 0-m |  |  |  |  |  |  |  |   
Number of files (NOTE 3) | 1 |  |  |  |  |  |  |  |   
Reserved bits for extension of FDT descriptor (NOTE 7) | 0-m |  |  |  |  |  |  |  |   
Length of the Nth file (NOTE 4) | 2 | Binary FDT content |  |  |  |  |  |  |   
Content Length | Content Type | Content MD5 | FEC-OTI-FEC-Encoding-ID | FEC Information bit (NOTE 6) | mbms2012:Alternate-Content-Location-1 | mbms2012:Alternate-Content-Location-2 | mbms2012:File-ETag | 1 (NOTE 5) |   
Transport Object Identifier (TOI) of the Nth file | 2 |  |  |  |  |  |  |  |   
Length of Content-location of the Nth file | 2 |  |  |  |  |  |  |  |   
Content-location of the Nth file | 0-m |  |  |  |  |  |  |  |   
Length of Content-Length of the Nth file | 2 |  |  |  |  |  |  |  |   
Content-Length of the Nth file | 0-m |  |  |  |  |  |  |  |   
Content-Type of the Nth file | 1 |  |  |  |  |  |  |  |   
Length of Content-MD5 of the Nth file | 2 |  |  |  |  |  |  |  |   
Content-MD5 of the Nth file | 0-m |  |  |  |  |  |  |  |   
FEC-OTI-FEC-Encoding-ID of the Nth file | 1 |  |  |  |  |  |  |  |   
FEC-OTI-Maximum-Source-Block-Length of the Nth file | 2 or 4 (NOTE 2) |  |  |  |  |  |  |  |   
FEC-OTI-Encoding-Symbol-Length of the Nth file | 2 |  |  |  |  |  |  |  |   
FEC-OTI-Max-Number-of-Encoding-Symbols of the Nth file | 2 |  |  |  |  |  |  |  |   
Length of FEC-OTI-Scheme-Specific-Info of the Nth file | 2 |  |  |  |  |  |  |  |   
FEC-OTI-Scheme-Specific-Info of the Nth file | 0-m |  |  |  |  |  |  |  |   
Length of mbms2012:Alternate-Content-Location-1 of the Nth file | 2 |  |  |  |  |  |  |  |   
mbms2012:Alternate-Content-Location-1 of the Nth file | 0-m |  |  |  |  |  |  |  |   
Length of mbms2012:Alternate-Content-Location-2 of the Nth file | 2 |  |  |  |  |  |  |  |   
mbms2012:Alternate-Content-Location-2 of the Nth file | 0-m |  |  |  |  |  |  |  |   
Length of mbms2012:File-ETag of the Nth file | 2 |  |  |  |  |  |  |  |   
mbms2012:File-ETag | 0-m |  |  |  |  |  |  |  |   
Reserved bits for extension of the Nth file (NOTE 4) | 0-m |  |  |  |  |  |  |  |   
Figure 7.4.3-1: Example of AD-hoc binary FDT Instance format
NOTE 1: Content-type of 8 bits could be suffisant for IoT applications.
NOTE 2: 2 octets for FEC Encoding IDs 0, 128, and 130; 4 octets for FEC
Encoding ID 129.
NOTE 3: A maximum of 255 files delivered in a single FLUTE session could be
suffisant since multiple FLUTE sessions are possible.
NOTE 4: If the length value of the N^th^ file in the binary FDT is higher than
the actual length, the reserved bit for extension are present. The content and
values of the extension fields are FFS.
NOTE 5: A list of flags indicates whether the element appears in the FDT or
N^th^ file. The value \'0\' indicates that the flag is not appeared, the
corresponding length and content fields of this flag are not appeared in the
binary FDT. The value \'1\' indicates that the flag is present. The order of
the flag content follows the order in the list of flags. For the elements
which have a specific length such as FEC related information, there is no
length field.
NOTE 6: The FEC Information bit is set to \'0\' if compact no-code FEC is
used. Otherwise, this flag is set to \'1\', the corresponding fields (FEC-OTI-
Maximum-Source-Block-Length, FEC-OTI-Encoding-Symbol-Length, Length of FEC-
OTI-Scheme-Specific-Info, FEC-OTI-Scheme-Specific-Info) related to FEC are
present.
NOTE 7: If the value of the length of FDT descriptor is higher than the actual
length, the reserved bits for extension are present. The content and values of
extension fields are FFS.
### 7.4.4 Key-Length-Value (KLV) format
Section 7.4.3 presents the ad-hoc binary format where each data representation
requires a customized binary format. Another possible solution is to use a
special Key-Length-Value for all formats and procedures for MBMS IoT. In this
KLV format, each data type is associated to a key value while the Length field
indicates the actual length of the Value field. For instance, one can define
up to 255 keys for MBMS IoT as shown in Table 7.4.4-1.
* * *
**Key** **Data type** **Length** **Value** 1 Content-Location 2  
2 Content-Type 1  
3 mbms2012:File-ETag 2  
...  
255
* * *
Table 7.4.4-1: Example table for KLV format
This KLV solution can be considered as a subset of ASN.1 solution using BER,
PER or OER encoding rules.
### 7.4.5 Performance comparison of binary data formats
#### 7.4.5.1 General considerations
There are important aspects to consider when comparing different data
representation schemes [24]. Some of the most relevant are,
  * how are optional fields within messages handled, i.e., how is a field's presence or absence represented,
  * possibility of future backward compatibility when extending a message, i.e., adding of new mandatory or optional data fields,
  * byte alignment,
  * providing the functionality of data compression, for example variable length representation of integers.
Table 7.4.5.1-1 show the properties of different schemes from the general
considerations [24]. The properties of ASN.1 UPER, Protobuf and EXI are
extracted from [24].
* * *
                                ASN.1 UPER (NOTE 7)   Protobuf (NOTE 7)   EXI (NOTE 7)        KLV            Ad-hoc binary format
Presence of optional fields Encoded Encoded Encoded Not encoded Encoded (NOTE
4) Extendability No (NOTE 1) Yes Yes Yes (NOTE 3) Yes (NOTE 5) Byte alignment
(NOTE 6) No (NOTE 2) Yes No Yes No Compression Yes Yes (byte blocks) Yes (byte
blocks) Yes Yes
* * *
Table 7.4.5.1-1: Overview of basic properties for different binary schemes
NOTE 1: Other ASN.1 encoding rules (e.g. BER) satisfy this property.
NOTE 2: The aligned PER encoding rule satisfies this property.
NOTE 3: The extendability of KLV format is limited to the pre-defined maxinum
number of keys (e.g. 255 keys if 8 bits are used).
NOTE 4: Optional fields are presented by a list of flags.
NOTE 5: If reserved bits for extension are used.
NOTE 6: Byte alignment indicates that the fields are aligned to 8-bit octet
boundaries by inserting padding bits.
NOTE 7: The assessment of ASN.1 UPER, Protobuf and EXI reflects the view of
the authors in [24].
#### 7.4.5.2 Performance comparison
Figure 7.4.5.2-1 shows better compactness of EXI compared to both XML and
ASN.1 PER [22]. However, the comparison between EXI and ASN.1 PER in terms of
processing efficiency is not shown in the evaluation performed by W3C.
{width="5.333333333333333in" height="3.6479166666666667in"}
Figure 7.4.5.2-1: EXI compactness compared to ASN.1 PER
NOTE: Whenever a schema is available, EXI uses the schema-informed for the
test cases [22].
Table 7.4.5.2-1 also confirms the better compactness of EXI compared to ASN.1
PER [23]. In this evaluation, EXI uses schema-informed and no-compression.
* * *
              **JTLM Data (360 bytes)**   **Location Data (103 bytes)**
Format Size (bytes) Ratio Size (bytes) Ratio XML 360 100% 103 100% ASN.1 PER
105 29% 27 26% EXI 39 11% 17 17%
* * *
Table 7.4.5.2-1: Comparison in terms of compactness between XML, ASN.1 PER and
EXI
NOTE: The compactness performance of EXI may be different when schema-less is
used.
Table 7.4.5.2-2 shows the processing efficiency for both encoding and decoding
[23]. ASN.1 PER shows better processing efficiency with Location Data (103
bytes).
* * *
              **Encode**   **Decode**
Format TPS Ratio TPS Ratio XML 15858 1 9216 1 EXI 185029 x11.7 277409 x30.0
ASN.1 PER 310862 x19.6 318419 x34.6
* * *
Table 7.4.5.2-2: Comparison in terms of processing efficiency between XML,
ASN.1 PER and EXI
NOTE: TPS stands for transactions per second.
The evaluation between Protobuf, EXI and ASN.1 UPER is performed in the
context of wireless Car-to-X communication [24]. The performance metrics
considered in this evaluation are:
  * Computation time
  * Memory footprint on computation
  * Encoded data length.
Tables 7.4.5.2-3 and 7.4.5.2-4 show the encoding and decoding performance
results for CAM (Cooperative Awareness Message) and DENM (Decentralized
Environmental Notification Message) messages with Protobuf, ASN.1 UPER and
EXI.
* * *
                   **CAM**      **DENM**
Encoding type Protobuf ASN.1 UPER EXI Protobuf ASN.1 UPER EXI Heap / Stack 242
/ 1864 66 / 3112 62656 / 210 126 / 1752 75 / 2792 61608 / 175 Encoded length
165 41 64 (opt: 61) 114 43 52 (opt: 51)
* * *
Table 7.4.5.2-3: Encoding performance results for CAMs and DENMs [24]
* * *
                       Protobuf     ASN.1 UPER   EXI
CAM: heap / stack 242 / 1800 370 / 2968 3850 / 210 DENM: heap / stack 126 /
1624 816 / 2872 3630 / 135
* * *
Table 7.4.5.2-4: Memory related decoding performance results for CAMs and
DENMs [24]
NOTE: Size of encoded messages is one of the key parameters in the evaluation
in [24], data optimized schemes are used for EXI.
The following conclusions are drawn from the evaluation in [24]:
  * ASN.1 UPER outperforms Protobuf and EXI in terms of required encoding delay and runtime (Figure 7.4.5.2-2).
  * EXI showed to be the most expensive in terms of memory footprint (Tables 7.4.5.2-3 and 7.4.5.2-4).
  * ASN.1 UPER encoding performs better compared to EXI and Protobuf in terms of encoding length for CAM and DENM messages (Tables 7.4.5.2-3 and 7.4.5.2-4).
  * In terms of runtime, binary encoding performs significantly better than ASN.1 UPER in all studied cases (Figure 7.4.5.2-2).
{width="6.686111111111111in" height="2.3513888888888888in"}
Figure 7.4.5.2-2: Encoding (left) and decoding (right) runtime performance of
ETSI ITS CAM, DENM and security envelope encoding on an Intel Core i7
processor [24]
NOTE 1: Sec. 1w/o indicates security profile 1 for CAM message without
certificate. Sec. 1w indicates security profile 1 for CAM message with
certificate. Sec. 2 indicates security profile 2 for DENM message. Sec. 3
indicate security profile 3 for generic message.
NOTE 2: The binary format is specialized for CAM and DENM messages.
#### 7.4.5.3 Summary
The following conclusions are drawn from the performance comparison in section
7.4.5.2:
  * Binary data formats (e.g. EXI, ASN.1, Protobuf) significantly outperform the XML data representation in terms of both compactness, encoding/decoding processing efficiency and memory usage.
  * ASN.1 UPER is better than EXI in terms of processing efficiency and memory footprint [24].
  * ASN.1 PER is better than EXI in terms of processing efficiency [23].
  * EXI is better than ASN.1 (UPER or PER) in terms of compactness in the evaluation performed by W3C. In the evaluation performed by [24], ASN.1 UPER performs better than EXI for CAM and DENM messages in terms of encoded data length.
  * Binary encoding specialized for CAM and DENM messages significantly better than ASN.1 UPER and EXI in terms of run time.
#### 7.4.5.3 Recommandation
#### According to previous results, it is recommended to use ASN.1 PER as
basis for XML binary format for IoT
## 7.5 Solution for announcement during wake-up periods
This solution addresses the recommended requirement in section 4.2.2. IoT
devices use eDRX (Extended Discontinuous Reception) and PSM (Power Saving
Mode) to save battery consumption. When a software/firmware update is
required, the service announcement using continuous/carousel broadcast
delivery of SACH (Service Announcement Channel) may not be efficient from the
network perspective since IoT devices are not expected to be awake throughout
the day, but only infrequently. Furthermore, they do not wake-up at the same
time and more importantly, they are not reachable while being in power saving
mode. This solution proposes to inform the IoT devices about a newly scheduled
download delivery session during their wake-up periods when the devices are
reachable.
For initially unplanned data delivery use case described in section 4.2, when
a new MBMS schedule containing the new software/firmware update for IoT
devices becomes available, the network will send a message to inform the IoT
UEs about the new schedule when they wake up, but before returning to power
saving mode.
Such message to inform IoT UEs about a new MBMS schedule can either
  * Indicate the time at which service announcement based on SACH will be sent;
  * Contain the service announcement including the Schedule Description if the size is small.
The time interval from when a new file delivery schedule is announced to when
the actual MBMS file delivery session as announced by that schedule will start
is larger than the maximum PSM period of all IoT devices. This constraint
ensures that all IoT devices are informed about the new file delivery
schedule.
According to 3GPP TS 23.682 clause 4.5.4, a UE using PSM is available for
mobile terminating services only for the period of an Active Time after a
mobile originated event like data transfer or signalling, e.g. after a
periodic TAU/RAU procedure (Tracking Area Update/Routing Area Update). Figure
7.5-1 shows an example when the IoT UE #1 has available data to send to the
network and the network takes advantage of this reachable period to inform the
UE about a newly scheduled download delivery session. The IoT UE #2 receives
an announcement later when it wakes up to send data. Due to some reasons (e.g.
lost connectivity), the IoT UE #3 does not wake up periodically to send data.
The IOT UE #3 wakes up to update its tracking area due to the expiration of
TAU timer, it also receives the announcement from the network.
{width="5.636805555555555in" height="3.29375in"}
Figure 7.5-1: Inform about a new schedule during UE wake-up periods
NOTE: Waking up due to expiration of TAU timer is not common for battery-
constrained IoT applications. In practice, to optimize the battery usage in
IoT devices, periodic TAU timer is configured to be longer than the periodic
time when the devices wake up to send data to the network.
The network may use PUT CoAP method with Content-Format option to deliver the
information about a new MBMS schedule (Figure 7.5-2). In this example, ID 42
is used to indicate an octet-stream data type.
{width="6.2131944444444445in" height="1.1930555555555555in"}
Figure 7.5-2: Example use of CoAP PUT method to inform about a new schedule
NOTE 1: The message content is out of scope of this solution and is addressed
in other solutions.
NOTE 2: If the content carried in PUT method is larger than the maximum CoAP
message size preferred by IoT UEs, block-wise transfer as described in RFC
7959 can be applied.
## 7.6 Solution for announcement with critical data delivery
This solution addresses the recommended requirement in section 4.3.2. The
solution for service announcement when a critical software/firmware update is
required is as follows:
  * When a new MBMS schedule containing a critical software/firmware update for IoT devices becomes available, the network will send a message to inform the IoT UEs about the new schedule when they are reachable;
  * The network may schedule multiple critical delivery sessions where the time between two consecutive delivery sessions is considered as critical interval;
  * The time interval from when a critical file delivery schedule is announced to when the first MBMS file delivery session as announced by that schedule will start can be shorter than the minimum PSM period of all IoT devices.
The IoT UEs using PSM and/or eDRX can be reachable in the following possible
cases:
  * In connected mode if the IoT UEs have just sent data to the network;
  * In active state after PSM;
  * In idle state and listen for paging (DRX or eDRX)
NOTE 1: Other possible cases where the IoT devices are reachable are out of
scope of this study.
NOTE 2: The IoT UEs which do not use neither PSM nor eDRX follows the paging
procedures as regular UEs.
NOTE 3: The details how the network pages the IoT devices are out of scope of
this study.
Similar to the solution in section 7.5, a message to inform IoT UEs about a
critical MBMS schedule can either
  * Indicate the time at which service announcement based on SACH will be sent;
  * Contain the service announcement including the Schedule Description.
> Figure 7.6-1 shows an example when the IoT UE #1 wakes up and has available
> data to send to the network. Since the IoT UE #1 has switched to Idle state
> at the time a new MBMS schedule has been created and is sent over the MBMS
> bearer (as respresented by the left-most vertical dashed line), the network
> will page the device and inform the UE about a newly scheduled download
> delivery session for critical data. The IoT UE #2 receives the announcement
> later when it wakes up to send data. Both IoT UE #1 and #2 wake up at the
> scheduled time (First repetition of broadcast delivery of files according to
> the schedule) to receive the software/firmware update from the network. The
> IoT UE #3 wakes up after the first repetition of broadcast delivery of files
> is completed, it also receives the announcement from the network for the
> next download delivery session (Second repetition of broadcast delivery of
> files according to the schedule). During the next wake up periods of IoT UE
> #1 or #2, the network does not inform about the download delivery session
> since they already received the software/firmware update. The process
> continues until all IoT devices receive a criticial software/firmware update
> and have appropriate action (e.g. successful update).
{width="6.060416666666667in" height="3.571527777777778in"}
Figure 7.6-1: Announcement of broadcast schedule for a critical download
delivery session during UE wake-up from PSM to send data and subsequent
broadcast delivery/reception of the associated file
7.7 Solution for reception report procedures
This solution addresses the recommended requirements in section 4.1.2. There
are 4 _reportType defined in 3GPP TS 26.346, Table 7.7-1 shows the supported
reportType for IoT devices._
* * *
**_reportType_** **IoT profiles** Rack-IoT Yes (NOTE 1) StaR No (NOTE 2) StaR-
all No (NOTE 2) StaR-only Yes (NOTE 2)
* * *
**Table 7.7-1: supported _reportType_ for IoT devices**
NOTE 1: _reportType_ Rack-IoT is an extension of Rack (defined in _3GPP TS
26.346)_ in order to fulfil the requirements for IoT. According to 3GPP TS
26.346 clause 9.4.3, \"_The samplePercentage attribute is optional and
behaviour shall default to 100 (%) when it is not present. The
samplePercentage attribute may be used with StaR, StaR-only and StaR-all, but
shall not be used with RAck_ \". _For IoT devices, this samplePercentage
attribute can be useful to save battery consumption in the device for non-
critical software delivery. For critical software delivery, this attribute
shall be set to 100._
NOTE 2: StaR-only might not be desirable for Low-end IoT profile. However,
StaR-only can be useful for High-end IoT profile while other statistical
report variants are not necessary.
Table 7.7-1 show the fields that could be contained in the reception report
message for RAck-IoT _reportType_.
**Table 7.7-1: Fields contained in binary reception report message for RAck-
IoT _reportType_**
* * *
**Field name** **Presence (Mandatory/Optional)** IoT ID (NOTE 1) M Number of
files (NOTE 2) M Status of the file (NOTE 3) M ID of the file (NOTE 4) M
* * *
NOTE 1: IoT ID can be _clientId or_ _deviceId, or both_. According to clause
9.4.6 of TS 26.346, the _deviceId_ attribute is a unique identifier for the
receiver device, e.g. an IMEI of the UE while the _clientId_ attribute is
unique identifier for the receiver, e.g. an MSISDN of the UE. For IoT
applications, the _deviceId_ attribute could be more important than
_clientId_.
NOTE 2: A maximum of 255 files delivered in a single FLUTE session could be
sufficient since multiple FLUTE sessions are possible.
NOTE 3: The status value addresses the recommended requirement where the 3GPP
system supports a mechanism to acknowledge a successful reception and action
required (e.g. successful file update). For example, the status value is set
to \'0\' for \"acknowledged\", \'1\' for \"acknowledged with successful
action\", \'2\' for \"acknowledged with unsuccessful action\". Other values
are reserved.
NOTE 4: ID of the file can be _fileURI_ , _Content-MD5_ or File-Etag.
_fileURI_ could be mandatory while _Content-MD5_ and File-Etag could be
optional.
A proposal of ASN.1 PER definition for reception report message for RAck-IoT
type is depicted as follows
\-- ASN1START
MBMSIoT-ReceptionReport-Message-RAck-IoT ::= SEQUENCE {
identifier IoT-ID-IEs,
fileReporting SEQUENCE (SIZE(1..255)) OF ReceptionReport-File-RAck-IoT-IEs,
locationType ENUMERATED{cgi, ecgi, sai, ...} OPTIONAL,
nonCriticalExtension ReceptionReportMessage-RAck-IoT-Extension-IEs OPTIONAL
}
IoT-ID-IEs ::= SEQUENCE {
deviceId OCTET STRING (SIZE(1..255)),
clientId OCTET STRING (SIZE(1..255)) OPTIONAL
}
ReceptionReportMessage-RAck-IoT-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
ReceptionReport-File-RAck-IoT-IEs ::= SEQUENCE {
status ENUMERATED {acknowledged, acknowledgedAndSuccessfulAction,
acknowledgedAndUnsuccessfulAction, ...},
identifier File-ID-IEs,
nonCriticalExtension ReceptionRepot-File-RAck-IoT-Extension-IEs OPTIONAL
}
File-ID-IEs ::= SEQUENCE {
fileURI OCTET STRING (SIZE(1..255)),
contentMD5 BIT STRING (SIZE(128)) OPTIONAL,
fileEtag OCTET STRING (SIZE(1..255)) OPTIONAL
}
ReceptionRepot-File-RAck-IoT-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
\-- ASN1STOP
NOTE 1: ASN.1 defines multiple character string types (e.g. BMPString,
IA5String, GeneralString, GraphicString, NumericString, PrintableString,
TeletexString, UniversalString, UTF8String, VideotexString, VisibleString,
etc.). The encoding does not matter for Low-end IoT devices without user
interface, OCTET STRING type can represent an identifier, a URL or URI.
NOTE 2: The string size is limited to 255 in order to occupy only 1 octet for
the field description.
In 3GPP TS 26.346, reception report is sent in a single HTTP POST request
carrying XML formatted metadata for each reported received content (file).
However, IoT devices, especially low-end profile, might not have HTTP and TCP
stacks. Figure 7.7-2 shows the solution for reception report using POST CoAP
method. In this example, ID 42 for Content-Format is used to indicate an
octet-stream data type.
{width="5.896527777777778in" height="1.4270833333333333in"}
**Figure 7.7-2: Example use of CoAP POST method to send reception report**
NOTE: If the content carried in POST method is larger than the maximum CoAP
message size preferred by the CoAP client and server, block-wise transfer as
described in RFC 7959 can be applied.
7.8 Solution for service announcement procedures
#### 7.8.1 Unicast delivery of service announcement using CoAP
3GPP TS 26.346 clause 5.2.5 specifies the user service announcement over
point-to-point push bearers where SMS or HTTP push bearers are used for
delivery of metadata envelope and metadata fragments. As indicated in the
section 6.1, a CoAP based solution for Interactive Announcement Function
instead of HTTP could be more appropriate. The solutions in the sections 7.5
and 7.6 indicate that a unicast delivery of service announcement using CoAP is
possible. The unicast delivery of service announcement using CoAP could be
used for the use cases described in sections 4.2 and 4.3.
NOTE: The broadcast schedule using SACH could be used for the use case 3
described in section 4.3.
#### 7.8.2 Service announcement profiles for IoT devices
The Service announcement for IoT devices might be kept as small and simple as
possible. The profiling for IoT applications is based on the MBMS User Service
Discovery / Announcement Profile 1a specified in the Annex L.2 of 3GPP TS
26.346.
3GPP TS 2.346 clause 11.1 specifies the MBMS metadata envelope. To reduce the
service announcement size (i.e. reduce battery consumption), the software
update for each Low-end IoT device type (e.g. smart water-metering, smart
electric-metering) might be carried in different MBMS sessions. Thus, a
metadata envelope based on ASN.1 PER binary encoding for Low-end profile
contains only one USBD fragment, one Session Description fragment, one
Schedule Description fragment, and optionally one Associated Delivery
Procedure Description (ADPD) fragment. A USBD contains only one instance of
USD fragment.
Clause 11.1.4 of 3GPP TS 26.346 indicates that a metadata fragment can be
embedded or referenced within a metadata envelope. For IoT applications, it's
desirable to use the embedded metadata fragments within the metadata envelope.
Table 7.8.1-1 shows the list of supported metadata fragment in a metadata
envelope.
* * *
**Metadata fragment** **Recommended for Low-end profile** **Recommended for
High-end profile** USBD M M Session Description M M Schedule Description M M
Associated Delivery Procedure Description O O MPD No O Initialization Segment
Description (ISD) No O NOTE: MPD and ISD are not required for IoT devices.
* * *
**Table 7.8.1-1: List of metadata fragments in a metadata envelope.**
Clause L.2.4 in 3GPP TS 26.346 specifies that the _validFrom_ and _validUntil_
attributes in each _item_ of the metadata envelope are identical for all
fragments of a given MBMS User Service. Therefore, a single (_validFrom_ ,
_validUntil_) attribute couple for a metadata envelope in binary format is
required for IoT devices to reduce the size (i.e. reduce battery consumption).
The time is expressed as UTC timestamp.
Clause L.2.5 in 3GPP TS 26.346 specifies the list of supported attributes and
elements for a USBD fragment. Table 7.8.1-2 shows the profiling of USBD
fragment for IoT devices.
**Table 7.8.1-2: List of supported attributes and elements for USBD fragment
used by IoT service providers**
+----------------------+----------------------+----------------------+ | **Attribute or |** Recommended for | **MBMS profile 1a in | | element** | Low-end IoT category | Annex L.2 3GPP TS | | | profile**| 26.346** | +----------------------+----------------------+----------------------+ | bundleDescript | No (NOTE 1) | M | | ion.sv:schemaVersion | | | +----------------------+----------------------+----------------------+ | bundleDescription.us | M | M | | erServiceDescription | | | +----------------------+----------------------+----------------------+ | bundleDesc | M | M | | ription.userServiceD | | | | escription.serviceId | | | +----------------------+----------------------+----------------------+ | bundleDescriptio | O | M | | n.userServiceDescrip | | | | tion.r7:serviceClass | | | +----------------------+----------------------+----------------------+ | bundleDescripti | M | M | | on.userServiceDescri | | | | ption.deliveryMethod | | | +----------------------+----------------------+----------------------+ | bundleDescription. | M | M | | userServiceDescripti | | | | on.deliveryMethod\@s | | | | essionDescriptionURI | | | +----------------------+----------------------+----------------------+ | bundleDesc | M | M | | ription.userServiceD | | | | escription.deliveryM | | | | ethod\@associatedPro | | | | cedureDescriptionURI | | | +----------------------+----------------------+----------------------+ | bundleDescri | O | O | | ption.userServiceDes | | | | cription.deliveryMet | | | | hod\@accessPointName | | | +----------------------+----------------------+----------------------+ | bundleDe | No (NOTE 1) | M | | scription.userServic | | | | eDescription.deliver | | | | yMethod.sv:delimiter | | | +----------------------+----------------------+----------------------+ | b | M (NOTE 2) | M | | undleDescription.use | | | | rServiceDescription. | | | | requiredCapabilities | | | +----------------------+----------------------+----------------------+ | bundleDes | M (NOTE 2) | M | | cription.userService | | | | Description.required | | | | Capabilities.feature | | | +----------------------+----------------------+----------------------+ | bundleDescri | M | M | | ption.userServiceDes | | | | cription.r9:schedule | | | +----------------------+----------------------+----------------------+ | bundleDescrip | No (NOTE 1) | M | | tion.userServiceDesc | | | | ription.sv:delimiter | | | +----------------------+----------------------+----------------------+ | bundleDescri | No (NOTE 3) | M | | ption.userServiceDes | | | | cription.r9:mediaPre | | | | sentationDescription | | | +----------------------+----------------------+----------------------+ | bundl | No (NOTE 3) | O | | eDescription.userSer | | | | viceDescription.name | | | +----------------------+----------------------+----------------------+ | bundleDescriptio | No (NOTE 3) | O | | n.userServiceDescrip | | | | tion.serviceLanguage | | | +----------------------+----------------------+----------------------+ | bundleDescription.us | O | O | | erServiceDescription | | | | .r9:availabilityInfo | | | +----------------------+----------------------+----------------------+ | bund | O | O | | leDescription.userSe | | | | rviceDescription.r9: | | | | availabilityInfo.inf | | | | oBinding.serviceArea | | | +----------------------+----------------------+----------------------+ | bundleD | O | O | | escription.userServi | | | | ceDescription.r9:ava | | | | ilabilityInfo.infoBi | | | | nding.radioFrequency | | | +----------------------+----------------------+----------------------+ | NOTE 1: The | | | | _schemaVersion_ and | | | | _delimiter_ elements | | | | are only applied for | | | | XML data format. | | | | | | | | NOTE 2: "MBMS User | | | | Service Discovery / | | | | Announcement Profile | | | | 1a" specifies the | | | | value \'22\' to the | | | | _feature_ element. | | | | | | | | NOTE 3: The | | | | _r9:mediaPrese | | | | ntationDescription_ , | | | | _name_ and | | | | _serviceLanguage_ | | | | elements are not | | | | necessary for IoT | | | | devices. | | | +----------------------+----------------------+----------------------+
NOTE: The list of non-supported attributes and elements specified in the
clause L.2.5 of 3GPP TS 26.346 are not supported for IoT devices.
Clause L.2.6 in 3GPP TS 26.346 specifies the list of supported attributes and
elements for Schedule Description fragment. Table 7.8.1-3 shows the list of
supported attributes and elements of the Schedule Description fragment for IoT
devices.
**Table 7.8.1-3: List of supported attributes and elements for Schedule
Description fragment used by IoT service providers**
* * *
**Attribute or element** **Recommended for Low-end IoT category profile**
**MBMS profile 1a in Annex L.2 3GPP TS 26.346**
scheduleDescription.sv:schemaVersion No M
scheduleDescription.serviceSchedule.sessionSchedule M M
scheduleDescription.serviceSchedule.sessionSchedule.start M M
scheduleDescription.serviceSchedule.sessionSchedule.stop M M
scheduleDescription.serviceSchedule.sessionSchedule.index M M
scheduleDescription.serviceSchedule.sessionScheduleOverride O O
scheduleDescription.serviceSchedule.sessionScheduleOverride\@index O O
scheduleDescription.serviceSchedule.sessionScheduleOverride\@cancelled O O
scheduleDescription.serviceSchedule.fileSchedule O O
scheduleDescription.serviceSchedule.fileSchedule.fileURI O O
scheduleDescription.serviceSchedule.fileSchedule.fileURI\@cancelled O O
scheduleDescription.serviceSchedule.deliveryInfo O O
scheduleDescription.serviceSchedule.deliveryInfo\@start O O
scheduleDescription.serviceSchedule.deliveryInfo\@stop O O NOTE 1: The
schemaVersion is only applied for XML data format.
* * *
NOTE: The list of non-supported attributes and elements specified in the
clause L.2.6 of 3GPP TS 26.346 are not supported for IoT devices. The time is
expressed in UTC timestamp.
Clause L.2.7 in 3GPP TS 26.346 specifies the list of supported attributes and
elements for Associated Delivery Procedure Description fragment. Table 7.8.1-4
shows the list of supported attributes and elements of the ADPD fragment for
IoT devices.
**Table 7.8.1-4: List of supported attributes and elements for ADPD fragment
for IoT service providers**
* * *
**Attribute or element** **Recommended for Low-end IoT category profile**
**MBMS profile 1a in Annex L.2 3GPP TS 26.346**
associatedProcedureDescription.postFileRepair O O
associatedProcedureDescription.postFileRepair\@offsetTime O O
associatedProcedureDescription.postFileRepair\@randomTimePeriod O O
associatedProcedureDescription.postFileRepair.serviceURI O O
associatedProcedureDescription.postReceptionReport O O
associatedProcedureDescription.postReceptionReport\@offsetTime O O
associatedProcedureDescription.postReceptionReport\@randomTimePeriod O O
associatedProcedureDescription.postReceptionReport\@samplePercentage O O
associatedProcedureDescription.postReceptionReport\@forceTimeIndependence O O
associatedProcedureDescription.postReceptionReport\@reportType O O
associatedProcedureDescription.postReceptionReport.serviceURI O O
* * *
NOTE: The list of non-supported attributes and elements specified in the
clause L.2.7 of 3GPP TS 26.346 are not supported for IoT devices.
The parameters for Session Description fragment of an MBMS download session is
specified in the clause 7.3.2 of 3GPP TS 26.346. The non-recognized, non-
supported or invalid parameters are ignored by the IoT devices.
An example of ASN.1 PER definition for Service Announcement is depicted as
follows. This definition uses the embedded mode for all metadata fragments
except the Session Description fragment. The Session Description fragment is
referenced by the SDP file.
\-- ASN1START
MBMSIoT-ServiceAnnouncement ::= SEQUENCE {
validFrom UTCTime,
vaidUntil UTCTime,
usbd USBD-Fragment-IEs,
sessionDescription OCTET STRING (SIZE(1..255)),
scheduleDescription ScheduleDescription-Fragment-IEs,
adpd ADPD-Fragment-IEs OPTIONAL,
nonCriticalExtension ServiceAnnouncement-Extension-IEs OPTIONAL
}
ServiceAnnouncement-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
USBD-Fragment-IEs ::= SEQUENCE {
serviceID OCTET STRING (SIZE(1..255)),
r7ServiceClass OCTET STRING (SIZE(1..255))OPTIONAL,
deliveryMethod DeliveryMethod-IEs,
requiredCapabilities INTEGER(0..255),
availabilityInfo AvailabilityInfo-IEs OPTIONAL,
nonCriticalExtension USBD-Fragment-Extension-IEs OPTIONAL
}
USBD-Fragment-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
DeliveryMethod-IEs ::= SEQUENCE {
sessionDescriptionURI OCTET STRING (SIZE(1..255)),
associatedProcedureDescriptionURI OCTET STRING (SIZE(1..255)),
accessPointName OCTET STRING (SIZE(1..50)) OPTIONAL,
nonCriticalExtension DeliveryMethod-Extension-IEs OPTIONAL
}
DeliveryMethod-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
AvailabilityInfo-IEs ::= SEQUENCE {
serviceArea INTEGER (0..65535) OPTIONAL,
radioFrequency INTEGER (0..4294967295) OPTIONAL,
nonCriticalExtension AvailabilityInfo-Extension-IEs OPTIONAL
}
AvailabilityInfo-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
ScheduleDescription-Fragment-IEs ::= SEQUENCE {
serviceSchedule SEQUENCE (SIZE(1..8)) OF ServiceSchedule-IEs
}
ServiceSchedule-IEs ::= SEQUENCE {
sessionSchedule SEQUENCE (SIZE(0..255)) OF SessionScheduleDescription-IEs
OPTIONAL,
fileSchedule SEQUENCE (SIZE(0..255)) OF FileScheduleDescription-IEs ,
sessionScheduleOverride SessionScheduleOverride-IEs OPTIONAL,
nonCriticalExtension ServiceSchedule-Extension-IEs OPTIONAL
}
ServiceSchedule-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
SessionScheduleDescription-IEs ::= SEQUENCE {
start UTCTime,
stop UTCTime,
index INTEGER (0..4294967295),
nonCriticalExtension SessionScheduleDescription-Extension-IEs OPTIONAL
}
SessionScheduleDescription-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
FileScheduleDescription-IEs ::= SEQUENCE {
fileURI FileURI-IEs OPTIONAL,
deliveryInfo DeliveryInfo-IEs OPTIONAL,
nonCriticalExtension FileScheduleDescription-Extension-IEs OPTIONAL
}
FileScheduleDescription-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
FileURI-IEs ::= SEQUENCE {
fileURI OCTET STRING (SIZE(1..255)),
cancelled BOOLEAN,
nonCriticalExtension FileURI-Extension-IEs OPTIONAL
}
FileURI-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
SessionScheduleOverride-IEs ::= SEQUENCE {
index INTEGER (0..4294967295),
cancelled BOOLEAN,
nonCriticalExtension SessionScheduleOverride-Extension-IEs OPTIONAL
}
SessionScheduleOverride-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
DeliveryInfo-IEs ::= SEQUENCE {
start UTCTime OPTIONAL,
stop UTCTime OPTIONAL,
nonCriticalExtension DeliveryInfo-Extension-IEs OPTIONAL
}
DeliveryInfo-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
ADPD-Fragment-IEs ::= SEQUENCE {
postFileRepair PostFileRepair-IEs OPTIONAL,
postReceptionReport PostReceptionReport-IEs OPTIONAL
}
PostFileRepair-IEs ::= SEQUENCE {
offsetTime INTEGER (0..4294967295) OPTIONAL,
randomPeriodTime INTEGER (0..4294967295) OPTIONAL,
serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,
nonCriticalExtension PostFileRepair-Extension-IEs OPTIONAL
}
PostFileRepair-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
PostReceptionReport-IEs ::= SEQUENCE {
offsetTime INTEGER (0..4294967295) OPTIONAL,
randomPeriodTime INTEGER (0..4294967295) OPTIONAL,
samplePercentage INTEGER(0..100) OPTIONAL,
forceTimeIndependence BOOLEAN OPTIONAL,
reportType INTEGER(0..3) OPTIONAL,
serviceURI OCTET STRING (SIZE(1..255)) OPTIONAL,
nonCriticalExtension PostReceptionReport-Extension-IEs OPTIONAL
}
PostReceptionReport-Extension-IEs ::= SEQUENCE {
lateNonCriticalExtension OCTET STRING OPTIONAL,
nonCriticalExtension SEQUENCE {} OPTIONAL
}
\-- ASN1STOP
NOTE 1: It is not necessary to have the compression (e.g. gzip) in SA file
using ASN.1 PER definition.
NOTE 2: The maximum URL/URI length for IoT applications could be limited to
255.
NOTE 3: _ServiceArea_ element type is unsigned short. _RadioFrequency_ element
type is unsigned integer.
NOTE 4: If an ASN.1 PER IE contains less than 7 elements, adding a
nonCriticalExtension element does not occupy an additional octet for the
bitmap element descriptor which describes the presence or absence of the
elements. It's up to the implementation to handle or ignore the
nonCriticalExtension elements.
# 8 Conclusions
TBA
#
# Foreword
This Technical Report has been produced by the 3^rd^ Generation Partnership
Project (3GPP).
The contents of the present document are subject to continuing work within the
TSG and may change following formal TSG approval. Should the TSG modify the
contents of the present document, it will be re-released by the TSG with an
identifying change of release date and an increase in version number as
follows:
Version x.y.z
where:
x the first digit:
1 presented to TSG for information;
2 presented to TSG for approval;
3 or greater indicates TSG approved document under change control.
y the second digit is incremented for all changes of substance, i.e. technical
enhancements, corrections, updates, etc.
z the third digit is incremented when editorial only changes have been
incorporated in the document.
# Introduction
The present document studies solutions to recommend application layer FEC
technologies which will provide the most significant enhancement to the
performance of Mission Critical services (i.e., MCVideo, MCPTT and MCData) for
Release 15.
# 1 Scope
The objective of the present document is to document the progress of the study
item to investigate and recommend an FEC scheme for MCVideo that can be
utilized equally by the two FEC procedures specified in 3GPP TS 23.280 [7].
The study will also consider whether the same or a similar scheme may be
utilized for other MC services over MBMS (e.g. MCData -- file download, or
MCPTT group communications). The use of FEC is within the context of the MC
services common functional architecture as explained in subclause 5.2.6 of
3GPP TS 23.280 [7]. This study item will build upon the existing stage-2
application architecture for MC services as defined in 3GPP TS 23.280 [7],
3GPP TS 23.281 [8], 3GPP TS 23.282 [9], and 3GPP TS 23.379 [10].
# 2 References
The following documents contain provisions which, through reference in this
text, constitute provisions of the present document.
\- References are either specific (identified by date of publication, edition
number, version number, etc.) or non‑specific.
\- For a specific reference, subsequent revisions do not apply.
\- For a non-specific reference, the latest version applies. In the case of a
reference to a 3GPP document (including a GSM document), a non-specific
reference implicitly refers to the latest version of that document _in the
same Release as the present document_.
[1] 3GPP TR 21.905: \"Vocabulary for 3GPP Specifications\".
[2] 3GPP TS 22.146: \"Multimedia Broadcast/Multicast Service (MBMS); Stage
1\".
[3] 3GPP TS 22.179: \"Mission Critical Push to Talk (MCPTT) over LTE; Stage
1\".
[4] 3GPP TS 22.281: \"Mission Critical Video services over LTE\".
[5] 3GPP TS 22.282: \"Mission Critical Data over LTE\".
[6] 3GPP TS 23.203: \"Policy and charging control architecture\".
[7] 3GPP TS 23.280: \"Common functional architecture to support mission
critical services; Stage 2\".
[8] 3GPP TS 23.281: \"Functional architecture and information flows to support
Mission Critical Video (MCVideo); Stage 2\".
[9] 3GPP TS 23.282: \"Functional architecture and information flows to support
Mission Critical Data (MCData); Stage 2\".
[10] 3GPP TS 23.379: \"Functional architecture and information flows to
support Mission Critical Push To Talk (MCPTT); Stage 2\".
[11] 3GPP TS 23.468: \"Group Communication System Enablers for LTE (GCSE_LTE);
Stage 2\".
[12] 3GPP TR 23.780: \"Study on Multimedia Broadcast and Multicast Service
(MBMS) usage for mission critical communication services\".
[13] 3GPP TS 24.380: \"Mission Critical Push To Talk (MCPTT) media plane
control; Protocol specification\".
[14] 3GPP TS 26.179: \"Mission Critical Push To Talk (MCPTT); Codecs and media
handling\".
[15] 3GPP TS 26.281: \"Mission Critical Video (MCVideo); Codecs and media
handling\".
> [16] 3GPP TS 26.346: \"Multimedia Broadcast/Multicast Service (MBMS);
> Protocols and codecs\".
>
> [17] 3GPP TR 26.947: \"Multimedia Broadcast/Multicast Service (MBMS);
> Selection and characterisation of application layer Forward Error Correction
> (FEC)\".
[18] 3GPP TR 26.989: \"Mission Critical Push To Talk (MCPTT); Media, codecs
and Multimedia Broadcast/Multicast Service (MBMS) enhancements for MCPTT over
LTE\".
[19] 3GPP TR 36.829: \"Enhanced performance requirement for LTE User Equipment
(UE)\".
[20] 3GPP TR 36.868: \"Evolved Universal Terrestrial Radio Access (E-UTRA);
Study on group communication for E-UTRA\".
[21] 3GPP TR 36.890: \"Study on Support of single-cell point-to-multipoint
transmission in LTE\".
[22] IETF RFC 6363: \"Forward Error Correction (FEC) Framework\" M. Watson, A.
Begen and V. Roca, October 2011.
[23] Recommendation ITU-R M.2377-0: \"Radiocommunication objectives and
requirements for Public Protection and Disaster Relief (PPDR)\".
[24] R1-120831: \"Reply LS on LS on MBMS FEC Evaluation Framework \".
[25] IETF Internet Draft: \"Forward Error Correction (FEC) Framework Extension
to Sliding Window Codes\" V. Roca and A. Begen.
[26] IETF Internet Draft: \"The Sliding Window Random Linear Code (RLC)
Forward Erasure Correction (FEC) Scheme for FECFRAME\".
[27] IETF RFC 6681: \"Raptor FEC Schemes for FECFRAME\" M. Watson, T.
Stockhammer and M. Luby, August 2012.
[28] \"Mobile Data Broadcasting over MBMS Tradeoffs in Forward Error
Correction\" M. Luby, M. Watson, T. Gasiba, and T. Stockhammer, Proceedings of
the 4^th^ international conference on Mobile and ubiquitous multimedia, 2006.
# 3 Definitions and abbreviations
## 3.1 Definitions
For the purposes of the present document, the terms and definitions given in
3GPP TR 21.905 [1] and the following apply. A term defined in the present
document takes precedence over the definition of the same term, if any, in
3GPP TR 21.905 [1].
**Multimedia Broadcast/Multicast Service (MBMS):** See 3GPP TS 22.146 [2].
**Mission Critical:** Quality or characteristic of a communication activity,
application, service or device, that requires low setup and transfer latency,
high availability and reliability, ability to handle large numbers of users
and devices, strong security and priority and pre-emption handling.
**Mission Critical Applications:** Generic communication applications with
mission critical characteristics, traditionally encompassing push-to-talk
voice (MCPTT), real-time video (MCVideo) and real-time data (MCData).
## 3.2 Abbreviations
For the purposes of the present document, the abbreviations given in TR 21.905
[1] and the following apply. An abbreviation defined in the present document
takes precedence over the definition of the same abbreviation, if any, in TR
21.905 [1].
BM-SC Broadcast-Multicast - Service Centre
CBR Constant Bit Rate
FEC Forward Error Correction
GCS AS Group Communication Service Application Server
GCSE_LTE Group Communication Service Enabler over LTE
MBMS Multimedia Broadcast/Multicast Service
MC Mission Critical
MCData Mission Critical Data
MCH Multicast Channel
MCPTT Mission Critical Push-To-Talk
MCS Modulation and Coding Scheme
MCVideo Mission Critical Video
MSP MCH Scheduling Period
PER Packet Error Rate
PPDR Public Protection and Disaster Relief
SDP Session Description Protocol
SNR Signal-to-Noise Ratio
UC Unicast
UE User Equipment
# 4 Reference Architecture
## 4.1 Introduction
Figure 4.1-1 shows a reference architecture of the MCVideo server and MCVideo
UE support over unicast (UC) and MBMS adapted from the common functional
architecture to support MC services in 3GPP TS 23.280 [7]. The MCVideo server
interacts with MCVideo UE over the MCVideo-1 interface for application
signalling. The MCVideo server determines whether to deliver the video over UC
or MBMS. MCVideo media content is transmitted via LTE bearers, which are
communication pipes with one end in the MCVideo server and the other end in
the MCVideo UE.
FEC can be applied by the BM-SC if requested by the MCVideo server or directly
by the MCVideo server (per 3GPP TS 23.280 [7]). FEC is decoded by the MCVideo
client. Either method is independent of the other.
Figure 4.1-1: MCVideo support Reference Architecture
Note: MB2-C and MB2-U terminate at the BM-SC.
# 5 Use of MBMS for mission critical services
## 5.1 Procedures and information flows
Procedures and information flows are specified in subclause 10.7 of 3GPP TS
23.280 [7].
MBMS bearers for MC services are announced with the MBMS bearer announcement
flow (3GPP TS 23.468 [11] subclause 10.7.2.1), containing in particular the
SDP of the media transported within the MBMS bearer. This announcement is sent
in unicast over the GC1 reference point or over MBMS (3GPP TS 22.179 [3]
subclause 10.7.3.5).
MBMS bearers are used to deliver group communication media and their
associated application level control signalling (e.g. call control, floor
control, MBMS bearer announcement) per 3GPP TS 22.179 [3] subclause 10.7.3.4.
A MBMS bearer for mission critical services may be pre-established in certain
pre-configured areas (3GPP TS 23.468 [11] subclause 10.7.3.1): the MBMS bearer
is created and announced before the initiation of group communication
sessions. When a user originates a request for a group communication session
for one of these areas, the pre-established MBMS bearer(s) is used for the DL
media transmission and the MC service server sends to the group a message
identifying the MC service media flow and the TMGI of the (pre-established)
MBMS bearer, such as the MapGroupToBearer message for MCPTT, specified in 3GPP
TS 23.379 [10], or the MapGroupToBearer message for MCVideo, specified in 3GPP
TS 23.380 [8].
A MBMS bearer for mission critical services may be also dynamically
established per 3GPP TS 23.468 [11] subclause 10.7.3.2 when a new group
communication session is initiated.
A MBMS bearer for MCPTT may carry several MCPTT media streams, announced
within the SDP from the MBMS announcement. When a group communication is
initiated, the MapGroupToBearer message indicates on which MBMS subchannel
(i.e., TMGI, multicast IP address and UDP port number) a particular media
stream (identified via its m-line within the SDP for the group) is being sent.
Similarly, a MBMS bearer for MCVideo may carry several MCVideo media streams,
announced within the SDP from the MBMS bearer announcement. If audio and video
are delivered in separate streams, the MapGroupToBearer message points to one
media stream for the audio and to another media stream for the video.
## 5.2 New procedures related to FEC
### 5.2.0 General
FEC can be applied by the BM-SC if requested by the MC service server (3GPP TS
23.280 [7] subclause 10.7.3.11.2), or directly by the MC service server (3GPP
TS 23.280 [7] subclause 10.7.3.11.3). FEC is decoded by the MC service client.
Either method is independent of the other.
An extension to MB2 is specified in 3GPP TS 23.280 [7] to enable the BM-SC to
apply FEC. The following subclause describes this extension, based on [7].
### 5.2.1 MB2 extension
The MB2 extension consists of two new request messages over MB2: \"Setup FEC
request\" and \"Release FEC request\". These messages can be used with pre-
established MBMS bearers or dynamic MBMS bearers.
Figure 5.2.1-1: Application of FEC by the BM-SC (from Figure 10.7.3.11.2-1 in
3GPP TS 23.280 [7])
The new Setup FEC request message over MB2 includes the following elements:
the TMGI of the bearer transporting those media, the media descriptions
(codecs, transport protocols, bitrates, destination IP addresses and ports),
the identification of the FEC repair packet flow (IP destination and port), an
upper bound to the additional latency resulting to FEC application. This
request may be performed several times to separately protect different sets of
media transported within the same MBMS bearer.
The response message includes a modified list of media information and FEC
information. The response also includes an identifier to the FEC process
instance which can be used to release the application of FEC for these media
flows with the new Release FEC request.
### 5.2.2 Link with FEC Frame
These procedures consist of protecting one or several UDP flows (identified by
IP destination and port) by an additional UDP flow, as allowed by FEC Frame
(IETF RFC 6363 [22]). FEC Frame is the FEC mechanism in charge of protection
against losses within the streaming delivery method (3GPP TS 26.346 [16]).
These procedures allow the modification of the delivery protocol to be
announced within the SDP since source media packets may be modified by the
application of FEC (e.g. addition of a footer of header), as is done by FEC
Frame.
## 5.3 MBMS configuration and parameters
### 5.3.1 Bandwidth
Studies performed by several member states and sector members on the required
bandwidth for broadband PPDR are presented in Annex 7 of ITU-R M.2377-0 [23].
Table 5.3.1-1 bandwidth requirements (from in Annex 7 of ITU-RM.2377-0 [23])
* * *
Source Bandwidth requirements (MHz) Comments  
Uplink Downlink  
CEPT 10 10 Data only. Based on ECC Report 199 UAE 16.9 12.5 Two incidents
data. Motorola Solutions > 20 20 Level 3 incident (FDD) Israel 20 20  
China 30-40 TD -- LTE; depends on different scenarios  
Korea 10 10
* * *
Several governments have already allocated dedicated spectrum for PSLTE:
\- The Government of Korea decided to use Public Safety LTE technologies with
2 × 10 MHz frequency in the band 28 (700 MHz) for PDDR.
\- USA allocated the whole band 14 (700 MHz), which is 2 x 10 MHz FDD band.
\- France allocated 2 x 3 MHz from band 28 and 2 x 5 MHz in the new band 68.
NOTE: These bandwidths may be used for modelling the MBMS channel.
### 5.3.2 Coverage
Transmissions of mission critical group communications face more challenging
environments (indoor, basement, elevator, stairwell, etc.) than non-mission
critical services such as TV over MBMS. Consequently, MCS for mission critical
services will be more conservative than commercial services.
# 6 Media Diversity for Mission Critical Services
## 6.1 MCPTT
The MCPTT calls are transported as RTP streams. The packet loss rate for MCPTT
should be under 10^-2,^ corresponding to the QCI 65 (3GPP 23.203 [6]).
Several MCPTT group calls can be transported with a MBMS bearer. As mentioned
in subclause 5.2, this bearer may contain several media descriptions. The
TMGI, destination IP addresses and port of these calls are not defined in
advance within the SDP but announced within the \"MapGroupToBearer\" call
control message (clause 8.4.4 of 3GPP TS 24.380 [8]).
MBMS bearers are also used to transport call control messages (e.g.
\"MapGroupToBearer\", \"UnmapGroupToBearer\") and floor control messages (e.g.
Floor Taken, Floor Idle).
Messages for call control and floor control are already protected against
losses by repeating them (see clauses 4.1.3.2 and 4.1.3.3 in 3GPP TS 24.380
[13]).
Codecs and media handling for MCPTT are specified in 3GPP TS 26.179 [14].
## 6.2 MCVideo
MCVideo is transported by RTP or SRTP (3GPP TS 26.281 [15]). Video and audio
may be separated. The target packet loss rate is under 10^-3^, corresponding
to the QCI 2, for conversational video (3GPP TS 23.203 [6]).
## 6.3 MCData
### 6.3.0 General
MCData offers several capabilities: SDS, File Distribution, and Data
Streaming.
### 6.3.1 SDS capability
SDS (for Short Data Service): The SDS feature of the MCData Service could be
considered as a basic protocol carrying a limited size, but variable content,
payload message. This message could be text or could be marked for extensible
purposes including short binary messages for application communication.
Messaging could be one-to-one messaging or could be group messaging using
groups as specified in MCCoRe (3GPP TS 22.282 [5]).
### 6.3.2 File Distribution capability
File distribution can be used to provide a standalone file transfer capability
or can be invoked by a controlling application to support the purpose of the
application.
### 6.3.3 Data Streaming capability
Data streaming delivers continuous multimedia data (i.e. speech, audio and
video) over an MBMS bearer.
## 6.4 Latency requirements for mission critical services
Adding FEC introduces extra latency in the end to end media transport (related
to mouth to ear latency, KPI 3 in MCPTT) and in the join time on an ongoing
group communication (defined as KPI 4 for MCPTT). This extra latency can be
bounded to fulfil the low latency requirements for mission critical services.
Table 6.4-1 compares the latency requirements with the latency estimations:
Table 6.4-1: bandwidth requirements (from clause 6.7.3.2 in 3GPP TR 23.780
[12])
* * *
                                                                                                                                       End to end delay for media transport\   Time for joining an ongoing group communication\   References
                                                                                                                                       (KPI 3)                                 (KPI 4)
Latency requirement MCPTT \ 0.1 %:
\- increase CNR, with a 0.2 step (CNR = CNR + 0.2)
\- perform a link level simulation for MCS 12 over 100.000 Mbsfn subframes.
\- For the given CNR:
\- Generate the loss traces for MCS 12 / 13 / 14 / 15 / 16.
\- Evaluate the performances of various AL-FEC schemes (RLC, Raptor10, Reed
Solomon) for different FEC latency budget: 240/480 ms, and 1 / 2 / 4 seconds.
1 packet per mbsfn subrame, 1 mbsfn subframe per frame.
\- Performance is express as achievable throughput for a combination of MCS
and AL-FEC.
# 11 Solutions
## 11.1 Solution #1: Convolutional FEC for MCVideo
### 11.1.1 Solution description
#### 11.1.1.1 Introduction
This solution uses an extension to FEC Frame (IETF RFC 6363 [21]), namely FEC
Frame Ext [25] associated to the RLC FEC scheme [26]. IETF Internet Drafts
[25] and [26] are Working Group Item documents of the IETF Transport Area
Working Group (TSVWG).
FECFrame (IETF RFC 6363 [21]) allows applying FEC to arbitrary packet flows
over unreliable transport and is primarily intended for real-time, or
streaming, media. FECFrame as per RFC 6363 is restricted to block FEC codes.
The backward compatible extension FEC Frame Ext [25] allows the use of sliding
window codes (i.e. convolutional codes).
When applying a block FEC code, the block size is a balance between robustness
(in particular in front of long loss bursts for which there is an incentive to
increase the block size), and the FEC latency budget. The FEC repair symbols
are generated by the encoder only when the source block is complete (enough
packets have been reserved from the source) and the decoder have to wait the
end reception of the source and repair symbols of a given block before
decoding and forwarding them to the packet flow consumer (typically the media
player). Oppositely, a sliding window FEC code allows generating on the fly
repair packets, and the decoder continuously decodes. Sliding window FEC code
are specifically specified to respond to the low-latency constraint.
Figure 11.1.1.1-1: Sliding window FEC principle
The FECFrame Ext and the RLC FEC Scheme are detailed in the following clauses.
This proposed solution is then evaluated and its performance is compared to
block FEC schemes.
#### 11.1.1.2 FECFrame extension for convolutional FEC
As an extension of FECFrame, the following statements are still valid for its
extension (FECFrame Ext):
\- FECFrame Ext is described in terms of an additional layer between the
transport layer (e.g. UDP) and protocols running over this transport layer.
\- FECFrame Ext is applicable to protect a set of UDP source streams,
identified by their destination IP and port (and also possibly source IP and
port).
\- With FECFrame Ext, the source packets are transport unaltered, with the
exception of a possible additional trailer or footer (containing the Explicit
Source FEC Payload ID).
\- FECFrame Ext makes use of a FEC scheme, which defines the FEC encoding and
decoding, the protocol fields and procedures used to identify packet payload
data in the context of the FEC scheme.
The fundamental difference between FECFrame and its extension consists in the
extension ability to transmit immediately any new ADU (Application Data Unit,
e.g. source packet) to a convolutional FEC Scheme and to ask for on-the-fly
generation of new repair symbols, as shown below.
The figure 11.1.1.2 illustrates the FECFrame Ext encoder operation with a
convolutional FEC Code and reproduces the description of the steps from clause
4.2. in [25]:
{width="6.695138888888889in" height="3.4166666666666665in"}
Figure 11.1.1.2-1: FECFrame Ext encoder operation with a convolutional code,\
from the Figure 2 in [25]
1\. A new Application Data Unit (ADU) is provided by the application. In this
study context, the ADU is a UDP packet.
2\. The FEC Framework immediately communicates this ADU to the FEC scheme
(With a block FEC scheme, the FEC Framework would have to wait for the
building of a FEC Source Block).
3\. The sliding encoding window is updated by the FEC scheme. The ADU to
source symbols mapping as well as the encoding window management details are
both the responsibility of the FEC scheme.
4\. The Source FEC Payload ID information of the source packet is determined
by the FEC scheme. If required by the FEC scheme, the Source FEC Payload ID is
encoded into the Explicit Source FEC Payload ID field and returned to the FEC
Framework.
5\. The FEC Framework constructs the FEC source packet according to RFC 6363
[22] Figure 6, using the Explicit Source FEC Payload ID provided by the FEC
scheme if applicable.
6\. The FEC source packet is sent using normal transport-layer procedures.
This packet is sent using the same ADU flow identification information as
would have been used for the original source packet if the FEC Framework were
not present (for example, in the UDP case, the UDP source and destination
addresses and ports on the IP datagram carrying the source packet will be the
same whether or not the FEC Framework is applied).
7\. When the FEC Framework needs to send one or several FEC repair packets
(e.g. according to the target Code Rate), it asks the FEC scheme to create one
or several repair packet payloads from the current sliding encoding window
along with their Repair FEC Payload ID.
8\. The Repair FEC Payload IDs and repair packet payloads are provided back by
the FEC scheme to the FEC Framework.
9\. The FEC Framework constructs FEC repair packets according to RFC 6363 [22]
Figure 7, using the FEC Payload IDs and repair packet payloads provided by the
FEC scheme.
10\. The FEC repair packets are sent using normal transport-layer procedures.
The port(s) and multicast group(s) to be used for FEC repair packets are
defined in the FEC Framework Configuration Information.
#### 11.1.1.3 The Sliding Window RLC FEC Scheme
[26] introduces a fully-specified FEC scheme for FECFrame Ext: the Sliding
Window RLC (Random Linear Code) FEC Scheme.
[26] provides, particular:
\- specific related procedures: RLC parameters derivation, source symbols
mapping, pseudo-random number generator, and coding coefficients generation
function;
\- the format Source FEC Payload ID and Repair FEC Payload ID formats.
\- the FEC Framework Configuration Information (FFCI) carrying signalling
information for the session;
\- the code specification.
This code is defined over GF(2^m^) (Gallois Field), where m equals 1, 4 or 8.
Repair packets are generated and send on-the-fly after computing a linear
combination of the source symbols present is the current encoding window.
Main principles of the Sliding Window RLC FEC Scheme are described in [26],
subclause 1.2:
_\"At the receiver, a linear system is managed from the set of received source
and repair packets. new variables (representing source symbols) and equations
(representing the linear combination of each repair symbol received) are added
upon receiving new packets. Variables are removed when they are too old with
respect to their validity period (real-time constraints), as well as the
associated equations they are involved in. Erased source symbols are then
recovered thanks this linear system whenever its rank permits it._
_The Sliding Window RLC FEC scheme is designed so as to reduce the
transmission overhead. The main requirement is that each repair packet header
must enable a receiver to reconstruct the list of source symbols and the
associated random coefficients used during the encoding process. In order to
minimize packet overhead, the set of symbols in the encoding window as well as
the set of coefficients over GF(2^m^) used in the linear combination are not
individually listed in the repair packet header. Instead, each FEC repair
packet header contains:_
_\- the Encoding Symbol Identifier (ESI) of the first source symbol in the
encoding window as well as the number of symbols. These two pieces of
information enable each receiver to easily reconstruct the set of source
symbols considered during encoding;_
_\- the seed used by a coding coefficients generation function. This
information enables each receiver to generate the same set of coding
coefficients over GF(2^m^) as the sender\"._
Each FEC repair packet features a header, called Repair FEC Payload ID.
Similarly, each FEC source packet features a trailer, called Explicit Source
FEC Payload ID, that contains the ESI of the first source.
#### 11.1.1.4 Parameters
The RLC FEC scheme relies on several internal parameters:
\- Maximum FEC-related latency budget (**max_lat**): This can be regarded as
the latency budget permitted for all FEC-related operations.
\- Encoding window size (**ew_size** in symbols): used by a sender during FEC
encoding. More precisely, each repair symbol is a linear combination of the
ew_size source symbols present in the encoding window when RLC encoding took
place.
\- Linear system size (**ls_size** , in symbols): used by a receiver when
managing the linear system used for decoding. ls_size is the size of the
linear system, i.e., the set of received or erased source symbols that are
part of the linear system.
\- Decoding window size (**dw_size** , in symbols): used by a receiver when
managing the linear system used for decoding. dw_size is the size of the
decoding window, i.e., a subset of the linear system, corresponding to the
last received or erased source symbols that are part of the linear system.
Only decoded symbols from this window should be delivered to the application.
Symbols which are decoded too late, out of the decoding window, are not
delivered but help solving the linear system and decoding the newest.
In addition, a target **code rate** is configured in the FEC Frame Ext encoder
to manage the frequency of repair symbol generation.
2 parameters are transmitted within the FEC Scheme-Specific Information:
\- Encoding symbol size (**T**): a non-negative integer that indicates the
size of each encoding symbol in bytes;
\- m parameter (**m**): the length of the elements in the finite field, in
bits, where m is equal to 1, 4 or 8.
#### 11.1.1.5 Performance evaluation
To evaluate the performance of this solution, its performance is compared to
the performance of an ideal MDS (Maximum Distance Separable) FEC block code.
Evaluating the performance of an ideal MDS FEC code provides an upper bound
for the performance of any block FEC scheme in terms of maximum supported
media rate.
Its performance is also compared to Raptor [27], which protects non-mission
critical RTP streams within the MBMS Streaming Delivery Method as specified in
3GPP TS 26.346 [16].
With a MDS FEC code, a block can always be decoded on an erasure channel if
m≥k where m is the number of received symbols and k the number of source
symbols per block. With Raptor, the decoding failure probability for a given
block is estimated as an upper-bound in [28] as 0.85 * 0.567m−k. However, when
using Raptor, and by the use an appropriate number of symbols per packet (G
parameter), we can reduce the decoding failure probability when one more
packet has been received. In this case, the evaluation for Raptor is done with
G set to 20. As the considered payload sizes in the evaluation procedure (454
and 952 bytes) are not divisible by 20, the evaluation is done for raptor with
440 and 940 as payload sizes.
NOTE 1: Raptor is only evaluated here in the \"block -- DURING\" mode, as the
\"block BEGINNING\" mode for a MDS code at 3 km/hr already shows bad
performances as described in the next subclauses.
NOTE 2: An appropriate value for G may further increase the performance of
Raptor to provide full MDS performance.
The simulation procedures are described in B.1 Simulation procedure for
MCVideo. In the simulation, the _ew_size_ parameter is set to floor (0.75 *
_dw_size_)). _ls_size_ is set to 60 when the FEC latency budget is 240 or 480
ms, and 120 when the latency budget is set to 960 ms.
The list of results for RLC and ideal MDS FEC Block is provided in the
submission_RLC_MDS-Block-Beginning_MDS-Block-During_Raptor-Block-During.xls
attached file.
These results are presented below by the repair traffic overhead, which is
linked to the code rate:
repair traffic overhead = 1/code_rate - 1
For instance, code_rate = 2/3 corresponds to a 50% repair traffic overhead
(50% traffic in addition to source traffic), and code_rate = 0:5 to a 100%
repair overhead (traffic is doubled).
##### 11.1.1.5.1 Repair traffic overhead for mode 1 (bitrate 398.4 kbps,
packet size: 498 bytes)
Figure 11.1.1.5.1-1 shows the required traffic overhead to obtain a residual
packet loss rate below 10^-3^, across the 3 km/hr and 120 km/hr channels for
with the 240 ms, 480 ms and 960 ms latency budgets, for the mode 1.
{width="6.695138888888889in" height="6.0784722222222225in"}
Figure 11.1.1.5.1-1: Repair traffic overhead for mode 1\ (Raptor with a value
G=20)
Figure 11.1.1.5.1-1 provides the results from the less favourable conditions
(FEC latency budget down to 240 ms, and bursty losses at 3 km/hr), to the best
conditions (latency budget up to 960 ms, and random losses at 120 km/hr).
In the less favourable conditions (240 ms latency budget at 3 km/hr), the
10^-3^ target loss rate cannot be achieved for a 10% BLER. With a 5% BLER, a
104% repair traffic overhead is enough for RLC to reach the target.
Not surprisingly, an ideal MDS FEC scheme, using the Block-Beginning
transmission mode, suffers far more from the loss bursts at 3 km/hr, as full
blocks are sent in a row, and can be more severely damaged by loss bursts than
the Block-During mode, where the blocks are spread across the full latency
budget. Oppositely, when the losses are random, as at 120 km/hr, the Block-
Beginning mode is more efficient than the Block-During mode, as the Block-
Beginning mode allows bigger blocks. However, whatever the loss distribution,
the RLC provides the best results.
Only at 120 km/h, when the losses are random, with a big FEC latency budget at
960 ms, the Block-Beginning mode provides equivalent performances to RLC.
Raptor performance can be compared to the MDS FEC scheme in the Block-During
mode. With the used configuration of G, Raptor may need to send more repair
packets. These inappropriate settings result that only in few cases (e.g. [120
km/hr, 240 ms budget], [3 km/hr, 960 ms budget]), performances are equivalent.
Proper recommendations for the setting of Raptor parameters need to be
provided to ensure that Raptor results in the same performance as MDS schemes.
##### 11.1.1.5.2 Repair traffic overhead for mode 2 (bitrate 398.4 kbps,
packet size: 996 bytes)
Figure 11.1.1.5.2-1 shows the required traffic overhead to obtain a residual
packet loss rate below 10^-3^, across the 3 km/hr and 120 km/hr channels for
with the 240ms, 480 ms and 960 ms latency budgets, for the mode 2.
{width="6.695138888888889in" height="5.5993055555555555in"}
Figure 11.1.1.5.2-1: Repair traffic overhead for mode 2\ (Raptor with a value
G=20)
In the mode 2 (bitrate 398.4 kbps, packet size: 996 bytes), IP packets are
sent over 2 MAC-PDUs, into different subframes, one packet every 20 ms. These
conditions are less favourable than mode 1: packets have more chances to be
lost, as each MAC-PDU can be lost, and the number of packet per FEC latency
budget is decreased by half: a 240 ms duration contains only 12 packets which
strongly reduces the block size for Block FEC schemes, and the decoding window
size for convolutional FEC schemes. This is why, in the worst conditions (3
km/hr, 240 ms budget), the target cannot be reached at a 5% BLER (334% of
overhead would be required for RLC, and such a code rate can be considered
unreasonable).
With a 480 ms FEC latency budget and a BLER at 5%, RLC requires overheads of
85.19% at 3 km/hr and 38.89% at 120 km/hr. Block-Beginning transmission mode
behaves badly against the loss bursts at 3 km/hr (250% overhead) while 50%
overhead is required at 120 km/hr. Again, Block-During transmission mode is
more performant at 3 km/hr than Block-Beginning mode, less performant at 120
km/hr and both are behind RLC.
As illustrated in figure 11.1.1.5.1-2, in mode 2, RLC yields the best results
in every considered case.
##### 11.1.1.5.3 Repair traffic overhead for mode 3 (bitrate 796.8.4 kbps,
packet size: 996 bytes)
Figure 11.1.1.5.3-1 shows the required traffic overhead to obtain a residual
packet loss rate below 10^-3^, across the 3 km/hr and 120 km/hr channels for
with the 240 ms, 480 ms and 960 ms latency budgets, for the mode 3.
{width="6.695138888888889in" height="5.6125in"}
Figure 11.1.1.5.3-1: Repair traffic overhead for mode 3\ (Raptor with a value
G=20)
In mode 3, there is one packet per frame, sent over 2 PDUs. There are any many
packets per FEC Latency budget, as in mode 1, but packets are sent within 2
PDUs, as in mode 2. Overheads with mode 3 are higher than mode 1, and lower
than mode 2.
Again, in mode 3, RLC yields the best results in every condition.
#### 11.1.1.6 Performance of AL-FEC compared to MCS dimensioning.
##### 11.1.1.6.1 General
As mentioned in the key issue 9.4, the packet loss rate can also be reduced by
decrementing the MCS. Combination of AL-FEC and MCS dimensioning are here
evaluated in term of achievable throughput.
The solution follows the methodology given in 10.5. For the sake of clarity,
figures of the following subclauses depict the results for RLC and for an MDS
FEC block code, scheduled according to the block during mode.
Achievable throughputs can be compared to the usage of MCS dimensioning alone,
set to 12 according the methodology given in clause 10.5. In that case, the
achievable throughput, for an MBMS bearer allocating 1 subframe per frame
within a 5 Mhz band, is 459 200 bps.
##### 11.1.1.6.2 3 km/h, 751 Mhz
Results of the simulation at 3 km/h, 751 Mhz are illustrated in figure
11.1.1.6.2-1:
Figure 11.1.1.6.2-1: Achievable throughput (bps) for RLC and Reed-Solomon at 3
km/h, 751 MHz
This use-case (3km/h, 751 MHz) has the largest coherence time. Not
surprisingly, with a small latency budget (\ maxE_, _R = R + 1_ , restart Loop 1
\- Record last value of _K_ as _maxK_
\- Report maximum streaming rate as (_G_ *_K_ *_T_ *8 / latency budget for
Block-BEGINNING mode, and _G_ *_K_ *_T_ *8*2 / latency budget for Block-DURING
mode) where _T_ is the symbol size.
Note 1: According the mode (Block-BEGINNING, Block-DURING) one or two FIFO
queues is managed.
NOTE 2: When SDUs are sent over two PDUs, a SDU is lost if one of the 2
following PDUs in the loss transcript is lost.
###### ### Annex B: Tools for evaluation
# B.1 Generate Markov Traces
The attached java code \"LossGenerator.java\" and \"Random.java\" may be used
to generate the loss traces independently.
This code is directly evolved from 3GPP TR 26.947 [17]. The only change is the
new parameter nSubframe, indicating the number of subframes per frame,
allocated for the given MBMS bearer.
The java trace file can be executed as follows:
> java LossVectorGenerator p q gBLER bBLER nSubframe subsamp n seed offset
> vectorfile
with:
> p (transition probability from good to bad state)
>
> q (transition probability from bad to good state)
>
> gBLER (BLER for the good markov state)
>
> bBLER (BLER for the bad markov state)
>
> nSubframe (number of subframes allocated per frame)
>
> subsamp (subsampling for markov trace)
>
> n (length of the vector to be generated)
>
> seed (for the prng)
>
> offset (iterate n times before generating the vector)
>
> vectorFile (file name where to output the vector)
Table B.1 provides the instructions how to generate the error traces.
Table B.1: Markov Trace generation for MCVideo test cases
* * *
Test Case Error conditions Test Script parameters VID10 Markov, 3 km/h, 5%
0.0180 0.2401 0.0006 0.7054 1 1 180000 0 0 errortrace_vid10.txt VID11 0.0180
0.2401 0.0006 0.7054 1 1 180000 0 0 errortrace_vid11.txt VID12 0.0180 0.2401
0.0006 0.7054 2 1 180000 0 0 errortrace_vid12.txt VID37 Markov, 120 km/h, 5%
0.2707 0.7095 0.0000 0.1954 1 1 180000 0 0 errortrace_vid37.txt VID38 0.2707
0.7095 0.0000 0.1954 1 1 180000 0 0 errortrace_vid38.txt VID39 0.2707 0.7095
0.0000 0.1954 2 1 180000 0 0 errortrace_vid39.txt
* * *
#